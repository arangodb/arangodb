<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.7.1">
<meta name="author" content="Peter Dimov">
<title>Boost.Mp11: A C++11 metaprogramming library</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Uncomment @import statement below to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
*:not(pre)>code.nobreak{word-wrap:normal}
*:not(pre)>code.nowrap{white-space:nowrap}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote::before{display:none}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{word-spacing:0;line-height:1.6}
.quoteblock.abstract blockquote::before,.quoteblock.abstract p::before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd){background:#f8f8f7}
table.stripes-none tr,table.stripes-odd tr:nth-of-type(even){background:none}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Boost.Mp11: A C++11 metaprogramming library</h1>
<div class="details">
<span id="author" class="author">Peter Dimov</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#overview">Overview</a></li>
<li><a href="#definitions">Definitions</a></li>
<li><a href="#examples">Examples</a>
<ul class="sectlevel2">
<li><a href="#generating_test_cases">Generating Test Cases</a></li>
<li><a href="#writing_common_type_specializations">Writing common_type Specializations</a></li>
<li><a href="#fixing_tuple_cat">Fixing tuple_cat</a></li>
<li><a href="#computing_return_types">Computing Return Types</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a>
<ul class="sectlevel2">
<li><a href="#integral">Integral Constants, &lt;boost/mp11/integral.hpp&gt;</a>
<ul class="sectlevel3">
<li><a href="#mp_boolb">mp_bool&lt;B&gt;</a></li>
<li><a href="#mp_true">mp_true</a></li>
<li><a href="#mp_false">mp_false</a></li>
<li><a href="#mp_to_boolt">mp_to_bool&lt;T&gt;</a></li>
<li><a href="#mp_nott">mp_not&lt;T&gt;</a></li>
<li><a href="#mp_inti">mp_int&lt;I&gt;</a></li>
<li><a href="#mp_size_tn">mp_size_t&lt;N&gt;</a></li>
</ul>
</li>
<li><a href="#list">List Operations, &lt;boost/mp11/list.hpp&gt;</a>
<ul class="sectlevel3">
<li><a href="#mp_listt">mp_list&lt;T&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_list_ct_i">mp_list_c&lt;T, I&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_is_listl">mp_is_list&lt;L&gt;</a></li>
<li><a href="#mp_sizel">mp_size&lt;L&gt;</a></li>
<li><a href="#mp_emptyl">mp_empty&lt;L&gt;</a></li>
<li><a href="#mp_assignl1_l2">mp_assign&lt;L1, L2&gt;</a></li>
<li><a href="#mp_clearl">mp_clear&lt;L&gt;</a></li>
<li><a href="#mp_frontl">mp_front&lt;L&gt;</a></li>
<li><a href="#mp_pop_frontl">mp_pop_front&lt;L&gt;</a></li>
<li><a href="#mp_firstl">mp_first&lt;L&gt;</a></li>
<li><a href="#mp_restl">mp_rest&lt;L&gt;</a></li>
<li><a href="#mp_secondl">mp_second&lt;L&gt;</a></li>
<li><a href="#mp_thirdl">mp_third&lt;L&gt;</a></li>
<li><a href="#mp_push_frontl_t">mp_push_front&lt;L, T&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_push_backl_t">mp_push_back&lt;L, T&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_renamel_y">mp_rename&lt;L, Y&gt;</a></li>
<li><a href="#mp_applyf_l">mp_apply&lt;F, L&gt;</a></li>
<li><a href="#mp_apply_qq_l">mp_apply_q&lt;Q, L&gt;</a></li>
<li><a href="#mp_appendl">mp_append&lt;L&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_replace_frontl_t">mp_replace_front&lt;L, T&gt;</a></li>
<li><a href="#mp_replace_firstl_t">mp_replace_first&lt;L, T&gt;</a></li>
<li><a href="#mp_replace_secondl_t">mp_replace_second&lt;L, T&gt;</a></li>
<li><a href="#mp_replace_thirdl_t">mp_replace_third&lt;L, T&gt;</a></li>
</ul>
</li>
<li><a href="#utility">Utility Components, &lt;boost/mp11/utility.hpp&gt;</a>
<ul class="sectlevel3">
<li><a href="#mp_identityt">mp_identity&lt;T&gt;</a></li>
<li><a href="#mp_identity_tt">mp_identity_t&lt;T&gt;</a></li>
<li><a href="#mp_inheritt">mp_inherit&lt;T&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_if_cc_t_e">mp_if_c&lt;C, T, E&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_ifc_t_e">mp_if&lt;C, T, E&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_eval_if_cc_t_f_u">mp_eval_if_c&lt;C, T, F, U&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_eval_ifc_t_f_u">mp_eval_if&lt;C, T, F, U&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_eval_if_qc_t_q_u">mp_eval_if_q&lt;C, T, Q, U&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_condc_t_r">mp_cond&lt;C, T, R&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_validf_t">mp_valid&lt;F, T&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_deferf_t">mp_defer&lt;F, T&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_quotef">mp_quote&lt;F&gt;</a></li>
<li><a href="#mp_quote_traitf">mp_quote_trait&lt;F&gt;</a></li>
<li><a href="#mp_invokeq_t">mp_invoke&lt;Q, T&#8230;&#8203;&gt;</a></li>
</ul>
</li>
<li><a href="#algorithm">Algorithms, &lt;boost/mp11/algorithm.hpp&gt;</a>
<ul class="sectlevel3">
<li><a href="#mp_transformf_l">mp_transform&lt;F, L&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_transform_qq_l">mp_transform_q&lt;Q, L&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_transform_ifp_f_l">mp_transform_if&lt;P, F, L&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_transform_if_qqp_qf_l">mp_transform_if_q&lt;Qp, Qf, L&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_filll_v">mp_fill&lt;L, V&gt;</a></li>
<li><a href="#mp_countl_v">mp_count&lt;L, V&gt;</a></li>
<li><a href="#mp_count_ifl_p">mp_count_if&lt;L, P&gt;</a></li>
<li><a href="#mp_count_if_ql_q">mp_count_if_q&lt;L, Q&gt;</a></li>
<li><a href="#mp_containsl_v">mp_contains&lt;L, V&gt;</a></li>
<li><a href="#mp_repeat_cl_n">mp_repeat_c&lt;L, N&gt;</a></li>
<li><a href="#mp_repeatl_n">mp_repeat&lt;L, N&gt;</a></li>
<li><a href="#mp_productf_l">mp_product&lt;F, L&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_product_qq_l">mp_product_q&lt;Q, L&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_drop_cl_n">mp_drop_c&lt;L, N&gt;</a></li>
<li><a href="#mp_dropl_n">mp_drop&lt;L, N&gt;</a></li>
<li><a href="#mp_from_sequences">mp_from_sequence&lt;S&gt;</a></li>
<li><a href="#mp_iota_cn">mp_iota_c&lt;N&gt;</a></li>
<li><a href="#mp_iotan">mp_iota&lt;N&gt;</a></li>
<li><a href="#mp_at_cl_i">mp_at_c&lt;L, I&gt;</a></li>
<li><a href="#mp_atl_i">mp_at&lt;L, I&gt;</a></li>
<li><a href="#mp_take_cl_n">mp_take_c&lt;L, N&gt;</a></li>
<li><a href="#mp_takel_n">mp_take&lt;L, N&gt;</a></li>
<li><a href="#mp_insert_cl_i_t">mp_insert_c&lt;L, I, T&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_insertl_i_t">mp_insert&lt;L, I, T&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_erase_cl_i_j">mp_erase_c&lt;L, I, J&gt;</a></li>
<li><a href="#mp_erasel_i_j">mp_erase&lt;L, I, J&gt;</a></li>
<li><a href="#mp_replacel_v_w">mp_replace&lt;L, V, W&gt;</a></li>
<li><a href="#mp_replace_ifl_p_w">mp_replace_if&lt;L, P, W&gt;</a></li>
<li><a href="#mp_replace_if_ql_q_w">mp_replace_if_q&lt;L, Q, W&gt;</a></li>
<li><a href="#mp_replace_at_cl_i_w">mp_replace_at_c&lt;L, I, W&gt;</a></li>
<li><a href="#mp_replace_atl_i_w">mp_replace_at&lt;L, I, W&gt;</a></li>
<li><a href="#mp_copy_ifl_p">mp_copy_if&lt;L, P&gt;</a></li>
<li><a href="#mp_copy_if_ql_q">mp_copy_if_q&lt;L, Q&gt;</a></li>
<li><a href="#mp_removel_v">mp_remove&lt;L, V&gt;</a></li>
<li><a href="#mp_remove_ifl_p">mp_remove_if&lt;L, P&gt;</a></li>
<li><a href="#mp_remove_if_ql_q">mp_remove_if_q&lt;L, Q&gt;</a></li>
<li><a href="#mp_partitionl_p">mp_partition&lt;L, P&gt;</a></li>
<li><a href="#mp_partition_ql_q">mp_partition_q&lt;L, Q&gt;</a></li>
<li><a href="#mp_sortl_p">mp_sort&lt;L, P&gt;</a></li>
<li><a href="#mp_sort_ql_q">mp_sort_q&lt;L, Q&gt;</a></li>
<li><a href="#mp_nth_element_cl_i_p">mp_nth_element_c&lt;L, I, P&gt;</a></li>
<li><a href="#mp_nth_elementl_i_p">mp_nth_element&lt;L, I, P&gt;</a></li>
<li><a href="#mp_nth_element_ql_i_q">mp_nth_element_q&lt;L, I, Q&gt;</a></li>
<li><a href="#mp_min_elementl_p">mp_min_element&lt;L, P&gt;</a></li>
<li><a href="#mp_min_element_ql_q">mp_min_element_q&lt;L, Q&gt;</a></li>
<li><a href="#mp_max_elementl_p">mp_max_element&lt;L, P&gt;</a></li>
<li><a href="#mp_max_element_ql_q">mp_max_element_q&lt;L, Q&gt;</a></li>
<li><a href="#mp_findl_v">mp_find&lt;L, V&gt;</a></li>
<li><a href="#mp_find_ifl_p">mp_find_if&lt;L, P&gt;</a></li>
<li><a href="#mp_find_if_ql_q">mp_find_if_q&lt;L, Q&gt;</a></li>
<li><a href="#mp_reversel">mp_reverse&lt;L&gt;</a></li>
<li><a href="#mp_foldl_v_f">mp_fold&lt;L, V, F&gt;</a></li>
<li><a href="#mp_fold_ql_v_q">mp_fold_q&lt;L, V, Q&gt;</a></li>
<li><a href="#mp_reverse_foldl_v_f">mp_reverse_fold&lt;L, V, F&gt;</a></li>
<li><a href="#mp_reverse_fold_ql_v_q">mp_reverse_fold_q&lt;L, V, Q&gt;</a></li>
<li><a href="#mp_uniquel">mp_unique&lt;L&gt;</a></li>
<li><a href="#mp_all_ofl_p">mp_all_of&lt;L, P&gt;</a></li>
<li><a href="#mp_all_of_ql_q">mp_all_of_q&lt;L, Q&gt;</a></li>
<li><a href="#mp_none_ofl_p">mp_none_of&lt;L, P&gt;</a></li>
<li><a href="#mp_none_of_ql_q">mp_none_of_q&lt;L, Q&gt;</a></li>
<li><a href="#mp_any_ofl_p">mp_any_of&lt;L, P&gt;</a></li>
<li><a href="#mp_any_of_ql_q">mp_any_of_q&lt;L, Q&gt;</a></li>
<li><a href="#mp_for_eachlf">mp_for_each&lt;L&gt;(f)</a></li>
<li><a href="#mp_with_indexni_f">mp_with_index&lt;N&gt;(i, f)</a></li>
</ul>
</li>
<li><a href="#set">Set Operations, &lt;boost/mp11/set.hpp&gt;</a>
<ul class="sectlevel3">
<li><a href="#mp_is_sets">mp_is_set&lt;S&gt;</a></li>
<li><a href="#mp_set_containss_v">mp_set_contains&lt;S, V&gt;</a></li>
<li><a href="#mp_set_push_backs_t">mp_set_push_back&lt;S, T&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_set_push_fronts_t">mp_set_push_front&lt;S, T&#8230;&#8203;&gt;</a></li>
</ul>
</li>
<li><a href="#map">Map Operations, &lt;boost/mp11/map.hpp&gt;</a>
<ul class="sectlevel3">
<li><a href="#mp_is_mapm">mp_is_map&lt;M&gt;</a></li>
<li><a href="#mp_map_findm_k">mp_map_find&lt;M, K&gt;</a></li>
<li><a href="#mp_map_containsm_k">mp_map_contains&lt;M, K&gt;</a></li>
<li><a href="#mp_map_insertm_t">mp_map_insert&lt;M, T&gt;</a></li>
<li><a href="#mp_map_replacem_t">mp_map_replace&lt;M, T&gt;</a></li>
<li><a href="#mp_map_updatem_t_f">mp_map_update&lt;M, T, F&gt;</a></li>
<li><a href="#mp_map_update_qm_t_q">mp_map_update_q&lt;M, T, Q&gt;</a></li>
<li><a href="#mp_map_erasem_k">mp_map_erase&lt;M, K&gt;</a></li>
<li><a href="#mp_map_keysm">mp_map_keys&lt;M&gt;</a></li>
</ul>
</li>
<li><a href="#function">Helper Metafunctions, &lt;boost/mp11/function.hpp&gt;</a>
<ul class="sectlevel3">
<li><a href="#mp_voidt">mp_void&lt;T&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_andt">mp_and&lt;T&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_allt">mp_all&lt;T&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_ort">mp_or&lt;T&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_anyt">mp_any&lt;T&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_samet">mp_same&lt;T&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_plust">mp_plus&lt;T&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_lesst1_t2">mp_less&lt;T1, T2&gt;</a></li>
<li><a href="#mp_mint1_t">mp_min&lt;T1, T&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_maxt1_t">mp_max&lt;T1, T&#8230;&#8203;&gt;</a></li>
</ul>
</li>
<li><a href="#bind">Bind, &lt;boost/mp11/bind.hpp&gt;</a>
<ul class="sectlevel3">
<li><a href="#mp_argi">mp_arg&lt;I&gt;</a></li>
<li><a href="#1_9">_1, &#8230;&#8203;, _9</a></li>
<li><a href="#mp_bindf_t">mp_bind&lt;F, T&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_bind_qq_t">mp_bind_q&lt;Q, T&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_bind_frontf_t">mp_bind_front&lt;F, T&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_bind_front_qq_t">mp_bind_front_q&lt;Q, T&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_bind_backf_t">mp_bind_back&lt;F, T&#8230;&#8203;&gt;</a></li>
<li><a href="#mp_bind_back_qq_t">mp_bind_back_q&lt;Q, T&#8230;&#8203;&gt;</a></li>
</ul>
</li>
<li><a href="#integer_sequence">Integer Sequences, &lt;boost/mp11/integer_sequence.hpp&gt;</a>
<ul class="sectlevel3">
<li><a href="#integer_sequencet_i">integer_sequence&lt;T, I&#8230;&#8203;&gt;</a></li>
<li><a href="#make_integer_sequencet_n">make_integer_sequence&lt;T, N&gt;</a></li>
<li><a href="#index_sequencei">index_sequence&lt;I&#8230;&#8203;&gt;</a></li>
<li><a href="#make_index_sequencen">make_index_sequence&lt;N&gt;</a></li>
<li><a href="#index_sequence_fort">index_sequence_for&lt;T&#8230;&#8203;&gt;</a></li>
</ul>
</li>
<li><a href="#tuple">Tuple Operations, &lt;boost/mp11/tuple.hpp&gt;</a>
<ul class="sectlevel3">
<li><a href="#tuple_applyf_tp">tuple_apply(f, tp)</a></li>
<li><a href="#construct_from_tuplettp">construct_from_tuple&lt;T&gt;(tp)</a></li>
<li><a href="#tuple_for_eachtp_f">tuple_for_each(tp, f)</a></li>
</ul>
</li>
<li><a href="#mp11">Convenience Header, &lt;boost/mp11.hpp&gt;</a></li>
<li><a href="#mpl">MPL Support, &lt;boost/mp11/mpl.hpp&gt;</a></li>
</ul>
</li>
<li><a href="#copyright_license_and_acknowledgments">Appendix A: Copyright, License, and Acknowledgments</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="overview">Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Mp11 is a C++11 metaprogramming library for compile-time manipulation of data structures
that contain types. It&#8217;s based on template aliases and variadic templates and implements the
approach outlined in the article
<a href="simple_cxx11_metaprogramming.html">"Simple C++ metaprogramming"</a>
and <a href="simple_cxx11_metaprogramming_2.html">its sequel</a>. Reading these
articles before proceeding with this documentation is <em>highly</em> recommended.</p>
</div>
<div class="paragraph">
<p>The general principles upon which Mp11 is built are that algorithms and metafunctions are
template aliases of the form <code>F&lt;T&#8230;&#8203;&gt;</code> and data structures are lists of the form <code>L&lt;T&#8230;&#8203;&gt;</code>,
with the library placing no requirements on <code>L</code>. <code>mp_list&lt;T&#8230;&#8203;&gt;</code> is the built-in list type,
but <code>std::tuple&lt;T&#8230;&#8203;&gt;</code>, <code>std::pair&lt;T1, T2&gt;</code> and <code>std::variant&lt;T&#8230;&#8203;&gt;</code> are also perfectly
legitimate list types, although of course <code>std::pair&lt;T1, T2&gt;</code>, due to having exactly two elements,
is not resizeable and will consequently not work with algorithms that need to add or remove
elements.</p>
</div>
<div class="paragraph">
<p>Another distinguishing feature of this approach is that lists (<code>L&lt;T&#8230;&#8203;&gt;</code>) have the same form as
metafunctions (<code>F&lt;T&#8230;&#8203;&gt;</code>) and can therefore be used as such. For example, applying <code>std::add_pointer_t</code>
to the list <code>std::tuple&lt;int, float&gt;</code> by way of <code>mp_transform&lt;std::add_pointer_t, std::tuple&lt;int, float&gt;&gt;</code>
gives us <code>std::tuple&lt;int*, float*&gt;</code>, but we can also apply <code>mp_list</code> to the same tuple:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>using R = mp_transform&lt;mp_list, std::tuple&lt;int, float&gt;&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>and get <code>std::tuple&lt;mp_list&lt;int&gt;, mp_list&lt;float&gt;&gt;</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="definitions">Definitions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A <em>list</em> is a&#8201;&#8212;&#8201;usually but not necessarily variadic&#8201;&#8212;&#8201;template class whose parameters are all types,
for example <code>mp_list&lt;char[], void&gt;</code>, <code>mp_list&lt;&gt;</code>, <code>std::tuple&lt;int, float, char&gt;</code>, <code>std::pair&lt;int, float&gt;</code>, <code>std::shared_ptr&lt;X&gt;</code>.</p>
</div>
<div class="paragraph">
<p>A <em>metafunction</em> is a class template or a template alias whose parameters are all types, for example <code>std::add_pointer_t</code>,
<code>std::is_const</code>, <code>mp_second</code>, <code>mp_push_front</code>, <code>mp_list</code>, <code>std::tuple</code>, <code>std::pair</code>, <code>std::shared_ptr</code>, or</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>template&lt;class...&gt; using F1 = void;

template&lt;class T&gt; using F2 = T*;

template&lt;class... T&gt; using F3 = std::integral_constant&lt;std::size_t, sizeof...(T)&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A <em>quoted metafunction</em> is a class with a public metafunction member called <code>fn</code>, for example</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>struct Q1 { template&lt;class...&gt; using fn = void; };

struct Q2 { template&lt;class T&gt; using fn = T*; };

struct Q3 { template&lt;class... T&gt; using fn =
  std::integral_constant&lt;std::size_t, sizeof...(T)&gt;; };</code></pre>
</div>
</div>
<div class="paragraph">
<p>An <em>integral constant type</em> is a class with a public member <code>value</code> that is an integral constant in the C++ sense. For example,
<code>std::integral_constant&lt;int, 7&gt;</code>, or</p>
</div>
<div class="literalblock">
<div class="content">
<pre>struct N { static int constexpr value = 2; };</pre>
</div>
</div>
<div class="paragraph">
<p>A <em>set</em> is a list whose elements are unique.</p>
</div>
<div class="paragraph">
<p>A <em>map</em> is a list of lists, the inner lists having at least one element (the key.) The keys of the map must be unique. For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>using M1 = std::tuple&lt;std::pair&lt;int, int*&gt;, std::pair&lt;float, float*&gt;,
    std::pair&lt;void, void*&gt;&gt;;

using M2 = mp_list&lt;mp_list&lt;int, int*&gt;, mp_list&lt;float&gt;,
    mp_list&lt;char, char[1], char[2]&gt;&gt;;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="examples">Examples</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="generating_test_cases">Generating Test Cases</h3>
<div class="paragraph">
<p>Let&#8217;s suppose that we have written a metafunction <code>result&lt;T, U&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>template&lt;class T&gt; using promote = typename std::common_type&lt;T, int&gt;::type;

template&lt;class T, class U&gt; using result =
    typename std::common_type&lt;promote&lt;T&gt;, promote&lt;U&gt;&gt;::type;</code></pre>
</div>
</div>
<div class="paragraph">
<p>that ought to represent the result of an arithmetic operation on the integer types <code>T</code> and <code>U</code>,
for example <code>t + u</code>. We want to test whether <code>result&lt;T, U&gt;</code> gives correct results for various combinations
of <code>T</code> and <code>U</code>, so we write the function</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>template&lt;class T1, class T2&gt; void test_result()
{
    using T3 = decltype( T1() + T2() );
    using T4 = result&lt;T1, T2&gt;;

    std::cout &lt;&lt; ( std::is_same&lt;T3, T4&gt;::value? "[PASS]": "[FAIL]" ) &lt;&lt; std::endl;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and then need to call it a substantial number of times:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>int main()
{
    test_result&lt;char, char&gt;();
    test_result&lt;char, short&gt;();
    test_result&lt;char, int&gt;();
    test_result&lt;char, unsigned&gt;();
    // ...
}</pre>
</div>
</div>
<div class="paragraph">
<p>Writing all those type combinations by hand is unwieldy, error prone, and worst of all, boring. This is
how we can leverage Mp11 to automate the task:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>#include &lt;boost/mp11.hpp&gt;
#include &lt;boost/core/demangle.hpp&gt;
#include &lt;type_traits&gt;
#include &lt;iostream&gt;
#include &lt;typeinfo&gt;

using namespace boost::mp11;

template&lt;class T&gt; std::string name()
{
    return boost::core::demangle( typeid(T).name() );
}

template&lt;class T&gt; using promote = typename std::common_type&lt;T, int&gt;::type;

template&lt;class T, class U&gt; using result =
    typename std::common_type&lt;promote&lt;T&gt;, promote&lt;U&gt;&gt;::type;

template&lt;class T1, class T2&gt; void test_result( mp_list&lt;T1, T2&gt; const&amp; )
{
    using T3 = decltype( T1() + T2() );
    using T4 = result&lt;T1, T2&gt;;

    std::cout &lt;&lt; ( std::is_same&lt;T3, T4&gt;::value? "[PASS] ": "[FAIL] " )
        &lt;&lt; name&lt;T1&gt;() &lt;&lt; " + " &lt;&lt; name&lt;T2&gt;() &lt;&lt; " -&gt; " &lt;&lt; name&lt;T3&gt;()
        &lt;&lt; ", result: " &lt;&lt; name&lt;T4&gt;() &lt;&lt; std::endl;
}

int main()
{
    using L = std::tuple&lt;char, short, int, unsigned, long, unsigned long&gt;;
    tuple_for_each( mp_product&lt;mp_list, L, L&gt;(), [](auto&amp;&amp; x){ test_result(x); } );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>How does it work?</p>
</div>
<div class="paragraph">
<p><code>mp_product&lt;F, L1, L2&gt;</code> calls <code>F&lt;T1, T2&gt;</code> where <code>T1</code> varies over the elements of <code>L1</code> and <code>T2</code> varies over
the elements of <code>L2</code>, as if by executing two nested loops. It then returns a list of these results, of the same
type as <code>L1</code>.</p>
</div>
<div class="paragraph">
<p>In our case, both lists are the same <code>std::tuple</code>, and <code>F</code> is <code>mp_list</code>, so <code>mp_product&lt;mp_list, L, L&gt;</code> will get us
<code>std::tuple&lt;mp_list&lt;char, char&gt;, mp_list&lt;char, short&gt;, mp_list&lt;char, int&gt;, &#8230;&#8203;, mp_list&lt;unsigned long, long&gt;, mp_list&lt;unsigned long, unsigned long&gt;&gt;</code>.</p>
</div>
<div class="paragraph">
<p>We then default-construct this tuple and pass it to <code>tuple_for_each</code>. <code>tuple_for_each(tp, f)</code> calls <code>f</code> for every
tuple element; we use a (C++14) lambda that calls <code>test_result</code>.</p>
</div>
<div class="paragraph">
<p>In pure C++11, we can&#8217;t use a lambda with an <code>auto&amp;&amp;</code> parameter, so we&#8217;ll have to make <code>test_result</code> a function object with
a templated <code>operator()</code> and pass that to <code>tuple_for_each</code> directly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>struct test_result
{
    template&lt;class T1, class T2&gt; void operator()( mp_list&lt;T1, T2&gt; const&amp; ) const
    {
        using T3 = decltype( T1() + T2() );
        using T4 = result&lt;T1, T2&gt;;

        std::cout &lt;&lt; ( std::is_same&lt;T3, T4&gt;::value? "[PASS] ": "[FAIL] " )
            &lt;&lt; name&lt;T1&gt;() &lt;&lt; " + " &lt;&lt; name&lt;T2&gt;() &lt;&lt; " -&gt; " &lt;&lt; name&lt;T3&gt;()
            &lt;&lt; ", result: " &lt;&lt; name&lt;T4&gt;() &lt;&lt; std::endl;
    }
};

int main()
{
    using L = std::tuple&lt;char, short, int, unsigned, long, unsigned long&gt;;
    tuple_for_each( mp_product&lt;mp_list, L, L&gt;(), test_result() );
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="writing_common_type_specializations">Writing common_type Specializations</h3>
<div class="paragraph">
<p>The standard trait <code>std::common_type</code>, used to obtain a type to which all of its arguments can convert without
unnecessary loss of precision, can be user-specialized when its default implementation (based on the ternary <code>?:</code>
operator) is unsuitable.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s write a <code>common_type</code> specialization for two <code>std::tuple</code> arguments. For that, we need a metafunction that
applies <code>std::common_type</code> to each pair of elements and gathers the results into a tuple:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>template&lt;class... T&gt; using common_type_t =
    typename std::common_type&lt;T...&gt;::type; // standard in C++14

template&lt;class Tp1, class Tp2&gt; using common_tuple =
    mp_transform&lt;common_type_t, Tp1, Tp2&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>then specialize <code>common_type</code> to use it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>namespace std
{

    template&lt;class... T1, class... T2&gt;
    struct common_type&lt;std::tuple&lt;T1...&gt;, std::tuple&lt;T2...&gt;&gt;:
        mp_defer&lt;common_tuple, std::tuple&lt;T1...&gt;, std::tuple&lt;T2...&gt;&gt;
    {
    };

} // std</code></pre>
</div>
</div>
<div class="paragraph">
<p>(There is no need to specialize <code>std::common_type</code> for more than two arguments - it takes care of synthesizing the appropriate semantics from
the binary case.)</p>
</div>
<div class="paragraph">
<p>The subtlety here is the use of <code>mp_defer</code>. We could have defined a nested <code>type</code> to <code>common_tuple&lt;std::tuple&lt;T1&#8230;&#8203;&gt;, std::tuple&lt;T2&#8230;&#8203;&gt;&gt;</code>,
and it would still have worked in all valid cases. By letting <code>mp_defer</code> define <code>type</code>, though, we make our specialization <em>SFINAE-friendly</em>.</p>
</div>
<div class="paragraph">
<p>That is, when our <code>common_tuple</code> causes a substitution failure instead of a hard error, <code>mp_defer</code> will not define a nested <code>type</code>,
and <code>common_type_t</code>, which is defined as <code>typename common_type&lt;&#8230;&#8203;&gt;::type</code>, will also cause a substitution failure.</p>
</div>
<div class="paragraph">
<p>As another example, consider the hypothetical type <code>expected&lt;T, E&#8230;&#8203;&gt;</code> that represents either a successful return with a value of <code>T</code>,
or an unsuccessful return with an error code of some type in the list <code>E&#8230;&#8203;</code>. The common type of <code>expected&lt;T1, E1, E2, E3&gt;</code> and
<code>expected&lt;T2, E1, E4, E5&gt;</code> is <code>expected&lt;common_type_t&lt;T1, T2&gt;, E1, E2, E3, E4, E5&gt;</code>. That is, the possible return values are
combined into their common type, and we take the union of the set of error types.</p>
</div>
<div class="paragraph">
<p>Therefore,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>template&lt;class T1, class E1, class T2, class E2&gt; using common_expected =
    mp_rename&lt;mp_push_front&lt;mp_unique&lt;mp_append&lt;E1, E2&gt;&gt;, common_type_t&lt;T1, T2&gt;&gt;,
        expected&gt;;

namespace std
{

    template&lt;class T1, class... E1, class T2, class... E2&gt;
    struct common_type&lt;expected&lt;T1, E1...&gt;, expected&lt;T2, E2...&gt;&gt;:
        mp_defer&lt;common_expected, T1, mp_list&lt;E1...&gt;, T2, mp_list&lt;E2...&gt;&gt;
    {
    };

} // std</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we&#8217;ve taken a different tack; instead of passing the <code>expected</code> types to <code>common_expected</code>, we&#8217;re passing the <code>T</code> types and lists of
the <code>E</code> types. This makes our job easier. <code>mp_unique&lt;mp_append&lt;E1, E2&gt;&gt;</code> gives us the concatenation of <code>E1</code> and <code>E2</code> with the duplicates
removed; we then add <code>common_type_t&lt;T1, T2&gt;</code> to the front via <code>mp_push_front</code>; and finally, we <code>mp_rename</code> the resultant <code>mp_list</code>
to <code>expected</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="fixing_tuple_cat">Fixing tuple_cat</h3>
<div class="paragraph">
<p>The article <a href="http://pdimov.com/cpp2/simple_cxx11_metaprogramming.html#">Simple C++11 metaprogramming</a> builds an
implementation of the standard function <code>tuple_cat</code>, with the end result given below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>template&lt;class L&gt; using F = mp_iota&lt;mp_size&lt;L&gt;&gt;;

template&lt;class R, class...Is, class... Ks, class Tp&gt;
R tuple_cat_( mp_list&lt;Is...&gt;, mp_list&lt;Ks...&gt;, Tp tp )
{
    return R{ std::get&lt;Ks::value&gt;(std::get&lt;Is::value&gt;(tp))... };
}

template&lt;class... Tp,
    class R = mp_append&lt;std::tuple&lt;&gt;, typename std::remove_reference&lt;Tp&gt;::type...&gt;&gt;
    R tuple_cat( Tp &amp;&amp;... tp )
{
    std::size_t const N = sizeof...(Tp);

    // inner

    using list1 = mp_list&lt;
        mp_rename&lt;typename std::remove_reference&lt;Tp&gt;::type, mp_list&gt;...&gt;;

    using list2 = mp_iota_c&lt;N&gt;;

    using list3 = mp_transform&lt;mp_fill, list1, list2&gt;;

    using inner = mp_apply&lt;mp_append, list3&gt;;

    // outer

    using list4 = mp_transform&lt;F, list1&gt;;

    using outer = mp_apply&lt;mp_append, list4&gt;;

    //

    return tuple_cat_&lt;R&gt;( inner(), outer(),
        std::forward_as_tuple( std::forward&lt;Tp&gt;(tp)... ) );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This function, however, is not entirely correct, in that it doesn&#8217;t handle some cases properly. For example,
trying to concatenate tuples containing move-only elements such as <code>unique_ptr</code> fails:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>std::tuple&lt;std::unique_ptr&lt;int&gt;&gt; t1;
std::tuple&lt;std::unique_ptr&lt;float&gt;&gt; t2;

auto result = ::tuple_cat( std::move( t1 ), std::move( t2 ) );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Trying to concatenate <code>const</code> tuples fails:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>std::tuple&lt;int&gt; const t1;
std::tuple&lt;float&gt; const t2;

auto result = ::tuple_cat( t1, t2 );</code></pre>
</div>
</div>
<div class="paragraph">
<p>And finally, the standard <code>tuple_cat</code> is specified to work on arbitrary tuple-like types (that is, all types
that support <code>tuple_size</code>, <code>tuple_element</code>, and <code>get</code>), while our implementation only works with <code>tuple</code> and
<code>pair</code>. <code>std::array</code>, for example, fails:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>std::array&lt;int, 2&gt; t1{ 1, 2 };
std::array&lt;float, 3&gt; t2{ 3.0f, 4.0f, 5.0f };

auto result = ::tuple_cat( t1, t2 );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s fix these one by one. Support for move-only types is easy, if one knows where to look. The problem is
that <code>Tp</code> that we&#8217;re passing to the helper <code>tuple_cat_</code> is (correctly) <code>tuple&lt;unique_ptr&lt;int&gt;&amp;&amp;, unique_ptr&lt;float&gt;&amp;&amp;&gt;</code>,
but <code>std::get&lt;0&gt;(tp)</code> still returns <code>unique_ptr&lt;int&gt;&amp;</code>, because <code>tp</code> is an lvalue. This behavior is a bit
surprising, but is intended to prevent inadvertent double moves.</p>
</div>
<div class="paragraph">
<p>Long story short, we need <code>std::move(tp)</code> in <code>tuple_cat_</code> to make <code>tp</code> an rvalue:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>template&lt;class R, class...Is, class... Ks, class Tp&gt;
R tuple_cat_( mp_list&lt;Is...&gt;, mp_list&lt;Ks...&gt;, Tp tp )
{
    return R{ std::get&lt;Ks::value&gt;(std::get&lt;Is::value&gt;(std::move(tp)))... };
}</pre>
</div>
</div>
<div class="paragraph">
<p>Next, <code>const</code>-qualified tuples. The issue here is that we&#8217;re stripping references from the input tuples, but not
<code>const</code>. As a result, we&#8217;re trying to manipulate types such as <code>tuple&lt;int&gt; const</code> with Mp11 algorithms, and these
types do not fit the list concept. We just need to strip qualifiers as well, by defining the useful <code>remove_cv_ref</code>
primitive that is inexplicably missing from the standard library:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>template&lt;class T&gt; using remove_cv_ref = typename std::remove_cv&lt;
    typename std::remove_reference&lt;T&gt;::type&gt;::type;</pre>
</div>
</div>
<div class="paragraph">
<p>and then by using <code>remove_cv_ref&lt;Tp&gt;</code> in place of <code>typename std::remove_reference&lt;Tp&gt;::type</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>template&lt;class... Tp,
    class R = mp_append&lt;std::tuple&lt;&gt;, remove_cv_ref&lt;Tp&gt;...&gt;&gt;
    R tuple_cat( Tp &amp;&amp;... tp )
{
    std::size_t const N = sizeof...(Tp);

    // inner

    using list1 = mp_list&lt;mp_rename&lt;remove_cv_ref&lt;Tp&gt;, mp_list&gt;...&gt;;

    // ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, tuple-like types. We&#8217;ve so far exploited the fact that <code>std::pair</code> and <code>std::tuple</code> are valid Mp11 lists,
but in general, arbitrary tuple-like types aren&#8217;t, so we need to convert them into such. For that, we&#8217;ll need to
define a metafunction <code>from_tuple_like</code> that will take an arbitrary tuple-like type and will return, in our case,
the corresponding <code>mp_list</code>.</p>
</div>
<div class="paragraph">
<p>Technically, a more principled approach would&#8217;ve been to return <code>std::tuple</code>, but here <code>mp_list</code> will prove more
convenient.</p>
</div>
<div class="paragraph">
<p>What we need is, given a tuple-like type <code>Tp</code>, to obtain <code>mp_list&lt;std::tuple_element&lt;0, Tp&gt;::type, std::tuple_element&lt;1, Tp&gt;::type,
&#8230;&#8203;, std::tuple_element&lt;N-1, Tp&gt;::type&gt;</code>, where <code>N</code> is <code>tuple_size&lt;Tp&gt;::value</code>. Here&#8217;s one way to do it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>template&lt;class T, class I&gt; using tuple_element =
    typename std::tuple_element&lt;I::value, T&gt;::type;

template&lt;class T&gt; using from_tuple_like =
    mp_product&lt;tuple_element, mp_list&lt;T&gt;, mp_iota&lt;std::tuple_size&lt;T&gt;&gt;&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>(<code>mp_iota&lt;N&gt;</code> is an algorithm that returns an <code>mp_list</code> with elements <code>mp_size_t&lt;0&gt;</code>, <code>mp_size_t&lt;1&gt;</code>, &#8230;&#8203;, <code>mp_size_t&lt;N-1&gt;</code>.)</p>
</div>
<div class="paragraph">
<p>Remember that <code>mp_product&lt;F, L1, L2&gt;</code> performs the equivalent of two nested loops over the elements of <code>L1</code> and <code>L2</code>,
applying <code>F</code> to the two variables and gathering the result. In our case <code>L1</code> consists of the single element <code>T</code>, so
only the second loop (over <code>mp_iota&lt;N&gt;</code>, where <code>N</code> is <code>tuple_size&lt;T&gt;</code>), remains, and we get a list of the same type
as <code>L1</code> (an <code>mp_list</code>) with contents <code>tuple_element&lt;T, mp_size_t&lt;0&gt;&gt;</code>, <code>tuple_element&lt;T, mp_size_t&lt;1&gt;&gt;</code>, &#8230;&#8203;,
<code>tuple_element&lt;T, mp_size_t&lt;N-1&gt;&gt;</code>.</p>
</div>
<div class="paragraph">
<p>For completeness&#8217;s sake, here&#8217;s another, more traditional way to achieve the same result:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>template&lt;class T&gt; using from_tuple_like =
    mp_transform_q&lt;mp_bind_front&lt;tuple_element, T&gt;, mp_iota&lt;std::tuple_size&lt;T&gt;&gt;&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>With all these fixes applied, our fully operational <code>tuple_cat</code> now looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>template&lt;class L&gt; using F = mp_iota&lt;mp_size&lt;L&gt;&gt;;

template&lt;class R, class...Is, class... Ks, class Tp&gt;
R tuple_cat_( mp_list&lt;Is...&gt;, mp_list&lt;Ks...&gt;, Tp tp )
{
    return R{ std::get&lt;Ks::value&gt;(std::get&lt;Is::value&gt;(std::move(tp)))... };
}

template&lt;class T&gt; using remove_cv_ref = typename std::remove_cv&lt;
    typename std::remove_reference&lt;T&gt;::type&gt;::type;

template&lt;class T, class I&gt; using tuple_element =
    typename std::tuple_element&lt;I::value, T&gt;::type;

template&lt;class T&gt; using from_tuple_like =
    mp_product&lt;tuple_element, mp_list&lt;T&gt;, mp_iota&lt;std::tuple_size&lt;T&gt;&gt;&gt;;

template&lt;class... Tp,
    class R = mp_append&lt;std::tuple&lt;&gt;, from_tuple_like&lt;remove_cv_ref&lt;Tp&gt;&gt;...&gt;&gt;
    R tuple_cat( Tp &amp;&amp;... tp )
{
    std::size_t const N = sizeof...(Tp);

    // inner

    using list1 = mp_list&lt;from_tuple_like&lt;remove_cv_ref&lt;Tp&gt;&gt;...&gt;;
    using list2 = mp_iota_c&lt;N&gt;;

    using list3 = mp_transform&lt;mp_fill, list1, list2&gt;;

    using inner = mp_apply&lt;mp_append, list3&gt;;

    // outer

    using list4 = mp_transform&lt;F, list1&gt;;

    using outer = mp_apply&lt;mp_append, list4&gt;;

    //

    return tuple_cat_&lt;R&gt;( inner(), outer(),
        std::forward_as_tuple( std::forward&lt;Tp&gt;(tp)... ) );
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="computing_return_types">Computing Return Types</h3>
<div class="paragraph">
<p>C++17 has a standard variant type, called <code>std::variant</code>. It also defines a function template
<code>std::visit</code> that can be used to apply a function to the contained value of one or more variants.
So for instance, if the variant <code>v1</code> contains <code>1</code>, and the variant <code>v2</code> contains <code>2.0f</code>,
<code>std::visit(f, v1, v2)</code> will call <code>f(1, 2.0f)</code>.</p>
</div>
<div class="paragraph">
<p>However, <code>std::visit</code> has one limitation: it cannot return a result unless all
possible applications of the function have the same return type. If, for instance, <code>v1</code> and <code>v2</code>
are both of type <code>std::variant&lt;short, int, float&gt;</code>,</p>
</div>
<div class="literalblock">
<div class="content">
<pre>std::visit( []( auto const&amp; x, auto const&amp; y ){ return x + y; }, v1, v2 );</pre>
</div>
</div>
<div class="paragraph">
<p>will fail to compile because the result of <code>x + y</code> can be either <code>int</code> or <code>float</code> depending on
what <code>v1</code> and <code>v2</code> hold.</p>
</div>
<div class="paragraph">
<p>A type that can hold either <code>int</code> or <code>float</code> already exists, called, surprisingly enough, <code>std::variant&lt;int, float&gt;</code>.
Let&#8217;s write our own function template <code>rvisit</code> that is the same as <code>visit</code> but returns a <code>variant</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>template&lt;class F, class... V&gt; auto rvisit( F&amp;&amp; f, V&amp;&amp;... v )
{
    using R = /*...*/;

    return std::visit( [&amp;]( auto&amp;&amp;... x )
        { return R( std::forward&lt;F&gt;(f)( std::forward&lt;decltype(x)&gt;(x)... ) ); },
        std::forward&lt;V&gt;( v )... );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>What this does is basically calls <code>std::visit</code> to do the work, but instead of passing it <code>f</code>, we pass a lambda that does the same as <code>f</code> except
it converts the result to a common type <code>R</code>. <code>R</code> is supposed to be <code>std::variant&lt;&#8230;&#8203;&gt;</code> where the ellipsis denotes the return types of
calling <code>f</code> with all possible combinations of variant values.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll first define a helper quoted metafunction <code>Qret&lt;F&gt;</code> that returns the result of the application of <code>F</code> to arguments of type <code>T&#8230;&#8203;</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>template&lt;class F&gt; struct Qret
{
    template&lt;class... T&gt; using fn =
        decltype( std::declval&lt;F&gt;()( std::declval&lt;T&gt;()... ) );
};</pre>
</div>
</div>
<div class="paragraph">
<p>(Unfortunately, we can&#8217;t just define this metafunction inside <code>rvisit</code>; the language prohibits defining template aliases inside functions.)</p>
</div>
<div class="paragraph">
<p>With <code>Qret</code> in hand, a <code>variant</code> of the possible return types is just a matter of applying it over the possible combinations of the variant values:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>using R = mp_product_q&lt;Qret&lt;F&gt;, std::remove_reference_t&lt;V&gt;...&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>Why does this work? <code>mp_product&lt;F, L1&lt;T1&#8230;&#8203;&gt;, L2&lt;T2&#8230;&#8203;&gt;, &#8230;&#8203;, Ln&lt;Tn&#8230;&#8203;&gt;&gt;</code> returns <code>L1&lt;F&lt;U1, U2, &#8230;&#8203;, Un&gt;, &#8230;&#8203;&gt;</code>, where <code>Ui</code> traverse all
possible combinations of list values. Since in our case all <code>Li</code> are <code>std::variant</code>, the result will also be <code>std::variant</code>. (<code>mp_product_q</code> is
the same as <code>mp_product</code>, but for quoted metafunctions such as our <code>Qret&lt;F&gt;</code>.)</p>
</div>
<div class="paragraph">
<p>One more step remains. Suppose that, as above, we&#8217;re passing two variants of type <code>std::variant&lt;short, int, float&gt;</code> and <code>F</code> is
<code>[]( auto const&amp; x, auto const&amp; y ){ return x + y; }</code>. This will generate <code>R</code> of length 9, one per each combination, but many of those
elements will be the same, either <code>int</code> or <code>float</code>, and we need to filter out the duplicates. So, we pass the result to <code>mp_unique</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>using R = mp_unique&lt;mp_product_q&lt;Qret&lt;F&gt;, std::remove_reference_t&lt;V&gt;...&gt;&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>and we&#8217;re done:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>#include &lt;boost/mp11.hpp&gt;
#include &lt;boost/core/demangle.hpp&gt;
#include &lt;variant&gt;
#include &lt;type_traits&gt;
#include &lt;typeinfo&gt;
#include &lt;iostream&gt;

using namespace boost::mp11;

template&lt;class F&gt; struct Qret
{
    template&lt;class... T&gt; using fn =
        decltype( std::declval&lt;F&gt;()( std::declval&lt;T&gt;()... ) );
};

template&lt;class F, class... V&gt; auto rvisit( F&amp;&amp; f, V&amp;&amp;... v )
{
    using R = mp_unique&lt;mp_product_q&lt;Qret&lt;F&gt;, std::remove_reference_t&lt;V&gt;...&gt;&gt;;

    return std::visit( [&amp;]( auto&amp;&amp;... x )
        { return R( std::forward&lt;F&gt;(f)( std::forward&lt;decltype(x)&gt;(x)... ) ); },
        std::forward&lt;V&gt;( v )... );
}

template&lt;class T&gt; std::string name()
{
    return boost::core::demangle( typeid(T).name() );
}

template&lt;class V&gt; void print_variant( char const * n, V const&amp; v )
{
    std::cout &lt;&lt; "(" &lt;&lt; name&lt;decltype(v)&gt;() &lt;&lt; ")" &lt;&lt; n &lt;&lt; ": ";

    std::visit( []( auto const&amp; x )
        { std::cout &lt;&lt; "(" &lt;&lt; name&lt;decltype(x)&gt;() &lt;&lt; ")" &lt;&lt; x &lt;&lt; std::endl; }, v );
}

int main()
{
    std::variant&lt;char, int, float&gt; v1( 1 );

    print_variant( "v1", v1 );

    std::variant&lt;short, int, double&gt; v2( 3.14 );

    print_variant( "v2", v2 );

    auto v3 = rvisit( []( auto const&amp; x, auto const&amp; y ){ return x + y; }, v1, v2 );

    print_variant( "v3", v3 );
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reference">Reference</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The contents of the library are in namespace <code>boost::mp11</code>.</p>
</div>
<div class="sect2">
<h3 id="integral">Integral Constants, &lt;boost/mp11/integral.hpp&gt;</h3>
<div class="paragraph">
<p>For an Mp11 integral constant type <code>T</code>, <code>T::value</code> is an integral constant in the C++ sense.</p>
</div>
<div class="sect3">
<h4 id="mp_boolb">mp_bool&lt;B&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;bool B&gt; using mp_bool = std::integral_constant&lt;bool, B&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>Same as <code>std::bool_constant</code> in C++17.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_true">mp_true</h4>
<div class="literalblock">
<div class="content">
<pre>using mp_true = mp_bool&lt;true&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>Same as <code>std::true_type</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_false">mp_false</h4>
<div class="literalblock">
<div class="content">
<pre>using mp_false = mp_bool&lt;false&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>Same as <code>std::false_type</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_to_boolt">mp_to_bool&lt;T&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class T&gt; using mp_to_bool = mp_bool&lt;static_cast&lt;bool&gt;(T::value)&gt;;</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_nott">mp_not&lt;T&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class T&gt; using mp_not = mp_bool&lt; !T::value &gt;;</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_inti">mp_int&lt;I&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;int I&gt; using mp_int = std::integral_constant&lt;int, I&gt;;</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_size_tn">mp_size_t&lt;N&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;std::size_t N&gt; using mp_size_t = std::integral_constant&lt;std::size_t, N&gt;;</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="list">List Operations, &lt;boost/mp11/list.hpp&gt;</h3>
<div class="sect3">
<h4 id="mp_listt">mp_list&lt;T&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class... T&gt; struct mp_list {};</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_list</code> is the standard list type of Mp11, although the library is not restricted to it and can operate on arbitrary class templates
such as <code>std::tuple</code> or <code>std::variant</code>. Even <code>std::pair</code> can be used if the transformation does not alter the number of the elements in
the list.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_list_ct_i">mp_list_c&lt;T, I&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class T, T... I&gt; using mp_list_c =
    mp_list&lt;std::integral_constant&lt;T, I&gt;...&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_list_c</code> produces an <code>mp_list</code> of the <code>std::integral_constant</code> types corresponding to its integer template arguments.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 1. Using mp_list_c</div>
<div class="content">
<pre class="highlight"><code>using L1 = mp_list_c&lt;int, 2, 3&gt;; // mp_list&lt;mp_int&lt;2&gt;, mp_int&lt;3&gt;&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_is_listl">mp_is_list&lt;L&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L&gt; using mp_is_list = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_is_list&lt;L&gt;</code> is <code>mp_true</code> if <code>L</code> is a list (an instantiation of a class template whose template parameters are types), <code>mp_false</code> otherwise.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_sizel">mp_size&lt;L&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L&gt; using mp_size = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_size&lt;L&gt;</code> returns the number of elements in the list <code>L</code>, as a <code>mp_size_t</code>. In other words, <code>mp_size&lt;L&lt;T&#8230;&#8203;&gt;&gt;</code> is an alias for
<code>mp_size_t&lt;sizeof&#8230;&#8203;(T)&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 2. Using mp_size with mp_list</div>
<div class="content">
<pre class="highlight"><code>using L1 = mp_list&lt;&gt;;
using R1 = mp_size&lt;L1&gt;; // mp_size_t&lt;0&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Code Example 3. Using mp_size with std::pair</div>
<div class="content">
<pre class="highlight"><code>using L2 = std::pair&lt;int, int&gt;;
using R2 = mp_size&lt;L2&gt;; // mp_size_t&lt;2&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Code Example 4. Using mp_size with std::tuple</div>
<div class="content">
<pre class="highlight"><code>using L3 = std::tuple&lt;float&gt;;
using R3 = mp_size&lt;L3&gt;; // mp_size_t&lt;1&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_emptyl">mp_empty&lt;L&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L&gt; using mp_empty = mp_bool&lt;mp_size&lt;L&gt;::value == 0&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_empty&lt;L&gt;</code> is an alias for <code>mp_true</code> if the list <code>L</code> is empty, for <code>mp_false</code> otherwise.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 5. Using mp_empty with std::tuple</div>
<div class="content">
<pre class="highlight"><code>using L1 = std::tuple&lt;float&gt;;
using R1 = mp_empty&lt;L1&gt;; // mp_false

using L2 = std::tuple&lt;&gt;;
using R2 = mp_empty&lt;L2&gt;; // mp_true</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_assignl1_l2">mp_assign&lt;L1, L2&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L1, class L2&gt; using mp_assign = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_assign&lt;L1&lt;T1&#8230;&#8203;&gt;, L2&lt;T2&#8230;&#8203;&gt;&gt;</code> is an alias for <code>L1&lt;T2&#8230;&#8203;&gt;</code>. That is, it replaces the elements of <code>L1</code> with those of <code>L2</code>.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 6. Using mp_assign with mp_list and std::tuple</div>
<div class="content">
<pre class="highlight"><code>using L1 = std::tuple&lt;long&gt;;
using L2 = mp_list&lt;int, float&gt;;

using R1 = mp_assign&lt;L1, L2&gt;; // std::tuple&lt;int, float&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Code Example 7. Using mp_assign with mp_list and std::pair</div>
<div class="content">
<pre class="highlight"><code>using L1 = std::pair&lt;long, char&gt;;
using L2 = mp_list&lt;int, float&gt;;

using R1 = mp_assign&lt;L1, L2&gt;; // std::pair&lt;int, float&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_clearl">mp_clear&lt;L&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L&gt; using mp_clear = mp_assign&lt;L, mp_list&lt;&gt;&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_clear&lt;L&lt;T&#8230;&#8203;&gt;&gt;</code> is an alias for <code>L&lt;&gt;</code>, that is, it removes the elements of <code>L</code>.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 8. Using mp_clear with std::tuple</div>
<div class="content">
<pre class="highlight"><code>using L1 = std::tuple&lt;int, float&gt;;
using R1 = mp_clear&lt;L1&gt;; // std::tuple&lt;&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_frontl">mp_front&lt;L&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L&gt; using mp_front = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_front&lt;L&gt;</code> is the first element of the list <code>L</code>. That is, <code>mp_front&lt;L&lt;T1, T&#8230;&#8203;&gt;&gt;</code> is an alias for <code>T1</code>.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 9. Using mp_front with std::pair</div>
<div class="content">
<pre class="highlight"><code>using L1 = std::pair&lt;int, float&gt;;
using R1 = mp_front&lt;L1&gt;; // int</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Code Example 10. Using mp_front with std::tuple</div>
<div class="content">
<pre class="highlight"><code>using L2 = std::tuple&lt;float, double, long double&gt;;
using R2 = mp_front&lt;L2&gt;; // float</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Code Example 11. Using mp_front with mp_list</div>
<div class="content">
<pre class="highlight"><code>using L3 = mp_list&lt;char[1], char[2], char[3], char[4]&gt;;
using R3 = mp_front&lt;L3&gt;; // char[1]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_pop_frontl">mp_pop_front&lt;L&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L&gt; using mp_pop_front = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_pop_front&lt;L&gt;</code> removes the first element of the list <code>L</code>. That is, <code>mp_pop_front&lt;L&lt;T1, T&#8230;&#8203;&gt;&gt;</code> is an alias for <code>L&lt;T&#8230;&#8203;&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 12. Using mp_pop_front with std::tuple</div>
<div class="content">
<pre class="highlight"><code>using L1 = std::tuple&lt;float, double, long double&gt;;
using R1 = mp_pop_front&lt;L1&gt;; // std::tuple&lt;double, long double&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Code Example 13. Using mp_pop_front with mp_list</div>
<div class="content">
<pre class="highlight"><code>using L2 = mp_list&lt;void&gt;;
using R2 = mp_pop_front&lt;L2&gt;; // mp_list&lt;&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_firstl">mp_first&lt;L&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L&gt; using mp_first = mp_front&lt;L&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_first</code> is another name for <code>mp_front</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_restl">mp_rest&lt;L&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L&gt; using mp_rest = mp_pop_front&lt;L&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_rest</code> is another name for <code>mp_pop_front</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_secondl">mp_second&lt;L&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L&gt; using mp_second = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_second&lt;L&gt;</code> is the second element of the list <code>L</code>. That is, <code>mp_second&lt;L&lt;T1, T2, T&#8230;&#8203;&gt;&gt;</code> is an alias for <code>T2</code>.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 14. Using mp_second with std::pair</div>
<div class="content">
<pre class="highlight"><code>using L1 = std::pair&lt;int, float&gt;;
using R1 = mp_second&lt;L1&gt;; // float</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Code Example 15. Using mp_second with std::tuple</div>
<div class="content">
<pre class="highlight"><code>using L2 = std::tuple&lt;float, double, long double&gt;;
using R2 = mp_second&lt;L2&gt;; // double</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Code Example 16. Using mp_second with mp_list</div>
<div class="content">
<pre class="highlight"><code>using L3 = mp_list&lt;char[1], char[2], char[3], char[4]&gt;;
using R3 = mp_second&lt;L3&gt;; // char[2]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_thirdl">mp_third&lt;L&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L&gt; using mp_third = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_third&lt;L&gt;</code> is the third element of the list <code>L</code>. That is, <code>mp_third&lt;L&lt;T1, T2, T3, T&#8230;&#8203;&gt;&gt;</code> is an alias for <code>T3</code>.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 17. Using mp_third with std::tuple</div>
<div class="content">
<pre class="highlight"><code>using L1 = std::tuple&lt;float, double, long double&gt;;
using R1 = mp_third&lt;L1&gt;; // long double</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Code Example 18. Using mp_third with mp_list</div>
<div class="content">
<pre class="highlight"><code>using L2 = mp_list&lt;char[1], char[2], char[3], char[4]&gt;;
using R2 = mp_third&lt;L2&gt;; // char[3]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_push_frontl_t">mp_push_front&lt;L, T&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class... T&gt; using mp_push_front = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_push_front&lt;L, T&#8230;&#8203;&gt;</code> inserts the elements <code>T&#8230;&#8203;</code> at the front of the list <code>L</code>. That is, <code>mp_push_front&lt;L&lt;U&#8230;&#8203;&gt;, T&#8230;&#8203;&gt;</code>
is an alias for <code>L&lt;T&#8230;&#8203;, U&#8230;&#8203;&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 19. Using mp_push_front with std::tuple</div>
<div class="content">
<pre class="highlight"><code>using L1 = std::tuple&lt;double, long double&gt;;
using R1 = mp_push_front&lt;L1, float&gt;; // std::tuple&lt;float, double, long double&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Code Example 20. Using mp_push_front with mp_list</div>
<div class="content">
<pre class="highlight"><code>using L2 = mp_list&lt;void&gt;;
using R2 = mp_push_front&lt;L2, char[1], char[2]&gt;; // mp_list&lt;char[1], char[2], void&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_push_backl_t">mp_push_back&lt;L, T&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class... T&gt; using mp_push_back = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_push_back&lt;L, T&#8230;&#8203;&gt;</code> inserts the elements <code>T&#8230;&#8203;</code> at the back of the list <code>L</code>. That is, <code>mp_push_back&lt;L&lt;U&#8230;&#8203;&gt;, T&#8230;&#8203;&gt;</code>
is an alias for <code>L&lt;U&#8230;&#8203;, T&#8230;&#8203;&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 21. Using mp_push_back with std::tuple</div>
<div class="content">
<pre class="highlight"><code>using L1 = std::tuple&lt;double, long double&gt;;
using R1 = mp_push_back&lt;L1, float&gt;; // std::tuple&lt;double, long double, float&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Code Example 22. Using mp_push_back with mp_list</div>
<div class="content">
<pre class="highlight"><code>using L2 = mp_list&lt;void&gt;;
using R2 = mp_push_back&lt;L2, char[1], char[2]&gt;; // mp_list&lt;void, char[1], char[2]&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_renamel_y">mp_rename&lt;L, Y&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, template&lt;class...&gt; class Y&gt; using mp_rename = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_rename&lt;L, Y&gt;</code> changes the type of the list <code>L</code> to <code>Y</code>. That is, <code>mp_rename&lt;L&lt;T&#8230;&#8203;&gt;, Y&gt;</code> is an alias for <code>Y&lt;T&#8230;&#8203;&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 23. Using mp_rename to rename std::pair to std::tuple</div>
<div class="content">
<pre class="highlight"><code>using L1 = std::pair&lt;double, long double&gt;;
using R1 = mp_rename&lt;L1, std::tuple&gt;; // std::tuple&lt;double, long double&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Code Example 24. Using mp_rename to rename std::tuple to mp_list</div>
<div class="content">
<pre class="highlight"><code>using L2 = std::tuple&lt;void&gt;;
using R2 = mp_rename&lt;L2, mp_list&gt;; // mp_list&lt;void&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_applyf_l">mp_apply&lt;F, L&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;template&lt;class...&gt; class F, class L&gt; using mp_apply = mp_rename&lt;L, F&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_apply&lt;F, L&gt;</code> applies the metafunction <code>F</code> to the contents of the list <code>L</code>, that is, <code>mp_apply&lt;F, L&lt;T&#8230;&#8203;&gt;&gt;</code> is an alias for <code>F&lt;T&#8230;&#8203;&gt;</code>.
(<code>mp_apply</code> is the same as <code>mp_rename</code> with the arguments reversed.)</p>
</div>
<div class="listingblock">
<div class="title">Code Example 25. Using mp_apply with std::pair</div>
<div class="content">
<pre class="highlight"><code>using L1 = std::pair&lt;double, long double&gt;;
using R1 = mp_apply&lt;std::is_same, L1&gt;; // std::is_same&lt;double, long double&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_apply_qq_l">mp_apply_q&lt;Q, L&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class Q, class L&gt; using mp_apply_q = mp_apply&lt;Q::template fn, L&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>Same as <code>mp_apply</code>, but takes a quoted metafunction.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 26. Using mp_apply_q with mp_bind_front</div>
<div class="content">
<pre class="highlight"><code>using L1 = std::tuple&lt;double, long double&gt;;
using L2 = mp_list&lt;int, long&gt;;

using R1 = mp_apply_q&lt;mp_bind_front&lt;mp_push_back, L1&gt;, L2&gt;;
  // R1 is std::tuple&lt;double, long double, int, long&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_appendl">mp_append&lt;L&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class... L&gt; using mp_append = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_append&lt;L&#8230;&#8203;&gt;</code> concatenates the lists in <code>L&#8230;&#8203;</code> into a single list that has the same type as the first list. <code>mp_append&lt;&gt;</code>
is an alias for <code>mp_list&lt;&gt;</code>. <code>mp_append&lt;L1&lt;T1&#8230;&#8203;&gt;, L2&lt;T2&#8230;&#8203;&gt;, &#8230;&#8203;, Ln&lt;Tn&#8230;&#8203;&gt;&gt;</code> is an alias for <code>L1&lt;T1&#8230;&#8203;, T2&#8230;&#8203;, &#8230;&#8203;, Tn&#8230;&#8203;&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 27. Using mp_append with lists of various types</div>
<div class="content">
<pre class="highlight"><code>using L1 = std::tuple&lt;double, long double&gt;;
using L2 = mp_list&lt;int&gt;;
using L3 = std::pair&lt;short, long&gt;;
using L4 = mp_list&lt;&gt;;

using R1 = mp_append&lt;L1, L2, L3, L4&gt;;
  // std::tuple&lt;double, long double, int, short, long&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_replace_frontl_t">mp_replace_front&lt;L, T&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class T&gt; using mp_replace_front = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_replace_front&lt;L, T&gt;</code> replaces the first element of the list <code>L</code> with <code>T</code>. That is, <code>mp_replace_front&lt;L&lt;U1, U&#8230;&#8203;&gt;, T&gt;</code> is
an alias for <code>L&lt;T, U&#8230;&#8203;&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 28. Using mp_replace_front with std::pair</div>
<div class="content">
<pre class="highlight"><code>using L1 = std::pair&lt;int, float&gt;;
using R1 = mp_replace_front&lt;L1, void&gt;; // std::pair&lt;void, float&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Code Example 29. Using mp_replace_front with std::tuple</div>
<div class="content">
<pre class="highlight"><code>using L2 = std::tuple&lt;float, double, long double&gt;;
using R2 = mp_replace_front&lt;L2, void&gt;; // std::tuple&lt;void, double, long double&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Code Example 30. Using mp_replace_front with mp_list</div>
<div class="content">
<pre class="highlight"><code>using L3 = mp_list&lt;char[1], char[2], char[3], char[4]&gt;;
using R3 = mp_replace_front&lt;L3, void&gt;; // mp_list&lt;void, char[2], char[3], char[4]&gt;;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_replace_firstl_t">mp_replace_first&lt;L, T&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class T&gt; using mp_replace_first = mp_replace_front&lt;L, T&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_replace_first</code> is another name for <code>mp_replace_front</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_replace_secondl_t">mp_replace_second&lt;L, T&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class T&gt; using mp_replace_second = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_replace_second&lt;L, T&gt;</code> replaces the second element of the list <code>L</code> with <code>T</code>. That is, <code>mp_replace_second&lt;L&lt;U1, U2, U&#8230;&#8203;&gt;, T&gt;</code>
is an alias for <code>L&lt;U1, T, U&#8230;&#8203;&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 31. Using mp_replace_second with std::pair</div>
<div class="content">
<pre class="highlight"><code>using L1 = std::pair&lt;int, float&gt;;
using R1 = mp_replace_second&lt;L1, void&gt;; // std::pair&lt;int, void&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Code Example 32. Using mp_replace_second with std::tuple</div>
<div class="content">
<pre class="highlight"><code>using L2 = std::tuple&lt;float, double, long double&gt;;
using R2 = mp_replace_second&lt;L2, void&gt;; // std::tuple&lt;float, void, long double&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Code Example 33. Using mp_replace_front with mp_list</div>
<div class="content">
<pre class="highlight"><code>using L3 = mp_list&lt;char[1], char[2], char[3], char[4]&gt;;
using R3 = mp_replace_second&lt;L3, void&gt;; // mp_list&lt;char[1], void, char[3], char[4]&gt;;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_replace_thirdl_t">mp_replace_third&lt;L, T&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class T&gt; using mp_replace_third = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_replace_third&lt;L, T&gt;</code> replaces the third element of the list <code>L</code> with <code>T</code>. That is, <code>mp_replace_third&lt;L&lt;U1, U2, U3, U&#8230;&#8203;&gt;, T&gt;</code>
is an alias for <code>L&lt;U1, U2, T, U&#8230;&#8203;&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 34. Using mp_replace_third with std::tuple</div>
<div class="content">
<pre class="highlight"><code>using L1 = std::tuple&lt;float, double, long double&gt;;
using R1 = mp_replace_third&lt;L1, void&gt;; // std::tuple&lt;float, double, void&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Code Example 35. Using mp_replace_third with mp_list</div>
<div class="content">
<pre class="highlight"><code>using L2 = mp_list&lt;char[1], char[2], char[3], char[4]&gt;;
using R2 = mp_replace_third&lt;L2, void&gt;; // mp_list&lt;char[1], char[2], void, char[4]&gt;;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="utility">Utility Components, &lt;boost/mp11/utility.hpp&gt;</h3>
<div class="sect3">
<h4 id="mp_identityt">mp_identity&lt;T&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class T&gt; struct mp_identity
{
    using type = T;
};</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_identity</code> is a simple <em>transformation type trait</em> (as per the C++ standard)
that just returns the same type. It&#8217;s useful both as such, and as a type wrapper
for passing types as values to functions.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 36. Using mp_identity as a type trait</div>
<div class="content">
<pre class="highlight"><code>template&lt;class T&gt; using addp_if_not_ref =
    typename mp_if&lt;std::is_reference&lt;T&gt;, mp_identity&lt;T&gt;, std::add_pointer&lt;T&gt;&gt;::type;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Code Example 37. Using mp_identity to protect qualifiers and references</div>
<div class="content">
<pre class="highlight"><code>template&lt;class T&gt; void print1()
{
    std::cout &lt;&lt; typeid(T).name() &lt;&lt; std::endl;
}

template&lt;class T&gt; void print2()
{
    std::cout &lt;&lt; typeid(mp_identity&lt;T&gt;).name() &lt;&lt; std::endl;
}

int main()
{
    print1&lt;int const&amp;&gt;(); // 'int'
    print2&lt;int const&amp;&gt;(); // 'mp_identity&lt;int const &amp;&gt;'
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_identity_tt">mp_identity_t&lt;T&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class T&gt; using mp_identity_t = typename mp_identity&lt;T&gt;::type;</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_inheritt">mp_inherit&lt;T&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class... T&gt; struct mp_inherit: T... {};</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_if_cc_t_e">mp_if_c&lt;C, T, E&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;bool C, class T, class... E&gt; using mp_if_c = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_if_c&lt;true, T, E&#8230;&#8203;&gt;</code> is an alias for <code>T</code>. <code>mp_if_c&lt;false, T, E&gt;</code> is an alias for <code>E</code>. Otherwise, the result is a substitution failure.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 38. Using mp_if_c to select between two alternatives</div>
<div class="content">
<pre class="highlight"><code>using R1 = mp_if_c&lt;true, int, void&gt;;  // int

using R2 = mp_if_c&lt;false, int, void&gt;; // void</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Code Example 39. Using mp_if_c to fail substitution when a condition is not met</div>
<div class="content">
<pre class="highlight"><code>template&lt;class I&gt; using void_if_5 = mp_if_c&lt;I::value == 5, void&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This example returns <code>void</code> when <code>I::value</code> is 5, and generates a substitution failure
otherwise. It&#8217;s the same as <code>std::enable_if_t&lt;I::value == 5&gt;</code> in C++14, or
<code>typename std::enable_if&lt;I::value == 5&gt;::type</code> in C++11.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_ifc_t_e">mp_if&lt;C, T, E&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class C, class T, class... E&gt; using mp_if =
    mp_if_c&lt;static_cast&lt;bool&gt;(C::value), T, E...&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>Like <code>mp_if_c</code>, but the first argument is a type.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 40. Using mp_if to select between two alternatives</div>
<div class="content">
<pre class="highlight"><code>using R1 = mp_if&lt;mp_true, int, void&gt;;  // int

using R2 = mp_if&lt;mp_false, int, void&gt;; // void</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Code Example 41. Using mp_if to fail substitution when a condition is not met</div>
<div class="content">
<pre class="highlight"><code>template&lt;class T&gt; using void_if_const = mp_if&lt;std::is_const&lt;T&gt;, void&gt;;

template&lt;class... T&gt; using void_if_all_const =
    mp_if&lt;mp_all&lt;std::is_const&lt;T&gt;...&gt;, void&gt;;

template&lt;class T&gt; using if_non_const = mp_if&lt;mp_not&lt;std::is_const&lt;T&gt;&gt;, T&gt;;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_eval_if_cc_t_f_u">mp_eval_if_c&lt;C, T, F, U&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;bool C, class T, template&lt;class...&gt; class F, class... U&gt; using mp_eval_if_c =
    /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_eval_if_c&lt;C, T, F, U&#8230;&#8203;&gt;</code> is an alias for <code>T</code> when <code>C</code> is <code>true</code>, for <code>F&lt;U&#8230;&#8203;&gt;</code> otherwise. Its purpose
is to avoid evaluating <code>F&lt;U&#8230;&#8203;&gt;</code> when the condition is <code>true</code> as it may not be valid in this case.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 42. Using mp_eval_if_c to select the first pack element, or void</div>
<div class="content">
<pre class="highlight"><code>template&lt;class... T&gt; using first_or_void =
    mp_eval_if_c&lt;sizeof...(T) == 0, void, mp_apply, mp_first, mp_list&lt;T...&gt;&gt;;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_eval_ifc_t_f_u">mp_eval_if&lt;C, T, F, U&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class C, class T, template&lt;class...&gt; class F, class... U&gt; using mp_eval_if =
    mp_eval_if_c&lt;static_cast&lt;bool&gt;(C::value), T, F, U...&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>Like <code>mp_eval_if_c</code>, but the first argument is a type.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 43. Using mp_eval_if to select the first list element, or void</div>
<div class="content">
<pre class="highlight"><code>template&lt;class L&gt; using first_or_void = mp_eval_if&lt;mp_empty&lt;L&gt;, void, mp_first, L&gt;;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_eval_if_qc_t_q_u">mp_eval_if_q&lt;C, T, Q, U&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class C, class T, class Q, class... U&gt; using mp_eval_if_q =
    mp_eval_if&lt;C, T, Q::template fn, U...&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>Like <code>mp_eval_if</code>, but takes a quoted metafunction.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_condc_t_r">mp_cond&lt;C, T, R&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class C, class T, class... R&gt; using mp_cond = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_cond&lt;C, T, R&#8230;&#8203;&gt;</code> is an alias for <code>T</code> when <code>static_cast&lt;bool&gt;(C::value)</code> is <code>true</code>.
When <code>static_cast&lt;bool&gt;(C::value)</code> is <code>false</code>, it&#8217;s an alias for <code>mp_cond&lt;R&#8230;&#8203;&gt;</code>.</p>
</div>
<div class="paragraph">
<p>(If <code>static_cast&lt;bool&gt;(C::value)</code> is a substitution failure, the result is too a substitution
failure.)</p>
</div>
<div class="listingblock">
<div class="title">Code Example 44. Using mp_cond</div>
<div class="content">
<pre class="highlight"><code>template&lt;int N&gt; using unsigned_ = mp_cond&lt;
    mp_bool&lt;N ==  8&gt;, uint8_t,
    mp_bool&lt;N == 16&gt;, uint16_t,
    mp_bool&lt;N == 32&gt;, uint32_t,
    mp_bool&lt;N == 64&gt;, uint64_t,
    mp_true, unsigned // default case
&gt;;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_validf_t">mp_valid&lt;F, T&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;template&lt;class...&gt; class F, class... T&gt; using mp_valid = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_valid&lt;F, T&#8230;&#8203;&gt;</code> is an alias for <code>mp_true</code> when <code>F&lt;T&#8230;&#8203;&gt;</code> is a valid expression, for <code>mp_false</code> otherwise.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 45. Using mp_valid to write a metafunction that checks for the existence of a nested type</div>
<div class="content">
<pre class="highlight"><code>template&lt;class T&gt; using get_nested_type = typename T::type;

template&lt;class T&gt; struct has_nested_type: mp_valid&lt;get_nested_type, T&gt; {};</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_deferf_t">mp_defer&lt;F, T&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;template&lt;class...&gt; class F, class... T&gt; using mp_defer = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p>When <code>mp_valid&lt;F, T&#8230;&#8203;&gt;</code> is <code>mp_true</code>, <code>mp_defer&lt;F, T&#8230;&#8203;&gt;</code> is a struct with a nested type <code>type</code> which is an alias for <code>F&lt;T&#8230;&#8203;&gt;</code>. Otherwise,
<code>mp_defer&lt;F, T&#8230;&#8203;&gt;</code> is an empty struct.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_quotef">mp_quote&lt;F&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;template&lt;class...&gt; class F&gt; struct mp_quote
{
    template&lt;class... T&gt; using fn = F&lt;T...&gt;;
};</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_quote&lt;F&gt;</code> transforms the template <code>F</code> into a type with a nested template <code>fn</code> such that <code>fn&lt;T&#8230;&#8203;&gt;</code> returns <code>F&lt;T&#8230;&#8203;&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 46. Using mp_quote to make a list of metafunctions</div>
<div class="content">
<pre class="highlight"><code>using LQ = mp_list&lt;mp_quote&lt;std::is_const&gt;, mp_quote&lt;std::is_volatile&gt;&gt;;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_quote_traitf">mp_quote_trait&lt;F&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;template&lt;class...&gt; class F&gt; struct mp_quote_trait
{
    template&lt;class... T&gt; using fn = typename F&lt;T...&gt;::type;
};</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_quote_trait&lt;F&gt;</code> transforms the C++03-style trait <code>F</code> into a quoted metafunction.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 47. Using mp_quote_trait with std::add_pointer</div>
<div class="content">
<pre class="highlight"><code>using L1 = mp_list&lt;int, void, float&gt;;
using R1 = mp_transform_q&lt;mp_quote_trait&lt;std::add_pointer&gt;, L1&gt;;
  // mp_list&lt;int*, void*, float*&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_invokeq_t">mp_invoke&lt;Q, T&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class Q, class... T&gt; using mp_invoke = typename Q::template fn&lt;T...&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_invoke&lt;Q, T&#8230;&#8203;&gt;</code> evaluates the nested template <code>fn</code> of a quoted metafunction. <code>mp_invoke&lt;mp_quote&lt;F&gt;, T&#8230;&#8203;&gt;</code> returns <code>F&lt;T&#8230;&#8203;&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 48. Using mp_invoke to invoke a list of metafunctions, technique 1</div>
<div class="content">
<pre class="highlight"><code>using LQ = mp_list&lt;mp_quote&lt;std::is_const&gt;, mp_quote&lt;std::is_volatile&gt;&gt;;

template&lt;class T&gt; using is_const_and_volatile =
    mp_all&lt;mp_product&lt;mp_invoke, LQ, mp_list&lt;T&gt;&gt;&gt;;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Code Example 49. Using mp_invoke to invoke a list of metafunctions, technique 2</div>
<div class="content">
<pre class="highlight"><code>template&lt;class T&gt; using is_const_and_volatile =
    mp_all&lt;mp_transform_q&lt;mp_bind_back&lt;mp_invoke, T&gt;, LQ&gt;&gt;;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Code Example 50. Using mp_invoke to invoke a list of metafunctions, technique 3</div>
<div class="content">
<pre class="highlight"><code>template&lt;class T&gt; using is_const_and_volatile =
    mp_all&lt;mp_transform&lt;mp_invoke, LQ, mp_fill&lt;LQ, T&gt;&gt;&gt;;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="algorithm">Algorithms, &lt;boost/mp11/algorithm.hpp&gt;</h3>
<div class="sect3">
<h4 id="mp_transformf_l">mp_transform&lt;F, L&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;template&lt;class...&gt; class F, class... L&gt; using mp_transform = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_transform&lt;F, L1&lt;T1&#8230;&#8203;&gt;, L2&lt;T2&#8230;&#8203;&gt;, &#8230;&#8203;, Ln&lt;Tn&#8230;&#8203;&gt;&gt;</code> applies <code>F</code> to each successive tuple of elements and returns <code>L1&lt;F&lt;T1, T2, &#8230;&#8203;, Tn&gt;&#8230;&#8203;&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 51. Using mp_transform to produce a list of pointers from a list of pointees</div>
<div class="content">
<pre class="highlight"><code>template&lt;class T&gt; using add_pointer_t =
    typename std::add_pointer&lt;T&gt;::type;  // std::add_pointer_t in C++14

using L1 = std::tuple&lt;void, int, float&gt;;
using R1 = mp_transform&lt;add_pointer_t, L1&gt;; // std::tuple&lt;void*, int*, float*&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Code Example 52. Using mp_transform to compare the contents of two lists of types</div>
<div class="content">
<pre class="highlight"><code>using L1 = std::tuple&lt;void, int, float&gt;;
using L2 = mp_list&lt;void, int, float&gt;;

using R1 = mp_all&lt;mp_transform&lt;std::is_same, L1, L2&gt;&gt;; // mp_true</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Code Example 53. Using mp_transform to compare the contents of two lists of integral constants</div>
<div class="content">
<pre class="highlight"><code>template&lt;class T1, class T2&gt; using eq = mp_bool&lt;T1::value == T2::value&gt;;

using L1 = std::tuple&lt;mp_int&lt;1&gt;, mp_int&lt;2&gt;, mp_int&lt;3&gt;&gt;;
using L2 = mp_list&lt;mp_size_t&lt;1&gt;, mp_size_t&lt;2&gt;, mp_size_t&lt;3&gt;&gt;;

using R1 = mp_all&lt;mp_transform&lt;eq, L1, L2&gt;&gt;; // mp_true</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all" style="width: 85%;">
<caption class="title">Illustration 1. mp_transform on one list</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>L1</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>1</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>2</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>n</sub></code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle" colspan="5"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>mp_transform&lt;F, L1&gt;</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>F&lt;A<sub>1</sub>&gt;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>F&lt;A<sub>2</sub>&gt;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>F&lt;A<sub>n</sub>&gt;</code></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all" style="width: 85%;">
<caption class="title">Illustration 2. mp_transform on two lists</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>L1</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>1</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>2</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>n</sub></code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle" colspan="5"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>L2</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>B<sub>1</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>B<sub>2</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>B<sub>n</sub></code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle" colspan="5"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>mp_transform&lt;F, L1, L2&gt;</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>F&lt;A<sub>1</sub>,B<sub>1</sub>&gt;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>F&lt;A<sub>2</sub>,B<sub>2</sub>&gt;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>F&lt;A<sub>n</sub>,B<sub>n</sub>&gt;</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="mp_transform_qq_l">mp_transform_q&lt;Q, L&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class Q, class... L&gt; using mp_transform_q =
    mp_transform&lt;Q::template fn, L...&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>As <code>mp_transform</code>, but takes a quoted metafunction.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 54. Using mp_transform_q to count the occurrences of <code>void</code> in a list</div>
<div class="content">
<pre class="highlight"><code>using L1 = std::tuple&lt;void, int, float, void, int&gt;;

using R1 = mp_apply&lt;mp_plus,
    mp_transform_q&lt;mp_bind_front&lt;std::is_same, void&gt;, L1&gt;&gt;; // mp_int&lt;2&gt;</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all" style="width: 85%;">
<caption class="title">Illustration 3. mp_transform_q on two lists</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>L1</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>1</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>2</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>n</sub></code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle" colspan="5"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>L2</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>B<sub>1</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>B<sub>2</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>B<sub>n</sub></code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle" colspan="5"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>mp_transform_q&lt;Q, L1, L2&gt;</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>Q::fn&lt;A<sub>1</sub>,B<sub>1</sub>&gt;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>Q::fn&lt;A<sub>2</sub>,B<sub>2</sub>&gt;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>Q::fn&lt;A<sub>n</sub>,B<sub>n</sub>&gt;</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="mp_transform_ifp_f_l">mp_transform_if&lt;P, F, L&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;template&lt;class...&gt; class P, template&lt;class...&gt; class F, class... L&gt;
    using mp_transform_if = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_transform_if&lt;P, F, L1, L2, &#8230;&#8203;, Ln&gt;</code> replaces the elements of the list <code>L1</code> for which <code>mp_to_bool&lt;P&lt;T1, T2, &#8230;&#8203;, Tn&gt;&gt;</code> is <code>mp_true</code> with
<code>F&lt;T1, T2, &#8230;&#8203;, Tn&gt;</code>, and returns the result, where <code>Ti</code> are the corresponding elements of <code>Li</code>.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 55. Using mp_transform_if to replace the occurrences of 'void' in a list with the corresponding elements of a second list</div>
<div class="content">
<pre class="highlight"><code>using L1 = std::tuple&lt;void, int, float, void, int&gt;;
using L2 = std::tuple&lt;char[1], char[2], char[3], char[4], char[5]&gt;;

template&lt;class T1, class T2&gt; using first_is_void = std::is_same&lt;T1, void&gt;;
template&lt;class T1, class T2&gt; using second = T2;

using R1 = mp_transform_if&lt;first_is_void, second, L1, L2&gt;;
  // std::tuple&lt;char[1], int, float, char[4], int&gt;</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all" style="width: 85%;">
<caption class="title">Illustration 4. mp_transform_if</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>L1</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>1</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>2</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>n</sub></code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle" colspan="5"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>P&lt;A<sub>i</sub>&gt;</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>mp_false</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>mp_true</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>mp_false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle" colspan="5"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>L2</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>B<sub>1</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>B<sub>2</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>B<sub>n</sub></code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle" colspan="5"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>mp_transform_if&lt;P, F, L1, L2&gt;</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>1</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>F&lt;A<sub>2</sub>,B<sub>2</sub>&gt;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>n</sub></code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="mp_transform_if_qqp_qf_l">mp_transform_if_q&lt;Qp, Qf, L&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class Qp, class Qf, class... L&gt; using mp_transform_if_q =
    mp_transform_if&lt;Qp::template fn, Qf::template fn, L...&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>As <code>mp_transform_if</code>, but takes quoted metafunctions.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 56. Using mp_transform_if_q to replace the occurrences of 'void' in a list with the corresponding elements of a second list</div>
<div class="content">
<pre class="highlight"><code>using L1 = std::tuple&lt;void, int, float, void, int&gt;;
using L2 = std::tuple&lt;char[1], char[2], char[3], char[4], char[5]&gt;;

using R1 = mp_transform_if_q&lt;mp_bind&lt;std::is_same, _1, void&gt;, _2, L1, L2&gt;;
  // std::tuple&lt;char[1], int, float, char[4], int&gt;</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all" style="width: 85%;">
<caption class="title">Illustration 5. mp_transform_if_q</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>L1</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>1</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>2</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>n</sub></code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle" colspan="5"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>Qp::fn&lt;A<sub>i</sub>&gt;</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>mp_false</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>mp_true</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>mp_false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle" colspan="5"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>L2</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>B<sub>1</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>B<sub>2</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>B<sub>n</sub></code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle" colspan="5"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>mp_transform_if_q&lt;Qp, _2, L1, L2&gt;</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>1</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>B<sub>2</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>n</sub></code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="mp_filll_v">mp_fill&lt;L, V&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class V&gt; using mp_fill = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_fill&lt;L&lt;T&#8230;&#8203;&gt;, V&gt;</code> returns <code>L&lt;V, V, &#8230;&#8203;, V&gt;</code>, with the result having the same size as the input.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 57. Using mp_fill with std::tuple</div>
<div class="content">
<pre class="highlight"><code>using L1 = std::tuple&lt;void, int, float&gt;;
using R1 = mp_fill&lt;L1, double&gt;; // std::tuple&lt;double, double, double&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Code Example 58. Using mp_fill with std::pair</div>
<div class="content">
<pre class="highlight"><code>using L1 = std::pair&lt;int, float&gt;;
using R1 = mp_fill&lt;L1, void&gt;; // std::pair&lt;void, void&gt;</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all" style="width: 85%;">
<caption class="title">Illustration 6. mp_fill</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>L1</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>1</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>2</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>n</sub></code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle" colspan="5"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>mp_fill&lt;L1, V&gt;</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>V</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>V</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>V</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="mp_countl_v">mp_count&lt;L, V&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class V&gt; using mp_count = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_count&lt;L, V&gt;</code> returns <code>mp_size_t&lt;N&gt;</code>, where <code>N</code> is the number of elements of <code>L</code> same as <code>V</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_count_ifl_p">mp_count_if&lt;L, P&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, template&lt;class...&gt; class P&gt; using mp_count_if = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_count_if&lt;L, P&gt;</code> returns <code>mp_size_t&lt;N&gt;</code>, where <code>N</code> is the number of elements <code>T</code> of <code>L</code> for which <code>mp_to_bool&lt;P&lt;T&gt;&gt;</code> is <code>mp_true</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_count_if_ql_q">mp_count_if_q&lt;L, Q&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class Q&gt; using mp_count_if_q = mp_count_if&lt;L, Q::template fn&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>As <code>mp_count_if</code>, but takes a quoted metafunction.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_containsl_v">mp_contains&lt;L, V&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class V&gt; using mp_contains = mp_to_bool&lt;mp_count&lt;L, V&gt;&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_contains&lt;L, V&gt;</code> is <code>mp_true</code> when <code>L</code> contains an element <code>V</code>, <code>mp_false</code> otherwise.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_repeat_cl_n">mp_repeat_c&lt;L, N&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, std::size_t N&gt; using mp_repeat_c = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_repeat_c&lt;L, N&gt;</code> returns a list of the same form as <code>L</code> that consists of <code>N</code> concatenated copies of <code>L</code>.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 59. Using mp_repeat_c</div>
<div class="content">
<pre class="highlight"><code>using L1 = tuple&lt;int&gt;;
using R1 = mp_repeat_c&lt;L1, 3&gt;; // tuple&lt;int, int, int&gt;

using L2 = pair&lt;int, float&gt;;
using R2 = mp_repeat_c&lt;L2, 1&gt;; // pair&lt;int, float&gt;

using L3 = mp_list&lt;int, float&gt;;
using R3 = mp_repeat_c&lt;L3, 2&gt;; // mp_list&lt;int, float, int, float&gt;

using L4 = mp_list&lt;int, float, double&gt;;
using R4 = mp_repeat_c&lt;L4, 0&gt;; // mp_list&lt;&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_repeatl_n">mp_repeat&lt;L, N&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class N&gt; using mp_repeat = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p>Same as <code>mp_repeat_c</code> but with a type argument <code>N</code>. The number of copies is <code>N::value</code> and must be nonnegative.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_productf_l">mp_product&lt;F, L&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;template&lt;class...&gt; class F, class... L&gt; using mp_product = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_product&lt;F, L1&lt;T1&#8230;&#8203;&gt;, L2&lt;T2&#8230;&#8203;&gt;, &#8230;&#8203;, Ln&lt;Tn&#8230;&#8203;&gt;&gt;</code> evaluates <code>F&lt;U1, U2, &#8230;&#8203;, Un&gt;</code> for values <code>Ui</code> taken from
the Cartesian product of the lists, as if the elements <code>Ui</code> are formed by <code>n</code> nested loops, each traversing <code>Li</code>.
It returns a list of the form <code>L1&lt;V&#8230;&#8203;&gt;</code> containing the results of the application of <code>F</code>.</p>
</div>
<table class="tableblock frame-all grid-all" style="width: 85%;">
<caption class="title">Illustration 7. mp_product on two lists</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>L1</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>1</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>2</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>n</sub></code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle" colspan="5"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>L2</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>B<sub>1</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>B<sub>2</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>B<sub>m</sub></code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle" colspan="5"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>mp_product&lt;F, L1, L2&gt;</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>F&lt;A<sub>1</sub>,B<sub>1</sub>&gt;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>F&lt;A<sub>1</sub>,B<sub>2</sub>&gt;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>F&lt;A<sub>1</sub>,B<sub>m</sub>&gt;</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>F&lt;A<sub>2</sub>,B<sub>1</sub>&gt;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>F&lt;A<sub>2</sub>,B<sub>2</sub>&gt;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>F&lt;A<sub>2</sub>,B<sub>m</sub>&gt;</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"></td>
<td class="tableblock halign-center valign-middle" colspan="4"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>F&lt;A<sub>n</sub>,B<sub>1</sub>&gt;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>F&lt;A<sub>n</sub>,B<sub>2</sub>&gt;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>F&lt;A<sub>n</sub>,B<sub>m</sub>&gt;</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="mp_product_qq_l">mp_product_q&lt;Q, L&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class Q, class... L&gt; using mp_product_q = mp_product&lt;Q::template fn, L...&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>As <code>mp_product</code>, but takes a quoted metafunction.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_drop_cl_n">mp_drop_c&lt;L, N&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, std::size_t N&gt; using mp_drop_c = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_drop_c&lt;L, N&gt;</code> removes the first <code>N</code> elements of <code>L</code> and returns the result.</p>
</div>
<table class="tableblock frame-all grid-all" style="width: 85%;">
<caption class="title">Illustration 8. mp_drop_c</caption>
<colgroup>
<col style="width: 40%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>L1</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>1</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>m</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>m+1</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>n</sub></code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle" colspan="7"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>mp_drop_c&lt;L1, M&gt;</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>m+1</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>n</sub></code></p></td>
<td class="tableblock halign-center valign-middle" colspan="3"></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="mp_dropl_n">mp_drop&lt;L, N&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class N&gt; using mp_drop = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p>Same as <code>mp_drop_c</code>, but with a type argument <code>N</code>. <code>N::value</code> must be a nonnegative number.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_from_sequences">mp_from_sequence&lt;S&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class S&gt; using mp_from_sequence = /*...*/</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_from_sequence</code> transforms an integer sequence produced by <code>make_integer_sequence</code> into an <code>mp_list</code>
of the corresponding <code>std::integral_constant</code> types. Given</p>
</div>
<div class="literalblock">
<div class="content">
<pre>template&lt;class T, T... I&gt; struct S;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_from_sequence&lt;S&lt;T, I&#8230;&#8203;&gt;&gt;</code> is an alias for <code>mp_list&lt;std::integral_constant&lt;T, I&gt;&#8230;&#8203;&gt;</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_iota_cn">mp_iota_c&lt;N&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;std::size_t N&gt; using mp_iota_c = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_iota_c&lt;N&gt;</code> is an alias for <code>mp_list&lt;mp_size_t&lt;0&gt;, mp_size_t&lt;1&gt;, &#8230;&#8203;, mp_size_t&lt;N-1&gt;&gt;</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_iotan">mp_iota&lt;N&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class N&gt; using mp_iota = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p>Same as <code>mp_iota_c</code>, but with a type argument <code>N</code>. <code>N::value</code> must be a nonnegative number. Returns
<code>mp_list&lt;std::integral_constant&lt;T, 0&gt;, std::integral_constant&lt;T, 1&gt;, &#8230;&#8203;, std::integral_constant&lt;T, N::value-1&gt;&gt;</code>
where <code>T</code> is the type of <code>N::value</code>.</p>
</div>
<table class="tableblock frame-all grid-all" style="width: 85%;">
<caption class="title">Illustration 9. mp_iota</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>mp_iota&lt;mp_int&lt;4&gt;&gt;</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>mp_int&lt;0&gt;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>mp_int&lt;1&gt;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>mp_int&lt;2&gt;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>mp_int&lt;3&gt;</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="mp_at_cl_i">mp_at_c&lt;L, I&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, std::size_t I&gt; using mp_at_c = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_at_c&lt;L, I&gt;</code> returns the <code>I</code>-th element of <code>L</code>, zero-based.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_atl_i">mp_at&lt;L, I&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class I&gt; using mp_at = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p>Same as <code>mp_at_c</code>, but with a type argument <code>I</code>. <code>I::value</code> must be a nonnegative number.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_take_cl_n">mp_take_c&lt;L, N&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, std::size_t N&gt; using mp_take_c = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_take_c&lt;L, N&gt;</code> returns a list of the same form as <code>L</code> containing the first <code>N</code> elements of <code>L</code>.</p>
</div>
<table class="tableblock frame-all grid-all" style="width: 85%;">
<caption class="title">Illustration 10. mp_take_c</caption>
<colgroup>
<col style="width: 40%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>L1</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>1</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>m</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>m+1</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>n</sub></code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle" colspan="7"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>mp_take_c&lt;L1, M&gt;</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>1</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>m</sub></code></p></td>
<td class="tableblock halign-center valign-middle" colspan="3"></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="mp_takel_n">mp_take&lt;L, N&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class N&gt; using mp_take = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p>Same as <code>mp_take_c</code>, but with a type argument <code>N</code>. <code>N::value</code> must be a nonnegative number.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_insert_cl_i_t">mp_insert_c&lt;L, I, T&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, std::size_t I, class... T&gt; using mp_insert_c =
    mp_append&lt;mp_take_c&lt;L, I&gt;, mp_push_front&lt;mp_drop_c&lt;L, I&gt;, T...&gt;&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>Inserts the elements <code>T&#8230;&#8203;</code> into the list <code>L</code> at position <code>I</code> (a zero-based index).</p>
</div>
<table class="tableblock frame-all grid-all" style="width: 85%;">
<caption class="title">Illustration 11. mp_insert_c with two elements</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 8.3333%;">
<col style="width: 8.3333%;">
<col style="width: 8.3333%;">
<col style="width: 8.3333%;">
<col style="width: 8.3333%;">
<col style="width: 8.3333%;">
<col style="width: 8.3333%;">
<col style="width: 8.3336%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>L1</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>1</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>m</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>m+1</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>n</sub></code></p></td>
<td class="tableblock halign-center valign-middle" colspan="2"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle" colspan="9"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>mp_insert_c&lt;L1, M, B<sub>1</sub>, B<sub>2</sub>&gt;</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>1</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>m</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>B<sub>1</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>B<sub>2</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>m+1</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>n</sub></code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="mp_insertl_i_t">mp_insert&lt;L, I, T&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class I, class... T&gt; using mp_insert =
    mp_append&lt;mp_take&lt;L, I&gt;, mp_push_front&lt;mp_drop&lt;L, I&gt;, T...&gt;&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>Same as <code>mp_insert_c</code>, but with a type argument <code>I</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_erase_cl_i_j">mp_erase_c&lt;L, I, J&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, std::size_t I, std::size_t J&gt; using mp_erase_c =
    mp_append&lt;mp_take_c&lt;L, I&gt;, mp_drop_c&lt;L, J&gt;&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>Removes from the list <code>L</code> the elements with indices from <code>I</code> (inclusive) to <code>J</code> (exclusive).</p>
</div>
<table class="tableblock frame-all grid-all" style="width: 85%;">
<caption class="title">Illustration 12. mp_erase_c</caption>
<colgroup>
<col style="width: 30.7692%;">
<col style="width: 7.6923%;">
<col style="width: 7.6923%;">
<col style="width: 7.6923%;">
<col style="width: 7.6923%;">
<col style="width: 7.6923%;">
<col style="width: 7.6923%;">
<col style="width: 7.6923%;">
<col style="width: 7.6923%;">
<col style="width: 7.6924%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>L1</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>0</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>i-1</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>i</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>j-1</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>j</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>n-1</sub></code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle" colspan="10"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>mp_erase_c&lt;L1, I, J&gt;</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>0</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>i-1</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>j</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>n-1</sub></code></p></td>
<td class="tableblock halign-center valign-middle" colspan="3"></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="mp_erasel_i_j">mp_erase&lt;L, I, J&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class I, class J&gt; using mp_erase =
    mp_append&lt;mp_take&lt;L, I&gt;, mp_drop&lt;L, J&gt;&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>Same as <code>mp_erase_c</code>, but with a type arguments <code>I</code> and <code>J</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_replacel_v_w">mp_replace&lt;L, V, W&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class V, class W&gt; using mp_replace = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p>Replaces all <code>V</code> elements of <code>L</code> with <code>W</code> and returns the result.</p>
</div>
<table class="tableblock frame-all grid-all" style="width: 85%;">
<caption class="title">Illustration 13. mp_replace</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>L1</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>1</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>V</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>n</sub></code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle" colspan="5"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>mp_replace&lt;L1, V, W&gt;</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>1</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>W</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>n</sub></code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="mp_replace_ifl_p_w">mp_replace_if&lt;L, P, W&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, template&lt;class...&gt; class P, class W&gt; using mp_replace_if = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p>Replaces all <code>T</code> elements of <code>L</code> for which <code>mp_to_bool&lt;P&lt;T&gt;&gt;</code> is <code>mp_true</code> with <code>W</code> and returns the result.</p>
</div>
<table class="tableblock frame-all grid-all" style="width: 85%;">
<caption class="title">Illustration 14. mp_replace_if</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>L1</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>1</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>2</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>n</sub></code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle" colspan="5"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>P&lt;A<sub>i</sub>&gt;</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>mp_false</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>mp_true</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>mp_false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle" colspan="5"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>mp_replace_if&lt;L1, P, W&gt;</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>1</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>W</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>n</sub></code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="mp_replace_if_ql_q_w">mp_replace_if_q&lt;L, Q, W&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class Q, class W&gt; using mp_replace_if_q =
    mp_replace_if&lt;L, Q::template fn, W&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>As <code>mp_replace_if</code>, but takes a quoted metafunction.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_replace_at_cl_i_w">mp_replace_at_c&lt;L, I, W&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, std::size_t I, class W&gt; using mp_replace_at_c = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p>Replaces the element of <code>L</code> at zero-based index <code>I</code> with <code>W</code> and returns the result.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_replace_atl_i_w">mp_replace_at&lt;L, I, W&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class I, class W&gt; using mp_replace_at = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p>Same as <code>mp_replace_at_c</code>, but with a type argument <code>I</code>. <code>I::value</code> must be a nonnegative number.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_copy_ifl_p">mp_copy_if&lt;L, P&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, template&lt;class...&gt; class P&gt; using mp_copy_if = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p>Copies the elements <code>T</code> of <code>L</code> for which <code>mp_to_bool&lt;P&lt;T&gt;&gt;</code> is <code>mp_true</code> to a new list of the same form and returns it.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_copy_if_ql_q">mp_copy_if_q&lt;L, Q&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class Q&gt; using mp_copy_if_q = mp_copy_if&lt;L, Q::template fn&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>As <code>mp_copy_if</code>, but takes a quoted metafunction.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_removel_v">mp_remove&lt;L, V&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class V&gt; using mp_remove = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p>Removes all <code>V</code> elements of <code>L</code> and returns the result.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_remove_ifl_p">mp_remove_if&lt;L, P&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, template&lt;class...&gt; class P&gt; using mp_remove_if = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p>Removes all elements <code>T</code> of <code>L</code> for which <code>mp_to_bool&lt;P&lt;T&gt;&gt;</code> is <code>mp_true</code> and returns the result.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_remove_if_ql_q">mp_remove_if_q&lt;L, Q&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class Q&gt; using mp_remove_if_q = mp_remove_if&lt;L, Q::template fn&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>As <code>mp_remove_if</code>, but takes a quoted metafunction.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_partitionl_p">mp_partition&lt;L, P&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, template&lt;class...&gt; class P&gt; using mp_partition = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_partition&lt;L&lt;T&#8230;&#8203;&gt;, P&gt;</code> partitions <code>L</code> into two lists <code>L&lt;U1&#8230;&#8203;&gt;</code> and <code>L&lt;U2&#8230;&#8203;&gt;</code> such that <code>mp_to_bool&lt;P&lt;T&gt;&gt;</code> is <code>mp_true</code>
for the elements of <code>L&lt;U1&#8230;&#8203;&gt;</code> and <code>mp_false</code> for the elements of <code>L&lt;U2&#8230;&#8203;&gt;</code>. Returns <code>L&lt;L&lt;U1&#8230;&#8203;&gt;, L&lt;U2&#8230;&#8203;&gt;&gt;</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_partition_ql_q">mp_partition_q&lt;L, Q&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class Q&gt; using mp_partition_q = mp_partition&lt;L, Q::template fn&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>As <code>mp_partition</code>, but takes a quoted metafunction.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_sortl_p">mp_sort&lt;L, P&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, template&lt;class...&gt; class P&gt; using mp_sort = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_sort&lt;L, P&gt;</code> sorts the list <code>L</code> according to the strict weak ordering <code>mp_to_bool&lt;P&lt;T, U&gt;&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 60. Using mp_sort to sort a list of std::ratio values</div>
<div class="content">
<pre>#include &lt;ratio&gt;

using L1 = mp_list&lt;std::ratio&lt;1,2&gt;, std::ratio&lt;1,4&gt;&gt;;
using R1 = mp_sort&lt;L1, std::ratio_less&gt;; // mp_list&lt;ratio&lt;1,4&gt;, ratio&lt;1,2&gt;&gt;</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_sort_ql_q">mp_sort_q&lt;L, Q&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class Q&gt; using mp_sort_q = mp_sort&lt;L, Q::template fn&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>As <code>mp_sort</code>, but takes a quoted metafunction.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_nth_element_cl_i_p">mp_nth_element_c&lt;L, I, P&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, std::size_t I, template&lt;class...&gt; class P&gt; using mp_nth_element_c =
    /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p>Returns the element at position <code>I</code> in <code>mp_sort&lt;L, P&gt;</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_nth_elementl_i_p">mp_nth_element&lt;L, I, P&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class I, template&lt;class...&gt; class P&gt; using mp_nth_element = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p>Like <code>mp_nth_element_c</code>, but with a type argument <code>I</code>. <code>I::value</code> must be a nonnegative number.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_nth_element_ql_i_q">mp_nth_element_q&lt;L, I, Q&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class I, class Q&gt; using mp_nth_element_q =
    mp_nth_element&lt;L, I, Q::template fn&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>Like <code>mp_nth_element</code>, but takes a quoted metafunction.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_min_elementl_p">mp_min_element&lt;L, P&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, template&lt;class...&gt; class P&gt; using mp_min_element = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_min_element&lt;L, P&gt;</code> returns the minimal element of the list <code>L</code> according to the ordering <code>mp_to_bool&lt;P&lt;T, U&gt;&gt;</code>.</p>
</div>
<div class="paragraph">
<p>It&#8217;s equivalent to <code>mp_fold&lt;mp_rest&lt;L&gt;, mp_first&lt;L&gt;, F&gt;</code>, where <code>F&lt;T, U&gt;</code> returns <code>mp_if&lt;P&lt;T, U&gt;, T, U&gt;</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_min_element_ql_q">mp_min_element_q&lt;L, Q&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class Q&gt; using mp_min_element_q = mp_min_element&lt;L, Q::template fn&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>As <code>mp_min_element</code>, but takes a quoted metafunction.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_max_elementl_p">mp_max_element&lt;L, P&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, template&lt;class...&gt; class P&gt; using mp_max_element = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_max_element&lt;L, P&gt;</code> returns the maximal element of the list <code>L</code> according to the ordering <code>mp_to_bool&lt;P&lt;T, U&gt;&gt;</code>.</p>
</div>
<div class="paragraph">
<p>It&#8217;s equivalent to <code>mp_fold&lt;mp_rest&lt;L&gt;, mp_first&lt;L&gt;, F&gt;</code>, where <code>F&lt;T, U&gt;</code> returns <code>mp_if&lt;P&lt;U, T&gt;, T, U&gt;</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_max_element_ql_q">mp_max_element_q&lt;L, Q&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class Q&gt; using mp_max_element_q = mp_max_element&lt;L, Q::template fn&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>As <code>mp_max_element</code>, but takes a quoted metafunction.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_findl_v">mp_find&lt;L, V&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class V&gt; using mp_find = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_find&lt;L, V&gt;</code> returns the index at which the type <code>V</code> is located in the list <code>L</code>. It&#8217;s an alias for <code>mp_size_t&lt;I&gt;</code>,
where <code>I</code> is the zero-based index of the first occurrence of <code>V</code> in <code>L</code>. If <code>L</code> does not contain <code>V</code>, <code>mp_find&lt;L, V&gt;</code>
is <code>mp_size&lt;L&gt;</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_find_ifl_p">mp_find_if&lt;L, P&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, template&lt;class...&gt; class P&gt; using mp_find_if = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_find_f&lt;L, P&gt;</code> is an alias for <code>mp_size_t&lt;I&gt;</code>, where <code>I</code> is the zero-based index of the first element <code>T</code> in <code>L</code> for which
<code>mp_to_bool&lt;P&lt;T&gt;&gt;</code> is <code>mp_true</code>. If there is no such element, <code>mp_find_if&lt;L, P&gt;</code> is <code>mp_size&lt;L&gt;</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_find_if_ql_q">mp_find_if_q&lt;L, Q&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class Q&gt; using mp_find_if_q = mp_find_if&lt;L, Q::template fn&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>As <code>mp_find_if</code>, but takes a quoted metafunction.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_reversel">mp_reverse&lt;L&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L&gt; using mp_reverse = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_reverse&lt;L&lt;T1, T2, &#8230;&#8203;, Tn&gt;&gt;</code> is <code>L&lt;Tn, &#8230;&#8203;, T2, T1&gt;</code>.</p>
</div>
<table class="tableblock frame-all grid-all" style="width: 85%;">
<caption class="title">Illustration 15. mp_reverse</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>L1</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>1</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>2</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>n</sub></code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle" colspan="5"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code><strong>mp_reverse&lt;L1&gt;</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>n</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>n-1</sub></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>A<sub>1</sub></code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="mp_foldl_v_f">mp_fold&lt;L, V, F&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class V, template&lt;class...&gt; class F&gt; using mp_fold = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_fold&lt;L&lt;T1, T2, &#8230;&#8203;, Tn&gt;, V, F&gt;</code> is <code>F&lt; F&lt; F&lt; F&lt;V, T1&gt;, T2&gt;, &#8230;&#8203;&gt;, Tn&gt;</code>, or <code>V</code>, if <code>L</code> is empty.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 61. Using mp_fold to add the contents of a list of std::ratio values</div>
<div class="content">
<pre>#include &lt;ratio&gt;

using L1 = mp_list&lt;std::ratio&lt;1,8&gt;, std::ratio&lt;1,4&gt;, std::ratio&lt;1,2&gt;&gt;;
using R1 = mp_fold&lt;L1, std::ratio&lt;0,1&gt;, std::ratio_add&gt;; // std::ratio&lt;7,8&gt;</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_fold_ql_v_q">mp_fold_q&lt;L, V, Q&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class V, class Q&gt; using mp_fold_q =
    mp_fold&lt;L, V, Q::template fn&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>As <code>mp_fold</code>, but takes a quoted metafunction.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_reverse_foldl_v_f">mp_reverse_fold&lt;L, V, F&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class V, template&lt;class...&gt; class F&gt; using mp_reverse_fold =
    /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_reverse_fold&lt;L&lt;T1, T2, &#8230;&#8203;, Tn&gt;, V, F&gt;</code> is <code>F&lt;T1, F&lt;T2, F&lt;&#8230;&#8203;, F&lt;Tn, V&gt;&gt;&gt;&gt;</code>, or <code>V</code>, if <code>L</code> is empty.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_reverse_fold_ql_v_q">mp_reverse_fold_q&lt;L, V, Q&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class V, class Q&gt; using mp_reverse_fold_q =
    mp_reverse_fold&lt;L, V, Q::template fn&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>As <code>mp_reverse_fold</code>, but takes a quoted metafunction.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_uniquel">mp_unique&lt;L&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L&gt; using mp_unique = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_unique&lt;L&gt;</code> returns a list of the same form as <code>L</code> with the duplicate elements removed.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_all_ofl_p">mp_all_of&lt;L, P&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, template&lt;class...&gt; class P&gt; using mp_all_of =
    mp_bool&lt; mp_count_if&lt;L, P&gt;::value == mp_size&lt;L&gt;::value &gt;;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_all_of&lt;L, P&gt;</code> is <code>mp_true</code> when <code>P</code> holds for all elements of <code>L</code>, <code>mp_false</code> otherwise. When <code>L</code> is empty, the result is <code>mp_true</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_all_of_ql_q">mp_all_of_q&lt;L, Q&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class Q&gt; using mp_all_of_q = mp_all_of&lt;L, Q::template fn&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>As <code>mp_all_of</code>, but takes a quoted metafunction.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_none_ofl_p">mp_none_of&lt;L, P&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, template&lt;class...&gt; class P&gt; using mp_none_of =
    mp_bool&lt; mp_count_if&lt;L, P&gt;::value == 0 &gt;;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_none_of&lt;L, P&gt;</code> is <code>mp_true</code> when <code>P</code> holds for no element of <code>L</code>, <code>mp_false</code> otherwise. When <code>L</code> is empty, the result is <code>mp_true</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_none_of_ql_q">mp_none_of_q&lt;L, Q&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class Q&gt; using mp_none_of_q = mp_none_of&lt;L, Q::template fn&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>As <code>mp_none_of</code>, but takes a quoted metafunction.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_any_ofl_p">mp_any_of&lt;L, P&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, template&lt;class...&gt; class P&gt; using mp_any_of =
    mp_bool&lt; mp_count_if&lt;L, P&gt;::value != 0 &gt;;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_any_of&lt;L, P&gt;</code> is <code>mp_true</code> when <code>P</code> holds for at least one element of <code>L</code>, <code>mp_false</code> otherwise. When <code>L</code> is empty, the result is <code>mp_false</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_any_of_ql_q">mp_any_of_q&lt;L, Q&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class Q&gt; using mp_any_of_q = mp_any_of&lt;L, Q::template fn&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>As <code>mp_any_of</code>, but takes a quoted metafunction.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_for_eachlf">mp_for_each&lt;L&gt;(f)</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class L, class F&gt; constexpr F mp_for_each(F&amp;&amp; f);</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_for_each&lt;L&gt;(f)</code> calls <code>f</code> with <code>T()</code> for each element <code>T</code> of the list <code>L</code>, in order.</p>
</div>
<div class="paragraph">
<p>Returns <code>std::forward&lt;F&gt;(f)</code>.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 62. Using mp_for_each and a C++14 lambda to print a tuple</div>
<div class="content">
<pre class="highlight"><code>template&lt;class... T&gt; void print( std::tuple&lt;T...&gt; const &amp; tp )
{
    std::size_t const N = sizeof...(T);

    mp_for_each&lt;mp_iota_c&lt;N&gt;&gt;( [&amp;]( auto I ){

        // I is mp_size_t&lt;0&gt;, mp_size_t&lt;1&gt;, ..., mp_size_t&lt;N-1&gt;

        std::cout &lt;&lt; std::get&lt;I&gt;(tp) &lt;&lt; std::endl;

    });
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_with_indexni_f">mp_with_index&lt;N&gt;(i, f)</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;std::size_t N, class F&gt;
  constexpr auto mp_with_index( std::size_t i, F &amp;&amp; f )
    -&gt; decltype(std::declval&lt;F&gt;()(std::declval&lt;mp_size_t&lt;0&gt;&gt;()));</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_with_index&lt;N&gt;(i, f)</code> calls <code>f</code> with <code>mp_size_t&lt;i&gt;()</code> and returns the result. <code>i</code> must be less than <code>N</code>.
Only <code>constexpr</code> on C++14 and higher.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>template&lt;class N, class F&gt;
  constexpr auto mp_with_index( std::size_t i, F &amp;&amp; f )
    -&gt; decltype(std::declval&lt;F&gt;()(std::declval&lt;mp_size_t&lt;0&gt;&gt;()));</pre>
</div>
</div>
<div class="paragraph">
<p>Returns <code>mp_with_index&lt;N::value&gt;(i, f)</code>.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 63. Using mp_with_index and a C++14 lambda to print the active element of a variant</div>
<div class="content">
<pre class="highlight"><code>template&lt;class... T&gt; void print( std::variant&lt;T...&gt; const&amp; v )
{
    mp_with_index&lt;sizeof...(T)&gt;( v.index(), [&amp;]( auto I ) {

        // I is mp_size_t&lt;v.index()&gt; here

        std::cout &lt;&lt; std::get&lt;I&gt;( v ) &lt;&lt; std::endl;

    });
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="set">Set Operations, &lt;boost/mp11/set.hpp&gt;</h3>
<div class="paragraph">
<p>A set is a list whose elements are unique.</p>
</div>
<div class="sect3">
<h4 id="mp_is_sets">mp_is_set&lt;S&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class S&gt; using mp_is_set = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_is_set&lt;S&gt;</code> is <code>mp_true</code> if <code>S</code> is a set, <code>mp_false</code> otherwise.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_set_containss_v">mp_set_contains&lt;S, V&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class S, class V&gt; using mp_set_contains = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_set_contains&lt;S, V&gt;</code> is <code>mp_true</code> if the type <code>V</code> is an element of the set <code>S</code>, <code>mp_false</code> otherwise.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_set_push_backs_t">mp_set_push_back&lt;S, T&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class S, class... T&gt; using mp_set_push_back = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p>For each <code>T1</code> in <code>T&#8230;&#8203;</code>, <code>mp_set_push_back&lt;S, T&#8230;&#8203;&gt;</code> appends <code>T1</code> to the end of <code>S</code> if it&#8217;s not already an element of <code>S</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_set_push_fronts_t">mp_set_push_front&lt;S, T&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class S, class... T&gt; using mp_set_push_front = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_set_push_front&lt;S, T&#8230;&#8203;&gt;</code> inserts at the front of <code>S</code> those elements of <code>T&#8230;&#8203;</code> for which <code>S</code> does not already contain the same type.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="map">Map Operations, &lt;boost/mp11/map.hpp&gt;</h3>
<div class="paragraph">
<p>A map is a list of lists, the inner lists having at least one element (the key.) The keys of the map must be unique.</p>
</div>
<div class="sect3">
<h4 id="mp_is_mapm">mp_is_map&lt;M&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class M&gt; using mp_is_map = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_is_map&lt;M&gt;</code> is <code>mp_true</code> if <code>M</code> is a map, <code>mp_false</code> otherwise.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_map_findm_k">mp_map_find&lt;M, K&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class M, class K&gt; using mp_map_find = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_map_find&lt;M, K&gt;</code> is an alias for the element of the map <code>M</code> with a key <code>K</code>, or for <code>void</code>, if there is no such element.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_map_containsm_k">mp_map_contains&lt;M, K&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class M, class K&gt; using mp_map_contains =
    mp_not&lt;std::is_same&lt;mp_map_find&lt;M, K&gt;, void&gt;&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_map_contains&lt;M, K&gt;</code> is <code>mp_true</code> if the map <code>M</code> contains an element with a key <code>K</code>, <code>mp_false</code> otherwise.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_map_insertm_t">mp_map_insert&lt;M, T&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class M, class T&gt; using mp_map_insert =
    mp_if&lt; mp_map_contains&lt;M, mp_first&lt;T&gt;&gt;, M, mp_push_back&lt;M, T&gt; &gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>Inserts the element <code>T</code> into the map <code>M</code>, if an element with a key <code>mp_first&lt;T&gt;</code> is not already in <code>M</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_map_replacem_t">mp_map_replace&lt;M, T&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class M, class T&gt; using mp_map_replace = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p>If the map <code>M</code> does not contain an element with a key <code>mp_first&lt;T&gt;</code>, inserts it (using <code>mp_push_back&lt;M, T&gt;</code>); otherwise,
replaces the existing element with <code>T</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_map_updatem_t_f">mp_map_update&lt;M, T, F&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class M, class T, template&lt;class...&gt; class F&gt; using mp_map_update = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p>If the map <code>M</code> does not contain an element with a key <code>mp_first&lt;T&gt;</code>, inserts it (using <code>mp_push_back&lt;M, T&gt;</code>); otherwise,
replaces the existing element <code>L&lt;X, Y&#8230;&#8203;&gt;</code> with <code>L&lt;X, F&lt;X, Y&#8230;&#8203;&gt;&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 64. Using mp_map_update to count the number of occurrences of types in a list</div>
<div class="content">
<pre class="highlight"><code>template&lt;class T, class U&gt; using inc2nd = mp_int&lt;U::value + 1&gt;;

template&lt;class M, class T&gt; using count_types =
    mp_map_update&lt;M, std::pair&lt;T, mp_int&lt;1&gt;&gt;, inc2nd&gt;;

using L1 = mp_list&lt;float, char, float, float, float, float, char, float&gt;;

using R1 = mp_fold&lt;L1, std::tuple&lt;&gt;, count_types&gt;;
// std::tuple&lt;std::pair&lt;float, mp_int&lt;6&gt;&gt;, std::pair&lt;char, mp_int&lt;2&gt;&gt;&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_map_update_qm_t_q">mp_map_update_q&lt;M, T, Q&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class M, class T, class Q&gt; using mp_map_update_q =
    mp_map_update&lt;M, T, Q::template fn&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>As <code>mp_map_update</code>, but takes a quoted metafunction.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_map_erasem_k">mp_map_erase&lt;M, K&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class M, class K&gt; using mp_map_erase = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p>If the map <code>M</code> contains an element with a key <code>K</code>, removes it.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_map_keysm">mp_map_keys&lt;M&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class M&gt; using mp_map_keys = mp_transform&lt;mp_first, M&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_map_keys&lt;M&gt;</code> returns a list of the keys of <code>M</code>. When <code>M</code> is a valid map, the keys are unique, so the result is a set.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="function">Helper Metafunctions, &lt;boost/mp11/function.hpp&gt;</h3>
<div class="sect3">
<h4 id="mp_voidt">mp_void&lt;T&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class... T&gt; using mp_void = void;</pre>
</div>
</div>
<div class="paragraph">
<p>Same as <code>std::void_t</code> from C++17.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_andt">mp_and&lt;T&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class... T&gt; using mp_and = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_and&lt;T&#8230;&#8203;&gt;</code> applies <code>mp_to_bool</code> to the types in <code>T&#8230;&#8203;</code>, in order. If the result of an application is <code>mp_false</code>, <code>mp_and</code>
returns <code>mp_false</code>. If the application causes a substitution failure, returns <code>mp_false</code>. If all results are <code>mp_true</code>,
returns <code>mp_true</code>. <code>mp_and&lt;&gt;</code> is <code>mp_true</code>.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 65. mp_and behavior</div>
<div class="content">
<pre class="highlight"><code>using R1 = mp_and&lt;mp_true, mp_true&gt;;   // mp_true

using R2 = mp_and&lt;mp_false, void&gt;;     // mp_false, void is not reached

using R3 = mp_and&lt;mp_false, mp_false&gt;; // mp_false

using R4 = mp_and&lt;void, mp_true&gt;;      // mp_false (!)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_allt">mp_all&lt;T&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class... T&gt; using mp_all = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_all&lt;T&#8230;&#8203;&gt;</code> is <code>mp_true</code> if <code>mp_to_bool&lt;U&gt;</code> is <code>mp_true</code> for all types <code>U</code> in <code>T&#8230;&#8203;</code>, <code>mp_false</code> otherwise. Same as
<code>mp_and</code>, but does not perform short-circuit evaluation. <code>mp_and&lt;mp_false, void&gt;</code> is <code>mp_false</code>, but <code>mp_all&lt;mp_false, void&gt;</code>
is an error because <code>void</code> does not have a nested <code>value</code>. The upside is that <code>mp_all</code> is potentially faster and does not
mask substitution failures as <code>mp_and</code> does.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 66. mp_all behavior</div>
<div class="content">
<pre class="highlight"><code>using R1 = mp_all&lt;mp_true, mp_true&gt;;   // mp_true

using R2 = mp_all&lt;mp_false, void&gt;;     // compile-time error

using R3 = mp_all&lt;mp_false, mp_false&gt;; // mp_false

using R4 = mp_all&lt;void, mp_true&gt;;      // compile-time error</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_ort">mp_or&lt;T&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class... T&gt; using mp_or = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_or&lt;T&#8230;&#8203;&gt;</code> applies <code>mp_to_bool</code> to the types in <code>T&#8230;&#8203;</code>, in order. If the result of an application is <code>mp_true</code>, <code>mp_or</code>
returns <code>mp_true</code>. If all results are <code>mp_false</code>, returns <code>mp_false</code>. <code>mp_or&lt;&gt;</code> is <code>mp_false</code>.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 67. mp_or behavior</div>
<div class="content">
<pre class="highlight"><code>using R1 = mp_or&lt;mp_true, mp_false&gt;;   // mp_true

using R2 = mp_or&lt;mp_true, void&gt;;       // mp_true, void is not reached

using R3 = mp_or&lt;mp_false, mp_false&gt;;  // mp_false

using R4 = mp_or&lt;void, mp_true&gt;;       // compile-time error</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_anyt">mp_any&lt;T&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class... T&gt; using mp_any = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_any&lt;T&#8230;&#8203;&gt;</code> is <code>mp_true</code> if <code>mp_to_bool&lt;U&gt;</code> is <code>mp_true</code> for any type <code>U</code> in <code>T&#8230;&#8203;</code>, <code>mp_false</code> otherwise. Same as
<code>mp_or</code>, but does not perform short-circuit evaluation.</p>
</div>
<div class="listingblock">
<div class="title">Code Example 68. mp_any behavior</div>
<div class="content">
<pre class="highlight"><code>using R1 = mp_any&lt;mp_true, mp_false&gt;;  // mp_true

using R2 = mp_any&lt;mp_true, void&gt;;      // compile-time error

using R3 = mp_any&lt;mp_false, mp_false&gt;; // mp_false

using R4 = mp_any&lt;void, mp_true&gt;;      // compile-time error</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mp_samet">mp_same&lt;T&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class... T&gt; using mp_same = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_same&lt;T&#8230;&#8203;&gt;</code> is <code>mp_true</code> if all the types in <code>T&#8230;&#8203;</code> are the same type, <code>mp_false</code> otherwise. <code>mp_same&lt;&gt;</code> is <code>mp_true</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_plust">mp_plus&lt;T&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class... T&gt; using mp_plus = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_plus&lt;T&#8230;&#8203;&gt;</code> is an integral constant type with a value that is the sum of <code>U::value</code> for all types <code>U</code> in <code>T&#8230;&#8203;</code>.
<code>mp_plus&lt;&gt;</code> is <code>mp_int&lt;0&gt;</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_lesst1_t2">mp_less&lt;T1, T2&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class T1, class T2&gt; using mp_less = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_less&lt;T1, T2&gt;</code> is <code>mp_true</code> when the numeric value of <code>T1::value</code> is less than the numeric value of <code>T2::value</code>,
<code>mp_false</code> otherwise.</p>
</div>
<div class="paragraph">
<p>(Note that this is not necessarily the same as <code>T1::value &lt; T2::value</code> when comparing between signed and unsigned types;
<code>-1 &lt; 1u</code> is <code>false</code>, but <code>mp_less&lt;mp_int&lt;-1&gt;, mp_size_t&lt;1&gt;&gt;</code> is <code>mp_true</code>.)</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_mint1_t">mp_min&lt;T1, T&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class T1, class... T&gt; using mp_min = mp_min_element&lt;mp_list&lt;T1, T...&gt;, mp_less&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_min&lt;T&#8230;&#8203;&gt;</code> returns the type <code>U</code> in <code>T&#8230;&#8203;</code> with the lowest <code>U::value</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_maxt1_t">mp_max&lt;T1, T&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class T1, class... T&gt; using mp_max = mp_max_element&lt;mp_list&lt;T1, T...&gt;, mp_less&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_max&lt;T&#8230;&#8203;&gt;</code> returns the type <code>U</code> in <code>T&#8230;&#8203;</code> with the highest <code>U::value</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="bind">Bind, &lt;boost/mp11/bind.hpp&gt;</h3>
<div class="sect3">
<h4 id="mp_argi">mp_arg&lt;I&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;std::size_t I&gt; struct mp_arg;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_arg&lt;I&gt;</code> is a quoted metafunction whose nested template <code>fn&lt;T&#8230;&#8203;&gt;</code> returns the <code>I</code>-th zero-based element of <code>T&#8230;&#8203;</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="1_9">_1, &#8230;&#8203;, _9</h4>
<div class="literalblock">
<div class="content">
<pre>using _1 = mp_arg&lt;0&gt;;
using _2 = mp_arg&lt;1&gt;;
using _3 = mp_arg&lt;2&gt;;
using _4 = mp_arg&lt;3&gt;;
using _5 = mp_arg&lt;4&gt;;
using _6 = mp_arg&lt;5&gt;;
using _7 = mp_arg&lt;6&gt;;
using _8 = mp_arg&lt;7&gt;;
using _9 = mp_arg&lt;8&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p><code>_1</code> to <code>_9</code> are placeholder types, the equivalent to the placeholders of <code>boost::bind</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_bindf_t">mp_bind&lt;F, T&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;template&lt;class...&gt; class F, class... T&gt; struct mp_bind;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_bind&lt;F, T&#8230;&#8203;&gt;</code> is a quoted metafunction that implements the type-based equivalent of <code>boost::bind</code>. Its nested
template <code>fn&lt;U&#8230;&#8203;&gt;</code> returns <code>F&lt;V&#8230;&#8203;&gt;</code>, where <code>V&#8230;&#8203;</code> is <code>T&#8230;&#8203;</code> with the placeholders replaced by the corresponding element
of <code>U&#8230;&#8203;</code> and the <code>mp_bind</code> expressions replaced with their corresponding evaluations against <code>U&#8230;&#8203;</code>.</p>
</div>
<div class="paragraph">
<p>For example, <code>mp_bind&lt;F, int, _2, mp_bind&lt;G, _1&gt;&gt;::fn&lt;float, void&gt;</code> is <code>F&lt;int, void, G&lt;float&gt;&gt;</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_bind_qq_t">mp_bind_q&lt;Q, T&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class Q, class... T&gt; using mp_bind_q = mp_bind&lt;Q::template fn, T...&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>As <code>mp_bind</code>, but takes a quoted metafunction.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_bind_frontf_t">mp_bind_front&lt;F, T&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;template&lt;class...&gt; class F, class... T&gt; struct mp_bind_front;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_bind_front&lt;F, T&#8230;&#8203;&gt;</code> binds the leftmost arguments of <code>F</code> to <code>T&#8230;&#8203;</code>. Its nested template <code>fn&lt;U&#8230;&#8203;&gt;</code> returns <code>F&lt;T&#8230;&#8203;, U&#8230;&#8203;&gt;</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_bind_front_qq_t">mp_bind_front_q&lt;Q, T&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class Q, class... T&gt; using mp_bind_front_q =
    mp_bind_front&lt;Q::template fn, T...&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>As <code>mp_bind_front</code>, but takes a quoted metafunction.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_bind_backf_t">mp_bind_back&lt;F, T&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;template&lt;class...&gt; class F, class... T&gt; struct mp_bind_back;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_bind_back&lt;F, T&#8230;&#8203;&gt;</code> binds the rightmost arguments of <code>F</code> to <code>T&#8230;&#8203;</code>. Its nested template <code>fn&lt;U&#8230;&#8203;&gt;</code> returns <code>F&lt;U&#8230;&#8203;, T&#8230;&#8203;&gt;</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mp_bind_back_qq_t">mp_bind_back_q&lt;Q, T&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class Q, class... T&gt; using mp_bind_back_q =
    mp_bind_back&lt;Q::template fn, T...&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>As <code>mp_bind_back</code>, but takes a quoted metafunction.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="integer_sequence">Integer Sequences, &lt;boost/mp11/integer_sequence.hpp&gt;</h3>
<div class="sect3">
<h4 id="integer_sequencet_i">integer_sequence&lt;T, I&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class T, T... I&gt; struct integer_sequence
{
};</pre>
</div>
</div>
<div class="paragraph">
<p><code>integer_sequence&lt;T, I&#8230;&#8203;&gt;</code> holds a sequence of integers of type <code>T</code>. Same as C++14&#8217;s <code>std::integer_sequence</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="make_integer_sequencet_n">make_integer_sequence&lt;T, N&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class T, T N&gt; using make_integer_sequence = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>make_integer_sequence&lt;T, N&gt;</code> is <code>integer_sequence&lt;T, 0, 1, &#8230;&#8203;, N-1&gt;</code>. Same as C++14&#8217;s <code>std::make_integer_sequence</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="index_sequencei">index_sequence&lt;I&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;std::size_t... I&gt; using index_sequence = integer_sequence&lt;std::size_t, I...&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p><code>index_sequence&lt;I&#8230;&#8203;&gt;</code> is an alias for <code>integer_sequence&lt;size_t, I&#8230;&#8203;&gt;</code>. Same as C++14&#8217;s <code>std::index_sequence</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="make_index_sequencen">make_index_sequence&lt;N&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;std::size_t N&gt; using make_index_sequence =
    make_integer_sequence&lt;std::size_t, N&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p><code>make_index_sequence&lt;N&gt;</code> is <code>index_sequence&lt;0, 1, &#8230;&#8203;, N-1&gt;</code>. Same as C++14&#8217;s <code>std::make_index_sequence</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="index_sequence_fort">index_sequence_for&lt;T&#8230;&#8203;&gt;</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class... T&gt; using index_sequence_for =
    make_integer_sequence&lt;std::size_t, sizeof...(T)&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p><code>index_sequence_for&lt;N&gt;</code> is <code>make_index_sequence&lt;sizeof&#8230;&#8203;(T)&gt;</code>. Same as C++14&#8217;s <code>std::index_sequence_for</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="tuple">Tuple Operations, &lt;boost/mp11/tuple.hpp&gt;</h3>
<div class="sect3">
<h4 id="tuple_applyf_tp">tuple_apply(f, tp)</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class F, class Tp&gt; constexpr /*...*/ tuple_apply(F&amp;&amp; f, Tp&amp;&amp; tp);</pre>
</div>
</div>
<div class="paragraph">
<p><code>tuple_apply(f, tp)</code> returns <code>std::forward&lt;F&gt;(f)(std::get&lt;J&gt;(std::forward&lt;Tp&gt;(tp))&#8230;&#8203;)</code> for <code>J</code> in 0..<code>N-1</code>,
where <code>N</code> is <code>std::tuple_size&lt;typename std::remove_reference&lt;Tp&gt;::type&gt;::value</code>. Same as <code>std::apply</code> in C++17.</p>
</div>
</div>
<div class="sect3">
<h4 id="construct_from_tuplettp">construct_from_tuple&lt;T&gt;(tp)</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class T, class Tp&gt; T construct_from_tuple(Tp&amp;&amp; tp);</pre>
</div>
</div>
<div class="paragraph">
<p><code>construct_from_tuple&lt;T&gt;(tp)</code> returns <code>T(std::get&lt;J&gt;(std::forward&lt;Tp&gt;(tp))&#8230;&#8203;)</code> for <code>J</code> in 0..<code>N-1</code>,
where <code>N</code> is <code>std::tuple_size&lt;typename std::remove_reference&lt;Tp&gt;::type&gt;::value</code>. Same as <code>std::make_from_tuple</code> in C++17.
The name of the function doesn&#8217;t match the C++17 one to avoid ambiguities when both are visible or in unqualified calls.</p>
</div>
</div>
<div class="sect3">
<h4 id="tuple_for_eachtp_f">tuple_for_each(tp, f)</h4>
<div class="literalblock">
<div class="content">
<pre>template&lt;class Tp, class F&gt; constexpr F tuple_for_each(Tp&amp;&amp; tp, F&amp;&amp; f);</pre>
</div>
</div>
<div class="paragraph">
<p><code>tuple_for_each(tp, f)</code> applies the function object <code>f</code> to each element of <code>tp</code> by evaluating the
expression <code>f(std::get&lt;J&gt;(std::forward&lt;Tp&gt;(tp)))</code> for <code>J</code> in 0..<code>N-1</code>, where <code>N</code> is <code>std::tuple_size&lt;typename std::remove_reference&lt;Tp&gt;::type&gt;::value</code>.</p>
</div>
<div class="paragraph">
<p>Returns <code>std::forward&lt;F&gt;(f)</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mp11">Convenience Header, &lt;boost/mp11.hpp&gt;</h3>
<div class="paragraph">
<p>The convenience header <code>&lt;boost/mp11.hpp&gt;</code> includes all of the
headers listed previously in this reference.</p>
</div>
</div>
<div class="sect2">
<h3 id="mpl">MPL Support, &lt;boost/mp11/mpl.hpp&gt;</h3>
<div class="paragraph">
<p>The header <code>&lt;boost/mp11/mpl.hpp&gt;</code>, when included, defines the
necessary support infrastructure for <code>mp_list</code> and <code>std::tuple</code>
to be valid <a href="../../../../libs/mpl">MPL</a> sequences.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<code>mpl.hpp</code> is not included by <code>&lt;boost/mp11.hpp&gt;</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="copyright_license_and_acknowledgments">Appendix A: Copyright, License, and Acknowledgments</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This documentation is</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Copyright 2017 Peter Dimov</p>
</li>
<li>
<p>Copyright 2017 Bjørn Reese</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>and is distributed under the <a href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License, Version 1.0</a>.</p>
</div>
<div class="paragraph">
<p>The "Simple C++11 metaprogramming" articles have been graciously converted to Asciidoc format for incorporation
into this documentation by Glen Fernandes.</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2018-08-01 20:50:50 UTC
</div>
</div>
<style>

*:not(pre)>code { background: none; color: #600000; }
table tr.even, table tr.alt, table tr:nth-of-type(even) { background: none; }

</style>
</body>
</html>