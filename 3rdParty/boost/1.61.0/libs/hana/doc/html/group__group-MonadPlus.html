<!--
Copyright Louis Dionne 2013-2016
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-->
<!-- boost-no-inspect -->
<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Boost.Hana: MonadPlus</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
// Copyright Louis Dionne 2013-2016
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
MathJax.Hub.Config({
    "HTML-CSS": {
        linebreaks: {
            automatic: true,
            width: "75% container"
        }
    }
});
</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Additional javascript for drawing charts. -->
<script type="text/javascript" src="highcharts.js"></script>
<script type="text/javascript" src="highcharts-data.js"></script>
<script type="text/javascript" src="highcharts-exporting.js"></script>
<script type="text/javascript" src="chart.js"></script>
<script type="text/javascript" src="hana.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Boost.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group-MonadPlus.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">MonadPlus<div class="ingroups"><a class="el" href="group__group-concepts.html">Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>The <code>MonadPlus</code> concept represents Monads with a monoidal structure. </p>
<p>Intuitively, whereas a Monad can be seen as some kind of container or context, a MonadPlus can be seen as a container or a context that can be concatenated with other containers or contexts. There must also be an identity element for this combining operation. For example, a tuple is a MonadPlus, because tuples can be concatenated and the empty tuple would act as an identity for concatenation. How is this different from a Monad which is also a Monoid? The answer is that the monoidal structure on a MonadPlus must <em>not</em> depend of the contents of the structure; it must not require the contents to be a Monoid in order to work.</p>
<p>While sequences are not the only possible model for MonadPlus, the method names used here refer to the MonadPlus of sequences under concatenation. Several useful functions generalizing operations on sequences are included with this concept, like <code>append</code>, <code>prepend</code> and <code>filter</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This documentation does not go into much details about the nature of the MonadPlus concept. However, there is a nice Haskell-oriented <a href="https://en.wikibooks.org/wiki/Haskell/MonadPlus">WikiBook</a> going into further details.</dd></dl>
<h2>Minimal complete definition </h2>
<p><code>concat</code> and <code>empty</code></p>
<h2>Laws </h2>
<p>First, a MonadPlus is required to have a monoidal structure. Hence, it is no surprise that for any MonadPlus <code>M</code>, we require <code>M(T)</code> to be a valid monoid. However, we do not enforce that <code>M(T)</code> actually models the Monoid concept provided by Hana. Further, for all objects <code>a, b, c</code> of data type <code>M(T)</code>, </p><div class="fragment"><div class="line"><span class="comment">// identity</span></div>
<div class="line"><a class="code" href="group__group-MonadPlus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(<a class="code" href="group__group-MonadPlus.html#gaa6be1e83ad72b9d69b43b4bada0f3a75">empty</a>&lt;M(T)&gt;(), a) == a</div>
<div class="line"><a class="code" href="group__group-MonadPlus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(a, <a class="code" href="group__group-MonadPlus.html#gaa6be1e83ad72b9d69b43b4bada0f3a75">empty</a>&lt;M(T)&gt;()) == a</div>
<div class="line"></div>
<div class="line"><span class="comment">// associativity</span></div>
<div class="line"><a class="code" href="group__group-MonadPlus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(a, <a class="code" href="group__group-MonadPlus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(b, c)) == <a class="code" href="group__group-MonadPlus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(<a class="code" href="group__group-MonadPlus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(a, b), c)</div>
</div><!-- fragment --><p>Secondly, a MonadPlus is also required to obey the following laws, which represent the fact that <code>empty&lt;M(T)&gt;()</code> must be some kind of absorbing element for the <code>chain</code> operation. For all objects <code>a</code> of data type <code>M(T)</code> and functions \( f : T \to M(U) \), </p><div class="fragment"><div class="line"><a class="code" href="group__group-Monad.html#ga05fdc2f887cb9967357487a432ace98b">chain</a>(<a class="code" href="group__group-MonadPlus.html#gaa6be1e83ad72b9d69b43b4bada0f3a75">empty</a>&lt;M(T)&gt;(), f)         == empty&lt;M(U)&gt;()</div>
<div class="line"><a class="code" href="group__group-Monad.html#ga05fdc2f887cb9967357487a432ace98b">chain</a>(a, <a class="code" href="group__group-functional.html#ga835970cb25a0c8dc200f1e5f8943538b">always</a>(<a class="code" href="group__group-MonadPlus.html#gaa6be1e83ad72b9d69b43b4bada0f3a75">empty</a>&lt;M(T)&gt;())) == <a class="code" href="group__group-MonadPlus.html#gaa6be1e83ad72b9d69b43b4bada0f3a75">empty</a>&lt;M(U)&gt;()</div>
</div><!-- fragment --><h2>Refined concepts </h2>
<p><code>Functor</code>, <code>Applicative</code> and <code>Monad</code></p>
<h2>Concrete models </h2>
<p><code><a class="el" href="structboost_1_1hana_1_1optional.html" title="Optional value whose optional-ness is known at compile-time. ">hana::optional</a></code>, <code><a class="el" href="structboost_1_1hana_1_1tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">hana::tuple</a></code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga08624924fe05f0cfbfbd6e439db01873"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-MonadPlus.html#ga08624924fe05f0cfbfbd6e439db01873">boost::hana::append</a></td></tr>
<tr class="memdesc:ga08624924fe05f0cfbfbd6e439db01873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an element to a monadic structure.Given an element <code>x</code> and a monadic structure <code>xs</code>, <code>append</code> returns a new monadic structure which is the result of lifting <code>x</code> into the monadic structure and then combining that (to the right) with <code>xs</code>. In other words,.  <a href="group__group-MonadPlus.html#ga08624924fe05f0cfbfbd6e439db01873">More...</a><br /></td></tr>
<tr class="separator:ga08624924fe05f0cfbfbd6e439db01873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1946e96c3b4c178c7ae8703724c29c37"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-MonadPlus.html#ga1946e96c3b4c178c7ae8703724c29c37">boost::hana::concat</a></td></tr>
<tr class="memdesc:ga1946e96c3b4c178c7ae8703724c29c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine two monadic structures together.Given two monadic structures, <code>concat</code> combines them together and returns a new monadic structure. The exact definition of <code>concat</code> will depend on the exact model of MonadPlus at hand, but for sequences it corresponds intuitively to simple concatenation.  <a href="group__group-MonadPlus.html#ga1946e96c3b4c178c7ae8703724c29c37">More...</a><br /></td></tr>
<tr class="separator:ga1946e96c3b4c178c7ae8703724c29c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf46c168f721da9effcc7336a997f5d6"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-MonadPlus.html#gaaf46c168f721da9effcc7336a997f5d6">boost::hana::cycle</a></td></tr>
<tr class="memdesc:gaaf46c168f721da9effcc7336a997f5d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine a monadic structure with itself <code>n</code> times.Given a monadic structure <code>xs</code> and a non-negative number <code>n</code>, <code>cycle</code> returns a new monadic structure which is the result of combining <code>xs</code> with itself <code>n</code> times using the <code>concat</code> operation. In other words,.  <a href="group__group-MonadPlus.html#gaaf46c168f721da9effcc7336a997f5d6">More...</a><br /></td></tr>
<tr class="separator:gaaf46c168f721da9effcc7336a997f5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6be1e83ad72b9d69b43b4bada0f3a75"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:gaa6be1e83ad72b9d69b43b4bada0f3a75"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-MonadPlus.html#gaa6be1e83ad72b9d69b43b4bada0f3a75">boost::hana::empty</a></td></tr>
<tr class="memdesc:gaa6be1e83ad72b9d69b43b4bada0f3a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identity of the monadic combination <code>concat</code>.<h2>Signature </h2>
Given a MonadPlus <code>M</code>, the signature is \( \mathtt{empty}_M : \emptyset \to M(T) \).  <a href="group__group-MonadPlus.html#gaa6be1e83ad72b9d69b43b4bada0f3a75">More...</a><br /></td></tr>
<tr class="separator:gaa6be1e83ad72b9d69b43b4bada0f3a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65cc6d9f522fb9e8e3b28d80ee5c822a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-MonadPlus.html#ga65cc6d9f522fb9e8e3b28d80ee5c822a">boost::hana::filter</a></td></tr>
<tr class="memdesc:ga65cc6d9f522fb9e8e3b28d80ee5c822a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter a monadic structure using a custom predicate.Given a monadic structure and a predicate, <code>filter</code> returns a new monadic structure containing only those elements that satisfy the predicate. This is a generalization of the usual <code>filter</code> function for sequences; it works for any MonadPlus. Intuitively, <code>filter</code> is somewhat equivalent to:  <a href="group__group-MonadPlus.html#ga65cc6d9f522fb9e8e3b28d80ee5c822a">More...</a><br /></td></tr>
<tr class="separator:ga65cc6d9f522fb9e8e3b28d80ee5c822a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3022fdfe454dc9bc1f79b5dfeba13b5e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-MonadPlus.html#ga3022fdfe454dc9bc1f79b5dfeba13b5e">boost::hana::prefix</a></td></tr>
<tr class="memdesc:ga3022fdfe454dc9bc1f79b5dfeba13b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a value before each element of a monadic structure.Given a monadic structure <code>xs</code> and a value <code>z</code> called the prefix, <code>prefix</code> returns a new monadic structure. <code>prefix</code> satisfies.  <a href="group__group-MonadPlus.html#ga3022fdfe454dc9bc1f79b5dfeba13b5e">More...</a><br /></td></tr>
<tr class="separator:ga3022fdfe454dc9bc1f79b5dfeba13b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69afbfd4e91125e3e52fcb409135ca7c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-MonadPlus.html#ga69afbfd4e91125e3e52fcb409135ca7c">boost::hana::prepend</a></td></tr>
<tr class="memdesc:ga69afbfd4e91125e3e52fcb409135ca7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepend an element to a monadic structure.Given a monadic structure <code>xs</code> and an element <code>x</code>, <code>prepend</code> returns a new monadic structure which is the result of lifting <code>x</code> into the monadic structure and then combining that (to the left) with <code>xs</code>. In other words,.  <a href="group__group-MonadPlus.html#ga69afbfd4e91125e3e52fcb409135ca7c">More...</a><br /></td></tr>
<tr class="separator:ga69afbfd4e91125e3e52fcb409135ca7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3cc0d6e0d8feb3d677bd1da64da6f43"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-MonadPlus.html#gae3cc0d6e0d8feb3d677bd1da64da6f43">boost::hana::remove</a></td></tr>
<tr class="memdesc:gae3cc0d6e0d8feb3d677bd1da64da6f43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all the elements of a monadic structure that are equal to some value.Given a monadic structure <code>xs</code> and a <code>value</code>, <code>remove</code> returns a new monadic structure equal to <code>xs</code> without all its elements that are equal to the given <code>value</code>. <code>remove</code> is equivalent to <code>remove_if</code> with the <code>equal.to(value)</code> predicate, i.e.  <a href="group__group-MonadPlus.html#gae3cc0d6e0d8feb3d677bd1da64da6f43">More...</a><br /></td></tr>
<tr class="separator:gae3cc0d6e0d8feb3d677bd1da64da6f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9700169a45664d50377c1be9d58accd3"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-MonadPlus.html#ga9700169a45664d50377c1be9d58accd3">boost::hana::remove_if</a></td></tr>
<tr class="memdesc:ga9700169a45664d50377c1be9d58accd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all the elements of a monadic structure that satisfy some predicate.Given a monadic structure <code>xs</code> and a unary predicate, <code>remove_if</code> returns a new monadic structure equal to <code>xs</code> without all its elements that satisfy the predicate. This is equivalent to <code>filter</code> with a negated predicate, i.e.  <a href="group__group-MonadPlus.html#ga9700169a45664d50377c1be9d58accd3">More...</a><br /></td></tr>
<tr class="separator:ga9700169a45664d50377c1be9d58accd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5f48c79d11923d6c1d70b18b7dd3f19"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:gad5f48c79d11923d6c1d70b18b7dd3f19"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-MonadPlus.html#gad5f48c79d11923d6c1d70b18b7dd3f19">boost::hana::replicate</a></td></tr>
<tr class="memdesc:gad5f48c79d11923d6c1d70b18b7dd3f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a monadic structure by combining a lifted value with itself <code>n</code> times.Given a value <code>x</code>, a non-negative <code><a class="el" href="structboost_1_1hana_1_1IntegralConstant.html" title="The IntegralConstant concept represents compile-time integral values. ">IntegralConstant</a></code> <code>n</code> and the tag of a monadic structure <code>M</code>, <code>replicate</code> creates a new monadic structure which is the result of combining <code>x</code> with itself <code>n</code> times inside the monadic structure. In other words, <code>replicate</code> simply <code>lift</code>s <code>x</code> into the monadic structure, and then combines that with itself <code>n</code> times:  <a href="group__group-MonadPlus.html#gad5f48c79d11923d6c1d70b18b7dd3f19">More...</a><br /></td></tr>
<tr class="separator:gad5f48c79d11923d6c1d70b18b7dd3f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61dab15f6ecf379121d4096fe0c8ab13"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-MonadPlus.html#ga61dab15f6ecf379121d4096fe0c8ab13">boost::hana::suffix</a></td></tr>
<tr class="memdesc:ga61dab15f6ecf379121d4096fe0c8ab13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a value after each element of a monadic structure.Given a monadic structure <code>xs</code> and a value <code>z</code> (called the suffix), <code>suffix</code> returns a new monadic structure such that.  <a href="group__group-MonadPlus.html#ga61dab15f6ecf379121d4096fe0c8ab13">More...</a><br /></td></tr>
<tr class="separator:ga61dab15f6ecf379121d4096fe0c8ab13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga08624924fe05f0cfbfbd6e439db01873"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::append</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2append_8hpp.html">boost/hana/fwd/append.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; x) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Append an element to a monadic structure.Given an element <code>x</code> and a monadic structure <code>xs</code>, <code>append</code> returns a new monadic structure which is the result of lifting <code>x</code> into the monadic structure and then combining that (to the right) with <code>xs</code>. In other words,. </p>
<div class="fragment"><div class="line"><a class="code" href="group__group-MonadPlus.html#ga08624924fe05f0cfbfbd6e439db01873">append</a>(xs, x) == <a class="code" href="group__group-MonadPlus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(xs, lift&lt;Xs&gt;(x))</div>
</div><!-- fragment --><p> where <code>Xs</code> is the tag of <code>xs</code>. For sequences, this has the intuitive behavior of simply appending an element to the end of the sequence, hence the name.</p>
<blockquote class="doxtable">
<h4>Rationale for not calling this <code>push_back</code></h4>
<p>See the rationale for using <code>prepend</code> instead of <code>push_front</code>. </p>
</blockquote>
<h2>Signature </h2>
<p>Given a MonadPlus <code>M</code>, the signature is \( \mathtt{append} : M(T) \times T \to M(T) \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>A monadic structure that will be combined to the left of the element.</td></tr>
    <tr><td class="paramname">x</td><td>An element to combine to the right of the monadic structure.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2016</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="append_8hpp.html">boost/hana/append.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">static_assert(<a class="code" href="group__group-MonadPlus.html#ga08624924fe05f0cfbfbd6e439db01873">hana::append</a>(hana::make_tuple(), 1) == hana::make_tuple(1), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(<a class="code" href="group__group-MonadPlus.html#ga08624924fe05f0cfbfbd6e439db01873">hana::append</a>(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>), 3.3) == hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(<a class="code" href="group__group-MonadPlus.html#ga08624924fe05f0cfbfbd6e439db01873">hana::append</a>(<a class="code" href="group__group-MonadPlus.html#ga08624924fe05f0cfbfbd6e439db01873">hana::append</a>(<a class="code" href="group__group-MonadPlus.html#ga08624924fe05f0cfbfbd6e439db01873">hana::append</a>(hana::make_tuple(), 1), <span class="charliteral">&#39;2&#39;</span>), 3.3) == hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga1946e96c3b4c178c7ae8703724c29c37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::concat</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2concat_8hpp.html">boost/hana/fwd/concat.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; ys) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Combine two monadic structures together.Given two monadic structures, <code>concat</code> combines them together and returns a new monadic structure. The exact definition of <code>concat</code> will depend on the exact model of MonadPlus at hand, but for sequences it corresponds intuitively to simple concatenation. </p>
<p>Also note that combination is not required to be commutative. In other words, there is no requirement that </p><div class="fragment"><div class="line"><a class="code" href="group__group-MonadPlus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(xs, ys) == <a class="code" href="group__group-MonadPlus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(ys, xs)</div>
</div><!-- fragment --><p> and indeed it does not hold in general.</p>
<h2>Signature </h2>
<p>Given a <code>MonadPlus</code> <code>M</code>, the signature of <code>concat</code> is \( \mathtt{concat} : M(T) \times M(T) \to M(T) \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs,ys</td><td>Two monadic structures to combine together.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2016</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="concat_8hpp.html">boost/hana/concat.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"><span class="keyword">using namespace </span>hana::literals;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">static_assert(</div>
<div class="line">    <a class="code" href="group__group-MonadPlus.html#ga1946e96c3b4c178c7ae8703724c29c37">hana::concat</a>(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>), hana::make_tuple(3.3, 4_c))</div>
<div class="line">        ==</div>
<div class="line">    hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3, 4_c)</div>
<div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaaf46c168f721da9effcc7336a997f5d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::cycle</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2cycle_8hpp.html">boost/hana/fwd/cycle.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span> <span class="keyword">const</span>&amp; n) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Combine a monadic structure with itself <code>n</code> times.Given a monadic structure <code>xs</code> and a non-negative number <code>n</code>, <code>cycle</code> returns a new monadic structure which is the result of combining <code>xs</code> with itself <code>n</code> times using the <code>concat</code> operation. In other words,. </p>
<div class="fragment"><div class="line"><a class="code" href="group__group-MonadPlus.html#gaaf46c168f721da9effcc7336a997f5d6">cycle</a>(xs, n) == <a class="code" href="group__group-MonadPlus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(xs, <a class="code" href="group__group-MonadPlus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(xs, ... <a class="code" href="group__group-MonadPlus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(xs, xs)))</div>
<div class="line">                                  <span class="comment">// ^^^^^ n times total</span></div>
</div><!-- fragment --><p>Also note that since <code>concat</code> is required to be associative, we could also have written </p><div class="fragment"><div class="line"><a class="code" href="group__group-MonadPlus.html#gaaf46c168f721da9effcc7336a997f5d6">cycle</a>(xs, n) == <a class="code" href="group__group-MonadPlus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(<a class="code" href="group__group-MonadPlus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(... <a class="code" href="group__group-MonadPlus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(xs, xs), xs), xs)</div>
<div class="line">                          <span class="comment">// ^^^^^ n times total</span></div>
</div><!-- fragment --><p>If <code>n</code> is zero, then the identity of <code>concat</code>, <code>empty</code>, is returned. In the case of sequences, this boils down to returning a sequence containing <code>n</code> copies of itself; for other models it might differ.</p>
<h2>Signature </h2>
<p>Given an <code><a class="el" href="structboost_1_1hana_1_1IntegralConstant.html" title="The IntegralConstant concept represents compile-time integral values. ">IntegralConstant</a></code> <code>C</code> and a <code>MonadPlus</code> <code>M</code>, the signature is \( \mathrm{cycle} : M(T) \times C \to M(T) \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>A monadic structure to combine with itself a certain number of times.</td></tr>
    <tr><td class="paramname">n</td><td>A non-negative <code><a class="el" href="structboost_1_1hana_1_1IntegralConstant.html" title="The IntegralConstant concept represents compile-time integral values. ">IntegralConstant</a></code> representing the number of times to combine the monadic structure with itself. If <code>n</code> is zero, <code>cycle</code> returns <code>empty</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2016</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cycle_8hpp.html">boost/hana/cycle.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">static_assert(<a class="code" href="group__group-MonadPlus.html#gaaf46c168f721da9effcc7336a997f5d6">hana::cycle</a>(hana::make_tuple(<span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;y&#39;</span>), hana::size_c&lt;2&gt;) == hana::make_tuple(<span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;y&#39;</span>, <span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;y&#39;</span>), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaa6be1e83ad72b9d69b43b4bada0f3a75"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::empty</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2empty_8hpp.html">boost/hana/fwd/empty.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= []() {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Identity of the monadic combination <code>concat</code>.<h2>Signature </h2>
Given a MonadPlus <code>M</code>, the signature is \( \mathtt{empty}_M : \emptyset \to M(T) \). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The tag of the monadic structure to return. This must be a model of the MonadPlus concept.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2016</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="empty_8hpp.html">boost/hana/empty.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(hana::empty&lt;hana::tuple_tag&gt;() == hana::make_tuple());</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(hana::empty&lt;hana::optional_tag&gt;() == hana::nothing);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga65cc6d9f522fb9e8e3b28d80ee5c822a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::filter</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2filter_8hpp.html">boost/hana/fwd/filter.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; pred) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Filter a monadic structure using a custom predicate.Given a monadic structure and a predicate, <code>filter</code> returns a new monadic structure containing only those elements that satisfy the predicate. This is a generalization of the usual <code>filter</code> function for sequences; it works for any MonadPlus. Intuitively, <code>filter</code> is somewhat equivalent to: </p>
<div class="fragment"><div class="line"><a class="code" href="group__group-MonadPlus.html#ga65cc6d9f522fb9e8e3b28d80ee5c822a">filter</a>(xs, pred) == <a class="code" href="group__group-Monad.html#gaa5fec6fb418de5da3ecb500fd6cc54dd">flatten</a>(<a class="code" href="group__group-Functor.html#ga5a8975f6e55375d5b6038a9c36ee63e7">transform</a>(xs, [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> pred(x) ? lift&lt;Xs&gt;(x) : empty&lt;Xs&gt;();</div>
<div class="line">})</div>
</div><!-- fragment --><p> In other words, we basically turn a monadic structure containing <code>[x1, ..., xn]</code> into a monadic structure containing </p><div class="fragment"><div class="line">[</div>
<div class="line">    pred(x1) ? [x1] : [],</div>
<div class="line">    pred(x2) ? [x2] : [],</div>
<div class="line">    ...</div>
<div class="line">    pred(xn) ? [xn] : []</div>
<div class="line">]</div>
</div><!-- fragment --><p> and we then <code>flatten</code> that.</p>
<h2>Signature </h2>
<p>Given a <code>MonadPlus</code> <code>M</code> and an <code><a class="el" href="structboost_1_1hana_1_1IntegralConstant.html" title="The IntegralConstant concept represents compile-time integral values. ">IntegralConstant</a></code> <code>Bool</code> holding a value of type <code>bool</code>, the signature is \( \mathtt{filter} : M(T) \times (T \to \mathtt{Bool}) \to M(T) \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The monadic structure to filter.</td></tr>
    <tr><td class="paramname">pred</td><td>A function called as <code>pred(x)</code> for each element <code>x</code> in the monadic structure and returning whether that element should be <b>kept</b> in the resulting structure. In the current version of the library, the predicate has to return an <code><a class="el" href="structboost_1_1hana_1_1IntegralConstant.html" title="The IntegralConstant concept represents compile-time integral values. ">IntegralConstant</a></code> holding a value convertible to a <code>bool</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2016</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ext_2std_2integral__constant_8hpp.html">boost/hana/ext/std/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="filter_8hpp.html">boost/hana/filter.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="compose_8hpp.html">boost/hana/functional/compose.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;type_traits&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// First take the type of an object, and then tell whether it&#39;s integral</span></div>
<div class="line">constexpr <span class="keyword">auto</span> is_integral = <a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">hana::compose</a>(hana::trait&lt;std::is_integral&gt;, hana::decltype_);</div>
<div class="line"></div>
<div class="line">static_assert(<a class="code" href="group__group-MonadPlus.html#ga65cc6d9f522fb9e8e3b28d80ee5c822a">hana::filter</a>(hana::make_tuple(1, 2.0, 3, 4.0), is_integral) == hana::make_tuple(1, 3), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(<a class="code" href="group__group-MonadPlus.html#ga65cc6d9f522fb9e8e3b28d80ee5c822a">hana::filter</a>(hana::just(3), is_integral) == hana::just(3), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-MonadPlus.html#ga65cc6d9f522fb9e8e3b28d80ee5c822a">hana::filter</a>(hana::just(3.0), is_integral) == hana::nothing);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --><h2>Benchmarks </h2>
<div class="benchmark-chart" style="min-width: 310px; height: 400px; margin: 0 auto" data-dataset="benchmark.filter.compile.json"> </div> 
</div>
</div>
<a class="anchor" id="ga3022fdfe454dc9bc1f79b5dfeba13b5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::prefix</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2prefix_8hpp.html">boost/hana/fwd/prefix.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; pref) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Inserts a value before each element of a monadic structure.Given a monadic structure <code>xs</code> and a value <code>z</code> called the prefix, <code>prefix</code> returns a new monadic structure. <code>prefix</code> satisfies. </p>
<div class="fragment"><div class="line"><a class="code" href="group__group-MonadPlus.html#ga3022fdfe454dc9bc1f79b5dfeba13b5e">prefix</a>(xs, z) == <a class="code" href="group__group-Monad.html#gaa5fec6fb418de5da3ecb500fd6cc54dd">flatten</a>(<a class="code" href="group__group-Functor.html#ga5a8975f6e55375d5b6038a9c36ee63e7">transform</a>(xs, [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__group-MonadPlus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(lift&lt;M&gt;(z), lift&lt;M&gt;(x));</div>
<div class="line">}))</div>
</div><!-- fragment --><p>For sequences, this simply corresponds to inserting the prefix before each element of the sequence. For example, given a sequence <code>[x1, ..., xn]</code>, <code>prefix</code> will return </p><div class="fragment"><div class="line">[z, x1, z, x2, ..., z, xn]</div>
</div><!-- fragment --><p> As explained above, this can be generalized to other MonadPlus models, with various levels of interest.</p>
<h2>Signature </h2>
<p>Given a MonadPlus <code>M</code>, the signature is \( \mathrm{prefix} : M(T) \times T \to M(T) \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>A monadic structure.</td></tr>
    <tr><td class="paramname">pref</td><td>A value (the prefix) to insert before each element of a monadic structure.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2016</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="prefix_8hpp.html">boost/hana/prefix.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"><span class="keyword">using namespace </span>std::literals;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga29b2b21ffa5513e5b706c50ffee980af">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">        <a class="code" href="group__group-MonadPlus.html#ga3022fdfe454dc9bc1f79b5dfeba13b5e">hana::prefix</a>(hana::make_tuple(<span class="stringliteral">&quot;dog&quot;</span>s, <span class="stringliteral">&quot;car&quot;</span>s, <span class="stringliteral">&quot;house&quot;</span>s), <span class="stringliteral">&quot;my&quot;</span>s)</div>
<div class="line">            ==</div>
<div class="line">        hana::make_tuple(<span class="stringliteral">&quot;my&quot;</span>, <span class="stringliteral">&quot;dog&quot;</span>, <span class="stringliteral">&quot;my&quot;</span>, <span class="stringliteral">&quot;car&quot;</span>, <span class="stringliteral">&quot;my&quot;</span>, <span class="stringliteral">&quot;house&quot;</span>)</div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga69afbfd4e91125e3e52fcb409135ca7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::prepend</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2prepend_8hpp.html">boost/hana/fwd/prepend.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; x) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Prepend an element to a monadic structure.Given a monadic structure <code>xs</code> and an element <code>x</code>, <code>prepend</code> returns a new monadic structure which is the result of lifting <code>x</code> into the monadic structure and then combining that (to the left) with <code>xs</code>. In other words,. </p>
<div class="fragment"><div class="line"><a class="code" href="group__group-MonadPlus.html#ga69afbfd4e91125e3e52fcb409135ca7c">prepend</a>(xs, x) == <a class="code" href="group__group-MonadPlus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(lift&lt;Xs&gt;(x), xs)</div>
</div><!-- fragment --><p>For sequences, this has the intuitive behavior of simply prepending an element to the beginning of the sequence, hence the name.</p>
<blockquote class="doxtable">
<h4>Rationale for not calling this <code>push_front</code></h4>
<p>While <code>push_front</code> is the de-facto name used in the standard library, it also strongly suggests mutation of the underlying sequence, which is not the case here. The author also finds that <code>push_front</code> suggests too strongly the sole interpretation of putting an element to the front of a sequence, whereas <code>prepend</code> is slightly more nuanced and bears its name better for e.g. <code><a class="el" href="structboost_1_1hana_1_1optional.html" title="Optional value whose optional-ness is known at compile-time. ">hana::optional</a></code>. </p>
</blockquote>
<h2>Signature </h2>
<p>Given a MonadPlus <code>M</code>, the signature is \( \mathtt{prepend} : M(T) \times T \to M(T) \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>A monadic structure that will be combined to the right of the element.</td></tr>
    <tr><td class="paramname">x</td><td>An element to combine to the left of the monadic structure.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2016</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="prepend_8hpp.html">boost/hana/prepend.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">static_assert(<a class="code" href="group__group-MonadPlus.html#ga69afbfd4e91125e3e52fcb409135ca7c">hana::prepend</a>(hana::make_tuple(), 1) == hana::make_tuple(1), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(<a class="code" href="group__group-MonadPlus.html#ga69afbfd4e91125e3e52fcb409135ca7c">hana::prepend</a>(hana::make_tuple(<span class="charliteral">&#39;2&#39;</span>, 3.3), 1) == hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gae3cc0d6e0d8feb3d677bd1da64da6f43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::remove</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2remove_8hpp.html">boost/hana/fwd/remove.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; <a class="code" href="group__group-Constant.html#ga1687520692a6b0c49e3a69de2980f388">value</a>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
<div class="ttc" id="group__group-Constant_html_ga1687520692a6b0c49e3a69de2980f388"><div class="ttname"><a href="group__group-Constant.html#ga1687520692a6b0c49e3a69de2980f388">boost::hana::value</a></div><div class="ttdeci">constexpr auto value</div><div class="ttdoc">Return the compile-time value associated to a constant.This function returns the value associated to ...</div><div class="ttdef"><b>Definition:</b> value.hpp:54</div></div>
</div><!-- fragment -->
<p>Remove all the elements of a monadic structure that are equal to some value.Given a monadic structure <code>xs</code> and a <code>value</code>, <code>remove</code> returns a new monadic structure equal to <code>xs</code> without all its elements that are equal to the given <code>value</code>. <code>remove</code> is equivalent to <code>remove_if</code> with the <code>equal.to(value)</code> predicate, i.e. </p>
<div class="fragment"><div class="line"><span class="keyword">remove</span>(xs, <a class="code" href="group__group-Constant.html#ga1687520692a6b0c49e3a69de2980f388">value</a>) == <a class="code" href="group__group-MonadPlus.html#ga9700169a45664d50377c1be9d58accd3">remove_if</a>(xs, <a class="code" href="group__group-Comparable.html#gacaf1ebea6b3ab96ac9dcb82f0e64e547">equal</a>.to(<a class="code" href="group__group-Constant.html#ga1687520692a6b0c49e3a69de2980f388">value</a>))</div>
</div><!-- fragment --><h2>Signature </h2>
<p>Given a MonadPlus <code>M</code> and a value of type <code>T</code>, the signature is \( \mathrm{remove} : M(T) \times T \to M(T) \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>A monadic structure to remove some elements from.</td></tr>
    <tr><td class="paramname">value</td><td>A value that is compared to every element <code>x</code> of the structure. Elements of the structure that are equal to that value are removed from the structure. This requires every element to be Comparable with <code>value</code>. Furthermore, in the current version of the library, comparing <code>value</code> with any element of the structure must yield a compile-time Logical.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2016</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="remove_8hpp.html">boost/hana/remove.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-MonadPlus.html#gae3cc0d6e0d8feb3d677bd1da64da6f43">hana::remove</a>(hana::tuple_t&lt;int, char, float&gt;, hana::type_c&lt;char&gt;) == hana::tuple_t&lt;int, float&gt;);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-MonadPlus.html#gae3cc0d6e0d8feb3d677bd1da64da6f43">hana::remove</a>(hana::just(hana::type_c&lt;int&gt;), hana::type_c&lt;char&gt;) == hana::just(hana::type_c&lt;int&gt;));</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-MonadPlus.html#gae3cc0d6e0d8feb3d677bd1da64da6f43">hana::remove</a>(hana::just(hana::type_c&lt;int&gt;), hana::type_c&lt;int&gt;) == hana::nothing);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga9700169a45664d50377c1be9d58accd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::remove_if</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2remove__if_8hpp.html">boost/hana/fwd/remove_if.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Remove all the elements of a monadic structure that satisfy some predicate.Given a monadic structure <code>xs</code> and a unary predicate, <code>remove_if</code> returns a new monadic structure equal to <code>xs</code> without all its elements that satisfy the predicate. This is equivalent to <code>filter</code> with a negated predicate, i.e. </p>
<div class="fragment"><div class="line"><a class="code" href="group__group-MonadPlus.html#ga9700169a45664d50377c1be9d58accd3">remove_if</a>(xs, predicate) == <a class="code" href="group__group-MonadPlus.html#ga65cc6d9f522fb9e8e3b28d80ee5c822a">filter</a>(xs, negated predicated)</div>
</div><!-- fragment --><h2>Signature </h2>
<p>Given a MonadPlus <code>M</code> and a predicate of type \( T \to Bool \) for some compile-time Logical <code>Bool</code>, the signature is \( \mathrm{remove\_if} : M(T) \times (T \to Bool) \to M(T) \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>A monadic structure to remove some elements from.</td></tr>
    <tr><td class="paramname">predicate</td><td>A unary predicate called as <code>predicate(x)</code>, where <code>x</code> is an element of the structure, and returning whether <code>x</code> should be removed from the structure. In the current version of the library, <code>predicate</code> must return a compile-time Logical.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2016</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ext_2std_2integral__constant_8hpp.html">boost/hana/ext/std/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="compose_8hpp.html">boost/hana/functional/compose.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="remove__if_8hpp.html">boost/hana/remove_if.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;type_traits&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// First get the type of the object, and then call the trait on it.</span></div>
<div class="line">constexpr <span class="keyword">auto</span> is_integral = <a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">hana::compose</a>(hana::trait&lt;std::is_integral&gt;, hana::decltype_);</div>
<div class="line"></div>
<div class="line">static_assert(<a class="code" href="group__group-MonadPlus.html#ga9700169a45664d50377c1be9d58accd3">hana::remove_if</a>(hana::make_tuple(1, 2.0, 3, 4.0), is_integral) == hana::make_tuple(2.0, 4.0), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(<a class="code" href="group__group-MonadPlus.html#ga9700169a45664d50377c1be9d58accd3">hana::remove_if</a>(hana::just(3.0), is_integral) == hana::just(3.0), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-MonadPlus.html#ga9700169a45664d50377c1be9d58accd3">hana::remove_if</a>(hana::just(3), is_integral) == hana::nothing);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gad5f48c79d11923d6c1d70b18b7dd3f19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::replicate</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2replicate_8hpp.html">boost/hana/fwd/replicate.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; x, <span class="keyword">auto</span> <span class="keyword">const</span>&amp; n) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Create a monadic structure by combining a lifted value with itself <code>n</code> times.Given a value <code>x</code>, a non-negative <code><a class="el" href="structboost_1_1hana_1_1IntegralConstant.html" title="The IntegralConstant concept represents compile-time integral values. ">IntegralConstant</a></code> <code>n</code> and the tag of a monadic structure <code>M</code>, <code>replicate</code> creates a new monadic structure which is the result of combining <code>x</code> with itself <code>n</code> times inside the monadic structure. In other words, <code>replicate</code> simply <code>lift</code>s <code>x</code> into the monadic structure, and then combines that with itself <code>n</code> times: </p>
<div class="fragment"><div class="line">replicate&lt;M&gt;(x, n) == <a class="code" href="group__group-MonadPlus.html#gaaf46c168f721da9effcc7336a997f5d6">cycle</a>(lift&lt;M&gt;(x), n)</div>
</div><!-- fragment --><p>If <code>n</code> is zero, then the identity of the <code>concat</code> operation is returned. In the case of sequences, this corresponds to creating a new sequence holding <code>n</code> copies of <code>x</code>.</p>
<h2>Signature </h2>
<p>Given an <code><a class="el" href="structboost_1_1hana_1_1IntegralConstant.html" title="The IntegralConstant concept represents compile-time integral values. ">IntegralConstant</a></code> <code>C</code> and MonadPlus <code>M</code>, the signature is \( \mathtt{replicate}_M : T \times C \to M(T) \).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The tag of the returned monadic structure. It must be a model of the MonadPlus concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to lift into a monadic structure and then combine with itself.</td></tr>
    <tr><td class="paramname">n</td><td>A non-negative <code><a class="el" href="structboost_1_1hana_1_1IntegralConstant.html" title="The IntegralConstant concept represents compile-time integral values. ">IntegralConstant</a></code> representing the number of times to combine <code>lift&lt;M&gt;(x)</code> with itself. If <code>n == 0</code>, <code>replicate</code> returns <code>empty&lt;M&gt;()</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2016</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="replicate_8hpp.html">boost/hana/replicate.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">static_assert(hana::replicate&lt;hana::tuple_tag&gt;(<span class="charliteral">&#39;x&#39;</span>, hana::size_c&lt;2&gt;) == hana::make_tuple(<span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;x&#39;</span>), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Of course, there can&#39;t be more than one element in an `optional`.</span></div>
<div class="line">static_assert(hana::replicate&lt;hana::optional_tag&gt;(<span class="charliteral">&#39;x&#39;</span>, hana::size_c&lt;2&gt;) == hana::just(<span class="charliteral">&#39;x&#39;</span>), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga61dab15f6ecf379121d4096fe0c8ab13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::suffix</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2suffix_8hpp.html">boost/hana/fwd/suffix.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; sfx) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Inserts a value after each element of a monadic structure.Given a monadic structure <code>xs</code> and a value <code>z</code> (called the suffix), <code>suffix</code> returns a new monadic structure such that. </p>
<div class="fragment"><div class="line"><a class="code" href="group__group-MonadPlus.html#ga61dab15f6ecf379121d4096fe0c8ab13">suffix</a>(xs, z) == <a class="code" href="group__group-Monad.html#gaa5fec6fb418de5da3ecb500fd6cc54dd">flatten</a>(<a class="code" href="group__group-Functor.html#ga5a8975f6e55375d5b6038a9c36ee63e7">transform</a>(xs, [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__group-MonadPlus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(lift&lt;M&gt;(x), lift&lt;M&gt;(z));</div>
<div class="line">}))</div>
</div><!-- fragment --><p>For sequences, this simply corresponds to inserting the suffix after each element of the sequence. For example, given a sequence <code>[x1, ..., xn]</code>, <code>suffix</code> will return </p><div class="fragment"><div class="line">[x1, z, x2, z, ..., xn, z]</div>
</div><!-- fragment --><p> As explained above, this can be generalized to other MonadPlus models, with various levels of interest.</p>
<h2>Signature </h2>
<p>Given a MonadPlus <code>M</code>, the signature is \( \mathtt{suffix} : M(T) \times T \to M(T) \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>A monadic structure.</td></tr>
    <tr><td class="paramname">sfx</td><td>A value (the suffix) to insert after each element of a monadic structure.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2016</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="suffix_8hpp.html">boost/hana/suffix.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">static_assert(</div>
<div class="line">    <a class="code" href="group__group-MonadPlus.html#ga61dab15f6ecf379121d4096fe0c8ab13">hana::suffix</a>(hana::make_tuple(1, 2, 3, 4), 0) == hana::make_tuple(1, 0, 2, 0, 3, 0, 4, 0)</div>
<div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!--
Copyright Louis Dionne 2013-2016
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-->
<!-- boost-no-inspect -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
  </ul>
</div>
</body>
</html>
