<!--
Copyright Louis Dionne 2013-2016
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-->
<!-- boost-no-inspect -->
<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Boost.Hana: boost::hana::tuple&lt; Xn &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
// Copyright Louis Dionne 2013-2016
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
MathJax.Hub.Config({
    "HTML-CSS": {
        linebreaks: {
            automatic: true,
            width: "75% container"
        }
    }
});
</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Additional javascript for drawing charts. -->
<script type="text/javascript" src="highcharts.js"></script>
<script type="text/javascript" src="highcharts-data.js"></script>
<script type="text/javascript" src="highcharts-exporting.js"></script>
<script type="text/javascript" src="chart.js"></script>
<script type="text/javascript" src="hana.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Boost.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structboost_1_1hana_1_1tuple.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Synopsis of associated functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structboost_1_1hana_1_1tuple-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::hana::tuple&lt; Xn &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__group-datatypes.html">Data types</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><h3>template&lt;typename... Xn&gt;<br />
struct boost::hana::tuple&lt; Xn &gt;</h3>

<p>General purpose index-based heterogeneous sequence with a fixed length. </p>
<p>The tuple is the bread and butter for static metaprogramming. Conceptually, it is like a <code><a class="el" href="structstd_1_1tuple.html" title="Adapter for std::tuples. ">std::tuple</a></code>; it is a container able of holding objects of different types and whose size is fixed at compile-time. However, Hana's tuple provides much more functionality than its <code>std</code> counterpart, and it is also much more efficient than all standard library implementations tested so far.</p>
<p>Tuples are index-based sequences. If you need an associative sequence with a key-based access, then you should consider <code><a class="el" href="structboost_1_1hana_1_1map.html" title="Basic associative container requiring unique, Comparable and Hashable keys. ">hana::map</a></code> or <code><a class="el" href="structboost_1_1hana_1_1set.html" title="Basic unordered container requiring unique, Comparable and Hashable keys. ">hana::set</a></code> instead.</p>
<h2>Modeled concepts </h2>
<p><code>Sequence</code>, and all the concepts it refines</p>
<h2>Provided operators </h2>
<p>For convenience, the following operators are provided: </p><div class="fragment"><div class="line">xs == ys        -&gt;          <a class="code" href="group__group-Comparable.html#gacaf1ebea6b3ab96ac9dcb82f0e64e547">equal</a>(xs, ys)</div>
<div class="line">xs != ys        -&gt;          <a class="code" href="group__group-Comparable.html#gae33be2e0d5e04f19082f4b7740dfc9cd">not_equal</a>(xs, ys)</div>
<div class="line"></div>
<div class="line">xs &lt; ys         -&gt;          <a class="code" href="group__group-Orderable.html#gad510011602bdb14686f1c4ec145301c9">less</a>(xs, ys)</div>
<div class="line">xs &lt;= ys        -&gt;          <a class="code" href="group__group-Orderable.html#ga9917dd82beb67151bf5657245d37b851">less_equal</a>(xs, ys)</div>
<div class="line">xs &gt; ys         -&gt;          <a class="code" href="group__group-Orderable.html#gaf9a073eafebbe514fb19dff82318f198">greater</a>(xs, ys)</div>
<div class="line">xs &gt;= ys        -&gt;          <a class="code" href="group__group-Orderable.html#ga6023631e7d0a01e16dc3fa4221fbd703">greater_equal</a>(xs, ys)</div>
<div class="line"></div>
<div class="line">xs | f          -&gt;          <a class="code" href="group__group-Monad.html#ga05fdc2f887cb9967357487a432ace98b">chain</a>(xs, f)</div>
<div class="line"></div>
<div class="line">xs[n]           -&gt;          <a class="code" href="group__group-Iterable.html#ga8a484304380eae38f3d9663d98860129">at</a>(xs, n)</div>
</div><!-- fragment --><h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2016</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="transform_8hpp.html">boost/hana/transform.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"><span class="keyword">using namespace </span>hana::literals;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Fish { std::string name; };</div>
<div class="line"><span class="keyword">struct </span>Cat  { std::string name; };</div>
<div class="line"><span class="keyword">struct </span>Dog  { std::string name; };</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    hana::tuple&lt;Fish, Cat, Dog&gt; animals{{<span class="stringliteral">&quot;Nemo&quot;</span>}, {<span class="stringliteral">&quot;Garfield&quot;</span>}, {<span class="stringliteral">&quot;Snoopy&quot;</span>}};</div>
<div class="line">    animals[0_c].name = <span class="stringliteral">&quot;Moby Dick&quot;</span>; <span class="comment">// can modify elements in place, like std::tuple</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span> names = <a class="code" href="group__group-Functor.html#ga5a8975f6e55375d5b6038a9c36ee63e7">hana::transform</a>(animals, [](<span class="keyword">auto</span> a) {</div>
<div class="line">      <span class="keywordflow">return</span> a.name;</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga29b2b21ffa5513e5b706c50ffee980af">BOOST_HANA_RUNTIME_CHECK</a>(names == hana::make_tuple(<span class="stringliteral">&quot;Moby Dick&quot;</span>, <span class="stringliteral">&quot;Garfield&quot;</span>, <span class="stringliteral">&quot;Snoopy&quot;</span>));</div>
<div class="line">}</div>
</div><!-- fragment --> </div><div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for boost::hana::tuple&lt; Xn &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="structboost_1_1hana_1_1tuple.png" usemap="#boost::hana::tuple&lt; Xn &gt;_map" alt=""/>
  <map id="boost::hana::tuple&lt; Xn &gt;_map" name="boost::hana::tuple&lt; Xn &gt;_map">
<area href="structboost_1_1hana_1_1detail_1_1operators_1_1adl.html" alt="boost::hana::detail::operators::adl&lt; tuple&lt; Xn... &gt; &gt;" shape="rect" coords="0,0,298,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Synopsis of associated functions</h2></td></tr>
<tr class="memitem:ad9d8c7efa77e573eba2dfc48b3343e66"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ad9d8c7efa77e573eba2dfc48b3343e66"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1tuple.html#ad9d8c7efa77e573eba2dfc48b3343e66">make&lt; tuple_tag &gt;</a></td></tr>
<tr class="memdesc:ad9d8c7efa77e573eba2dfc48b3343e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for creating a <code>tuple</code>.  <a href="#ad9d8c7efa77e573eba2dfc48b3343e66">More...</a><br /></td></tr>
<tr class="separator:ad9d8c7efa77e573eba2dfc48b3343e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c175cfb83276339f91e867d738a2e6"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1tuple.html#af3c175cfb83276339f91e867d738a2e6">make_tuple</a> = <a class="el" href="group__group-core.html#ga1d92480f0af1029878e773dafa3e2f60">make</a>&lt;<a class="el" href="structboost_1_1hana_1_1tuple__tag.html">tuple_tag</a>&gt;</td></tr>
<tr class="memdesc:af3c175cfb83276339f91e867d738a2e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to <code>make&lt;<a class="el" href="structboost_1_1hana_1_1tuple__tag.html" title="Tag representing hana::tuples. ">tuple_tag</a>&gt;</code>; provided for convenience.  <a href="#af3c175cfb83276339f91e867d738a2e6">More...</a><br /></td></tr>
<tr class="separator:af3c175cfb83276339f91e867d738a2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749b564c8f115957837761d75191beac"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1tuple.html#a749b564c8f115957837761d75191beac">to_tuple</a> = <a class="el" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">to</a>&lt;<a class="el" href="structboost_1_1hana_1_1tuple__tag.html">tuple_tag</a>&gt;</td></tr>
<tr class="memdesc:a749b564c8f115957837761d75191beac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>to&lt;<a class="el" href="structboost_1_1hana_1_1tuple__tag.html" title="Tag representing hana::tuples. ">tuple_tag</a>&gt;</code>; provided for convenience.  <a href="#a749b564c8f115957837761d75191beac">More...</a><br /></td></tr>
<tr class="separator:a749b564c8f115957837761d75191beac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1997546daf58a48cc15498d338a03da3"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a1997546daf58a48cc15498d338a03da3"><td class="memTemplItemLeft" align="right" valign="top">constexpr implementation_defined&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1tuple.html#a1997546daf58a48cc15498d338a03da3">tuple_t</a> {}</td></tr>
<tr class="memdesc:a1997546daf58a48cc15498d338a03da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a tuple specialized for holding <code><a class="el" href="structboost_1_1hana_1_1type.html" title="C++ type in value-level representation. ">hana::type</a></code>s.  <a href="#a1997546daf58a48cc15498d338a03da3">More...</a><br /></td></tr>
<tr class="separator:a1997546daf58a48cc15498d338a03da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c2f16caa2a1e12eefd1b3f69fa658e"><td class="memTemplParams" colspan="2">template&lt;typename T , T... v&gt; </td></tr>
<tr class="memitem:a85c2f16caa2a1e12eefd1b3f69fa658e"><td class="memTemplItemLeft" align="right" valign="top">constexpr implementation_defined&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1tuple.html#a85c2f16caa2a1e12eefd1b3f69fa658e">tuple_c</a> {}</td></tr>
<tr class="memdesc:a85c2f16caa2a1e12eefd1b3f69fa658e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a tuple specialized for holding <code><a class="el" href="structboost_1_1hana_1_1integral__constant.html" title="Compile-time value of an integral type. ">hana::integral_constant</a></code>s.  <a href="#a85c2f16caa2a1e12eefd1b3f69fa658e">More...</a><br /></td></tr>
<tr class="separator:a85c2f16caa2a1e12eefd1b3f69fa658e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a59b4d21f17e2caed8c31d8389d0f0878"><td class="memTemplParams" colspan="2"><a class="anchor" id="a59b4d21f17e2caed8c31d8389d0f0878"></a>
template&lt;typename... T, typename F &gt; </td></tr>
<tr class="memitem:a59b4d21f17e2caed8c31d8389d0f0878"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1tuple.html#a59b4d21f17e2caed8c31d8389d0f0878">operator|</a> (<a class="el" href="structboost_1_1hana_1_1tuple.html">tuple</a>&lt; T... &gt;, F)</td></tr>
<tr class="memdesc:a59b4d21f17e2caed8c31d8389d0f0878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code><a class="el" href="group__group-Monad.html#ga05fdc2f887cb9967357487a432ace98b" title="Feed a monadic value into a monadic computation.Given a monadic value and a monadic function...">hana::chain</a></code>. <br /></td></tr>
<tr class="separator:a59b4d21f17e2caed8c31d8389d0f0878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27607958295e6da8a0ba602a2db468f1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a27607958295e6da8a0ba602a2db468f1"></a>
template&lt;typename X , typename Y &gt; </td></tr>
<tr class="memitem:a27607958295e6da8a0ba602a2db468f1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1tuple.html#a27607958295e6da8a0ba602a2db468f1">operator==</a> (X &amp;&amp;x, Y &amp;&amp;y)</td></tr>
<tr class="memdesc:a27607958295e6da8a0ba602a2db468f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code><a class="el" href="group__group-Comparable.html#gacaf1ebea6b3ab96ac9dcb82f0e64e547" title="Returns a Logical representing whether x is equal to y.The equal function can be called in two differ...">hana::equal</a></code> <br /></td></tr>
<tr class="separator:a27607958295e6da8a0ba602a2db468f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cae3af55edb3eb05bfa184bda633f7d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0cae3af55edb3eb05bfa184bda633f7d"></a>
template&lt;typename X , typename Y &gt; </td></tr>
<tr class="memitem:a0cae3af55edb3eb05bfa184bda633f7d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1tuple.html#a0cae3af55edb3eb05bfa184bda633f7d">operator!=</a> (X &amp;&amp;x, Y &amp;&amp;y)</td></tr>
<tr class="memdesc:a0cae3af55edb3eb05bfa184bda633f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code><a class="el" href="group__group-Comparable.html#gae33be2e0d5e04f19082f4b7740dfc9cd" title="Returns a Logical representing whether x is not equal to y.The not_equal function can be called in tw...">hana::not_equal</a></code> <br /></td></tr>
<tr class="separator:a0cae3af55edb3eb05bfa184bda633f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada078dcf9e68b8e9a82b33c75dde8457"><td class="memTemplParams" colspan="2"><a class="anchor" id="ada078dcf9e68b8e9a82b33c75dde8457"></a>
template&lt;typename X , typename Y &gt; </td></tr>
<tr class="memitem:ada078dcf9e68b8e9a82b33c75dde8457"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1tuple.html#ada078dcf9e68b8e9a82b33c75dde8457">operator&lt;</a> (X &amp;&amp;x, Y &amp;&amp;y)</td></tr>
<tr class="memdesc:ada078dcf9e68b8e9a82b33c75dde8457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code><a class="el" href="group__group-Orderable.html#gad510011602bdb14686f1c4ec145301c9" title="Returns a Logical representing whether x is less than y. ">hana::less</a></code> <br /></td></tr>
<tr class="separator:ada078dcf9e68b8e9a82b33c75dde8457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd11fddefddbbbb87d3b24c7117528f"><td class="memTemplParams" colspan="2"><a class="anchor" id="aedd11fddefddbbbb87d3b24c7117528f"></a>
template&lt;typename X , typename Y &gt; </td></tr>
<tr class="memitem:aedd11fddefddbbbb87d3b24c7117528f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1tuple.html#aedd11fddefddbbbb87d3b24c7117528f">operator&gt;</a> (X &amp;&amp;x, Y &amp;&amp;y)</td></tr>
<tr class="memdesc:aedd11fddefddbbbb87d3b24c7117528f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code><a class="el" href="group__group-Orderable.html#gaf9a073eafebbe514fb19dff82318f198" title="Returns a Logical representing whether x is greater than y. ">hana::greater</a></code> <br /></td></tr>
<tr class="separator:aedd11fddefddbbbb87d3b24c7117528f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53817979990da799e659b2576799a79a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a53817979990da799e659b2576799a79a"></a>
template&lt;typename X , typename Y &gt; </td></tr>
<tr class="memitem:a53817979990da799e659b2576799a79a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1tuple.html#a53817979990da799e659b2576799a79a">operator&lt;=</a> (X &amp;&amp;x, Y &amp;&amp;y)</td></tr>
<tr class="memdesc:a53817979990da799e659b2576799a79a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code><a class="el" href="group__group-Orderable.html#ga9917dd82beb67151bf5657245d37b851" title="Returns a Logical representing whether x is less than or equal to y. ">hana::less_equal</a></code> <br /></td></tr>
<tr class="separator:a53817979990da799e659b2576799a79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f0436b623de5208767751e1e9f7e59"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa3f0436b623de5208767751e1e9f7e59"></a>
template&lt;typename X , typename Y &gt; </td></tr>
<tr class="memitem:aa3f0436b623de5208767751e1e9f7e59"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1tuple.html#aa3f0436b623de5208767751e1e9f7e59">operator&gt;=</a> (X &amp;&amp;x, Y &amp;&amp;y)</td></tr>
<tr class="memdesc:aa3f0436b623de5208767751e1e9f7e59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code><a class="el" href="group__group-Orderable.html#ga6023631e7d0a01e16dc3fa4221fbd703" title="Returns a Logical representing whether x is greater than or equal to y. ">hana::greater_equal</a></code> <br /></td></tr>
<tr class="separator:aa3f0436b623de5208767751e1e9f7e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8e10223983bfb3873c285be85f7ab273"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e10223983bfb3873c285be85f7ab273"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1tuple.html#a8e10223983bfb3873c285be85f7ab273">tuple</a> ()</td></tr>
<tr class="memdesc:a8e10223983bfb3873c285be85f7ab273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructs the <code>tuple</code>. Only exists when all the elements of the tuple are default constructible. <br /></td></tr>
<tr class="separator:a8e10223983bfb3873c285be85f7ab273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4e6193df38146b1eab93bcf963fc81"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1tuple.html#a4e4e6193df38146b1eab93bcf963fc81">tuple</a> (Xn const &amp;...xn)</td></tr>
<tr class="memdesc:a4e4e6193df38146b1eab93bcf963fc81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize each element of the tuple with the corresponding element from <code>xn...</code>. Only exists when all the elements of the tuple are copy-constructible.  <a href="#a4e4e6193df38146b1eab93bcf963fc81">More...</a><br /></td></tr>
<tr class="separator:a4e4e6193df38146b1eab93bcf963fc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5dd3930d94a900190de98247e0c415"><td class="memTemplParams" colspan="2">template&lt;typename... Yn&gt; </td></tr>
<tr class="memitem:a9a5dd3930d94a900190de98247e0c415"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1tuple.html#a9a5dd3930d94a900190de98247e0c415">tuple</a> (Yn &amp;&amp;...yn)</td></tr>
<tr class="memdesc:a9a5dd3930d94a900190de98247e0c415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize each element of the tuple by perfect-forwarding the corresponding element in <code>yn...</code>. Only exists when all the elements of the created tuple are constructible from the corresponding perfect-forwarded value.  <a href="#a9a5dd3930d94a900190de98247e0c415">More...</a><br /></td></tr>
<tr class="separator:a9a5dd3930d94a900190de98247e0c415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf99e86ab1506594eca03881748fe91"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6cf99e86ab1506594eca03881748fe91"></a>
template&lt;typename... Yn&gt; </td></tr>
<tr class="memitem:a6cf99e86ab1506594eca03881748fe91"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1tuple.html#a6cf99e86ab1506594eca03881748fe91">tuple</a> (<a class="el" href="structboost_1_1hana_1_1tuple.html">tuple</a>&lt; Yn... &gt; const &amp;other)</td></tr>
<tr class="memdesc:a6cf99e86ab1506594eca03881748fe91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-initialize a tuple from another tuple. Only exists when all the elements of the constructed tuple are copy-constructible from the corresponding element in the source tuple. <br /></td></tr>
<tr class="separator:a6cf99e86ab1506594eca03881748fe91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac504757198d85ab9de1258de634e3b71"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac504757198d85ab9de1258de634e3b71"></a>
template&lt;typename... Yn&gt; </td></tr>
<tr class="memitem:ac504757198d85ab9de1258de634e3b71"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1tuple.html#ac504757198d85ab9de1258de634e3b71">tuple</a> (<a class="el" href="structboost_1_1hana_1_1tuple.html">tuple</a>&lt; Yn... &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:ac504757198d85ab9de1258de634e3b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-initialize a tuple from another tuple. Only exists when all the elements of the constructed tuple are move-constructible from the corresponding element in the source tuple. <br /></td></tr>
<tr class="separator:ac504757198d85ab9de1258de634e3b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acddfa6d631c249ae667d52dd63c0aeaf"><td class="memTemplParams" colspan="2"><a class="anchor" id="acddfa6d631c249ae667d52dd63c0aeaf"></a>
template&lt;typename... Yn&gt; </td></tr>
<tr class="memitem:acddfa6d631c249ae667d52dd63c0aeaf"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structboost_1_1hana_1_1tuple.html">tuple</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1tuple.html#acddfa6d631c249ae667d52dd63c0aeaf">operator=</a> (<a class="el" href="structboost_1_1hana_1_1tuple.html">tuple</a>&lt; Yn... &gt; const &amp;other)</td></tr>
<tr class="memdesc:acddfa6d631c249ae667d52dd63c0aeaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a tuple to another tuple. Only exists when all the elements of the destination tuple are assignable from the corresponding element in the source tuple. <br /></td></tr>
<tr class="separator:acddfa6d631c249ae667d52dd63c0aeaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f0fe520974a22cc12a978f4b061caa"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad3f0fe520974a22cc12a978f4b061caa"></a>
template&lt;typename... Yn&gt; </td></tr>
<tr class="memitem:ad3f0fe520974a22cc12a978f4b061caa"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structboost_1_1hana_1_1tuple.html">tuple</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1tuple.html#ad3f0fe520974a22cc12a978f4b061caa">operator=</a> (<a class="el" href="structboost_1_1hana_1_1tuple.html">tuple</a>&lt; Yn... &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:ad3f0fe520974a22cc12a978f4b061caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-assign a tuple to another tuple. Only exists when all the elements of the destination tuple are move-assignable from the corresponding element in the source tuple. <br /></td></tr>
<tr class="separator:ad3f0fe520974a22cc12a978f4b061caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef38216a6c6da0296a5f7b5241e951b"><td class="memTemplParams" colspan="2"><a class="anchor" id="acef38216a6c6da0296a5f7b5241e951b"></a>
template&lt;typename N &gt; </td></tr>
<tr class="memitem:acef38216a6c6da0296a5f7b5241e951b"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto) constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1tuple.html#acef38216a6c6da0296a5f7b5241e951b">operator[]</a> (N &amp;&amp;n)</td></tr>
<tr class="memdesc:acef38216a6c6da0296a5f7b5241e951b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code><a class="el" href="group__group-Iterable.html#ga8a484304380eae38f3d9663d98860129" title="Returns the nth element of an iterable.Given an Iterable and an IntegralConstant index, at returns the element located at the index in the linearization of the iterable. Specifically, given an iterable xs with a linearization of [x1, ..., xN], at(xs, k) is equivalent to xk. ">hana::at</a></code> <br /></td></tr>
<tr class="separator:acef38216a6c6da0296a5f7b5241e951b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Associated functions</h2>
<a class="anchor" id="ad9d8c7efa77e573eba2dfc48b3343e66"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Xn&gt; </div>
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="group__group-core.html#ga1d92480f0af1029878e773dafa3e2f60">make</a>&lt; <a class="el" href="structboost_1_1hana_1_1tuple__tag.html">tuple_tag</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; ...xs) {</div>
<div class="line">        <span class="keywordflow">return</span> tuple&lt;std::decay_t&lt;decltype(xs)&gt;...&gt;{forwarded(xs)...};</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Function object for creating a <code>tuple</code>. </p>
<p>Given zero or more objects <code>xs...</code>, <code>make&lt;<a class="el" href="structboost_1_1hana_1_1tuple__tag.html" title="Tag representing hana::tuples. ">tuple_tag</a>&gt;</code> returns a new tuple containing those objects. The elements are held by value inside the resulting tuple, and they are hence copied or moved in. This is analogous to <code>std::make_tuple</code> for creating Hana tuples.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2016</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="core_2make_8hpp.html">boost/hana/core/make.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">auto</span> xs = hana::make&lt;hana::tuple_tag&gt;(1, 2, <span class="charliteral">&#39;3&#39;</span>, std::string{<span class="stringliteral">&quot;456&quot;</span>});</div>
<div class="line"></div>
<div class="line">    constexpr <span class="keyword">auto</span> ys = hana::make&lt;hana::tuple_tag&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.456);</div>
<div class="line">    static_assert(ys == hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.456), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="af3c175cfb83276339f91e867d738a2e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Xn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto make_tuple = <a class="el" href="group__group-core.html#ga1d92480f0af1029878e773dafa3e2f60">make</a>&lt;<a class="el" href="structboost_1_1hana_1_1tuple__tag.html">tuple_tag</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias to <code>make&lt;<a class="el" href="structboost_1_1hana_1_1tuple__tag.html" title="Tag representing hana::tuples. ">tuple_tag</a>&gt;</code>; provided for convenience. </p>

</div>
</div>
<a class="anchor" id="a749b564c8f115957837761d75191beac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Xn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto to_tuple = <a class="el" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">to</a>&lt;<a class="el" href="structboost_1_1hana_1_1tuple__tag.html">tuple_tag</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to <code>to&lt;<a class="el" href="structboost_1_1hana_1_1tuple__tag.html" title="Tag representing hana::tuples. ">tuple_tag</a>&gt;</code>; provided for convenience. </p>

</div>
</div>
<a class="anchor" id="a1997546daf58a48cc15498d338a03da3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Xn&gt; </div>
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr implementation_defined tuple_t {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a tuple specialized for holding <code><a class="el" href="structboost_1_1hana_1_1type.html" title="C++ type in value-level representation. ">hana::type</a></code>s. </p>
<p>This is functionally equivalent to <code>make&lt;<a class="el" href="structboost_1_1hana_1_1tuple__tag.html" title="Tag representing hana::tuples. ">tuple_tag</a>&gt;(type_c&lt;T&gt;...)</code>, except that using <code>tuple_t</code> allows the library to perform some compile-time optimizations. Also note that the type of the objects returned by <code>tuple_t</code> and an equivalent call to <code>make&lt;<a class="el" href="structboost_1_1hana_1_1tuple__tag.html" title="Tag representing hana::tuples. ">tuple_tag</a>&gt;</code> may differ.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2016</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="core_2to_8hpp.html">boost/hana/core/to.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">        hana::to_tuple(hana::tuple_t&lt;<span class="keywordtype">int</span>, <span class="keywordtype">char</span>, <span class="keywordtype">void</span>, <span class="keywordtype">int</span>(<span class="keywordtype">float</span>)&gt;)</div>
<div class="line">            ==</div>
<div class="line">        hana::make_tuple(hana::type_c&lt;int&gt;, hana::type_c&lt;char&gt;, hana::type_c&lt;void&gt;, hana::type_c&lt;<span class="keywordtype">int</span>(<span class="keywordtype">float</span>)&gt;)</div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a85c2f16caa2a1e12eefd1b3f69fa658e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Xn&gt; </div>
<div class="memtemplate">
template&lt;typename T , T... v&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr implementation_defined tuple_c {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a tuple specialized for holding <code><a class="el" href="structboost_1_1hana_1_1integral__constant.html" title="Compile-time value of an integral type. ">hana::integral_constant</a></code>s. </p>
<p>This is functionally equivalent to <code>make&lt;<a class="el" href="structboost_1_1hana_1_1tuple__tag.html" title="Tag representing hana::tuples. ">tuple_tag</a>&gt;(integral_c&lt;T, v&gt;...)</code>, except that using <code>tuple_c</code> allows the library to perform some compile-time optimizations. Also note that the type of the objects returned by <code>tuple_c</code> and an equivalent call to <code>make&lt;<a class="el" href="structboost_1_1hana_1_1tuple__tag.html" title="Tag representing hana::tuples. ">tuple_tag</a>&gt;</code> may differ.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2016</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="core_2to_8hpp.html">boost/hana/core/to.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="front_8hpp.html">boost/hana/front.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">        hana::to_tuple(hana::tuple_c&lt;int, 0, 1, 2&gt;)</div>
<div class="line">            ==</div>
<div class="line">        hana::make_tuple(hana::int_c&lt;0&gt;, hana::int_c&lt;1&gt;, hana::int_c&lt;2&gt;)</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-Iterable.html#ga8a67ea10e8082dbe6705e573fa978444">hana::front</a>(hana::tuple_c&lt;int, 0, 1, 2&gt;) == hana::int_c&lt;0&gt;);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4e4e6193df38146b1eab93bcf963fc81"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Xn&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structboost_1_1hana_1_1tuple.html">boost::hana::tuple</a>&lt; Xn &gt;::<a class="el" href="structboost_1_1hana_1_1tuple.html">tuple</a> </td>
          <td>(</td>
          <td class="paramtype">Xn const &amp;...&#160;</td>
          <td class="paramname"><em>xn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize each element of the tuple with the corresponding element from <code>xn...</code>. Only exists when all the elements of the tuple are copy-constructible. </p>
<dl class="section note"><dt>Note</dt><dd>Unlike the corresponding constructor for <code><a class="el" href="structstd_1_1tuple.html" title="Adapter for std::tuples. ">std::tuple</a></code>, this constructor is not explicit. This allows returning a tuple from a function with the brace-initialization syntax. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a5dd3930d94a900190de98247e0c415"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Xn&gt; </div>
<div class="memtemplate">
template&lt;typename... Yn&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structboost_1_1hana_1_1tuple.html">boost::hana::tuple</a>&lt; Xn &gt;::<a class="el" href="structboost_1_1hana_1_1tuple.html">tuple</a> </td>
          <td>(</td>
          <td class="paramtype">Yn &amp;&amp;...&#160;</td>
          <td class="paramname"><em>yn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize each element of the tuple by perfect-forwarding the corresponding element in <code>yn...</code>. Only exists when all the elements of the created tuple are constructible from the corresponding perfect-forwarded value. </p>
<dl class="section note"><dt>Note</dt><dd>Unlike the corresponding constructor for <code><a class="el" href="structstd_1_1tuple.html" title="Adapter for std::tuples. ">std::tuple</a></code>, this constructor is not explicit. This allows returning a tuple from a function with the brace-initialization syntax. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!--
Copyright Louis Dionne 2013-2016
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-->
<!-- boost-no-inspect -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><a class="el" href="namespaceboost_1_1hana.html">hana</a></li><li class="navelem"><a class="el" href="structboost_1_1hana_1_1tuple.html">tuple</a></li>
  </ul>
</div>
</body>
</html>
