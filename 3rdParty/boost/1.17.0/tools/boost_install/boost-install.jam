# Copyright 2018, 2019 Peter Dimov
# Distributed under the Boost Software License, Version 1.0.
# (See accompanying file LICENSE_1_0.txt or copy at http://boost.org/LICENSE_1_0.txt)

import modules ;
import boostcpp ;
import property-set ;
import "class" : new ;
import project ;
import common ;
import print ;
import os ;
import feature ;
import package ;
import sequence ;
import set ;
import type ;
import path ;
import regex ;
import ./boost-install-dirs ;

feature.feature library-type : : free ;
feature.feature boost-install.dependency : : free ;
feature.feature boost-install.includedir : : free ;
feature.feature boost-install.libdir : : free ;

if "--verbose" in [ modules.peek : ARGV ]
{
    .info-enabled = 1 ;
}

if "--debug-boost-install" in [ modules.peek : ARGV ]
{
    .debug-enabled = 1 ;
}

local rule .info ( messages * )
{
    if $(.info-enabled)
    {
        ECHO "info:" $(messages) ;
    }
}

local rule .debug ( messages * )
{
    if $(.debug-enabled)
    {
        ECHO "boost-install:" $(messages) ;
    }
}

# generate-cmake-variant-

rule generate-cmake-variant- ( target : sources * : properties * )
{
    .info generate-cmake-variant- $(target) ":" $(sources) ;

    local ps = [ property-set.create $(properties) ] ;

    print.output $(target) ;

    local version = [ $(ps).get <version> ] ;
    .info "  version=" $(version) ;

    local name = [ $(ps).get <name> ] ;
    .info "  name=" $(name) ;

    local variant = [ $(ps).get <variant> ] ;
    .info "  variant=" $(variant) ;

    local link = [ $(ps).get <link> ] ;
    .info "  link= " $(link) ;

    local runtime-link = [ $(ps).get <runtime-link> ] ;
    .info "  runtime-link=" $(runtime-link) ;

    local runtime-debugging = [ $(ps).get <runtime-debugging> ] ;
    .info "  runtime-debugging=" $(runtime-debugging) ;

    local threading = [ $(ps).get <threading> ] ;
    .info "  threading=" $(threading) ;

    local address-model = [ $(ps).get <address-model> ] ;
    .info "  address-model=" $(address-model) ;

    local toolset = [ MATCH ^-(.*) : [ common.format-name <toolset> : "" : "" : $(ps) ] ] ;
    .info "  toolset=" $(toolset) ;

    local fname = $(sources[1]:BS) ;
    .info "  fname=" $(fname) ;

    local layout = [ modules.peek boostcpp : layout ] ;
    .info "  layout=" $(layout) ;

    print.text

        "# Generated by Boost $(version)"
        ""
        : true ;

    print.text "# address-model=$(address-model)" "" : true ;

    if $(address-model) = 32
    {
        print.text

            "if(CMAKE_SIZEOF_VOID_P EQUAL 8)"
            "  _BOOST_SKIPPED(\"$(fname)\" \"32 bit, need 64\")"
            "  return()"
            "endif()"
            ""
            : true ;
    }
    else
    {
        print.text

            "if(CMAKE_SIZEOF_VOID_P EQUAL 4)"
            "  _BOOST_SKIPPED(\"$(fname)\" \"64 bit, need 32\")"
            "  return()"
            "endif()"
            ""
            : true ;
    }

    local python ;

    local relevant = [ $(ps).get <relevant> ] ;
    relevant = [ feature.expand-relevant $(relevant) ] ;

    if python in $(relevant)
    {
        python = [ $(ps).get <python> ] ;
    }

    if $(python)
    {
        .info "  python=" $(python) ;

        print.text "# python=$(python)" "" : true ;

        print.text

            "if(Boost_PYTHON_VERSION)"
            "  string(REGEX REPLACE \"([0-9]+[.][0-9]+)([.].*)?\" \"\\\\1\" __boost_pyver ${Boost_PYTHON_VERSION})"
            "  if(NOT __boost_pyver VERSION_EQUAL \"$(python)\")"
            "    _BOOST_SKIPPED(\"$(fname)\" \"$(python), Boost_PYTHON_VERSION=${Boost_PYTHON_VERSION}\")"
            "    return()"
            "  endif()"
            "endif()"
            ""
            : true ;
    }

    print.text "# layout=$(layout)" "" : true ;

    print.text "# toolset=$(toolset)" "" : true ;

    if $(layout) = versioned
    {
        print.text

            "if(Boost_COMPILER)"
            "  if(NOT Boost_COMPILER STREQUAL \"$(toolset)\" AND NOT Boost_COMPILER STREQUAL \"-$(toolset)\")"
            "    _BOOST_SKIPPED(\"$(fname)\" \"$(toolset), Boost_COMPILER=${Boost_COMPILER}\")"
            "    return()"
            "  endif()"
            "else()"
            "  if(BOOST_DETECTED_TOOLSET AND NOT BOOST_DETECTED_TOOLSET STREQUAL \"$(toolset)\")"
            "    _BOOST_SKIPPED(\"$(fname)\" \"$(toolset), detected ${BOOST_DETECTED_TOOLSET}, set Boost_COMPILER to override\")"
            "    return()"
            "  endif()"
            "endif()"
            ""
            : true ;
    }

    print.text "# link=$(link)" "" : true ;

    if $(link) = static
    {
        print.text

            "if(DEFINED Boost_USE_STATIC_LIBS)"
            "  if(NOT Boost_USE_STATIC_LIBS)"
            "    _BOOST_SKIPPED(\"$(fname)\" \"static, Boost_USE_STATIC_LIBS=${Boost_USE_STATIC_LIBS}\")"
            "    return()"
            "  endif()"
            "else()"
            "  if(NOT WIN32)"
            "    _BOOST_SKIPPED(\"$(fname)\" \"static, default is shared, set Boost_USE_STATIC_LIBS=ON to override\")"
            "    return()"
            "  endif()"
            "endif()"
            ""
            : true ;
    }
    else
    {
        print.text

            "if(DEFINED Boost_USE_STATIC_LIBS)"
            "  if(Boost_USE_STATIC_LIBS)"
            "    _BOOST_SKIPPED(\"$(fname)\" \"shared, Boost_USE_STATIC_LIBS=${Boost_USE_STATIC_LIBS}\")"
            "    return()"
            "  endif()"
            "else()"
            "  if(WIN32)"
            "    _BOOST_SKIPPED(\"$(fname)\" \"shared, default on Windows is static, set Boost_USE_STATIC_LIBS=OFF to override\")"
            "    return()"
            "  endif()"
            "endif()"
            ""
            : true ;
    }

    print.text "# runtime-link=$(runtime-link)" "" : true ;

    if $(runtime-link) = static
    {
        print.text

            "if(NOT Boost_USE_STATIC_RUNTIME)"
            "  _BOOST_SKIPPED(\"$(fname)\" \"static runtime, Boost_USE_STATIC_RUNTIME not ON\")"
            "  return()"
            "endif()"
            ""
            : true ;
    }
    else
    {
        print.text

            "if(Boost_USE_STATIC_RUNTIME)"
            "  _BOOST_SKIPPED(\"$(fname)\" \"shared runtime, Boost_USE_STATIC_RUNTIME=${Boost_USE_STATIC_RUNTIME}\")"
            "  return()"
            "endif()"
            ""
            : true ;
    }

    print.text "# runtime-debugging=$(runtime-debugging)" "" : true ;

    if $(runtime-debugging) = "on"
    {
        print.text

            "if(NOT \"${Boost_USE_DEBUG_RUNTIME}\" STREQUAL \"\" AND NOT Boost_USE_DEBUG_RUNTIME)"
            "  _BOOST_SKIPPED(\"$(fname)\" \"debug runtime, Boost_USE_DEBUG_RUNTIME=${Boost_USE_DEBUG_RUNTIME}\")"
            "  return()"
            "endif()"
            ""
            : true ;
    }
    else
    {
        print.text

            "if(Boost_USE_DEBUG_RUNTIME)"
            "  _BOOST_SKIPPED(\"$(fname)\" \"release runtime, Boost_USE_DEBUG_RUNTIME=${Boost_USE_DEBUG_RUNTIME}\")"
            "  return()"
            "endif()"
            ""
            : true ;
    }

    print.text "# threading=$(threading)" "" : true ;

    print.text "# variant=$(variant)" "" : true ;

    if $(variant) = debug
    {
        print.text

            "if(NOT \"${Boost_USE_DEBUG_LIBS}\" STREQUAL \"\" AND NOT Boost_USE_DEBUG_LIBS)"
            "  _BOOST_SKIPPED(\"$(fname)\" \"debug, Boost_USE_DEBUG_LIBS=${Boost_USE_DEBUG_LIBS}\")"
            "  return()"
            "endif()"
            ""
            : true ;
    }
    else
    {
        print.text

            "if(NOT \"${Boost_USE_RELEASE_LIBS}\" STREQUAL \"\" AND NOT Boost_USE_RELEASE_LIBS)"
            "  _BOOST_SKIPPED(\"$(fname)\" \"release, Boost_USE_RELEASE_LIBS=${Boost_USE_RELEASE_LIBS}\")"
            "  return()"
            "endif()"
            ""
            : true ;
    }

    print.text

        "if(Boost_VERBOSE OR Boost_DEBUG)"
        "  message(STATUS \"  [x] $(fname)\")"
        "endif()"
        ""
        : true ;

    local lname = [ MATCH boost_(.*) : $(name) ] ;
    .info "  lname=" $(lname) ;

    local target = "Boost::$(lname)" ;
    .info "  target=" $(target) ;

    print.text "# Target file name: $(fname)" "" : true ;

    print.text

        "get_target_property(__boost_imploc $(target) IMPORTED_LOCATION_$(variant:U))"
        "if(__boost_imploc)"
        "  message(WARNING \"Target $(target) already has an imported location '${__boost_imploc}', which will be overwritten with '${_BOOST_LIBDIR}/$(fname)'\")"
        "endif()"
        "unset(__boost_imploc)"
        ""
        "set_property(TARGET $(target) APPEND PROPERTY IMPORTED_CONFIGURATIONS $(variant:U))"
        ""
        "set_target_properties($(target) PROPERTIES"
        "  IMPORTED_LINK_INTERFACE_LANGUAGES_$(variant:U) CXX"
        "  IMPORTED_LOCATION_$(variant:U) \"${_BOOST_LIBDIR}/$(fname)\""
        "  )"
        ""
        : true ;

    if $(variant) = release
    {
        print.text

        "set_target_properties($(target) PROPERTIES"
        "  MAP_IMPORTED_CONFIG_MINSIZEREL Release"
        "  MAP_IMPORTED_CONFIG_RELWITHDEBINFO Release"
        "  )"
        ""
        : true ;
    }

    if $(link) = shared
    {
        print.text

        "set_target_properties($(target) PROPERTIES"
        "  INTERFACE_COMPILE_DEFINITIONS \"BOOST_$(lname:U)_DYN_LINK\""
        "  )"
        ""
        : true ;
    }

    local deps = [ MATCH "boost_(.*)" : [ $(ps).get <boost-install.dependency> ] ] headers ;
    .info "  deps=" $(deps) ;

    if $(deps)
    {
        print.text

            "list(APPEND _BOOST_$(lname:U)_DEPS $(deps:S=:J= ))"
            ""
            : true ;
    }
}

actions generate-cmake-variant-
{
}

# tag

local rule tag ( name : type ? : property-set )
{
    .debug tag $(name) ;

    local link = [ $(property-set).get <link> ] ;
    .debug "  link=" $(link) ;

    local python = ;

    local relevant = [ $(property-set).get <relevant> ] ;
    relevant = [ feature.expand-relevant $(relevant) ] ;

    if python in $(relevant)
    {
        python = [ $(property-set).get <python> ] ;
        .debug "  python=" $(python) ;
    }

    local r = [ boostcpp.tag $(name) : STATIC_LIB : $(property-set) ] ;

    r = $(r:S=$(name:S)) ;
    r = $(r:B=$(r:B)-$(link)) ;

    if $(python)
    {
        r = $(r:B=$(r:B)-py$(python)) ;
    }

    .debug "  result=" $(r) ;

    return $(r) ;
}

# choose-lib-target: get the import library, if present, the
#   shared/static library otherwise, ignore .pdb et al

local rule choose-lib-target ( sources * )
{
    local result ;

    for local t in $(sources)
    {
        if [ type.is-derived [ $(t).type ] IMPORT_LIB ]
        {
            return $(t) ;
        }
        else if [ type.is-derived [ $(t).type ] LIB ]
        {
            result = $(t) ;
        }
    }

    return $(result) ;
}

# get-dependency-names: Returns the base names of all
# dependency libraries.
#
local rule get-dependency-names ( sources * )
{
    local all-targets = [ collect-targets $(sources) ] ;
    local lib-names ;
    for local t in [ set.difference $(all-targets) : $(sources) ]
    {
        if [ $(t).type ] && [ type.is-derived [ $(t).type ] LIB ]
        {
            # Get back the original unmangled name of the library
            local subvariant = [ $(t).creating-subvariant ] ;
            local main-target = [ $(subvariant).main-target ] ;
            lib-names += [ $(main-target).name ] ;
        }
    }
    return [ sequence.unique $(lib-names) ] ;
}

# generate-cmake-variant

rule generate-cmake-variant ( project name : property-set : sources * )
{
    .debug generate-cmake-variant $(name) ;

    for local s in $(sources)
    {
        .debug "  name=" [ $(s).name ] ;
    }

    local lib-target = [ choose-lib-target $(sources) ] ;

    local other-names = [ get-dependency-names $(sources) ] ;
    property-set = [ $(property-set).add-raw <boost-install.dependency>$(other-names) ] ;

    local result ;

    if $(lib-target)
    {
        .debug "  lib-target=" [ $(lib-target).name ] ;

        local tag = [ tag $(name) : : $(property-set) ] ;

        local a = [ new non-scanning-action $(lib-target) : boost-install.generate-cmake-variant- : $(property-set) ] ;

        result += [ new file-target $(tag) : : $(project) : $(a) ] ;
    }

    # The result is an optional property set, the usage requirements,
    # followed by a list of targets. When the list is empty, we need
    # to include the property set, to avoid a warning.

    return [ property-set.empty ] $(result) ;
}

# generate-cmake-config-

local rule get-dir ( name : dir )
{
    if [ path.is-rooted $(dir) ]
    {
        if [ os.name ] = NT
        {
            dir = [ path.native $(dir) ] ;
            dir = [ regex.replace $(dir) \\\\ / ] ;
        }

        print.text

            "set($(name) \"$(dir)\")"

        : true ;
    }
    else
    {
        print.text

            "get_filename_component($(name) \"${_BOOST_CMAKEDIR}/$(dir)/\" ABSOLUTE)"

        : true ;
    }
}

rule generate-cmake-config- ( target : sources * : properties * )
{
    .info generate-cmake-config- $(target) ":" $(sources) ;

    local ps = [ property-set.create $(properties) ] ;

    print.output $(target) ;

    local version = [ $(ps).get <version> ] ;
    .info "  version=" $(version) ;

    local name = [ $(ps).get <name> ] ;
    .info "  name=" $(name) ;

    local library-type = [ $(ps).get <library-type> ] ;
    .info "  library-type=" $(library-type) ;

    local includedir = [ $(ps).get <boost-install.includedir> ] ;
    .info "  includedir=" $(includedir) ;

    local libdir = [ $(ps).get <boost-install.libdir> ] ;
    .info "  libdir=" $(libdir) ;

    local lname = [ MATCH boost_(.*) : $(name) ] ;
    .info "  lname=" $(lname) ;

    local ltarget = "Boost::$(lname)" ;
    .info "  ltarget=" $(ltarget) ;

    print.output $(target) ;

    print.text

        "# Generated by Boost $(version)"
        ""
        "if(TARGET $(ltarget))"
        "  return()"
        "endif()"
        ""
        "if(Boost_VERBOSE OR Boost_DEBUG)"
        "  message(STATUS \"Found $(name) ${$(name)_VERSION} at ${$(name)_DIR}\")"
        "endif()"
        ""
        "# Compute the include and library directories relative to this file."
        "get_filename_component(_BOOST_CMAKEDIR \"${CMAKE_CURRENT_LIST_DIR}/../\" ABSOLUTE)"
        : true ;

    get-dir "_BOOST_INCLUDEDIR" : $(includedir) ;
    get-dir "_BOOST_LIBDIR" : $(libdir) ;

    print.text

        ""
        "# Create imported target $(ltarget)"
        "add_library($(ltarget) $(library-type) IMPORTED)"
        ""
        "set_target_properties($(ltarget) PROPERTIES"
        "  INTERFACE_INCLUDE_DIRECTORIES \"\${_BOOST_INCLUDEDIR}\""
        "  INTERFACE_COMPILE_DEFINITIONS \"BOOST_ALL_NO_LIB\""
        ")"
        ""
        : true ;

    if $(library-type) != INTERFACE
    {
        print.text

            "include(${CMAKE_CURRENT_LIST_DIR}/../BoostDetectToolset-$(version).cmake)"
            ""
            "if(Boost_DEBUG)"
            "  message(STATUS \"Scanning ${CMAKE_CURRENT_LIST_DIR}/lib$(name)-variant*.cmake\")"
            "endif()"
            ""
            "file(GLOB __boost_variants \"${CMAKE_CURRENT_LIST_DIR}/lib$(name)-variant*.cmake\")"
            ""
            "macro(_BOOST_SKIPPED fname reason)"
            "  if(Boost_VERBOSE OR Boost_DEBUG)"
            "    message(STATUS \"  [ ] ${fname}\")"
            "  endif()"
            "  list(APPEND __boost_skipped \"${fname} (${reason})\")"
            "endmacro()"
            ""
            "foreach(f IN LISTS __boost_variants)"
            "  if(Boost_DEBUG)"
            "    message(STATUS \"  Including ${f}\")"
            "  endif()"
            "  include(${f})"
            "endforeach()"
            ""
            "unset(_BOOST_LIBDIR)"
            "unset(_BOOST_INCLUDEDIR)"
            "unset(_BOOST_CMAKEDIR)"
            ""
            "get_target_property(__boost_configs $(ltarget) IMPORTED_CONFIGURATIONS)"
            ""
            "if(__boost_variants AND NOT __boost_configs)"
            "  set(__boost_message \"No suitable build variant has been found.\")"
            "  if(__boost_skipped)"
            "    set(__boost_message \"${__boost_message}\\nThe following variants have been tried and rejected:\")"
            "    foreach(s IN LISTS __boost_skipped)"
            "      set(__boost_message \"${__boost_message}\\n* ${s}\")"
            "    endforeach()"
            "  endif()"
            "  set($(name)_FOUND 0)"
            "  set($(name)_NOT_FOUND_MESSAGE ${__boost_message})"
            "  unset(__boost_message)"
            "  unset(__boost_skipped)"
            "  unset(__boost_configs)"
            "  unset(__boost_variants)"
            "  unset(_BOOST_$(lname:U)_DEPS)"
            "  return()"
            "endif()"
            ""
            "unset(__boost_skipped)"
            "unset(__boost_configs)"
            "unset(__boost_variants)"
            ""
            "if(_BOOST_$(lname:U)_DEPS)"
            "  list(REMOVE_DUPLICATES _BOOST_$(lname:U)_DEPS)"
            "  if(Boost_VERBOSE OR Boost_DEBUG)"
            "    message(STATUS \"Adding $(name) dependencies: ${_BOOST_$(lname:U)_DEPS}\")"
            "  endif()"
            "endif()"
            ""
            "foreach(dep_$(name) IN LISTS _BOOST_$(lname:U)_DEPS")
            "  set(_BOOST_QUIET)"
            "  if($(name)_FIND_QUIETLY)"
            "    set(_BOOST_QUIET QUIET)"
            "  endif()"
            "  set(_BOOST_REQUIRED)"
            "  if($(name)_FIND_REQUIRED)"
            "    set(_BOOST_REQUIRED REQUIRED)"
            "  endif()"
            "  get_filename_component(_BOOST_CMAKEDIR \"${CMAKE_CURRENT_LIST_DIR}/../\" ABSOLUTE)"
            "  find_package(boost_${dep_$(name)} $(version) EXACT CONFIG ${_BOOST_REQUIRED} ${_BOOST_QUIET} HINTS ${_BOOST_CMAKEDIR})"
            "  set_property(TARGET $(ltarget) APPEND PROPERTY INTERFACE_LINK_LIBRARIES Boost::${dep_$(name)})"
            "  unset(_BOOST_QUIET)"
            "  unset(_BOOST_REQUIRED)"
            "  unset(_BOOST_CMAKEDIR)"
            "  if(NOT boost_${dep_$(name)}_FOUND)"
            "    set($(name)_FOUND 0)"
            "    set($(name)_NOT_FOUND_MESSAGE \"A required dependency, boost_${dep_$(name)}, has not been found.\")"
            "    unset(_BOOST_$(lname:U)_DEPS)"
            "    return()"
            "  endif()"
            "endforeach()"
            ""
            "unset(_BOOST_$(lname:U)_DEPS)"
            ""
            : true ;

        if $(name) = boost_thread
        {
            print.text

            "include(CMakeFindDependencyMacro)"
            "find_dependency(Threads)"
            "set_property(TARGET $(ltarget) APPEND PROPERTY INTERFACE_LINK_LIBRARIES Threads::Threads)"
            ""
            : true ;
        }
    }
    else
    {
        print.text

            "unset(_BOOST_LIBDIR)"
            "unset(_BOOST_INCLUDEDIR)"
            "unset(_BOOST_CMAKEDIR)"
            ""
            : true ;
    }

    print.text

        "mark_as_advanced($(name)_DIR)"
        ""
        : true ;
}

actions generate-cmake-config-
{
}

# generate-cmake-config

rule generate-cmake-config ( project name : property-set : sources * )
{
    .debug generate-cmake-config $(name) ;

    local pname = [ $(property-set).get <name> ] ;
    local version = [ $(property-set).get <version> ] ;
    local location = [ $(property-set).get <location> ] ;
    local library-type = [ $(property-set).get <library-type> ] ;
    local includedir = [ $(property-set).get <boost-install.includedir> ] ;
    local libdir = [ $(property-set).get <boost-install.libdir> ] ;

    local ps = [ property-set.create
        <name>$(pname) <version>$(version) <location>$(location)
        <library-type>$(library-type) <boost-install.includedir>$(includedir)
        <boost-install.libdir>$(libdir) ] ;

    local result ;

    local a = [ new non-scanning-action : boost-install.generate-cmake-config- : $(ps) ] ;

    result += [ new file-target $(name) : : $(project) : $(a) ] ;

    return $(result) ;
}

# generate-cmake-config-version-

rule generate-cmake-config-version- ( target : sources * : properties * )
{
    .info generate-cmake-config-version- $(target) ":" $(sources) ;

    local ps = [ property-set.create $(properties) ] ;

    print.output $(target) ;

    local version = [ $(ps).get <version> ] ;
    .info "  version=" $(version) ;

    print.output $(target) ;

    print.text

        "# Generated by Boost $(version)"
        ""
        "set(PACKAGE_VERSION $(version))"
        ""
        "if(PACKAGE_VERSION VERSION_LESS PACKAGE_FIND_VERSION)"
        "  set(PACKAGE_VERSION_COMPATIBLE FALSE)"
        "else()"
        "  set(PACKAGE_VERSION_COMPATIBLE TRUE)"
        "  if(PACKAGE_FIND_VERSION STREQUAL PACKAGE_VERSION)"
        "    set(PACKAGE_VERSION_EXACT TRUE)"
        "  endif()"
        "endif()"
        ""
        : true ;
}

actions generate-cmake-config-version-
{
}

# generate-cmake-config-version

rule generate-cmake-config-version ( project name : property-set : sources * )
{
    .debug generate-cmake-config-version $(name) ;

    local pname = [ $(property-set).get <name> ] ;
    local version = [ $(property-set).get <version> ] ;
    local location = [ $(property-set).get <location> ] ;

    local ps = [ property-set.create <name>$(pname) <version>$(version) <location>$(location) ] ;

    local result ;

    local a = [ new non-scanning-action : boost-install.generate-cmake-config-version- : $(ps) ] ;

    result += [ new file-target $(name) : : $(project) : $(a) ] ;

    return $(result) ;
}

# install-cmake-config-

local rule install-cmake-config- ( location : includedir : libdir : version : name )
{
    #.debug install-cmake-config- $(name) ;

    local loc = $(location)/$(name)-$(version) ;

    local library-type = UNKNOWN ;

    if $(name) = boost_headers || $(name) = boost_math || $(name) = boost_exception
    {
        library-type = INTERFACE ;
    }

    local reqs = <name>$(name) <version>$(version) <location>$(loc) <library-type>$(library-type) <boost-install.includedir>$(includedir) <boost-install.libdir>$(libdir) ;

    local r ;

    r += [ generate $(name)-config.cmake : $(name) : <generating-rule>@boost-install%generate-cmake-config $(reqs) ] ;
    r += [ generate $(name)-config-version.cmake : $(name) : <generating-rule>@boost-install%generate-cmake-config-version $(reqs) ] ;

    if $(library-type) != INTERFACE
    {
        r += [ generate $(name)-variant.cmake : $(name) : <generating-rule>@boost-install%generate-cmake-variant $(reqs) ] ;
    }

    return $(r) ;
}

# install-cmake-config

rule install-cmake-config ( name * )
{
    #.debug install-cmake-config $(name) ;

    if "--no-cmake-config" in [ modules.peek : ARGV ]
    {
        local p = [ project.current ] ;

        alias install-detect-toolset ;
        $(p).mark-target-as-explicit install-detect-toolset ;

        alias install-cmake-config ;
        $(p).mark-target-as-explicit install-cmake-config ;
    }
    else
    {
        local BOOST_VERSION = [ modules.peek boostcpp : BOOST_VERSION ] ;

        local includedir = [ boost-install-dirs.includedir ] ;
        local libdir = [ boost-install-dirs.libdir ] ;
        local cmakedir = [ boost-install-dirs.cmakedir ] ;
        local header-subdir = [ boost-install-dirs.header-subdir ] ;

        if $(header-subdir)
        {
            includedir = $(includedir)/$(header-subdir) ;
        }

        includedir = [ path.relative-to [ path.make $(cmakedir) ] [ path.make $(includedir) ] ] ;
        libdir = [ path.relative-to [ path.make $(cmakedir) ] [ path.make $(libdir) ] ] ;

        local configs ;

        for local nm in $(name)
        {
            configs += [ install-cmake-config- $(cmakedir) : $(includedir) : $(libdir) : $(BOOST_VERSION) : $(nm) ] ;
        }

        local p = [ project.current ] ;

        # Target install-detect-toolset

        local boost-install-dir = [ modules.binding $(__name__) ] ;
        boost-install-dir = $(boost-install-dir:D) ;

        install install-detect-toolset : $(boost-install-dir)/BoostDetectToolset.cmake : <location>$(cmakedir) <name>BoostDetectToolset-$(BOOST_VERSION).cmake ;
        $(p).mark-target-as-explicit install-detect-toolset ;

        # Target install-boost-config

        install install-boost-config : $(boost-install-dir)/BoostConfig.cmake : <location>$(cmakedir)/Boost-$(BOOST_VERSION) ;
        $(p).mark-target-as-explicit install-boost-config ;

        # Target install-boost-config-version

        generate BoostConfigVersion.cmake : : <generating-rule>@boost-install%generate-cmake-config-version <name>Boost <version>$(BOOST_VERSION) <location>$(cmakedir)/Boost-$(BOOST_VERSION) ;
        $(p).mark-target-as-explicit BoostConfigVersion.cmake ;

        alias install-boost-config-version : BoostConfigVersion.cmake ;
        $(p).mark-target-as-explicit install-boost-config-version ;

        # Target install-cmake-config

        alias install-cmake-config : $(configs) install-detect-toolset install-boost-config install-boost-config-version ;
        $(p).mark-target-as-explicit install-cmake-config ;
    }
}

# collect-targets: Returns the targets and all their dependencies.
# Copied from stage.jam
# TODO: Factor this out as a utility in virtal-target.jam

rule collect-targets ( targets * )
{
    # Find subvariants
    local s ;
    for local t in $(targets)
    {
        s += [ $(t).creating-subvariant ] ;
    }
    s = [ sequence.unique $(s) ] ;

    local result = [ new set ] ;
    $(result).add $(targets) ;

    for local i in $(s)
    {
        $(i).all-referenced-targets $(result) ;
    }
    local result2 ;
    for local r in [ $(result).list ]
    {
        if $(r:G) != <use>
        {
            result2 += $(r:G=) ;
        }
    }
    DELETE_MODULE $(result) ;
    return [ sequence.unique $(result2) ] ;
}

# get-dependency-projects: Returns all the projects of any dependency of the sources.

rule get-dependency-projects ( sources * )
{
    local result ;
    for local t in [ collect-targets $(sources) ]
    {
        result += [ $(t).project ] ;
    }
    return [ sequence.unique $(result) ] ;
}

# generate-dependencies: find and generate the stage and install targets
# corresponding to the source libraries.

rule generate-dependencies ( project name ? : property-set : sources * )
{
    local stage-targets ;
    local stage-or-install = [ $(property-set).get <name> ] ;
    local excluded-projects = $(project) [ $(project).find /boost ] ;
    for local p in [ get-dependency-projects $(sources) ] [ $(project).find /boost/headers ]
    {
        if ! ( $(p) in $(excluded-projects) )
        {
            stage-targets += [ $(p).find $(stage-or-install) : no-error ] ;
        }
    }
    local props = [ $(property-set).propagated ] ;
    local result ;
    local usage-requirements = [ property-set.empty ] ;
    for local t in $(stage-targets)
    {
        local g = [ $(t).generate $(props) ] ;
        usage-requirements = [ $(usage-requirements).add $(g[1]) ] ;
        result += $(g[2-]) ;
    }
    return $(usage-requirements) $(result) ;
}

# boost-install

rule boost-install ( libraries * )
{
    .debug boost-install $(libraries) ;

    # Target install

    local p = [ project.current ] ;

    package.install install-libraries Boost
        : # No requirements
        : # No binaries
        : $(libraries)
        : # No headers
    ;

    $(p).mark-target-as-explicit install-libraries ;

    install-cmake-config $(libraries) ;

    generate install-dependencies : $(libraries) : <generating-rule>@boost-install%generate-dependencies <name>install ;
    $(p).mark-target-as-explicit install-dependencies ;

    alias install : install-libraries install-cmake-config install-dependencies ;
    $(p).mark-target-as-explicit install ;

    # Target stage

    local stage-locate = [ modules.peek boostcpp : BOOST_STAGE_LOCATE ] ;

    install stage-libraries-static : $(libraries) : <location>$(stage-locate)/lib <install-dependencies>on <install-type>STATIC_LIB ;
    $(p).mark-target-as-explicit stage-libraries-static ;

    install stage-libraries-shared : $(libraries) : <location>$(stage-locate)/lib <install-dependencies>on <install-type>SHARED_LIB ;
    $(p).mark-target-as-explicit stage-libraries-shared ;

    generate stage-dependencies : $(libraries) : <generating-rule>@boost-install%generate-dependencies <name>stage ;
    $(p).mark-target-as-explicit stage-dependencies ;

    alias stage : stage-libraries-static stage-libraries-shared stage-dependencies ;
    $(p).mark-target-as-explicit stage ;
}
