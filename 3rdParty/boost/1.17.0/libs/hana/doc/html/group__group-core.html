<!--
Copyright Louis Dionne 2013-2017
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-->
<!-- boost-no-inspect -->
<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<title>Boost.Hana: Core</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
// Copyright Louis Dionne 2013-2017
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
MathJax.Hub.Config({
    "HTML-CSS": {
        linebreaks: {
            automatic: true,
            width: "75% container"
        }
    }
});
</script><script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Additional javascript for drawing charts. -->
<script type="text/javascript" src="highcharts.js"></script>
<script type="text/javascript" src="highcharts-data.js"></script>
<script type="text/javascript" src="highcharts-exporting.js"></script>
<script type="text/javascript" src="chart.js"></script>
<script type="text/javascript" src="hana.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Boost.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   &#160;<span id="projectnumber">1.6.0</span>
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__group-core.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Core</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>Core utilities of the library. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1common.html">boost::hana::common&lt; T, U, enabler &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction returning the common data type between two data types.  <a href="structboost_1_1hana_1_1common.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1has__common.html">boost::hana::has_common&lt; T, U, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction returning whether two data types share a common data type.  <a href="structboost_1_1hana_1_1has__common.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1default__.html">boost::hana::default_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a tag-dispatched method implementation as a default implementation.  <a href="structboost_1_1hana_1_1default__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1is__default.html">boost::hana::is_default&lt; Method, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a tag-dispatched method implementation is a default implementation.  <a href="structboost_1_1hana_1_1is__default.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1tag__of.html">boost::hana::tag_of&lt; T, enabler &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction returning the tag associated to <code>T</code>.  <a href="structboost_1_1hana_1_1tag__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1is__convertible.html">boost::hana::is_convertible&lt; From, To, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether there is a Hana-conversion from a data type to another.  <a href="structboost_1_1hana_1_1is__convertible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1embedding.html">boost::hana::embedding&lt; bool &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks a conversion between data types as being an embedding.  <a href="structboost_1_1hana_1_1embedding.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1is__embedded.html">boost::hana::is_embedded&lt; From, To, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a data type can be embedded into another data type.  <a href="structboost_1_1hana_1_1is__embedded.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1when.html">boost::hana::when&lt; condition &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable a partial specialization only if a boolean condition is true.  <a href="structboost_1_1hana_1_1when.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga4da46c97755c0f430b063711b66ca05b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga4da46c97755c0f430b063711b66ca05b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core.html#ga4da46c97755c0f430b063711b66ca05b">boost::hana::common_t</a> = typename <a class="el" href="structboost_1_1hana_1_1common.html">common</a>&lt; T, U &gt;::<a class="el" href="structboost_1_1hana_1_1type.html">type</a></td></tr>
<tr class="memdesc:ga4da46c97755c0f430b063711b66ca05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to <code>common&lt;T, U&gt;::type</code>, provided for convenience.  <a href="group__group-core.html#ga4da46c97755c0f430b063711b66ca05b">More...</a><br /></td></tr>
<tr class="separator:ga4da46c97755c0f430b063711b66ca05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga686d1236161b5690ab302500077988e1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga686d1236161b5690ab302500077988e1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core.html#ga686d1236161b5690ab302500077988e1">boost::hana::tag_of_t</a> = typename <a class="el" href="structboost_1_1hana_1_1tag__of.html">hana::tag_of</a>&lt; T &gt;::<a class="el" href="structboost_1_1hana_1_1type.html">type</a></td></tr>
<tr class="memdesc:ga686d1236161b5690ab302500077988e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to <code><a class="el" href="structboost_1_1hana_1_1tag__of.html" title="Metafunction returning the tag associated to T.">tag_of</a>&lt;T&gt;::type</code>, provided for convenience.  <a href="group__group-core.html#ga686d1236161b5690ab302500077988e1">More...</a><br /></td></tr>
<tr class="separator:ga686d1236161b5690ab302500077988e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f5d717bbf6646619bb6219b104384dc"><td class="memTemplParams" colspan="2">template&lt;typename ... &gt; </td></tr>
<tr class="memitem:ga0f5d717bbf6646619bb6219b104384dc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core.html#ga0f5d717bbf6646619bb6219b104384dc">boost::hana::when_valid</a> = <a class="el" href="structboost_1_1hana_1_1when.html">when</a>&lt; true &gt;</td></tr>
<tr class="memdesc:ga0f5d717bbf6646619bb6219b104384dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of <code>when</code> allowing specializations to be enabled only if an expression is well-formed.  <a href="group__group-core.html#ga0f5d717bbf6646619bb6219b104384dc">More...</a><br /></td></tr>
<tr class="separator:ga0f5d717bbf6646619bb6219b104384dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga38cf78e1e3e262f7f1c71ddd9ca70cd9"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename optional_T &gt; </td></tr>
<tr class="memitem:ga38cf78e1e3e262f7f1c71ddd9ca70cd9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core.html#ga38cf78e1e3e262f7f1c71ddd9ca70cd9">boost::hana::is_a</a> = see-documentation</td></tr>
<tr class="memdesc:ga38cf78e1e3e262f7f1c71ddd9ca70cd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the tag of an object matches a given tag.  <a href="group__group-core.html#ga38cf78e1e3e262f7f1c71ddd9ca70cd9">More...</a><br /></td></tr>
<tr class="separator:ga38cf78e1e3e262f7f1c71ddd9ca70cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fdbde52f5fe384a816c6f39ff272df9"><td class="memTemplParams" colspan="2"><a id="ga7fdbde52f5fe384a816c6f39ff272df9"></a>
template&lt;typename Tag , typename ... T&gt; </td></tr>
<tr class="memitem:ga7fdbde52f5fe384a816c6f39ff272df9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core.html#ga7fdbde52f5fe384a816c6f39ff272df9">boost::hana::is_an</a> = <a class="el" href="group__group-core.html#ga38cf78e1e3e262f7f1c71ddd9ca70cd9">is_a</a>&lt;Tag, T...&gt;</td></tr>
<tr class="memdesc:ga7fdbde52f5fe384a816c6f39ff272df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>is_a</code>; provided for consistency with the rules of the English language. <br /></td></tr>
<tr class="separator:ga7fdbde52f5fe384a816c6f39ff272df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d92480f0af1029878e773dafa3e2f60"><td class="memTemplParams" colspan="2">template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:ga1d92480f0af1029878e773dafa3e2f60"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core.html#ga1d92480f0af1029878e773dafa3e2f60">boost::hana::make</a></td></tr>
<tr class="memdesc:ga1d92480f0af1029878e773dafa3e2f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an object of the given tag with the given arguments.  <a href="group__group-core.html#ga1d92480f0af1029878e773dafa3e2f60">More...</a><br /></td></tr>
<tr class="separator:ga1d92480f0af1029878e773dafa3e2f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc70755c1d059139297814fb3bfeb91e"><td class="memTemplParams" colspan="2">template&lt;typename To &gt; </td></tr>
<tr class="memitem:gadc70755c1d059139297814fb3bfeb91e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">boost::hana::to</a></td></tr>
<tr class="memdesc:gadc70755c1d059139297814fb3bfeb91e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an object from one data type to another.  <a href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">More...</a><br /></td></tr>
<tr class="separator:gadc70755c1d059139297814fb3bfeb91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga4da46c97755c0f430b063711b66ca05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4da46c97755c0f430b063711b66ca05b">&#9670;&nbsp;</a></span>common_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__group-core.html#ga4da46c97755c0f430b063711b66ca05b">boost::hana::common_t</a> = typedef typename <a class="el" href="structboost_1_1hana_1_1common.html">common</a>&lt;T, U&gt;::<a class="el" href="structboost_1_1hana_1_1type.html">type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2core_2common_8hpp.html">boost/hana/fwd/core/common.hpp</a>&gt;</code></p>

<p>Alias to <code>common&lt;T, U&gt;::type</code>, provided for convenience. </p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="core_2common_8hpp.html">boost/hana/core/common.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;type_traits&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line">static_assert(std::is_same&lt;</div><div class="line">    hana::common_t&lt;int, float&gt;,</div><div class="line">    hana::common&lt;int, float&gt;::type</div><div class="line">&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
</div>
</div>
<a id="ga686d1236161b5690ab302500077988e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga686d1236161b5690ab302500077988e1">&#9670;&nbsp;</a></span>tag_of_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__group-core.html#ga686d1236161b5690ab302500077988e1">boost::hana::tag_of_t</a> = typedef typename <a class="el" href="structboost_1_1hana_1_1tag__of.html">hana::tag_of</a>&lt;T&gt;::<a class="el" href="structboost_1_1hana_1_1type.html">type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2core_2tag__of_8hpp.html">boost/hana/fwd/core/tag_of.hpp</a>&gt;</code></p>

<p>Alias to <code><a class="el" href="structboost_1_1hana_1_1tag__of.html" title="Metafunction returning the tag associated to T.">tag_of</a>&lt;T&gt;::type</code>, provided for convenience. </p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="core_2tag__of_8hpp.html">boost/hana/core/tag_of.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;type_traits&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">struct </span>PersonTag;</div><div class="line"><span class="keyword">struct </span>Person { <span class="keyword">using</span> hana_tag = PersonTag; };</div><div class="line">static_assert(std::is_same&lt;hana::tag_of_t&lt;Person&gt;, PersonTag&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
</div>
</div>
<a id="ga0f5d717bbf6646619bb6219b104384dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f5d717bbf6646619bb6219b104384dc">&#9670;&nbsp;</a></span>when_valid</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__group-core.html#ga0f5d717bbf6646619bb6219b104384dc">boost::hana::when_valid</a> = typedef <a class="el" href="structboost_1_1hana_1_1when.html">when</a>&lt;true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2core_2when_8hpp.html">boost/hana/fwd/core/when.hpp</a>&gt;</code></p>

<p>Variant of <code>when</code> allowing specializations to be enabled only if an expression is well-formed. </p>
<p><code>when_valid&lt;...&gt;</code> is always equivalent to <code>when&lt;true&gt;</code>. However, when used inside a partial specialization, SFINAE will cause the partial specialization to be ignored when the expression is ill-formed.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="core_2when_8hpp.html">boost/hana/core/when.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;type_traits&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = hana::when&lt;true&gt;&gt;</div><div class="line"><span class="keyword">struct </span>base_template;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct </span>base_template&lt;T, hana::<a class="code" href="group__group-core.html#ga0f5d717bbf6646619bb6219b104384dc">when_valid</a>&lt;typename T::value_type&gt;&gt; {</div><div class="line">    <span class="comment">// something useful...</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --><dl class="bug"><dt><b><a class="el" href="bug.html#_bug000001">Bug:</a></b></dt><dd>Using <code>when_valid</code> seems to trigger ambiguous partial specializations on GCC. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga38cf78e1e3e262f7f1c71ddd9ca70cd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38cf78e1e3e262f7f1c71ddd9ca70cd9">&#9670;&nbsp;</a></span>is_a</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag , typename optional_T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::is_a = see-documentation</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2core_2is__a_8hpp.html">boost/hana/fwd/core/is_a.hpp</a>&gt;</code></p>

<p>Returns whether the tag of an object matches a given tag. </p>
<p>Given a tag <code>Tag</code> and a C++ type <code>T</code>, <code>is_a&lt;Tag, T&gt;</code> is a compile-time Logical representing whether the tag of <code>T</code> is exactly <code>Tag</code>. In other words, it is equivalent to </p><div class="fragment"><div class="line">std::is_same&lt;Tag, tag_of&lt;T&gt;::type&gt;</div></div><!-- fragment --><p>For convenience, an alternate syntax is provided for using <code>is_a</code>. Specifically, <code>is_a&lt;Tag&gt;</code> is a function object returning whether the argument it is passed has the given tag. In other words, </p><div class="fragment"><div class="line">is_a&lt;Tag&gt;(x) == <a class="code" href="group__group-core.html#ga38cf78e1e3e262f7f1c71ddd9ca70cd9">is_a</a>&lt;Tag, decltype(x)&gt;</div></div><!-- fragment --><h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="core_2is__a_8hpp.html">boost/hana/core/is_a.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="not_8hpp.html">boost/hana/not.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line">static_assert(<a class="code" href="group__group-core.html#ga38cf78e1e3e262f7f1c71ddd9ca70cd9">hana::is_a</a>&lt;hana::tuple_tag, decltype(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3))&gt;, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(!hana::is_a&lt;hana::tuple_tag, void&gt;, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(<a class="code" href="group__group-core.html#ga7fdbde52f5fe384a816c6f39ff272df9">hana::is_an</a>&lt;hana::integral_constant_tag&lt;int&gt;&gt;(hana::int_c&lt;10&gt;), <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
</div>
</div>
<a id="ga1d92480f0af1029878e773dafa3e2f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d92480f0af1029878e773dafa3e2f60">&#9670;&nbsp;</a></span>make</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::make</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2core_2make_8hpp.html">boost/hana/fwd/core/make.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; ...x) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Create an object of the given tag with the given arguments. </p>
<p>This function serves the same purpose as constructors in usual C++. However, instead of creating an object of a specific C++ type, it creates an object of a specific tag, regardless of the C++ type of that object.</p>
<p>This function is actually a variable template, so <code>make&lt;T&gt;</code> can be passed around as a function object creating an object of tag <code>T</code>. Also, it uses tag-dispatching so this is how it should be customized for user-defined tags.</p>
<p>Finally, the default implementation of <code>make</code> is equivalent to calling the constructor of the given tag with the corresponding arguments. In other words, by default, </p><div class="fragment"><div class="line">make&lt;T&gt;(args...) == T(args...)</div></div><!-- fragment --><p>Note that the arguments are perfectly forwarded and the form of construction which is used is exactly as documented, i.e. <code>T(args...)</code>. However, if <code>T(args...)</code> is not a valid expression, a compilation error is triggered. This default behavior is useful because it makes foreign C++ types that have no notion of tag constructible with <code>make</code> out-of-the-box, since their tag is exactly themselves.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="core_2make_8hpp.html">boost/hana/core/make.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    hana::tuple&lt;int, char, double, std::string&gt; ts{1, <span class="charliteral">&#39;2&#39;</span>, 3.3, <span class="stringliteral">&quot;abcd&quot;</span>};</div><div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(ts == hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3, std::string{<span class="stringliteral">&quot;abcd&quot;</span>}));</div><div class="line"></div><div class="line">    <span class="comment">// std::string has no notion of tag, but it still works with make&lt;&gt;</span></div><div class="line">    std::string foo{<span class="stringliteral">&quot;foo&quot;</span>};</div><div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(hana::make&lt;std::string&gt;(<span class="stringliteral">&quot;foo&quot;</span>) == foo);</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="gadc70755c1d059139297814fb3bfeb91e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc70755c1d059139297814fb3bfeb91e">&#9670;&nbsp;</a></span>to</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::to</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2core_2to_8hpp.html">boost/hana/fwd/core/to.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; x) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Converts an object from one data type to another. </p>
<p><code>to</code> is a natural extension of the <code>static_cast</code> language construct to data types. Given a destination data type <code>To</code> and an object <code>x</code>, <code>to</code> creates a new object of data type <code>To</code> from <code>x</code>. Note, however, that <code>to</code> is not required to actually create a new object, and may return a reference to the original object (for example when trying to convert an object to its own data type).</p>
<p>As a natural extension to <code>static_cast</code>, <code>to</code> provides a default behavior. For the purpose of what follows, let <code>To</code> be the destination data type and <code>From</code> be the data type of <code>x</code>, i.e. the source data type. Then, <code>to</code> has the following default behavior:</p><ol type="1">
<li>If the <code>To</code> and <code>From</code> data types are the same, then the object is forwarded as-is.</li>
<li>Otherwise, if <code>From</code> is convertible to <code>To</code> using <code>static_cast</code>, <code>x</code> is converted to <code>From</code> using <code>static_cast</code>.</li>
<li>Otherwise, calling <code>to&lt;From&gt;(x)</code> triggers a static assertion.</li>
</ol>
<p>However, <code>to</code> is a tag-dispatched function, which means that <code>to_impl</code> may be specialized in the <code><a class="el" href="namespaceboost_1_1hana.html" title="Namespace containing everything in the library.">boost::hana</a></code> namespace to customize its behavior for arbitrary data types. Also note that <code>to</code> is tag-dispatched using both the <code>To</code> and the <code>From</code> data types, which means that <code>to_impl</code> is called as <code>to_impl&lt;To, From&gt;::apply(x)</code>. Also note that some concepts provide conversions to or from their models. For example, any <code>Foldable</code> may be converted into a <code>Sequence</code>. This is achieved by specializing <code>to_impl&lt;To, From&gt;</code> whenever <code>To</code> is a <code>Sequence</code> and <code>From</code> is a <code>Foldable</code>. When such conversions are provided, they are documented in the source concept, in this case <code>Foldable</code>.</p>
<h2>Hana-convertibility </h2>
<p>When an object <code>x</code> of data type <code>From</code> can be converted to a data type <code>To</code> using <code>to</code>, we say that <code>x</code> is Hana-convertible to the data type <code>To</code>. We also say that there is a Hana-conversion from <code>From</code> to <code>To</code>. This bit of terminology is useful to avoid mistaking the various kinds of conversions C++ offers.</p>
<h2>Embeddings </h2>
<p>As you might have seen by now, Hana uses algebraic and category- theoretical structures all around the place to help specify concepts in a rigorous way. These structures always have operations associated to them, which is why they are useful. The notion of embedding captures the idea of injecting a smaller structure into a larger one while preserving the operations of the structure. In other words, an embedding is an injective mapping that is also structure-preserving. Exactly what it means for a structure's operations to be preserved is left to explain by the documentation of each structure. For example, when we talk of a Monoid-embedding from a Monoid <code>A</code> to a Monoid <code>B</code>, we simply mean an injective transformation that preserves the identity and the associative operation, as documented in <code>Monoid</code>.</p>
<p>But what does this have to do with the <code>to</code> function? Quite simply, the <code>to</code> function is a mapping between two data types, which will sometimes be some kind of structure, and it is sometimes useful to know whether such a mapping is well-behaved, i.e. lossless and structure preserving. The criterion for this conversion to be well- behaved is exactly that of being an embedding. To specify that a conversion is an embedding, simply use the <code>embedding</code> type as a base class of the corresponding <code>to_impl</code> specialization. Obviously, you should make sure the conversion is really an embedding, unless you want to shoot yourself in the foot.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>The data type to which <code>x</code> should be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The object to convert to the given data type.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="core_2to_8hpp.html">boost/hana/core/to.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X, <span class="keyword">typename</span> Y, <span class="keyword">typename</span> Z&gt;</div><div class="line"><span class="keyword">struct </span>Triple {</div><div class="line">    X <a class="code" href="group__group-Product.html#ga34bbf4281de06dc3540441e8b2bd24f4">first</a>;</div><div class="line">    Y <a class="code" href="group__group-Product.html#ga7bb979d59ffc3ab862cb7d9dc7730077">second</a>;</div><div class="line">    Z third;</div><div class="line">};</div><div class="line"></div><div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> triple = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y, <span class="keyword">auto</span> z) {</div><div class="line">    <span class="keywordflow">return</span> Triple&lt;decltype(x), decltype(y), decltype(z)&gt;{x, y, z};</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>boost { <span class="keyword">namespace </span>hana {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X, <span class="keyword">typename</span> Y, <span class="keyword">typename</span> Z&gt;</div><div class="line">    <span class="keyword">struct </span>to_impl&lt;tuple_tag, Triple&lt;X, Y, Z&gt;&gt; {</div><div class="line">        <span class="keyword">static</span> constexpr <span class="keyword">auto</span> <a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">apply</a>(Triple&lt;X, Y, Z&gt; xs) {</div><div class="line">            <span class="keywordflow">return</span> make_tuple(xs.first, xs.second, xs.third);</div><div class="line">        }</div><div class="line">    };</div><div class="line">}}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div><div class="line">        hana::to&lt;hana::tuple_tag&gt;(triple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)</div><div class="line">    );</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!--
Copyright Louis Dionne 2013-2017
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-->
<!-- boost-no-inspect -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
  </ul>
</div>
</body>
</html>
