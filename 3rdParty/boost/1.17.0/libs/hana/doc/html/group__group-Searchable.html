<!--
Copyright Louis Dionne 2013-2017
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-->
<!-- boost-no-inspect -->
<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<title>Boost.Hana: Searchable</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
// Copyright Louis Dionne 2013-2017
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
MathJax.Hub.Config({
    "HTML-CSS": {
        linebreaks: {
            automatic: true,
            width: "75% container"
        }
    }
});
</script><script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Additional javascript for drawing charts. -->
<script type="text/javascript" src="highcharts.js"></script>
<script type="text/javascript" src="highcharts-data.js"></script>
<script type="text/javascript" src="highcharts-exporting.js"></script>
<script type="text/javascript" src="chart.js"></script>
<script type="text/javascript" src="hana.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Boost.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   &#160;<span id="projectnumber">1.6.0</span>
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__group-Searchable.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Searchable<div class="ingroups"><a class="el" href="group__group-concepts.html">Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>The <code>Searchable</code> concept represents structures that can be searched. </p>
<p>Intuitively, a <code>Searchable</code> is any structure, finite or infinite, containing elements that can be searched using a predicate. Sometimes, <code>Searchable</code>s will associate keys to values; one can search for a key with a predicate, and the value associated to it is returned. This gives rise to map-like data structures. Other times, the elements of the structure that are searched (i.e. those to which the predicate is applied) are the same that are returned, which gives rise to set-like data structures. In general, we will refer to the <em>keys</em> of a <code>Searchable</code> structure as those elements that are used for searching, and to the <em>values</em> of a <code>Searchable</code> as those elements that are returned when a search is successful. As was explained, there is no requirement that both notions differ, and it is often useful to have keys and values coincide (think about <code>std::set</code>).</p>
<p>Some methods like <code>any_of</code>, <code>all_of</code> and <code>none_of</code> allow simple queries to be performed on the keys of the structure, while other methods like <code>find</code> and <code>find_if</code> make it possible to find the value associated to a key. The most specific method should always be used if one cares about performance, because it is usually the case that heavy optimizations can be performed in more specific methods. For example, an associative data structure implemented as a hash table will be much faster to access using <code>find</code> than <code>find_if</code>, because in the second case it will have to do a linear search through all the entries. Similarly, using <code>contains</code> will likely be much faster than <code>any_of</code> with an equivalent predicate.</p>
<blockquote class="doxtable">
<p><b>Insight</b><br />
In a lazy evaluation context, any <code>Foldable</code> can also become a model of <code>Searchable</code> because we can search lazily through the structure with <code>fold_right</code>. However, in the context of C++, some <code>Searchable</code>s can not be folded; think for example of an infinite set. </p>
</blockquote>
<h2>Minimal complete definition </h2>
<p><code>find_if</code> and <code>any_of</code></p>
<p>When <code>find_if</code> and <code>any_of</code> are provided, the other functions are implemented according to the laws explained below.</p>
<dl class="section note"><dt>Note</dt><dd>We could implement <code>any_of(xs, pred)</code> by checking whether <code>find_if(xs, pred)</code> is an empty <code>optional</code> or not, and then reduce the minimal complete definition to <code>find_if</code>. However, this is not done because that implementation requires the predicate of <code>any_of</code> to return a compile-time <code>Logical</code>, which is more restrictive than what we have right now.</dd></dl>
<h2>Laws </h2>
<p>In order for the semantics of the methods to be consistent, some properties must be satisfied by any model of the <code>Searchable</code> concept. Rigorously, for any <code>Searchable</code>s <code>xs</code> and <code>ys</code> and any predicate <code>p</code>, the following laws should be satisfied: </p><div class="fragment"><div class="line"><a class="code" href="group__group-Searchable.html#ga5f7ff0125c448983e1b96c3ffb84f646">any_of</a>(xs, p) &lt;=&gt; !<a class="code" href="group__group-Searchable.html#ga3a168950082f38afd9edf256f336c8ba">all_of</a>(xs, negated p)</div><div class="line">              &lt;=&gt; !<a class="code" href="group__group-Searchable.html#ga43954c791b5b1351fb009e2a643d00f5">none_of</a>(xs, p)</div><div class="line"></div><div class="line"><a class="code" href="group__group-Searchable.html#ga38e7748956cbc9f3d9bb035ac8577906">contains</a>(xs, x) &lt;=&gt; <a class="code" href="group__group-Searchable.html#ga5f7ff0125c448983e1b96c3ffb84f646">any_of</a>(xs, <a class="code" href="group__group-Comparable.html#gacaf1ebea6b3ab96ac9dcb82f0e64e547">equal</a>.to(x))</div><div class="line"></div><div class="line"><a class="code" href="group__group-Searchable.html#ga6b6cdd69942b0fe3bf5254247f9c861e">find</a>(xs, x) == <a class="code" href="group__group-Searchable.html#ga7f99b80672aa80a7eb8b223955ce546f">find_if</a>(xs, <a class="code" href="group__group-Comparable.html#gacaf1ebea6b3ab96ac9dcb82f0e64e547">equal</a>.to(x))</div><div class="line"><a class="code" href="group__group-Searchable.html#ga7f99b80672aa80a7eb8b223955ce546f">find_if</a>(xs, <a class="code" href="group__group-functional.html#ga835970cb25a0c8dc200f1e5f8943538b">always</a>(false_)) == nothing</div><div class="line"></div><div class="line"><a class="code" href="group__group-Searchable.html#gadccfc79f1acdd8043d2baa16df16ec9f">is_subset</a>(xs, ys) &lt;=&gt; <a class="code" href="group__group-Searchable.html#ga3a168950082f38afd9edf256f336c8ba">all_of</a>(xs, [](<span class="keyword">auto</span> x) { <span class="keywordflow">return</span> <a class="code" href="group__group-Searchable.html#ga38e7748956cbc9f3d9bb035ac8577906">contains</a>(ys, x); })</div><div class="line"><a class="code" href="group__group-Searchable.html#ga3b8269d4f5cdd6dd549fae32280795a0">is_disjoint</a>(xs, ys) &lt;=&gt; <a class="code" href="group__group-Searchable.html#ga43954c791b5b1351fb009e2a643d00f5">none_of</a>(xs, [](<span class="keyword">auto</span> x) { <span class="keywordflow">return</span> <a class="code" href="group__group-Searchable.html#ga38e7748956cbc9f3d9bb035ac8577906">contains</a>(ys, x); })</div></div><!-- fragment --><p>Additionally, if all the keys of the <code>Searchable</code> are <code>Logical</code>s, the following laws should be satisfied: </p><div class="fragment"><div class="line"><a class="code" href="group__group-Searchable.html#gab7d632b9319b10b1eb7e98f9e1cf8a28">any</a>(xs)  &lt;=&gt; <a class="code" href="group__group-Searchable.html#ga5f7ff0125c448983e1b96c3ffb84f646">any_of</a>(xs, <span class="keywordtype">id</span>)</div><div class="line"><a class="code" href="group__group-Searchable.html#ga81ae9764dd7818ad36270c6419fb1082">all</a>(xs)  &lt;=&gt; <a class="code" href="group__group-Searchable.html#ga3a168950082f38afd9edf256f336c8ba">all_of</a>(xs, <span class="keywordtype">id</span>)</div><div class="line"><a class="code" href="group__group-Searchable.html#ga614ff1e575806f59246b17006e19d479">none</a>(xs) &lt;=&gt; <a class="code" href="group__group-Searchable.html#ga43954c791b5b1351fb009e2a643d00f5">none_of</a>(xs, <span class="keywordtype">id</span>)</div></div><!-- fragment --><h2>Concrete models </h2>
<p><code><a class="el" href="structboost_1_1hana_1_1map.html" title="Basic associative container requiring unique, Comparable and Hashable keys.">hana::map</a></code>, <code><a class="el" href="structboost_1_1hana_1_1optional.html" title="Optional value whose optional-ness is known at compile-time.">hana::optional</a></code>, <code><a class="el" href="structboost_1_1hana_1_1range.html" title="Compile-time half-open interval of hana::integral_constants.">hana::range</a></code>, <code><a class="el" href="structboost_1_1hana_1_1set.html" title="Basic unordered container requiring unique, Comparable and Hashable keys.">hana::set</a></code>, <code><a class="el" href="structboost_1_1hana_1_1string.html" title="Compile-time string.">hana::string</a></code>, <code><a class="el" href="structboost_1_1hana_1_1tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length.">hana::tuple</a></code></p>
<h2>Free model for builtin arrays </h2>
<p>Builtin arrays whose size is known can be searched as-if they were homogeneous tuples. However, since arrays can only hold objects of a single type and the predicate to <code>find_if</code> must return a compile-time <code>Logical</code>, the <code>find_if</code> method is fairly useless. For similar reasons, the <code>find</code> method is also fairly useless. This model is provided mainly because of the <code>any_of</code> method &amp; friends, which are both useful and compile-time efficient.</p>
<h2>Structure preserving functions </h2>
<p>Given two <code>Searchables</code> <code>S1</code> and <code>S2</code>, a function \( f : S_1(X) \to S_2(X) \) is said to preserve the <code>Searchable</code> structure if for all <code>xs</code> of data type <code>S1(X)</code> and predicates \( \mathtt{pred} : X \to Bool \) (for a <code>Logical</code> <code>Bool</code>), </p><div class="fragment"><div class="line"><a class="code" href="group__group-Searchable.html#ga5f7ff0125c448983e1b96c3ffb84f646">any_of</a>(xs, pred)  <span class="keywordflow">if</span> and only <span class="keywordflow">if</span>  <a class="code" href="group__group-Searchable.html#ga5f7ff0125c448983e1b96c3ffb84f646">any_of</a>(f(xs), pred)</div><div class="line"><a class="code" href="group__group-Searchable.html#ga7f99b80672aa80a7eb8b223955ce546f">find_if</a>(xs, pred) == <a class="code" href="group__group-Searchable.html#ga7f99b80672aa80a7eb8b223955ce546f">find_if</a>(f(xs), pred)</div></div><!-- fragment --><p>This is really just a generalization of the following, more intuitive requirements. For all <code>xs</code> of data type <code>S1(X)</code> and <code>x</code> of data type <code>X</code>, </p><div class="fragment"><div class="line">x ^<a class="code" href="group__group-Searchable.html#ga0d9456ceda38b6ca664998e79d7c45b7">in</a>^ xs  <span class="keywordflow">if</span> and only <span class="keywordflow">if</span>  x ^<a class="code" href="group__group-Searchable.html#ga0d9456ceda38b6ca664998e79d7c45b7">in</a>^ f(xs)</div><div class="line"><a class="code" href="group__group-Searchable.html#ga6b6cdd69942b0fe3bf5254247f9c861e">find</a>(xs, x) == <a class="code" href="group__group-Searchable.html#ga6b6cdd69942b0fe3bf5254247f9c861e">find</a>(f(xs), x)</div></div><!-- fragment --><p>These requirements can be understood as saying that <code>f</code> does not change the content of <code>xs</code>, although it may reorder elements. As usual, such a structure-preserving transformation is said to be an embedding if it is also injective, i.e. if it is a lossless transformation. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga81ae9764dd7818ad36270c6419fb1082"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Searchable.html#ga81ae9764dd7818ad36270c6419fb1082">boost::hana::all</a></td></tr>
<tr class="memdesc:ga81ae9764dd7818ad36270c6419fb1082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether all the keys of the structure are true-valued.The keys of the structure must be <code>Logical</code>s. If the structure is not finite, a false-valued key must appear at a finite "index" in order for this method to finish.  <a href="group__group-Searchable.html#ga81ae9764dd7818ad36270c6419fb1082">More...</a><br /></td></tr>
<tr class="separator:ga81ae9764dd7818ad36270c6419fb1082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a168950082f38afd9edf256f336c8ba"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Searchable.html#ga3a168950082f38afd9edf256f336c8ba">boost::hana::all_of</a></td></tr>
<tr class="memdesc:ga3a168950082f38afd9edf256f336c8ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether all the keys of the structure satisfy the <code>predicate</code>.If the structure is not finite, <code>predicate</code> has to return a false- valued <code>Logical</code> after looking at a finite number of keys for this method to finish.  <a href="group__group-Searchable.html#ga3a168950082f38afd9edf256f336c8ba">More...</a><br /></td></tr>
<tr class="separator:ga3a168950082f38afd9edf256f336c8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7d632b9319b10b1eb7e98f9e1cf8a28"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Searchable.html#gab7d632b9319b10b1eb7e98f9e1cf8a28">boost::hana::any</a></td></tr>
<tr class="memdesc:gab7d632b9319b10b1eb7e98f9e1cf8a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether any key of the structure is true-valued.The keys of the structure must be <code>Logical</code>s. If the structure is not finite, a true-valued key must appear at a finite "index" in order for this method to finish.  <a href="group__group-Searchable.html#gab7d632b9319b10b1eb7e98f9e1cf8a28">More...</a><br /></td></tr>
<tr class="separator:gab7d632b9319b10b1eb7e98f9e1cf8a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f7ff0125c448983e1b96c3ffb84f646"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Searchable.html#ga5f7ff0125c448983e1b96c3ffb84f646">boost::hana::any_of</a></td></tr>
<tr class="memdesc:ga5f7ff0125c448983e1b96c3ffb84f646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether any key of the structure satisfies the <code>predicate</code>.If the structure is not finite, <code>predicate</code> has to be satisfied after looking at a finite number of keys for this method to finish.  <a href="group__group-Searchable.html#ga5f7ff0125c448983e1b96c3ffb84f646">More...</a><br /></td></tr>
<tr class="separator:ga5f7ff0125c448983e1b96c3ffb84f646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c1826aee6c6eb577810bb99c5c3e53d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Searchable.html#ga3c1826aee6c6eb577810bb99c5c3e53d">boost::hana::at_key</a></td></tr>
<tr class="memdesc:ga3c1826aee6c6eb577810bb99c5c3e53d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value associated to the given key in a structure, or fail.Given a <code>key</code> and a <code>Searchable</code> structure, <code>at_key</code> returns the first value whose key is equal to the given <code>key</code>, and fails at compile-time if no such key exists. This requires the <code>key</code> to be compile-time <code>Comparable</code>, exactly like for <code>find</code>. <code>at_key</code> satisfies the following:  <a href="group__group-Searchable.html#ga3c1826aee6c6eb577810bb99c5c3e53d">More...</a><br /></td></tr>
<tr class="separator:ga3c1826aee6c6eb577810bb99c5c3e53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38e7748956cbc9f3d9bb035ac8577906"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Searchable.html#ga38e7748956cbc9f3d9bb035ac8577906">boost::hana::contains</a></td></tr>
<tr class="memdesc:ga38e7748956cbc9f3d9bb035ac8577906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the key occurs in the structure.Given a <code>Searchable</code> structure <code>xs</code> and a <code>key</code>, <code>contains</code> returns whether any of the keys of the structure is equal to the given <code>key</code>. If the structure is not finite, an equal key has to appear at a finite position in the structure for this method to finish. For convenience, <code>contains</code> can also be applied in infix notation.  <a href="group__group-Searchable.html#ga38e7748956cbc9f3d9bb035ac8577906">More...</a><br /></td></tr>
<tr class="separator:ga38e7748956cbc9f3d9bb035ac8577906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d9456ceda38b6ca664998e79d7c45b7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Searchable.html#ga0d9456ceda38b6ca664998e79d7c45b7">boost::hana::in</a> = <a class="el" href="group__group-functional.html#ga7bdafba6dc801f1d2d83731ad9714557">hana::infix</a>(<a class="el" href="group__group-functional.html#ga004f884cdbb85c2efe3383c1db450094">hana::flip</a>(<a class="el" href="group__group-Searchable.html#ga38e7748956cbc9f3d9bb035ac8577906">hana::contains</a>))</td></tr>
<tr class="memdesc:ga0d9456ceda38b6ca664998e79d7c45b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the key occurs in the structure.Specifically, this is equivalent to <code>contains</code>, except <code>in</code> takes its arguments in reverse order. Like <code>contains</code>, <code>in</code> can also be applied in infix notation for increased expressiveness. This function is not a method that can be overriden; it is just a convenience function provided with the concept.  <a href="group__group-Searchable.html#ga0d9456ceda38b6ca664998e79d7c45b7">More...</a><br /></td></tr>
<tr class="separator:ga0d9456ceda38b6ca664998e79d7c45b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b6cdd69942b0fe3bf5254247f9c861e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Searchable.html#ga6b6cdd69942b0fe3bf5254247f9c861e">boost::hana::find</a></td></tr>
<tr class="memdesc:ga6b6cdd69942b0fe3bf5254247f9c861e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the value associated to the given key in a structure.Given a <code>key</code> and a <code>Searchable</code> structure, <code>find</code> returns the <code>just</code> the first value whose key is equal to the given <code>key</code>, or <code>nothing</code> if there is no such key. Comparison is done with <code>equal</code>. <code>find</code> satisfies the following:  <a href="group__group-Searchable.html#ga6b6cdd69942b0fe3bf5254247f9c861e">More...</a><br /></td></tr>
<tr class="separator:ga6b6cdd69942b0fe3bf5254247f9c861e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f99b80672aa80a7eb8b223955ce546f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Searchable.html#ga7f99b80672aa80a7eb8b223955ce546f">boost::hana::find_if</a></td></tr>
<tr class="memdesc:ga7f99b80672aa80a7eb8b223955ce546f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the value associated to the first key satisfying a predicate.Given a <code>Searchable</code> structure <code>xs</code> and a predicate <code>pred</code>, <code>find_if(xs, pred)</code> returns <code>just</code> the first element whose key satisfies the predicate, or <code>nothing</code> if there is no such element.  <a href="group__group-Searchable.html#ga7f99b80672aa80a7eb8b223955ce546f">More...</a><br /></td></tr>
<tr class="separator:ga7f99b80672aa80a7eb8b223955ce546f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b8269d4f5cdd6dd549fae32280795a0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Searchable.html#ga3b8269d4f5cdd6dd549fae32280795a0">boost::hana::is_disjoint</a></td></tr>
<tr class="memdesc:ga3b8269d4f5cdd6dd549fae32280795a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether two <code>Searchable</code>s are disjoint.Given two <code>Searchable</code>s <code>xs</code> and <code>ys</code>, <code>is_disjoint</code> returns a <code>Logical</code> representing whether the keys in <code>xs</code> are disjoint from the keys in <code>ys</code>, i.e. whether both structures have no keys in common.  <a href="group__group-Searchable.html#ga3b8269d4f5cdd6dd549fae32280795a0">More...</a><br /></td></tr>
<tr class="separator:ga3b8269d4f5cdd6dd549fae32280795a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadccfc79f1acdd8043d2baa16df16ec9f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Searchable.html#gadccfc79f1acdd8043d2baa16df16ec9f">boost::hana::is_subset</a></td></tr>
<tr class="memdesc:gadccfc79f1acdd8043d2baa16df16ec9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a structure contains a subset of the keys of another structure.Given two <code>Searchable</code>s <code>xs</code> and <code>ys</code>, <code>is_subset</code> returns a <code>Logical</code> representing whether <code>xs</code> is a subset of <code>ys</code>. In other words, it returns whether all the keys of <code>xs</code> are also present in <code>ys</code>. This method does not return whether <code>xs</code> is a <em>strict</em> subset of <code>ys</code>; if <code>xs</code> and <code>ys</code> are equal, all the keys of <code>xs</code> are also present in <code>ys</code>, and <code>is_subset</code> returns true.  <a href="group__group-Searchable.html#gadccfc79f1acdd8043d2baa16df16ec9f">More...</a><br /></td></tr>
<tr class="separator:gadccfc79f1acdd8043d2baa16df16ec9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga614ff1e575806f59246b17006e19d479"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Searchable.html#ga614ff1e575806f59246b17006e19d479">boost::hana::none</a></td></tr>
<tr class="memdesc:ga614ff1e575806f59246b17006e19d479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether all of the keys of the structure are false-valued.The keys of the structure must be <code>Logical</code>s. If the structure is not finite, a true-valued key must appear at a finite "index" in order for this method to finish.  <a href="group__group-Searchable.html#ga614ff1e575806f59246b17006e19d479">More...</a><br /></td></tr>
<tr class="separator:ga614ff1e575806f59246b17006e19d479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43954c791b5b1351fb009e2a643d00f5"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Searchable.html#ga43954c791b5b1351fb009e2a643d00f5">boost::hana::none_of</a></td></tr>
<tr class="memdesc:ga43954c791b5b1351fb009e2a643d00f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether none of the keys of the structure satisfy the <code>predicate</code>.If the structure is not finite, <code>predicate</code> has to return a true- valued <code>Logical</code> after looking at a finite number of keys for this method to finish.  <a href="group__group-Searchable.html#ga43954c791b5b1351fb009e2a643d00f5">More...</a><br /></td></tr>
<tr class="separator:ga43954c791b5b1351fb009e2a643d00f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga81ae9764dd7818ad36270c6419fb1082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81ae9764dd7818ad36270c6419fb1082">&#9670;&nbsp;</a></span>all</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::all</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2all_8hpp.html">boost/hana/fwd/all.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Returns whether all the keys of the structure are true-valued.The keys of the structure must be <code>Logical</code>s. If the structure is not finite, a false-valued key must appear at a finite "index" in order for this method to finish. </p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="all_8hpp.html">boost/hana/all.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="bool_8hpp.html">boost/hana/bool.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="not_8hpp.html">boost/hana/not.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line">static_assert(<a class="code" href="group__group-Searchable.html#ga81ae9764dd7818ad36270c6419fb1082">hana::all</a>(hana::make_tuple(hana::true_c, <span class="keyword">true</span>, hana::true_c)), <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(!<a class="code" href="group__group-Searchable.html#ga81ae9764dd7818ad36270c6419fb1082">hana::all</a>(hana::make_tuple(<span class="keyword">true</span>, hana::false_c, hana::true_c)));</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
</div>
</div>
<a id="ga3a168950082f38afd9edf256f336c8ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a168950082f38afd9edf256f336c8ba">&#9670;&nbsp;</a></span>all_of</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::all_of</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2all__of_8hpp.html">boost/hana/fwd/all_of.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Returns whether all the keys of the structure satisfy the <code>predicate</code>.If the structure is not finite, <code>predicate</code> has to return a false- valued <code>Logical</code> after looking at a finite number of keys for this method to finish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to search.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(k)</code>, where <code>k</code> is a key of the structure, and returning a <code>Logical</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="all__of_8hpp.html">boost/hana/all_of.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ext_2std_2integral__constant_8hpp.html">boost/hana/ext/std/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mod_8hpp.html">boost/hana/mod.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="not_8hpp.html">boost/hana/not.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="not__equal_8hpp.html">boost/hana/not_equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="traits_8hpp.html">boost/hana/traits.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;type_traits&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"><span class="keyword">using namespace </span>hana::literals;</div><div class="line"></div><div class="line"></div><div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> is_odd = [](<span class="keyword">auto</span> x) {</div><div class="line">    <span class="keywordflow">return</span> x % 2_c != 0_c;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="group__group-Searchable.html#ga3a168950082f38afd9edf256f336c8ba">hana::all_of</a>(hana::make_tuple(1, 3), is_odd));</div><div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(!<a class="code" href="group__group-Searchable.html#ga3a168950082f38afd9edf256f336c8ba">hana::all_of</a>(hana::make_tuple(3_c, 4_c), is_odd));</div><div class="line"></div><div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div><div class="line">      !<a class="code" href="group__group-Searchable.html#ga3a168950082f38afd9edf256f336c8ba">hana::all_of</a>(hana::make_tuple(hana::type&lt;void&gt;{}, hana::type&lt;char&amp;&gt;{}),</div><div class="line">                    hana::traits::is_void)</div><div class="line">    );</div><div class="line"></div><div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div><div class="line">      <a class="code" href="group__group-Searchable.html#ga3a168950082f38afd9edf256f336c8ba">hana::all_of</a>(hana::make_tuple(hana::type_c&lt;int&gt;, hana::type_c&lt;char&gt;),</div><div class="line">                   hana::traits::is_integral)</div><div class="line">    );</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="gab7d632b9319b10b1eb7e98f9e1cf8a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7d632b9319b10b1eb7e98f9e1cf8a28">&#9670;&nbsp;</a></span>any</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::any</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2any_8hpp.html">boost/hana/fwd/any.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Returns whether any key of the structure is true-valued.The keys of the structure must be <code>Logical</code>s. If the structure is not finite, a true-valued key must appear at a finite "index" in order for this method to finish. </p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="any_8hpp.html">boost/hana/any.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="bool_8hpp.html">boost/hana/bool.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-Searchable.html#gab7d632b9319b10b1eb7e98f9e1cf8a28">hana::any</a>(hana::make_tuple(<span class="keyword">false</span>, hana::false_c, hana::true_c)));</div><div class="line">static_assert(<a class="code" href="group__group-Searchable.html#gab7d632b9319b10b1eb7e98f9e1cf8a28">hana::any</a>(hana::make_tuple(<span class="keyword">false</span>, hana::false_c, <span class="keyword">true</span>)), <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(!<a class="code" href="group__group-Searchable.html#gab7d632b9319b10b1eb7e98f9e1cf8a28">hana::any</a>(hana::make_tuple(<span class="keyword">false</span>, hana::false_c, hana::false_c)), <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
</div>
</div>
<a id="ga5f7ff0125c448983e1b96c3ffb84f646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f7ff0125c448983e1b96c3ffb84f646">&#9670;&nbsp;</a></span>any_of</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::any_of</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2any__of_8hpp.html">boost/hana/fwd/any_of.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Returns whether any key of the structure satisfies the <code>predicate</code>.If the structure is not finite, <code>predicate</code> has to be satisfied after looking at a finite number of keys for this method to finish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to search.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(k)</code>, where <code>k</code> is a key of the structure, and returning a <code>Logical</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="any__of_8hpp.html">boost/hana/any_of.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ext_2std_2integral__constant_8hpp.html">boost/hana/ext/std/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mod_8hpp.html">boost/hana/mod.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="not_8hpp.html">boost/hana/not.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="not__equal_8hpp.html">boost/hana/not_equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="traits_8hpp.html">boost/hana/traits.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;type_traits&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"><span class="keyword">using namespace </span>hana::literals;</div><div class="line"></div><div class="line"></div><div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> is_odd = [](<span class="keyword">auto</span> x) {</div><div class="line">    <span class="keywordflow">return</span> x % 2_c != 0_c;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="group__group-Searchable.html#ga5f7ff0125c448983e1b96c3ffb84f646">hana::any_of</a>(hana::make_tuple(1, 2), is_odd));</div><div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(!<a class="code" href="group__group-Searchable.html#ga5f7ff0125c448983e1b96c3ffb84f646">hana::any_of</a>(hana::make_tuple(2_c, 4_c), is_odd));</div><div class="line"></div><div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div><div class="line">      <a class="code" href="group__group-Searchable.html#ga5f7ff0125c448983e1b96c3ffb84f646">hana::any_of</a>(hana::make_tuple(hana::type&lt;void&gt;{}, hana::type&lt;char&amp;&gt;{}),</div><div class="line">                   hana::traits::is_void)</div><div class="line">    );</div><div class="line"></div><div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div><div class="line">      !<a class="code" href="group__group-Searchable.html#ga5f7ff0125c448983e1b96c3ffb84f646">hana::any_of</a>(hana::make_tuple(hana::type&lt;void&gt;{}, hana::type&lt;char&amp;&gt;{}),</div><div class="line">                    hana::traits::is_integral)</div><div class="line">    );</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="ga3c1826aee6c6eb577810bb99c5c3e53d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c1826aee6c6eb577810bb99c5c3e53d">&#9670;&nbsp;</a></span>at_key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::at_key</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2at__key_8hpp.html">boost/hana/fwd/at_key.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span> <span class="keyword">const</span>&amp; key) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Returns the value associated to the given key in a structure, or fail.Given a <code>key</code> and a <code>Searchable</code> structure, <code>at_key</code> returns the first value whose key is equal to the given <code>key</code>, and fails at compile-time if no such key exists. This requires the <code>key</code> to be compile-time <code>Comparable</code>, exactly like for <code>find</code>. <code>at_key</code> satisfies the following: </p>
<div class="fragment"><div class="line"><a class="code" href="group__group-Searchable.html#ga3c1826aee6c6eb577810bb99c5c3e53d">at_key</a>(xs, key) == <a class="code" href="group__group-Searchable.html#ga6b6cdd69942b0fe3bf5254247f9c861e">find</a>(xs, key).value()</div></div><!-- fragment --><p>If the <code>Searchable</code> actually stores the elements it contains, <code>at_key</code> is required to return a lvalue reference, a lvalue reference to const or a rvalue reference to the found value, where the type of reference must match that of the structure passed to <code>at_key</code>. If the <code>Searchable</code> does not store the elements it contains (i.e. it generates them on demand), this requirement is dropped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to be searched.</td></tr>
    <tr><td class="paramname">key</td><td>A key to be searched for in the structure. The key has to be <code>Comparable</code> with the other keys of the structure. In the current version of the library, the comparison of <code>key</code> with any other key of the structure must return a compile-time <code>Logical</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="at__key_8hpp.html">boost/hana/at_key.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="map_8hpp.html">boost/hana/map.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pair_8hpp.html">boost/hana/pair.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keyword">auto</span> m = hana::make_map(</div><div class="line">        hana::make_pair(hana::type&lt;int&gt;{}, std::string{<span class="stringliteral">&quot;int&quot;</span>}),</div><div class="line">        hana::make_pair(hana::int_&lt;3&gt;{}, std::string{<span class="stringliteral">&quot;3&quot;</span>})</div><div class="line">    );</div><div class="line"></div><div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(<a class="code" href="group__group-Searchable.html#ga3c1826aee6c6eb577810bb99c5c3e53d">hana::at_key</a>(m, hana::type&lt;int&gt;{}) == <span class="stringliteral">&quot;int&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// usage as operator[]</span></div><div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(m[hana::type&lt;int&gt;{}] == <span class="stringliteral">&quot;int&quot;</span>);</div><div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(m[hana::int_&lt;3&gt;{}] == <span class="stringliteral">&quot;3&quot;</span>);</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="ga38e7748956cbc9f3d9bb035ac8577906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38e7748956cbc9f3d9bb035ac8577906">&#9670;&nbsp;</a></span>contains</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::contains</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2contains_8hpp.html">boost/hana/fwd/contains.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; key) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Returns whether the key occurs in the structure.Given a <code>Searchable</code> structure <code>xs</code> and a <code>key</code>, <code>contains</code> returns whether any of the keys of the structure is equal to the given <code>key</code>. If the structure is not finite, an equal key has to appear at a finite position in the structure for this method to finish. For convenience, <code>contains</code> can also be applied in infix notation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to search.</td></tr>
    <tr><td class="paramname">key</td><td>A key to be searched for in the structure. The key has to be <code>Comparable</code> with the other keys of the structure.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="contains_8hpp.html">boost/hana/contains.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set_8hpp.html">boost/hana/set.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-Searchable.html#ga38e7748956cbc9f3d9bb035ac8577906">hana::contains</a>(hana::make_tuple(2, hana::int_c&lt;2&gt;, hana::int_c&lt;3&gt;, <span class="charliteral">&#39;x&#39;</span>), hana::int_c&lt;3&gt;));</div><div class="line"></div><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-Searchable.html#ga38e7748956cbc9f3d9bb035ac8577906">hana::contains</a>(hana::make_set(hana::int_c&lt;3&gt;, hana::type_c&lt;void&gt;), hana::type_c&lt;void&gt;));</div><div class="line"></div><div class="line"><span class="comment">// contains can be applied in infix notation</span></div><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div><div class="line">    hana::make_tuple(2, hana::int_c&lt;2&gt;, hana::int_c&lt;3&gt;, <span class="charliteral">&#39;x&#39;</span>) ^<a class="code" href="group__group-Searchable.html#ga38e7748956cbc9f3d9bb035ac8577906">hana::contains</a>^ hana::int_c&lt;2&gt;</div><div class="line">);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
</div>
</div>
<a id="ga0d9456ceda38b6ca664998e79d7c45b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d9456ceda38b6ca664998e79d7c45b7">&#9670;&nbsp;</a></span>in</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::in = <a class="el" href="group__group-functional.html#ga7bdafba6dc801f1d2d83731ad9714557">hana::infix</a>(<a class="el" href="group__group-functional.html#ga004f884cdbb85c2efe3383c1db450094">hana::flip</a>(<a class="el" href="group__group-Searchable.html#ga38e7748956cbc9f3d9bb035ac8577906">hana::contains</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2contains_8hpp.html">boost/hana/fwd/contains.hpp</a>&gt;</code></p>

<p>Return whether the key occurs in the structure.Specifically, this is equivalent to <code>contains</code>, except <code>in</code> takes its arguments in reverse order. Like <code>contains</code>, <code>in</code> can also be applied in infix notation for increased expressiveness. This function is not a method that can be overriden; it is just a convenience function provided with the concept. </p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="contains_8hpp.html">boost/hana/contains.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::int_c&lt;2&gt; ^<a class="code" href="group__group-Searchable.html#ga0d9456ceda38b6ca664998e79d7c45b7">hana::in</a>^ hana::make_tuple(2, hana::int_c&lt;2&gt;, hana::int_c&lt;3&gt;, <span class="charliteral">&#39;x&#39;</span>));</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
</div>
</div>
<a id="ga6b6cdd69942b0fe3bf5254247f9c861e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b6cdd69942b0fe3bf5254247f9c861e">&#9670;&nbsp;</a></span>find</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::find</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2find_8hpp.html">boost/hana/fwd/find.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span> <span class="keyword">const</span>&amp; key) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Finds the value associated to the given key in a structure.Given a <code>key</code> and a <code>Searchable</code> structure, <code>find</code> returns the <code>just</code> the first value whose key is equal to the given <code>key</code>, or <code>nothing</code> if there is no such key. Comparison is done with <code>equal</code>. <code>find</code> satisfies the following: </p>
<div class="fragment"><div class="line"><a class="code" href="group__group-Searchable.html#ga6b6cdd69942b0fe3bf5254247f9c861e">find</a>(xs, key) == <a class="code" href="group__group-Searchable.html#ga7f99b80672aa80a7eb8b223955ce546f">find_if</a>(xs, <a class="code" href="group__group-Comparable.html#gacaf1ebea6b3ab96ac9dcb82f0e64e547">equal</a>.to(key))</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to be searched.</td></tr>
    <tr><td class="paramname">key</td><td>A key to be searched for in the structure. The key has to be <code>Comparable</code> with the other keys of the structure. In the current version of the library, the comparison of <code>key</code> with any other key of the structure must return a compile-time <code>Logical</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="find_8hpp.html">boost/hana/find.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="map_8hpp.html">boost/hana/map.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pair_8hpp.html">boost/hana/pair.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div><div class="line">    <a class="code" href="group__group-Searchable.html#ga6b6cdd69942b0fe3bf5254247f9c861e">hana::find</a>(hana::make_tuple(hana::int_c&lt;1&gt;, hana::type_c&lt;int&gt;, <span class="charliteral">&#39;3&#39;</span>), hana::type_c&lt;int&gt;) == hana::just(hana::type_c&lt;int&gt;)</div><div class="line">);</div><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div><div class="line">    <a class="code" href="group__group-Searchable.html#ga6b6cdd69942b0fe3bf5254247f9c861e">hana::find</a>(hana::make_tuple(hana::int_c&lt;1&gt;, hana::type_c&lt;int&gt;, <span class="charliteral">&#39;3&#39;</span>), hana::type_c&lt;void&gt;) == hana::nothing</div><div class="line">);</div><div class="line"></div><div class="line">constexpr <span class="keyword">auto</span> m = hana::make_map(</div><div class="line">    hana::make_pair(hana::int_c&lt;2&gt;, 2),</div><div class="line">    hana::make_pair(hana::type_c&lt;float&gt;, 3.3),</div><div class="line">    hana::make_pair(hana::type_c&lt;char&gt;, hana::type_c&lt;int&gt;)</div><div class="line">);</div><div class="line">static_assert(<a class="code" href="group__group-Searchable.html#ga6b6cdd69942b0fe3bf5254247f9c861e">hana::find</a>(m, hana::type_c&lt;float&gt;) == hana::just(3.3), <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
</div>
</div>
<a id="ga7f99b80672aa80a7eb8b223955ce546f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f99b80672aa80a7eb8b223955ce546f">&#9670;&nbsp;</a></span>find_if</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::find_if</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2find__if_8hpp.html">boost/hana/fwd/find_if.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Finds the value associated to the first key satisfying a predicate.Given a <code>Searchable</code> structure <code>xs</code> and a predicate <code>pred</code>, <code>find_if(xs, pred)</code> returns <code>just</code> the first element whose key satisfies the predicate, or <code>nothing</code> if there is no such element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to be searched.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(k)</code>, where <code>k</code> is a key of the structure, and returning whether <code>k</code> is the key of the element being searched for. In the current version of the library, the predicate has to return an <code><a class="el" href="structboost_1_1hana_1_1IntegralConstant.html" title="The IntegralConstant concept represents compile-time integral values.">IntegralConstant</a></code> holding a value that can be converted to <code>bool</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ext_2std_2integral__constant_8hpp.html">boost/hana/ext/std/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="find__if_8hpp.html">boost/hana/find_if.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="compose_8hpp.html">boost/hana/functional/compose.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;type_traits&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// First get the type of the object, and then call the trait on it.</span></div><div class="line">constexpr <span class="keyword">auto</span> is_integral = <a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">hana::compose</a>(hana::trait&lt;std::is_integral&gt;, hana::typeid_);</div><div class="line">constexpr <span class="keyword">auto</span> is_class = <a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">hana::compose</a>(hana::trait&lt;std::is_class&gt;, hana::typeid_);</div><div class="line"></div><div class="line">static_assert(</div><div class="line">    <a class="code" href="group__group-Searchable.html#ga7f99b80672aa80a7eb8b223955ce546f">hana::find_if</a>(hana::make_tuple(1.0, 2, <span class="charliteral">&#39;3&#39;</span>), is_integral) == hana::just(2)</div><div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div><div class="line">    <a class="code" href="group__group-Searchable.html#ga7f99b80672aa80a7eb8b223955ce546f">hana::find_if</a>(hana::make_tuple(1.0, 2, <span class="charliteral">&#39;3&#39;</span>), is_class) == hana::nothing</div><div class="line">);</div><div class="line"></div><div class="line">constexpr <span class="keyword">auto</span> types = hana::tuple_t&lt;char, int, unsigned, long, unsigned long&gt;;</div><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div><div class="line">    <a class="code" href="group__group-Searchable.html#ga7f99b80672aa80a7eb8b223955ce546f">hana::find_if</a>(types, <a class="code" href="group__group-Comparable.html#gacaf1ebea6b3ab96ac9dcb82f0e64e547">hana::equal</a>.<a class="code" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">to</a>(hana::type_c&lt;unsigned&gt;)) == hana::just(hana::type_c&lt;unsigned&gt;)</div><div class="line">);</div><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div><div class="line">    <a class="code" href="group__group-Searchable.html#ga7f99b80672aa80a7eb8b223955ce546f">hana::find_if</a>(types, <a class="code" href="group__group-Comparable.html#gacaf1ebea6b3ab96ac9dcb82f0e64e547">hana::equal</a>.<a class="code" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">to</a>(hana::type_c&lt;void&gt;)) == hana::nothing</div><div class="line">);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
</div>
</div>
<a id="ga3b8269d4f5cdd6dd549fae32280795a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b8269d4f5cdd6dd549fae32280795a0">&#9670;&nbsp;</a></span>is_disjoint</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::is_disjoint</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2is__disjoint_8hpp.html">boost/hana/fwd/is_disjoint.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> <span class="keyword">const</span>&amp; xs, <span class="keyword">auto</span> <span class="keyword">const</span>&amp; ys) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Returns whether two <code>Searchable</code>s are disjoint.Given two <code>Searchable</code>s <code>xs</code> and <code>ys</code>, <code>is_disjoint</code> returns a <code>Logical</code> representing whether the keys in <code>xs</code> are disjoint from the keys in <code>ys</code>, i.e. whether both structures have no keys in common. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs,ys</td><td>Two <code>Searchable</code>s to test for disjointness.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="is__disjoint_8hpp.html">boost/hana/is_disjoint.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="map_8hpp.html">boost/hana/map.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="not_8hpp.html">boost/hana/not.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set_8hpp.html">boost/hana/set.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"><span class="keyword">using namespace </span>std::literals;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// Tuples</span></div><div class="line">    <span class="keyword">auto</span> xs = hana::make_tuple(hana::int_c&lt;1&gt;, <span class="stringliteral">&quot;alfa&quot;</span>s, hana::type_c&lt;int&gt;);</div><div class="line">    <span class="keyword">auto</span> ys = hana::make_tuple(hana::type_c&lt;void&gt;, hana::int_c&lt;3&gt;, <span class="stringliteral">&quot;bravo&quot;</span>s);</div><div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(<a class="code" href="group__group-Searchable.html#ga3b8269d4f5cdd6dd549fae32280795a0">hana::is_disjoint</a>(xs, ys));</div><div class="line"></div><div class="line">    <span class="comment">// Sets</span></div><div class="line">    <span class="keyword">auto</span> s1 = hana::make_set(hana::int_c&lt;1&gt;, hana::type_c&lt;void&gt;, hana::int_c&lt;2&gt;);</div><div class="line">    <span class="keyword">auto</span> s2 = hana::make_set(hana::type_c&lt;char&gt;, hana::type_c&lt;int&gt;, hana::int_c&lt;1&gt;);</div><div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(!<a class="code" href="group__group-Searchable.html#ga3b8269d4f5cdd6dd549fae32280795a0">hana::is_disjoint</a>(s1, s2));</div><div class="line"></div><div class="line">    <span class="comment">// Maps</span></div><div class="line">    <span class="keyword">auto</span> vowels = hana::make_map(</div><div class="line">        hana::make_pair(hana::char_c&lt;&#39;a&#39;&gt;, <span class="stringliteral">&quot;alfa&quot;</span>s),</div><div class="line">        hana::make_pair(hana::char_c&lt;&#39;e&#39;&gt;, <span class="stringliteral">&quot;echo&quot;</span>s),</div><div class="line">        hana::make_pair(hana::char_c&lt;&#39;i&#39;&gt;, <span class="stringliteral">&quot;india&quot;</span>s)</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> consonants = hana::make_map(</div><div class="line">        hana::make_pair(hana::char_c&lt;&#39;b&#39;&gt;, <span class="stringliteral">&quot;bravo&quot;</span>s),</div><div class="line">        hana::make_pair(hana::char_c&lt;&#39;c&#39;&gt;, <span class="stringliteral">&quot;charlie&quot;</span>s),</div><div class="line">        hana::make_pair(hana::char_c&lt;&#39;f&#39;&gt;, <span class="stringliteral">&quot;foxtrot&quot;</span>s)</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    );</div><div class="line"></div><div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-Searchable.html#ga3b8269d4f5cdd6dd549fae32280795a0">hana::is_disjoint</a>(vowels, consonants));</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="gadccfc79f1acdd8043d2baa16df16ec9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadccfc79f1acdd8043d2baa16df16ec9f">&#9670;&nbsp;</a></span>is_subset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::is_subset</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2is__subset_8hpp.html">boost/hana/fwd/is_subset.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; ys) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Returns whether a structure contains a subset of the keys of another structure.Given two <code>Searchable</code>s <code>xs</code> and <code>ys</code>, <code>is_subset</code> returns a <code>Logical</code> representing whether <code>xs</code> is a subset of <code>ys</code>. In other words, it returns whether all the keys of <code>xs</code> are also present in <code>ys</code>. This method does not return whether <code>xs</code> is a <em>strict</em> subset of <code>ys</code>; if <code>xs</code> and <code>ys</code> are equal, all the keys of <code>xs</code> are also present in <code>ys</code>, and <code>is_subset</code> returns true. </p>
<dl class="section note"><dt>Note</dt><dd>For convenience, <code>is_subset</code> can also be applied in infix notation.</dd></dl>
<h2>Cross-type version of the method </h2>
<p>This method is tag-dispatched using the tags of both arguments. It can be called with any two <code>Searchable</code>s sharing a common <code>Searchable</code> embedding, as defined in the main documentation of the <code>Searchable</code> concept. When <code>Searchable</code>s with two different tags but sharing a common embedding are sent to <code>is_subset</code>, they are first converted to this common <code>Searchable</code> and the <code>is_subset</code> method of the common embedding is then used. Of course, the method can be overriden for custom <code>Searchable</code>s for efficieny.</p>
<dl class="section note"><dt>Note</dt><dd>While cross-type dispatching for <code>is_subset</code> is supported, it is not currently used by the library because there are no models of <code>Searchable</code> with a common embedding.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to check whether it is a subset of <code>ys</code>.</td></tr>
    <tr><td class="paramname">ys</td><td>The structure to check whether it is a superset of <code>xs</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="is__subset_8hpp.html">boost/hana/is_subset.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line">static_assert(</div><div class="line">    <a class="code" href="group__group-Searchable.html#gadccfc79f1acdd8043d2baa16df16ec9f">hana::is_subset</a>(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), hana::make_tuple(3.3, 1, <span class="charliteral">&#39;2&#39;</span>, <span class="keyword">nullptr</span>))</div><div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// is_subset can be applied in infix notation</span></div><div class="line">static_assert(</div><div class="line">    hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3) ^<a class="code" href="group__group-Searchable.html#gadccfc79f1acdd8043d2baa16df16ec9f">hana::is_subset</a>^ hana::make_tuple(3.3, 1, <span class="charliteral">&#39;2&#39;</span>, <span class="keyword">nullptr</span>)</div><div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
</div>
</div>
<a id="ga614ff1e575806f59246b17006e19d479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga614ff1e575806f59246b17006e19d479">&#9670;&nbsp;</a></span>none</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::none</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2none_8hpp.html">boost/hana/fwd/none.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Returns whether all of the keys of the structure are false-valued.The keys of the structure must be <code>Logical</code>s. If the structure is not finite, a true-valued key must appear at a finite "index" in order for this method to finish. </p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="bool_8hpp.html">boost/hana/bool.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="none_8hpp.html">boost/hana/none.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="not_8hpp.html">boost/hana/not.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line">static_assert(<a class="code" href="group__group-Searchable.html#ga614ff1e575806f59246b17006e19d479">hana::none</a>(hana::make_tuple(<span class="keyword">false</span>, hana::false_c, hana::false_c)), <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(!<a class="code" href="group__group-Searchable.html#ga614ff1e575806f59246b17006e19d479">hana::none</a>(hana::make_tuple(<span class="keyword">false</span>, hana::false_c, <span class="keyword">true</span>)), <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(!<a class="code" href="group__group-Searchable.html#ga614ff1e575806f59246b17006e19d479">hana::none</a>(hana::make_tuple(<span class="keyword">false</span>, hana::false_c, hana::true_c)));</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
</div>
</div>
<a id="ga43954c791b5b1351fb009e2a643d00f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43954c791b5b1351fb009e2a643d00f5">&#9670;&nbsp;</a></span>none_of</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::none_of</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2none__of_8hpp.html">boost/hana/fwd/none_of.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Returns whether none of the keys of the structure satisfy the <code>predicate</code>.If the structure is not finite, <code>predicate</code> has to return a true- valued <code>Logical</code> after looking at a finite number of keys for this method to finish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to search.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(k)</code>, where <code>k</code> is a key of the structure, and returning a <code>Logical</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ext_2std_2integral__constant_8hpp.html">boost/hana/ext/std/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mod_8hpp.html">boost/hana/mod.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="none__of_8hpp.html">boost/hana/none_of.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="not_8hpp.html">boost/hana/not.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="not__equal_8hpp.html">boost/hana/not_equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;type_traits&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"><span class="keyword">using namespace </span>hana::literals;</div><div class="line"></div><div class="line"></div><div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> is_odd = [](<span class="keyword">auto</span> x) {</div><div class="line">    <span class="keywordflow">return</span> x % 2_c != 0_c;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-Searchable.html#ga43954c791b5b1351fb009e2a643d00f5">hana::none_of</a>(hana::make_tuple(2_c, 4_c), is_odd));</div><div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(!<a class="code" href="group__group-Searchable.html#ga43954c791b5b1351fb009e2a643d00f5">hana::none_of</a>(hana::make_tuple(1, 2), is_odd));</div><div class="line"></div><div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div><div class="line">        !<a class="code" href="group__group-Searchable.html#ga43954c791b5b1351fb009e2a643d00f5">hana::none_of</a>(hana::make_tuple(hana::type_c&lt;void&gt;, hana::type_c&lt;char&amp;&gt;), hana::trait&lt;std::is_void&gt;)</div><div class="line">    );</div><div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div><div class="line">        <a class="code" href="group__group-Searchable.html#ga43954c791b5b1351fb009e2a643d00f5">hana::none_of</a>(hana::make_tuple(hana::type_c&lt;void&gt;, hana::type_c&lt;char&amp;&gt;), hana::trait&lt;std::is_integral&gt;)</div><div class="line">    );</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!--
Copyright Louis Dionne 2013-2017
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-->
<!-- boost-no-inspect -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
  </ul>
</div>
</body>
</html>
