<!--
Copyright Louis Dionne 2013-2017
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-->
<!-- boost-no-inspect -->
<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<title>Boost.Hana: Logical</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
// Copyright Louis Dionne 2013-2017
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
MathJax.Hub.Config({
    "HTML-CSS": {
        linebreaks: {
            automatic: true,
            width: "75% container"
        }
    }
});
</script><script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Additional javascript for drawing charts. -->
<script type="text/javascript" src="highcharts.js"></script>
<script type="text/javascript" src="highcharts-data.js"></script>
<script type="text/javascript" src="highcharts-exporting.js"></script>
<script type="text/javascript" src="chart.js"></script>
<script type="text/javascript" src="hana.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Boost.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   &#160;<span id="projectnumber">1.6.0</span>
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__group-Logical.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Logical<div class="ingroups"><a class="el" href="group__group-concepts.html">Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>The <code>Logical</code> concept represents types with a truth value. </p>
<p>Intuitively, a <code>Logical</code> is just a <code>bool</code>, or something that can act like one. However, in the context of programming with heterogeneous objects, it becomes extremely important to distinguish between those objects whose truth value is known at compile-time, and those whose truth value is only known at runtime. The reason why this is so important is because it is possible to branch at compile-time on a condition whose truth value is known at compile-time, and hence the return type of the enclosing function can depend on that truth value. However, if the truth value is only known at runtime, then the compiler has to compile both branches (because any or both of them may end up being used), which creates the additional requirement that both branches must evaluate to the same type.</p>
<p>More specifically, <code>Logical</code> (almost) represents a <a href="http://en.wikipedia.org/wiki/Boolean_algebra_(structure)">boolean algebra</a>, which is a mathematical structure encoding the usual properties that allow us to reason with <code>bool</code>. The exact properties that must be satisfied by any model of <code>Logical</code> are rigorously stated in the laws below.</p>
<h2>Truth, falsity and logical equivalence </h2>
<p>A <code>Logical</code> <code>x</code> is said to be <em>true-valued</em>, or sometimes also just <em>true</em> as an abuse of notation, if </p><div class="fragment"><div class="line"><a class="code" href="group__group-Logical.html#gafd655d2222367131e7a63616e93dd080">if_</a>(x, <span class="keyword">true</span>, <span class="keyword">false</span>) == <span class="keyword">true</span></div></div><!-- fragment --><p>Similarly, <code>x</code> is <em>false-valued</em>, or sometimes just <em>false</em>, if </p><div class="fragment"><div class="line"><a class="code" href="group__group-Logical.html#gafd655d2222367131e7a63616e93dd080">if_</a>(x, <span class="keyword">true</span>, <span class="keyword">false</span>) == <span class="keyword">false</span></div></div><!-- fragment --><p>This provides a standard way of converting any <code>Logical</code> to a straight <code>bool</code>. The notion of truth value suggests another definition, which is that of logical equivalence. We will say that two <code>Logical</code>s <code>x</code> and <code>y</code> are <em>logically equivalent</em> if they have the same truth value. To denote that some expressions <code>p</code> and <code>q</code> of a Logical data type are logically equivalent, we will sometimes also write </p><div class="fragment"><div class="line">p   <span class="keywordflow">if</span> and only <span class="keywordflow">if</span>   q</div></div><!-- fragment --><p> which is very common in mathematics. The intuition behind this notation is that whenever <code>p</code> is true-valued, then <code>q</code> should be; but when <code>p</code> is false-valued, then <code>q</code> should be too. Hence, <code>p</code> should be true-valued when (and only when) <code>q</code> is true-valued.</p>
<h2>Minimal complete definition </h2>
<p><code>eval_if</code>, <code>not_</code> and <code>while_</code></p>
<p>All the other functions can be defined in those terms: </p><div class="fragment"><div class="line"><a class="code" href="group__group-Logical.html#gafd655d2222367131e7a63616e93dd080">if_</a>(cond, x, y) = <a class="code" href="group__group-Logical.html#gab64636f84de983575aac0208f5fa840c">eval_if</a>(cond, lazy(x), lazy(y))</div><div class="line"><a class="code" href="group__group-Logical.html#ga14066f5672867c123524e0e0978069eb">and_</a>(x, y) = <a class="code" href="group__group-Logical.html#gafd655d2222367131e7a63616e93dd080">if_</a>(x, y, x)</div><div class="line"><a class="code" href="group__group-Logical.html#ga68c00efbeb69339bfa157a78ebdd3f87">or_</a>(x, y) = <a class="code" href="group__group-Logical.html#gafd655d2222367131e7a63616e93dd080">if_</a>(x, x, y)</div><div class="line">etc...</div></div><!-- fragment --><h2>Laws </h2>
<p>As outlined above, the <code>Logical</code> concept almost represents a boolean algebra. The rationale for this laxity is to allow things like integers to act like <code>Logical</code>s, which is aligned with C++, even though they do not form a boolean algebra. Even though we depart from the usual axiomatization of boolean algebras, we have found through experience that the definition of a Logical given here is largely compatible with intuition.</p>
<p>The following laws must be satisfied for any data type <code>L</code> modeling the <code>Logical</code> concept. Let <code>a</code>, <code>b</code> and <code>c</code> be objects of a <code>Logical</code> data type, and let <code>t</code> and <code>f</code> be arbitrary <em>true-valued</em> and <em>false-valued</em> <code>Logical</code>s of that data type, respectively. Then, </p><div class="fragment"><div class="line"><span class="comment">// associativity</span></div><div class="line"><a class="code" href="group__group-Logical.html#ga68c00efbeb69339bfa157a78ebdd3f87">or_</a>(a, <a class="code" href="group__group-Logical.html#ga68c00efbeb69339bfa157a78ebdd3f87">or_</a>(b, c))   == <a class="code" href="group__group-Logical.html#ga68c00efbeb69339bfa157a78ebdd3f87">or_</a>(<a class="code" href="group__group-Logical.html#ga68c00efbeb69339bfa157a78ebdd3f87">or_</a>(a, b), c)</div><div class="line"><a class="code" href="group__group-Logical.html#ga14066f5672867c123524e0e0978069eb">and_</a>(a, <a class="code" href="group__group-Logical.html#ga14066f5672867c123524e0e0978069eb">and_</a>(b, c)) == <a class="code" href="group__group-Logical.html#ga14066f5672867c123524e0e0978069eb">and_</a>(<a class="code" href="group__group-Logical.html#ga14066f5672867c123524e0e0978069eb">and_</a>(a, b), c)</div><div class="line"></div><div class="line"><span class="comment">// equivalence through commutativity</span></div><div class="line"><a class="code" href="group__group-Logical.html#ga68c00efbeb69339bfa157a78ebdd3f87">or_</a>(a, b)   <span class="keywordflow">if</span> and only <span class="keywordflow">if</span>   <a class="code" href="group__group-Logical.html#ga68c00efbeb69339bfa157a78ebdd3f87">or_</a>(b, a)</div><div class="line"><a class="code" href="group__group-Logical.html#ga14066f5672867c123524e0e0978069eb">and_</a>(a, b)  <span class="keywordflow">if</span> and only <span class="keywordflow">if</span>   <a class="code" href="group__group-Logical.html#ga14066f5672867c123524e0e0978069eb">and_</a>(b, a)</div><div class="line"></div><div class="line"><span class="comment">// absorption</span></div><div class="line"><a class="code" href="group__group-Logical.html#ga68c00efbeb69339bfa157a78ebdd3f87">or_</a>(a, <a class="code" href="group__group-Logical.html#ga14066f5672867c123524e0e0978069eb">and_</a>(a, b)) == a</div><div class="line"><a class="code" href="group__group-Logical.html#ga14066f5672867c123524e0e0978069eb">and_</a>(a, <a class="code" href="group__group-Logical.html#ga68c00efbeb69339bfa157a78ebdd3f87">or_</a>(a, b)) == a</div><div class="line"></div><div class="line"><span class="comment">// left identity</span></div><div class="line"><a class="code" href="group__group-Logical.html#ga68c00efbeb69339bfa157a78ebdd3f87">or_</a>(a, f)  == a</div><div class="line"><a class="code" href="group__group-Logical.html#ga14066f5672867c123524e0e0978069eb">and_</a>(a, t) == a</div><div class="line"></div><div class="line"><span class="comment">// distributivity</span></div><div class="line"><a class="code" href="group__group-Logical.html#ga68c00efbeb69339bfa157a78ebdd3f87">or_</a>(a, <a class="code" href="group__group-Logical.html#ga14066f5672867c123524e0e0978069eb">and_</a>(b, c)) == <a class="code" href="group__group-Logical.html#ga14066f5672867c123524e0e0978069eb">and_</a>(<a class="code" href="group__group-Logical.html#ga68c00efbeb69339bfa157a78ebdd3f87">or_</a>(a, b), <a class="code" href="group__group-Logical.html#ga68c00efbeb69339bfa157a78ebdd3f87">or_</a>(a, c))</div><div class="line"><a class="code" href="group__group-Logical.html#ga14066f5672867c123524e0e0978069eb">and_</a>(a, <a class="code" href="group__group-Logical.html#ga68c00efbeb69339bfa157a78ebdd3f87">or_</a>(b, c)) == <a class="code" href="group__group-Logical.html#ga68c00efbeb69339bfa157a78ebdd3f87">or_</a>(<a class="code" href="group__group-Logical.html#ga14066f5672867c123524e0e0978069eb">and_</a>(a, b), <a class="code" href="group__group-Logical.html#ga14066f5672867c123524e0e0978069eb">and_</a>(a, c))</div><div class="line"></div><div class="line"><span class="comment">// complements</span></div><div class="line"><a class="code" href="group__group-Logical.html#ga68c00efbeb69339bfa157a78ebdd3f87">or_</a>(a, <a class="code" href="group__group-Logical.html#ga4a7c9d7037601d5e553fd20777958980">not_</a>(a))  is <span class="keyword">true</span>-valued</div><div class="line"><a class="code" href="group__group-Logical.html#ga14066f5672867c123524e0e0978069eb">and_</a>(a, <a class="code" href="group__group-Logical.html#ga4a7c9d7037601d5e553fd20777958980">not_</a>(a)) is <span class="keyword">false</span>-valued</div></div><!-- fragment --><blockquote class="doxtable">
<h4>Why is the above not a boolean algebra?</h4>
<p>If you look closely, you will find that we depart from the usual boolean algebras because:</p><ol type="1">
<li>we do not require the elements representing truth and falsity to be unique</li>
<li>we do not enforce commutativity of the <code>and_</code> and <code>or_</code> operations</li>
<li>because we do not enforce commutativity, the identity laws become left-identity laws </li>
</ol>
</blockquote>
<h2>Concrete models </h2>
<p><code><a class="el" href="structboost_1_1hana_1_1integral__constant.html" title="Compile-time value of an integral type.">hana::integral_constant</a></code></p>
<h2>Free model for arithmetic data types </h2>
<p>A data type <code>T</code> is arithmetic if <code>std::is_arithmetic&lt;T&gt;::value</code> is true. For an arithmetic data type <code>T</code>, a model of <code>Logical</code> is provided automatically by using the result of the builtin implicit conversion to <code>bool</code> as a truth value. Specifically, the minimal complete definition for those data types is </p><div class="fragment"><div class="line"><a class="code" href="group__group-Logical.html#gab64636f84de983575aac0208f5fa840c">eval_if</a>(cond, <a class="code" href="group__group-Monad.html#gaaddd3789de43cf989babb10cdc0b447a">then</a>, else_) = cond ? <a class="code" href="group__group-Monad.html#gaaddd3789de43cf989babb10cdc0b447a">then</a>(<span class="keywordtype">id</span>) : else(<a class="code" href="group__group-functional.html#gaef38cf34324c8edbd3597ae71811d00d">id</a>)</div><div class="line"><a class="code" href="group__group-Logical.html#ga4a7c9d7037601d5e553fd20777958980">not_</a>(cond) = static_cast&lt;T&gt;(cond ? false : true)</div><div class="line"><a class="code" href="group__group-Logical.html#ga08a767b86c330cac67daa891406d2730">while_</a>(pred, state, f) = equivalent <a class="code" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">to</a> a normal while loop</div></div><!-- fragment --><blockquote class="doxtable">
<h4>Rationale for not providing a model for all contextually convertible to bool data types</h4>
<p>The <code>not_</code> method can not be implemented in a meaningful way for all of those types. For example, one can not cast a pointer type <code>T*</code> to bool and then back again to <code>T*</code> in a meaningful way. With an arithmetic type <code>T</code>, however, it is possible to cast from <code>T</code> to bool and then to <code>T</code> again; the result will be <code>0</code> or <code>1</code> depending on the truth value. If you want to use a pointer type or something similar in a conditional, it is suggested to explicitly convert it to bool by using <code>to&lt;bool&gt;</code>. </p>
</blockquote>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga14066f5672867c123524e0e0978069eb"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Logical.html#ga14066f5672867c123524e0e0978069eb">boost::hana::and_</a></td></tr>
<tr class="memdesc:ga14066f5672867c123524e0e0978069eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether all the arguments are true-valued.<code>and_</code> can be called with one argument or more. When called with two arguments, <code>and_</code> uses tag-dispatching to find the right implementation. Otherwise,.  <a href="group__group-Logical.html#ga14066f5672867c123524e0e0978069eb">More...</a><br /></td></tr>
<tr class="separator:ga14066f5672867c123524e0e0978069eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab64636f84de983575aac0208f5fa840c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Logical.html#gab64636f84de983575aac0208f5fa840c">boost::hana::eval_if</a></td></tr>
<tr class="memdesc:gab64636f84de983575aac0208f5fa840c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally execute one of two branches based on a condition.Given a condition and two branches in the form of lambdas or <code><a class="el" href="structboost_1_1hana_1_1lazy.html" title="hana::lazy implements superficial laziness via a monadic interface.">hana::lazy</a></code>s, <code>eval_if</code> will evaluate the branch selected by the condition with <code>eval</code> and return the result. The exact requirements for what the branches may be are the same requirements as those for the <code>eval</code> function.  <a href="group__group-Logical.html#gab64636f84de983575aac0208f5fa840c">More...</a><br /></td></tr>
<tr class="separator:gab64636f84de983575aac0208f5fa840c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd655d2222367131e7a63616e93dd080"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Logical.html#gafd655d2222367131e7a63616e93dd080">boost::hana::if_</a></td></tr>
<tr class="memdesc:gafd655d2222367131e7a63616e93dd080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally return one of two values based on a condition.Specifically, <code>then</code> is returned iff <code>cond</code> is true-valued, and <code>else_</code> is returned otherwise. Note that some <code>Logical</code> models may allow <code>then</code> and <code>else_</code> to have different types, while others may require both values to have the same type.  <a href="group__group-Logical.html#gafd655d2222367131e7a63616e93dd080">More...</a><br /></td></tr>
<tr class="separator:gafd655d2222367131e7a63616e93dd080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a7c9d7037601d5e553fd20777958980"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Logical.html#ga4a7c9d7037601d5e553fd20777958980">boost::hana::not_</a></td></tr>
<tr class="memdesc:ga4a7c9d7037601d5e553fd20777958980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates a <code>Logical</code>.This method returns a <code>Logical</code> with the same tag, but whose truth-value is negated. Specifically, <code>not_(x)</code> returns a false-valued <code>Logical</code> if <code>x</code> is a true-valued <code>Logical</code>, and a true-valued one otherwise.  <a href="group__group-Logical.html#ga4a7c9d7037601d5e553fd20777958980">More...</a><br /></td></tr>
<tr class="separator:ga4a7c9d7037601d5e553fd20777958980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68c00efbeb69339bfa157a78ebdd3f87"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Logical.html#ga68c00efbeb69339bfa157a78ebdd3f87">boost::hana::or_</a></td></tr>
<tr class="memdesc:ga68c00efbeb69339bfa157a78ebdd3f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether any of the arguments is true-valued.<code>or_</code> can be called with one argument or more. When called with two arguments, <code>or_</code> uses tag-dispatching to find the right implementation. Otherwise,.  <a href="group__group-Logical.html#ga68c00efbeb69339bfa157a78ebdd3f87">More...</a><br /></td></tr>
<tr class="separator:ga68c00efbeb69339bfa157a78ebdd3f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08a767b86c330cac67daa891406d2730"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Logical.html#ga08a767b86c330cac67daa891406d2730">boost::hana::while_</a></td></tr>
<tr class="memdesc:ga08a767b86c330cac67daa891406d2730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function to an initial state while some predicate is satisfied.This method is a natural extension of the <code>while</code> language construct to manipulate a state whose type may change from one iteration to another. However, note that having a state whose type changes from one iteration to the other is only possible as long as the predicate returns a <code>Logical</code> whose truth value is known at compile-time.  <a href="group__group-Logical.html#ga08a767b86c330cac67daa891406d2730">More...</a><br /></td></tr>
<tr class="separator:ga08a767b86c330cac67daa891406d2730"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga14066f5672867c123524e0e0978069eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14066f5672867c123524e0e0978069eb">&#9670;&nbsp;</a></span>and_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::and_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2and_8hpp.html">boost/hana/fwd/and.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; x, <span class="keyword">auto</span>&amp;&amp; ...y) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Return whether all the arguments are true-valued.<code>and_</code> can be called with one argument or more. When called with two arguments, <code>and_</code> uses tag-dispatching to find the right implementation. Otherwise,. </p>
<div class="fragment"><div class="line"><a class="code" href="group__group-Logical.html#ga14066f5672867c123524e0e0978069eb">and_</a>(x) == x</div><div class="line"><a class="code" href="group__group-Logical.html#ga14066f5672867c123524e0e0978069eb">and_</a>(x, y, ...z) == <a class="code" href="group__group-Logical.html#ga14066f5672867c123524e0e0978069eb">and_</a>(<a class="code" href="group__group-Logical.html#ga14066f5672867c123524e0e0978069eb">and_</a>(x, y), z...)</div></div><!-- fragment --><h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="and_8hpp.html">boost/hana/and.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="bool_8hpp.html">boost/hana/bool.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-Logical.html#ga14066f5672867c123524e0e0978069eb">hana::and_</a>(hana::true_c, hana::true_c, hana::true_c, hana::true_c));</div><div class="line">static_assert(!<a class="code" href="group__group-Logical.html#ga14066f5672867c123524e0e0978069eb">hana::and_</a>(hana::true_c, <span class="keyword">false</span>, hana::true_c, hana::true_c), <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
</div>
</div>
<a id="gab64636f84de983575aac0208f5fa840c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab64636f84de983575aac0208f5fa840c">&#9670;&nbsp;</a></span>eval_if</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::eval_if</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2eval__if_8hpp.html">boost/hana/fwd/eval_if.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; cond, <span class="keyword">auto</span>&amp;&amp; <a class="code" href="group__group-Monad.html#gaaddd3789de43cf989babb10cdc0b447a">then</a>, <span class="keyword">auto</span>&amp;&amp; else_) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div><div class="ttc" id="group__group-Monad_html_gaaddd3789de43cf989babb10cdc0b447a"><div class="ttname"><a href="group__group-Monad.html#gaaddd3789de43cf989babb10cdc0b447a">boost::hana::then</a></div><div class="ttdeci">constexpr auto then</div><div class="ttdoc">Sequentially compose two monadic actions, discarding any value produced by the first but not its effe...</div><div class="ttdef"><b>Definition:</b> then.hpp:36</div></div>
</div><!-- fragment -->
<p>Conditionally execute one of two branches based on a condition.Given a condition and two branches in the form of lambdas or <code><a class="el" href="structboost_1_1hana_1_1lazy.html" title="hana::lazy implements superficial laziness via a monadic interface.">hana::lazy</a></code>s, <code>eval_if</code> will evaluate the branch selected by the condition with <code>eval</code> and return the result. The exact requirements for what the branches may be are the same requirements as those for the <code>eval</code> function. </p>
<h2>Deferring compile-time evaluation inside <code>eval_if</code> </h2>
<p>By passing a unary callable to <code>eval_if</code>, it is possible to defer the compile-time evaluation of selected expressions inside the lambda. This is useful when instantiating a branch would trigger a compile-time error; we only want the branch to be instantiated when that branch is selected. Here's how it can be achieved.</p>
<p>For simplicity, we'll use a unary lambda as our unary callable. Our lambda must accept a parameter (usually called <code>_</code>), which can be used to defer the compile-time evaluation of expressions as required. For example, </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> N&gt;</div><div class="line"><span class="keyword">auto</span> fact(N n) {</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__group-Logical.html#gab64636f84de983575aac0208f5fa840c">hana::eval_if</a>(n == hana::int_c&lt;0&gt;,</div><div class="line">        [] { <span class="keywordflow">return</span> hana::int_c&lt;1&gt;; },</div><div class="line">        [=](<span class="keyword">auto</span> <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a>) { <span class="keywordflow">return</span> n * fact(<a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a>(n) - hana::int_c&lt;1&gt;); }</div><div class="line">    );</div><div class="line">}</div></div><!-- fragment --><p>What happens here is that <code>eval_if</code> will call <code>eval</code> on the selected branch. In turn, <code>eval</code> will call the selected branch either with nothing &ndash; for the <em>then</em> branch &ndash; or with <code><a class="el" href="group__group-functional.html#gaef38cf34324c8edbd3597ae71811d00d" title="The identity function â€“ returns its argument unchanged.">hana::id</a></code> &ndash; for the <em>else</em> branch. Hence, <code>_(x)</code> is always the same as <code>x</code>, but the compiler can't tell until the lambda has been called! Hence, the compiler has to wait before it instantiates the body of the lambda and no infinite recursion happens. However, this trick to delay the instantiation of the lambda's body can only be used when the condition is known at compile-time, because otherwise both branches have to be instantiated inside the <code>eval_if</code> anyway.</p>
<p>There are several caveats to note with this approach to lazy branching. First, because we're using lambdas, it means that the function's result can't be used in a constant expression. This is a limitation of the current language.</p>
<p>The second caveat is that compilers currently have several bugs regarding deeply nested lambdas with captures. So you always risk crashing the compiler, but this is a question of time before it is not a problem anymore.</p>
<p>Finally, it means that conditionals can't be written directly inside unevaluated contexts. The reason is that a lambda can't appear in an unevaluated context, for example in <code>decltype</code>. One way to workaround this is to completely lift your type computations into variable templates instead. For example, instead of writing </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct </span>pointerize : decltype(</div><div class="line">    hana::eval_if(hana::traits::is_pointer(hana::type_c&lt;T&gt;),</div><div class="line">        [] { return hana::type_c&lt;T&gt;; },</div><div class="line">        [](auto _) { return _(hana::traits::add_pointer)(hana::type_c&lt;T&gt;); }</div><div class="line">    ))</div><div class="line">{ };</div></div><!-- fragment --><p>you could instead write</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">auto</span> pointerize_impl(T t) {</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__group-Logical.html#gab64636f84de983575aac0208f5fa840c">hana::eval_if</a>(hana::traits::is_pointer(t),</div><div class="line">        [] { <span class="keywordflow">return</span> hana::type_c&lt;T&gt;; },</div><div class="line">        [](<span class="keyword">auto</span> <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a>) { <span class="keywordflow">return</span> <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a>(hana::traits::add_pointer)(hana::type_c&lt;T&gt;); }</div><div class="line">    );</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">using</span> pointerize = decltype(pointerize_impl(hana::type_c&lt;T&gt;));</div></div><!-- fragment --><blockquote class="doxtable">
<p><b>Note</b>: This example would actually be implemented more easily with partial specializations, but my bag of good examples is empty at the time of writing this. </p>
</blockquote>
<p>Now, this hoop-jumping only has to be done in one place, because you should use normal function notation everywhere else in your metaprogram to perform type computations. So the syntactic cost is amortized over the whole program.</p>
<p>Another way to work around this limitation of the language would be to use <code><a class="el" href="structboost_1_1hana_1_1lazy.html" title="hana::lazy implements superficial laziness via a monadic interface.">hana::lazy</a></code> for the branches. However, this is only suitable when the branches are not too complicated. With <code><a class="el" href="structboost_1_1hana_1_1lazy.html" title="hana::lazy implements superficial laziness via a monadic interface.">hana::lazy</a></code>, you could write the previous example as </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct </span>pointerize : decltype(</div><div class="line">    hana::eval_if(hana::traits::is_pointer(hana::type_c&lt;T&gt;),</div><div class="line">        hana::make_lazy(hana::type_c&lt;T&gt;),</div><div class="line">        hana::make_lazy(hana::traits::add_pointer)(hana::type_c&lt;T&gt;)</div><div class="line">    ))</div><div class="line">{ };</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>The condition determining which of the two branches is selected.</td></tr>
    <tr><td class="paramname">then</td><td>An expression called as <code>eval(then)</code> if <code>cond</code> is true-valued.</td></tr>
    <tr><td class="paramname">else_</td><td>A function called as <code>eval(else_)</code> if <code>cond</code> is false-valued.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="eval__if_8hpp.html">boost/hana/eval_if.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lazy_8hpp.html">boost/hana/lazy.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="traits_8hpp.html">boost/hana/traits.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// eval_if with heterogeneous branches and a Constant condition</span></div><div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> safe_make_unsigned = [](<span class="keyword">auto</span> t) {</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__group-Logical.html#gab64636f84de983575aac0208f5fa840c">hana::eval_if</a>(hana::traits::is_integral(t),</div><div class="line">        hana::make_lazy(hana::traits::make_unsigned)(t),</div><div class="line">        hana::make_lazy(t)</div><div class="line">    );</div><div class="line">};</div><div class="line"></div><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(safe_make_unsigned(hana::type_c&lt;void&gt;) == hana::type_c&lt;void&gt;);</div><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(safe_make_unsigned(hana::type_c&lt;int&gt;) == hana::type_c&lt;unsigned int&gt;);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// eval_if with homogeneous branches and a constexpr or runtime condition</span></div><div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> safe_divide = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__group-Logical.html#gab64636f84de983575aac0208f5fa840c">hana::eval_if</a>(y == 0,</div><div class="line">        [=](<span class="keyword">auto</span>) { <span class="keywordflow">return</span> 0; },</div><div class="line">        [=](<span class="keyword">auto</span> <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a>) { <span class="keywordflow">return</span> <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a>(x) / y; }</div><div class="line">    );</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(safe_divide(6, 3) == 2);</div><div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(safe_divide(6, 0) == 0);</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="gafd655d2222367131e7a63616e93dd080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd655d2222367131e7a63616e93dd080">&#9670;&nbsp;</a></span>if_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::if_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2if_8hpp.html">boost/hana/fwd/if.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; cond, <span class="keyword">auto</span>&amp;&amp; <a class="code" href="group__group-Monad.html#gaaddd3789de43cf989babb10cdc0b447a">then</a>, <span class="keyword">auto</span>&amp;&amp; else_) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div><div class="ttc" id="group__group-Monad_html_gaaddd3789de43cf989babb10cdc0b447a"><div class="ttname"><a href="group__group-Monad.html#gaaddd3789de43cf989babb10cdc0b447a">boost::hana::then</a></div><div class="ttdeci">constexpr auto then</div><div class="ttdoc">Sequentially compose two monadic actions, discarding any value produced by the first but not its effe...</div><div class="ttdef"><b>Definition:</b> then.hpp:36</div></div>
</div><!-- fragment -->
<p>Conditionally return one of two values based on a condition.Specifically, <code>then</code> is returned iff <code>cond</code> is true-valued, and <code>else_</code> is returned otherwise. Note that some <code>Logical</code> models may allow <code>then</code> and <code>else_</code> to have different types, while others may require both values to have the same type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>The condition determining which of the two values is returned.</td></tr>
    <tr><td class="paramname">then</td><td>The value returned when <code>cond</code> is true-valued.</td></tr>
    <tr><td class="paramname">else_</td><td>The value returned when <code>cond</code> is false-valued.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="bool_8hpp.html">boost/hana/bool.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="if_8hpp.html">boost/hana/if.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line">static_assert(<a class="code" href="group__group-Logical.html#gafd655d2222367131e7a63616e93dd080">hana::if_</a>(<span class="keyword">true</span>, 1, 2) == 1, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(<a class="code" href="group__group-Logical.html#gafd655d2222367131e7a63616e93dd080">hana::if_</a>(<span class="keyword">false</span>, 1, 2) == 2, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line">static_assert(</div><div class="line">    <a class="code" href="group__group-Logical.html#gafd655d2222367131e7a63616e93dd080">hana::if_</a>(hana::true_c,</div><div class="line">        hana::make_tuple(<span class="charliteral">&#39;t&#39;</span>, <span class="charliteral">&#39;r&#39;</span>, <span class="charliteral">&#39;u&#39;</span>, <span class="charliteral">&#39;e&#39;</span>),</div><div class="line">        hana::make_tuple(<span class="charliteral">&#39;f&#39;</span>, <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;l&#39;</span>, <span class="charliteral">&#39;s&#39;</span>, <span class="charliteral">&#39;e&#39;</span>)</div><div class="line">    )</div><div class="line">        ==</div><div class="line">    hana::make_tuple(<span class="charliteral">&#39;t&#39;</span>, <span class="charliteral">&#39;r&#39;</span>, <span class="charliteral">&#39;u&#39;</span>, <span class="charliteral">&#39;e&#39;</span>)</div><div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
</div>
</div>
<a id="ga4a7c9d7037601d5e553fd20777958980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a7c9d7037601d5e553fd20777958980">&#9670;&nbsp;</a></span>not_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::not_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2not_8hpp.html">boost/hana/fwd/not.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; x) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Negates a <code>Logical</code>.This method returns a <code>Logical</code> with the same tag, but whose truth-value is negated. Specifically, <code>not_(x)</code> returns a false-valued <code>Logical</code> if <code>x</code> is a true-valued <code>Logical</code>, and a true-valued one otherwise. </p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="bool_8hpp.html">boost/hana/bool.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="not_8hpp.html">boost/hana/not.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-Logical.html#ga4a7c9d7037601d5e553fd20777958980">hana::not_</a>(hana::true_c) == hana::false_c);</div><div class="line">static_assert(<a class="code" href="group__group-Logical.html#ga4a7c9d7037601d5e553fd20777958980">hana::not_</a>(<span class="keyword">false</span>) == <span class="keyword">true</span>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
</div>
</div>
<a id="ga68c00efbeb69339bfa157a78ebdd3f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68c00efbeb69339bfa157a78ebdd3f87">&#9670;&nbsp;</a></span>or_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::or_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2or_8hpp.html">boost/hana/fwd/or.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; x, <span class="keyword">auto</span>&amp;&amp; ...y) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Return whether any of the arguments is true-valued.<code>or_</code> can be called with one argument or more. When called with two arguments, <code>or_</code> uses tag-dispatching to find the right implementation. Otherwise,. </p>
<div class="fragment"><div class="line"><a class="code" href="group__group-Logical.html#ga68c00efbeb69339bfa157a78ebdd3f87">or_</a>(x) == x</div><div class="line"><a class="code" href="group__group-Logical.html#ga68c00efbeb69339bfa157a78ebdd3f87">or_</a>(x, y, ...z) == <a class="code" href="group__group-Logical.html#ga68c00efbeb69339bfa157a78ebdd3f87">or_</a>(<a class="code" href="group__group-Logical.html#ga68c00efbeb69339bfa157a78ebdd3f87">or_</a>(x, y), z...)</div></div><!-- fragment --><h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="bool_8hpp.html">boost/hana/bool.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="not_8hpp.html">boost/hana/not.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="or_8hpp.html">boost/hana/or.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-Logical.html#ga68c00efbeb69339bfa157a78ebdd3f87">hana::or_</a>(hana::false_c, hana::false_c, hana::true_c));</div><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(!<a class="code" href="group__group-Logical.html#ga68c00efbeb69339bfa157a78ebdd3f87">hana::or_</a>(hana::false_c, hana::false_c, hana::false_c));</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
</div>
</div>
<a id="ga08a767b86c330cac67daa891406d2730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08a767b86c330cac67daa891406d2730">&#9670;&nbsp;</a></span>while_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::while_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2while_8hpp.html">boost/hana/fwd/while.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; pred, <span class="keyword">auto</span>&amp;&amp; state, <span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Apply a function to an initial state while some predicate is satisfied.This method is a natural extension of the <code>while</code> language construct to manipulate a state whose type may change from one iteration to another. However, note that having a state whose type changes from one iteration to the other is only possible as long as the predicate returns a <code>Logical</code> whose truth value is known at compile-time. </p>
<p>Specifically, <code>while_(pred, state, f)</code> is equivalent to </p><div class="fragment"><div class="line">f(...f(f(state)))</div></div><!-- fragment --><p> where <code>f</code> is iterated as long as <code>pred(f(...))</code> is a true-valued <code>Logical</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>A predicate called on the state or on the result of applying <code>f</code> a certain number of times to the state, and returning whether <code>f</code> should be applied one more time.</td></tr>
    <tr><td class="paramname">state</td><td>The initial state on which <code>f</code> is applied.</td></tr>
    <tr><td class="paramname">f</td><td>A function that is iterated on the initial state. Note that the return type of <code>f</code> may change from one iteration to the other, but only while <code>pred</code> returns a compile-time <code>Logical</code>. In other words, <code>decltype(f(stateN))</code> may differ from <code>decltype(f(stateN+1))</code>, but only if <code>pred(f(stateN))</code> returns a compile-time <code>Logical</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="less_8hpp.html">boost/hana/less.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="plus_8hpp.html">boost/hana/plus.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="while_8hpp.html">boost/hana/while.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"><span class="keyword">using namespace </span>hana::literals;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// while_ with a Constant condition (loop is unrolled at compile-time)</span></div><div class="line">    {</div><div class="line">        std::vector&lt;int&gt; ints;</div><div class="line">        <span class="keyword">auto</span> final_state = <a class="code" href="group__group-Logical.html#ga08a767b86c330cac67daa891406d2730">hana::while_</a>(<a class="code" href="group__group-Orderable.html#gad510011602bdb14686f1c4ec145301c9">hana::less</a>.than(10_c), 0_c, [&amp;](<span class="keyword">auto</span> i) {</div><div class="line">            ints.push_back(i);</div><div class="line">            <span class="keywordflow">return</span> i + 1_c;</div><div class="line">        });</div><div class="line"></div><div class="line">        <span class="comment">// The state is known at compile-time</span></div><div class="line">        <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(final_state == 10_c);</div><div class="line"></div><div class="line">        <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(ints == std::vector&lt;int&gt;{0, 1, 2, 3, 4, 5, 6, 7, 8, 9});</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// while_ with a constexpr or runtime condition (loop is not unrolled)</span></div><div class="line">    {</div><div class="line">        std::vector&lt;int&gt; ints;</div><div class="line">        <span class="keywordtype">int</span> final_state = <a class="code" href="group__group-Logical.html#ga08a767b86c330cac67daa891406d2730">hana::while_</a>(<a class="code" href="group__group-Orderable.html#gad510011602bdb14686f1c4ec145301c9">hana::less</a>.than(10), 0, [&amp;](<span class="keywordtype">int</span> i) {</div><div class="line">            ints.push_back(i);</div><div class="line">            <span class="keywordflow">return</span> i + 1;</div><div class="line">        });</div><div class="line"></div><div class="line">        <span class="comment">// The state is known only at runtime, or at compile-time if constexpr</span></div><div class="line">        <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(final_state == 10);</div><div class="line"></div><div class="line">        <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(ints == std::vector&lt;int&gt;{0, 1, 2, 3, 4, 5, 6, 7, 8, 9});</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!--
Copyright Louis Dionne 2013-2017
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-->
<!-- boost-no-inspect -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
  </ul>
</div>
</body>
</html>
