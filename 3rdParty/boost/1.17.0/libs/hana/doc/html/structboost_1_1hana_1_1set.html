<!--
Copyright Louis Dionne 2013-2017
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-->
<!-- boost-no-inspect -->
<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<title>Boost.Hana: boost::hana::set&lt; implementation_defined &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
// Copyright Louis Dionne 2013-2017
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
MathJax.Hub.Config({
    "HTML-CSS": {
        linebreaks: {
            automatic: true,
            width: "75% container"
        }
    }
});
</script><script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Additional javascript for drawing charts. -->
<script type="text/javascript" src="highcharts.js"></script>
<script type="text/javascript" src="highcharts-data.js"></script>
<script type="text/javascript" src="highcharts-exporting.js"></script>
<script type="text/javascript" src="chart.js"></script>
<script type="text/javascript" src="hana.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Boost.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   &#160;<span id="projectnumber">1.6.0</span>
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('structboost_1_1hana_1_1set.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Synopsis of associated functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structboost_1_1hana_1_1set-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::hana::set&lt; implementation_defined &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__group-datatypes.html">Data types</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><h3>template&lt;typename implementation_defined&gt;<br />
struct boost::hana::set&lt; implementation_defined &gt;</h3>

<p>Basic unordered container requiring unique, <code>Comparable</code> and <code>Hashable</code> keys. </p>
<p>A set is an unordered container that can hold heterogeneous keys. A set requires (and ensures) that no duplicates are present when inserting new keys.</p>
<dl class="section note"><dt>Note</dt><dd>The actual representation of a <code><a class="el" href="structboost_1_1hana_1_1set.html" title="Basic unordered container requiring unique, Comparable and Hashable keys.">hana::set</a></code> is implementation-defined. In particular, one should not take for granted the order of the template parameters and the presence of any additional constructors or assignment operators than what is documented. The canonical way of creating a <code><a class="el" href="structboost_1_1hana_1_1set.html" title="Basic unordered container requiring unique, Comparable and Hashable keys.">hana::set</a></code> is through <code>hana::make_set</code>. More details <a class="el" href="index.html#tutorial-containers-types">in the tutorial</a>.</dd></dl>
<h2>Modeled concepts </h2>
<ol type="1">
<li><code>Comparable</code><br />
Two sets are equal iff they contain the same elements, regardless of the order. <div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="not__equal_8hpp.html">boost/hana/not_equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set_8hpp.html">boost/hana/set.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div><div class="line">        hana::make_set(hana::int_c&lt;0&gt;, hana::type_c&lt;char&gt;, hana::int_c&lt;1&gt;)</div><div class="line">            ==</div><div class="line">        hana::make_set(hana::int_c&lt;1&gt;, hana::int_c&lt;0&gt;, hana::type_c&lt;char&gt;)</div><div class="line">    );</div><div class="line"></div><div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div><div class="line">        hana::make_set(hana::int_c&lt;0&gt;, hana::type_c&lt;char&gt;)</div><div class="line">            !=</div><div class="line">        hana::make_set(hana::int_c&lt;1&gt;)</div><div class="line">    );</div><div class="line">}</div></div><!-- fragment --></li>
<li>Foldable<br />
Folding a set is equivalent to folding the sequence of its values. However, note that the values are not required to be in any specific order, so using the folds provided here with an operation that is not both commutative and associative will yield non-deterministic behavior. <div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="maximum_8hpp.html">boost/hana/maximum.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="minimum_8hpp.html">boost/hana/minimum.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set_8hpp.html">boost/hana/set.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sum_8hpp.html">boost/hana/sum.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    constexpr <span class="keyword">auto</span> xs = hana::make_set(hana::int_c&lt;0&gt;, hana::int_c&lt;1&gt;, hana::int_c&lt;2&gt;);</div><div class="line">    static_assert(<a class="code" href="group__group-Foldable.html#ga347429451fdb15f9f7a7fc0de293be1a">hana::minimum</a>(xs) == hana::int_c&lt;0&gt;, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">    static_assert(<a class="code" href="group__group-Foldable.html#gaf3861a91607203b63a12708e18a4eac5">hana::maximum</a>(xs) == hana::int_c&lt;2&gt;, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">    static_assert(hana::sum&lt;&gt;(xs) == hana::int_c&lt;3&gt;, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">}</div></div><!-- fragment --></li>
<li>Searchable<br />
The elements in a set act as both its keys and its values. Since the elements of a set are unique, searching for an element will return either the only element which is equal to the searched value, or <code>nothing</code>. Also note that <code>operator[]</code> can be used instead of the <code>at_key</code> function. <div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="at__key_8hpp.html">boost/hana/at_key.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="find_8hpp.html">boost/hana/find.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set_8hpp.html">boost/hana/set.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    constexpr <span class="keyword">auto</span> xs = hana::make_set(hana::int_c&lt;0&gt;, hana::int_c&lt;1&gt;, hana::int_c&lt;2&gt;);</div><div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-Searchable.html#ga6b6cdd69942b0fe3bf5254247f9c861e">hana::find</a>(xs, hana::int_c&lt;0&gt;) == hana::just(hana::int_c&lt;0&gt;));</div><div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-Searchable.html#ga6b6cdd69942b0fe3bf5254247f9c861e">hana::find</a>(xs, hana::int_c&lt;3&gt;) == hana::nothing);</div><div class="line"></div><div class="line">    <span class="comment">// operator[] is equivalent to at_key</span></div><div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(xs[hana::int_c&lt;2&gt;] == hana::int_c&lt;2&gt;);</div><div class="line"></div><div class="line">    <span class="comment">// long_c&lt;0&gt; == int_&lt;0&gt;, and therefore int_&lt;0&gt; is found</span></div><div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(xs[hana::long_c&lt;0&gt;] == hana::int_c&lt;0&gt;);</div><div class="line">}</div></div><!-- fragment --></li>
</ol>
<h2>Conversion from any <code>Foldable</code> </h2>
<p>Any <code>Foldable</code> structure can be converted into a <code><a class="el" href="structboost_1_1hana_1_1set.html" title="Basic unordered container requiring unique, Comparable and Hashable keys.">hana::set</a></code> with <code>to&lt;<a class="el" href="structboost_1_1hana_1_1set__tag.html" title="Tag representing the hana::set container.">set_tag</a>&gt;</code>. The elements of the structure must all be compile-time <code>Comparable</code>. If the structure contains duplicate elements, only the first occurence will appear in the resulting set. More specifically, conversion from a <code>Foldable</code> is equivalent to </p><div class="fragment"><div class="line">to&lt;set_tag&gt;(xs) == <a class="code" href="group__group-Foldable.html#ga38c6b3f6b1cbadb9b8432a05ff16b7d2">fold_left</a>(xs, <a class="code" href="structboost_1_1hana_1_1set.html#af38c23fb98d8eec68c1491a8bca9ce43">make_set</a>(), <a class="code" href="structboost_1_1hana_1_1set.html#a5791e6dc0e27d8e3a113e4d94482550f">insert</a>)</div></div><!-- fragment --><p><b>Example</b> </p><div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="core_2to_8hpp.html">boost/hana/core/to.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set_8hpp.html">boost/hana/set.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    constexpr <span class="keyword">auto</span> xs = hana::make_tuple(</div><div class="line">        hana::int_c&lt;1&gt;,</div><div class="line">        hana::int_c&lt;3&gt;,</div><div class="line">        hana::type_c&lt;int&gt;,</div><div class="line">        hana::long_c&lt;1&gt;</div><div class="line">    );</div><div class="line"></div><div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div><div class="line">        hana::to&lt;hana::set_tag&gt;(xs)</div><div class="line">            ==</div><div class="line">        hana::make_set(hana::int_c&lt;1&gt;, hana::int_c&lt;3&gt;, hana::type_c&lt;int&gt;)</div><div class="line">    );</div><div class="line">}</div></div><!-- fragment --> </div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Synopsis of associated functions</h2></td></tr>
<tr class="memitem:aa337857e80b8a8c91880b0184aaf7534"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aa337857e80b8a8c91880b0184aaf7534"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1set.html#aa337857e80b8a8c91880b0184aaf7534">make&lt; set_tag &gt;</a></td></tr>
<tr class="memdesc:aa337857e80b8a8c91880b0184aaf7534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for creating a <code><a class="el" href="structboost_1_1hana_1_1set.html" title="Basic unordered container requiring unique, Comparable and Hashable keys.">hana::set</a></code>.  <a href="#aa337857e80b8a8c91880b0184aaf7534">More...</a><br /></td></tr>
<tr class="separator:aa337857e80b8a8c91880b0184aaf7534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38c23fb98d8eec68c1491a8bca9ce43"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1set.html#af38c23fb98d8eec68c1491a8bca9ce43">make_set</a> = <a class="el" href="group__group-core.html#ga1d92480f0af1029878e773dafa3e2f60">make</a>&lt;<a class="el" href="structboost_1_1hana_1_1set__tag.html">set_tag</a>&gt;</td></tr>
<tr class="memdesc:af38c23fb98d8eec68c1491a8bca9ce43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>make&lt;<a class="el" href="structboost_1_1hana_1_1set__tag.html" title="Tag representing the hana::set container.">set_tag</a>&gt;</code>; provided for convenience.  <a href="#af38c23fb98d8eec68c1491a8bca9ce43">More...</a><br /></td></tr>
<tr class="separator:af38c23fb98d8eec68c1491a8bca9ce43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5791e6dc0e27d8e3a113e4d94482550f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1set.html#a5791e6dc0e27d8e3a113e4d94482550f">insert</a></td></tr>
<tr class="memdesc:a5791e6dc0e27d8e3a113e4d94482550f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element in a <code><a class="el" href="structboost_1_1hana_1_1set.html" title="Basic unordered container requiring unique, Comparable and Hashable keys.">hana::set</a></code>.  <a href="#a5791e6dc0e27d8e3a113e4d94482550f">More...</a><br /></td></tr>
<tr class="separator:a5791e6dc0e27d8e3a113e4d94482550f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af856f7bf77f69cdf1b8fd4e566eaef9b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1set.html#af856f7bf77f69cdf1b8fd4e566eaef9b">erase_key</a></td></tr>
<tr class="memdesc:af856f7bf77f69cdf1b8fd4e566eaef9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an element from a <code><a class="el" href="structboost_1_1hana_1_1set.html" title="Basic unordered container requiring unique, Comparable and Hashable keys.">hana::set</a></code>.  <a href="#af856f7bf77f69cdf1b8fd4e566eaef9b">More...</a><br /></td></tr>
<tr class="separator:af856f7bf77f69cdf1b8fd4e566eaef9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd511f2c01f38405bfba0b6d5b2922e8"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1set.html#acd511f2c01f38405bfba0b6d5b2922e8">union_</a></td></tr>
<tr class="memdesc:acd511f2c01f38405bfba0b6d5b2922e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the union of two sets.  <a href="#acd511f2c01f38405bfba0b6d5b2922e8">More...</a><br /></td></tr>
<tr class="separator:acd511f2c01f38405bfba0b6d5b2922e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b3430482d4e88052e621f63a234f3eb"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1set.html#a3b3430482d4e88052e621f63a234f3eb">intersection</a></td></tr>
<tr class="memdesc:a3b3430482d4e88052e621f63a234f3eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the intersection of two sets.  <a href="#a3b3430482d4e88052e621f63a234f3eb">More...</a><br /></td></tr>
<tr class="separator:a3b3430482d4e88052e621f63a234f3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accbea694d32b341e860dac724c0c6933"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1set.html#accbea694d32b341e860dac724c0c6933">to_set</a> = <a class="el" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">to</a>&lt;<a class="el" href="structboost_1_1hana_1_1set__tag.html">set_tag</a>&gt;</td></tr>
<tr class="memdesc:accbea694d32b341e860dac724c0c6933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>to&lt;<a class="el" href="structboost_1_1hana_1_1set__tag.html" title="Tag representing the hana::set container.">set_tag</a>&gt;</code>; provided for convenience.  <a href="#accbea694d32b341e860dac724c0c6933">More...</a><br /></td></tr>
<tr class="separator:accbea694d32b341e860dac724c0c6933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718ddfe86437adbbca1e1a5db651d139"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1set.html#a718ddfe86437adbbca1e1a5db651d139">difference</a></td></tr>
<tr class="memdesc:a718ddfe86437adbbca1e1a5db651d139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set-theoretic difference of two sets.  <a href="#a718ddfe86437adbbca1e1a5db651d139">More...</a><br /></td></tr>
<tr class="separator:a718ddfe86437adbbca1e1a5db651d139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bcb2455eb9f7074185d8fb61a99801e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1set.html#a8bcb2455eb9f7074185d8fb61a99801e">symmetric_difference</a></td></tr>
<tr class="memdesc:a8bcb2455eb9f7074185d8fb61a99801e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the symmetric set-theoretic difference of two sets.  <a href="#a8bcb2455eb9f7074185d8fb61a99801e">More...</a><br /></td></tr>
<tr class="separator:a8bcb2455eb9f7074185d8fb61a99801e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a27607958295e6da8a0ba602a2db468f1"><td class="memTemplParams" colspan="2"><a id="a27607958295e6da8a0ba602a2db468f1"></a>
template&lt;typename X , typename Y &gt; </td></tr>
<tr class="memitem:a27607958295e6da8a0ba602a2db468f1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1set.html#a27607958295e6da8a0ba602a2db468f1">operator==</a> (X &amp;&amp;x, Y &amp;&amp;y)</td></tr>
<tr class="memdesc:a27607958295e6da8a0ba602a2db468f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code><a class="el" href="group__group-Comparable.html#gacaf1ebea6b3ab96ac9dcb82f0e64e547" title="Returns a Logical representing whether x is equal to y.The equal function can be called in two differ...">hana::equal</a></code> <br /></td></tr>
<tr class="separator:a27607958295e6da8a0ba602a2db468f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cae3af55edb3eb05bfa184bda633f7d"><td class="memTemplParams" colspan="2"><a id="a0cae3af55edb3eb05bfa184bda633f7d"></a>
template&lt;typename X , typename Y &gt; </td></tr>
<tr class="memitem:a0cae3af55edb3eb05bfa184bda633f7d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1set.html#a0cae3af55edb3eb05bfa184bda633f7d">operator!=</a> (X &amp;&amp;x, Y &amp;&amp;y)</td></tr>
<tr class="memdesc:a0cae3af55edb3eb05bfa184bda633f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code><a class="el" href="group__group-Comparable.html#gae33be2e0d5e04f19082f4b7740dfc9cd" title="Returns a Logical representing whether x is not equal to y.The not_equal function can be called in tw...">hana::not_equal</a></code> <br /></td></tr>
<tr class="separator:a0cae3af55edb3eb05bfa184bda633f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a51bdb213a03abc126668c4c3b14fc50b"><td class="memItemLeft" align="right" valign="top"><a id="a51bdb213a03abc126668c4c3b14fc50b"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1set.html#a51bdb213a03abc126668c4c3b14fc50b">set</a> ()=default</td></tr>
<tr class="memdesc:a51bdb213a03abc126668c4c3b14fc50b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default-construct a set. This constructor only exists when all the elements of the set are default-constructible. <br /></td></tr>
<tr class="separator:a51bdb213a03abc126668c4c3b14fc50b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937a7d47238690b571e7dd524278f6d5"><td class="memItemLeft" align="right" valign="top"><a id="a937a7d47238690b571e7dd524278f6d5"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1set.html#a937a7d47238690b571e7dd524278f6d5">set</a> (<a class="el" href="structboost_1_1hana_1_1set.html">set</a> const &amp;other)=default</td></tr>
<tr class="memdesc:a937a7d47238690b571e7dd524278f6d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-construct a set from another set. This constructor only exists when all the elements of the set are copy-constructible. <br /></td></tr>
<tr class="separator:a937a7d47238690b571e7dd524278f6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b7025edfb0c6c28f31d84598e130f0"><td class="memItemLeft" align="right" valign="top"><a id="ac5b7025edfb0c6c28f31d84598e130f0"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1set.html#ac5b7025edfb0c6c28f31d84598e130f0">set</a> (<a class="el" href="structboost_1_1hana_1_1set.html">set</a> &amp;&amp;other)=default</td></tr>
<tr class="memdesc:ac5b7025edfb0c6c28f31d84598e130f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-construct a set from another set. This constructor only exists when all the elements of the set are move-constructible. <br /></td></tr>
<tr class="separator:ac5b7025edfb0c6c28f31d84598e130f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f6165e7a2db4218c67d80929c457d2"><td class="memTemplParams" colspan="2"><a id="a00f6165e7a2db4218c67d80929c457d2"></a>
template&lt;typename Key &gt; </td></tr>
<tr class="memitem:a00f6165e7a2db4218c67d80929c457d2"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto) constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1set.html#a00f6165e7a2db4218c67d80929c457d2">operator[]</a> (Key &amp;&amp;key)</td></tr>
<tr class="memdesc:a00f6165e7a2db4218c67d80929c457d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code><a class="el" href="group__group-Searchable.html#ga3c1826aee6c6eb577810bb99c5c3e53d" title="Returns the value associated to the given key in a structure, or fail.Given a key and a Searchable st...">hana::at_key</a></code> <br /></td></tr>
<tr class="separator:a00f6165e7a2db4218c67d80929c457d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Associated functions</h2>
<a id="aa337857e80b8a8c91880b0184aaf7534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa337857e80b8a8c91880b0184aaf7534">&#9670;&nbsp;</a></span>make&lt; set_tag &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename implementation_defined &gt; </div>
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="group__group-core.html#ga1d92480f0af1029878e773dafa3e2f60">make</a>&lt; <a class="el" href="structboost_1_1hana_1_1set__tag.html">set_tag</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; ...xs) {</div><div class="line">        <span class="keywordflow">return</span> set&lt;implementation_defined&gt;{forwarded(xs)...};</div><div class="line">    }</div></div><!-- fragment -->
<p>Function object for creating a <code><a class="el" href="structboost_1_1hana_1_1set.html" title="Basic unordered container requiring unique, Comparable and Hashable keys.">hana::set</a></code>. </p>
<p>Given zero or more values <code>xs...</code>, <code>make&lt;<a class="el" href="structboost_1_1hana_1_1set__tag.html" title="Tag representing the hana::set container.">set_tag</a>&gt;</code> returns a <code>set</code> containing those values. The values must all be compile-time <code>Comparable</code>, and no duplicate values may be provided. To create a <code>set</code> from a sequence with possible duplicates, use <code>to&lt;<a class="el" href="structboost_1_1hana_1_1set__tag.html" title="Tag representing the hana::set container.">set_tag</a>&gt;</code> instead.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="core_2make_8hpp.html">boost/hana/core/make.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set_8hpp.html">boost/hana/set.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line">constexpr <span class="keyword">auto</span> xs = hana::make_set(hana::int_c&lt;1&gt;, hana::type_c&lt;void&gt;);</div><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(xs == hana::make&lt;hana::set_tag&gt;(hana::int_c&lt;1&gt;, hana::type_c&lt;void&gt;));</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
</div>
</div>
<a id="af38c23fb98d8eec68c1491a8bca9ce43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38c23fb98d8eec68c1491a8bca9ce43">&#9670;&nbsp;</a></span>make_set</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename implementation_defined &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto make_set = <a class="el" href="group__group-core.html#ga1d92480f0af1029878e773dafa3e2f60">make</a>&lt;<a class="el" href="structboost_1_1hana_1_1set__tag.html">set_tag</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to <code>make&lt;<a class="el" href="structboost_1_1hana_1_1set__tag.html" title="Tag representing the hana::set container.">set_tag</a>&gt;</code>; provided for convenience. </p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="core_2make_8hpp.html">boost/hana/core/make.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set_8hpp.html">boost/hana/set.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line">constexpr <span class="keyword">auto</span> xs = hana::make_set(hana::int_c&lt;1&gt;, hana::type_c&lt;void&gt;);</div><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(xs == hana::make&lt;hana::set_tag&gt;(hana::int_c&lt;1&gt;, hana::type_c&lt;void&gt;));</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
</div>
</div>
<a id="a5791e6dc0e27d8e3a113e4d94482550f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5791e6dc0e27d8e3a113e4d94482550f">&#9670;&nbsp;</a></span>insert</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename implementation_defined &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto insert</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; <a class="code" href="structboost_1_1hana_1_1set.html#a51bdb213a03abc126668c4c3b14fc50b">set</a>, <span class="keyword">auto</span>&amp;&amp; element) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Insert an element in a <code><a class="el" href="structboost_1_1hana_1_1set.html" title="Basic unordered container requiring unique, Comparable and Hashable keys.">hana::set</a></code>. </p>
<p>If the set already contains an element that compares equal, then nothing is done and the set is returned as is.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>The set in which to insert a value.</td></tr>
    <tr><td class="paramname">element</td><td>The value to insert. It must be compile-time <code>Comparable</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="insert_8hpp.html">boost/hana/insert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set_8hpp.html">boost/hana/set.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8hpp.html">boost/hana/string.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    constexpr <span class="keyword">auto</span> xs = hana::make_set(hana::int_c&lt;0&gt;, hana::type_c&lt;int&gt;);</div><div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div><div class="line">        <a class="code" href="group__group-Sequence.html#gae22a1a184b1b2dd550fa4fa619bed2e9">hana::insert</a>(xs, BOOST_HANA_STRING(<span class="stringliteral">&quot;abc&quot;</span>)) ==</div><div class="line">        hana::make_set(hana::int_c&lt;0&gt;, hana::type_c&lt;int&gt;, BOOST_HANA_STRING(<span class="stringliteral">&quot;abc&quot;</span>))</div><div class="line">    );</div><div class="line"></div><div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div><div class="line">        <a class="code" href="group__group-Sequence.html#gae22a1a184b1b2dd550fa4fa619bed2e9">hana::insert</a>(xs, hana::int_c&lt;0&gt;) == hana::make_set(hana::int_c&lt;0&gt;, hana::type_c&lt;int&gt;)</div><div class="line">    );</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="af856f7bf77f69cdf1b8fd4e566eaef9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af856f7bf77f69cdf1b8fd4e566eaef9b">&#9670;&nbsp;</a></span>erase_key</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename implementation_defined &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto erase_key</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; <a class="code" href="structboost_1_1hana_1_1set.html#a51bdb213a03abc126668c4c3b14fc50b">set</a>, <span class="keyword">auto</span>&amp;&amp; element) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Remove an element from a <code><a class="el" href="structboost_1_1hana_1_1set.html" title="Basic unordered container requiring unique, Comparable and Hashable keys.">hana::set</a></code>. </p>
<p>Returns a new set containing all the elements of the original, except the one comparing <code>equal</code> to the given element. If the set does not contain such an element, a new set equal to the original set is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>The set in which to remove a value.</td></tr>
    <tr><td class="paramname">element</td><td>The value to remove. It must be compile-time <code>Comparable</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="erase__key_8hpp.html">boost/hana/erase_key.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set_8hpp.html">boost/hana/set.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    constexpr <span class="keyword">auto</span> xs = hana::make_set(hana::int_c&lt;0&gt;, hana::type_c&lt;int&gt;, hana::type_c&lt;void&gt;);</div><div class="line"></div><div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::erase_key(xs, hana::type_c&lt;int&gt;) == hana::make_set(hana::int_c&lt;0&gt;, hana::type_c&lt;void&gt;));</div><div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::erase_key(xs, hana::type_c&lt;char&gt;) == xs);</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="acd511f2c01f38405bfba0b6d5b2922e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd511f2c01f38405bfba0b6d5b2922e8">&#9670;&nbsp;</a></span>union_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename implementation_defined &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto union_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; ys) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Returns the union of two sets. </p>
<p>Given two sets <code>xs</code> and <code>ys</code>, <code>union_(xs, ys)</code> is a new set containing all the elements of <code>xs</code> and all the elements of <code>ys</code>, without duplicates. For any object <code>x</code>, the following holds: <code>x</code> is in <code>hana::union_(xs, ys)</code> if and only if <code>x</code> is in <code>xs</code> or <code>x</code> is in <code>ys</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs,ys</td><td>Two sets to compute the union of.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set_8hpp.html">boost/hana/set.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8hpp.html">boost/hana/string.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="union_8hpp.html">boost/hana/union.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"><span class="keyword">using namespace </span>hana::literals;</div><div class="line"></div><div class="line"></div><div class="line">constexpr <span class="keyword">auto</span> xs = hana::make_set(hana::int_c&lt;1&gt;, hana::type_c&lt;void&gt;, hana::int_c&lt;2&gt;);</div><div class="line">constexpr <span class="keyword">auto</span> ys = hana::make_set(hana::int_c&lt;2&gt;, hana::type_c&lt;int&gt;, hana::int_c&lt;3&gt;);</div><div class="line"></div><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::union_(xs, ys) == hana::make_set(</div><div class="line">    hana::int_c&lt;1&gt;, hana::int_c&lt;2&gt;, hana::int_c&lt;3&gt;, hana::type_c&lt;void&gt;, hana::type_c&lt;int&gt;</div><div class="line">));</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
</div>
</div>
<a id="a3b3430482d4e88052e621f63a234f3eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b3430482d4e88052e621f63a234f3eb">&#9670;&nbsp;</a></span>intersection</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename implementation_defined &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto intersection</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; ys) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Returns the intersection of two sets. </p>
<p>Given two sets <code>xs</code> and <code>ys</code>, <code>intersection(xs, ys)</code> is a new set containing exactly those elements that are present both in <code>xs</code> and in <code>ys</code>. In other words, the following holds for any object <code>x</code>: </p><div class="fragment"><div class="line">x ^<a class="code" href="group__group-Searchable.html#ga0d9456ceda38b6ca664998e79d7c45b7">in</a>^ <a class="code" href="structboost_1_1hana_1_1set.html#a3b3430482d4e88052e621f63a234f3eb">intersection</a>(xs, ys) <span class="keywordflow">if</span> and only <span class="keywordflow">if</span> x ^<a class="code" href="group__group-Searchable.html#ga0d9456ceda38b6ca664998e79d7c45b7">in</a>^ xs &amp;&amp; x ^<a class="code" href="group__group-Searchable.html#ga0d9456ceda38b6ca664998e79d7c45b7">in</a>^ ys</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs,ys</td><td>Two sets to intersect.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="intersection_8hpp.html">boost/hana/intersection.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set_8hpp.html">boost/hana/set.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line">constexpr <span class="keyword">auto</span> xs = hana::make_set(hana::int_c&lt;1&gt;, hana::type_c&lt;void&gt;, hana::int_c&lt;2&gt;);</div><div class="line">constexpr <span class="keyword">auto</span> ys = hana::make_set(hana::int_c&lt;2&gt;, hana::type_c&lt;int&gt;, hana::int_c&lt;3&gt;);</div><div class="line"></div><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::intersection(xs, ys) == hana::make_set(hana::int_c&lt;2&gt;));</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
</div>
</div>
<a id="accbea694d32b341e860dac724c0c6933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accbea694d32b341e860dac724c0c6933">&#9670;&nbsp;</a></span>to_set</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename implementation_defined &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto to_set = <a class="el" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">to</a>&lt;<a class="el" href="structboost_1_1hana_1_1set__tag.html">set_tag</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to <code>to&lt;<a class="el" href="structboost_1_1hana_1_1set__tag.html" title="Tag representing the hana::set container.">set_tag</a>&gt;</code>; provided for convenience. </p>

</div>
</div>
<a id="a718ddfe86437adbbca1e1a5db651d139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a718ddfe86437adbbca1e1a5db651d139">&#9670;&nbsp;</a></span>difference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename implementation_defined &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto difference</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; ys) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">}</div></div><!-- fragment -->
<p>Returns the set-theoretic difference of two sets. </p>
<p>Given two sets <code>xs</code> and <code>ys</code>, <code>difference(xs, ys)</code> is a new set containing all the elements of <code>xs</code> that are <em>not</em> contained in <code>ys</code>. For any object <code>x</code>, the following holds: </p><div class="fragment"><div class="line">x ^<a class="code" href="group__group-Searchable.html#ga0d9456ceda38b6ca664998e79d7c45b7">in</a>^ <a class="code" href="structboost_1_1hana_1_1set.html#a718ddfe86437adbbca1e1a5db651d139">difference</a>(xs, ys) <span class="keywordflow">if</span> and only <span class="keywordflow">if</span> x ^<a class="code" href="group__group-Searchable.html#ga0d9456ceda38b6ca664998e79d7c45b7">in</a>^ xs &amp;&amp; !(x ^<a class="code" href="group__group-Searchable.html#ga0d9456ceda38b6ca664998e79d7c45b7">in</a>^ ys)</div></div><!-- fragment --><p>This operation is not commutative, i.e. <code>difference(xs, ys)</code> is not necessarily the same as <code>difference(ys, xs)</code>. Indeed, consider the case where <code>xs</code> is empty and <code>ys</code> isn't. Then, <code>difference(xs, ys)</code> is empty but <code>difference(ys, xs)</code> is equal to <code>ys</code>. For the symmetric version of this operation, see <code>symmetric_difference</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>A set param to remove values from.</td></tr>
    <tr><td class="paramname">ys</td><td>The set whose values are removed from <code>xs</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="difference_8hpp.html">boost/hana/difference.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set_8hpp.html">boost/hana/set.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line">constexpr <span class="keyword">auto</span> xs = hana::make_set(hana::int_c&lt;1&gt;, hana::int_c&lt;2&gt;, hana::type_c&lt;int&gt;, hana::int_c&lt;3&gt;);</div><div class="line">constexpr <span class="keyword">auto</span> ys = hana::make_set(hana::int_c&lt;3&gt;, hana::type_c&lt;void&gt;, hana::type_c&lt;int&gt;);</div><div class="line"></div><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::difference(xs, ys) == hana::make_set(hana::int_c&lt;1&gt;, hana::int_c&lt;2&gt;));</div><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::difference(ys, xs) == hana::make_set(hana::type_c&lt;void&gt;));</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
</div>
</div>
<a id="a8bcb2455eb9f7074185d8fb61a99801e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bcb2455eb9f7074185d8fb61a99801e">&#9670;&nbsp;</a></span>symmetric_difference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename implementation_defined &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto symmetric_difference</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; ys) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Returns the symmetric set-theoretic difference of two sets. </p>
<p>Given two sets <code>xs</code> and <code>ys</code>, <code>symmetric_difference(xs, ys)</code> is a new set containing all the elements of <code>xs</code> that are not contained in <code>ys</code>, and all the elements of <code>ys</code> that are not contained in <code>xs</code>. The symmetric difference of two sets satisfies the following: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1set.html#a8bcb2455eb9f7074185d8fb61a99801e">symmetric_difference</a>(xs, ys) == <a class="code" href="structboost_1_1hana_1_1set.html#acd511f2c01f38405bfba0b6d5b2922e8">union_</a>(<a class="code" href="structboost_1_1hana_1_1set.html#a718ddfe86437adbbca1e1a5db651d139">difference</a>(xs, ys), <a class="code" href="structboost_1_1hana_1_1set.html#a718ddfe86437adbbca1e1a5db651d139">difference</a>(ys, xs))</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs,ys</td><td>Two sets to compute the symmetric difference of.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set_8hpp.html">boost/hana/set.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="symmetric__difference_8hpp.html">boost/hana/symmetric_difference.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line">constexpr <span class="keyword">auto</span> xs = hana::make_set(hana::int_c&lt;1&gt;, hana::int_c&lt;2&gt;, hana::type_c&lt;int&gt;, hana::int_c&lt;3&gt;);</div><div class="line">constexpr <span class="keyword">auto</span> ys = hana::make_set(hana::int_c&lt;3&gt;, hana::type_c&lt;void&gt;, hana::type_c&lt;int&gt;);</div><div class="line"></div><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div><div class="line">    hana::symmetric_difference(xs, ys) == hana::make_set(hana::int_c&lt;1&gt;, hana::int_c&lt;2&gt;, hana::type_c&lt;void&gt;)</div><div class="line">);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!--
Copyright Louis Dionne 2013-2017
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-->
<!-- boost-no-inspect -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>boost</b></li><li class="navelem"><a class="el" href="namespaceboost_1_1hana.html">hana</a></li><li class="navelem"><a class="el" href="structboost_1_1hana_1_1set.html">set</a></li>
  </ul>
</div>
</body>
</html>
