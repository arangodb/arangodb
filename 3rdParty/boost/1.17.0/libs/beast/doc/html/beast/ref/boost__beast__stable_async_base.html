<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>stable_async_base</title>
<link rel="stylesheet" href="../../../../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../../index.html" title="Chapter&#160;1.&#160;Boost.Beast">
<link rel="up" href="../ref.html" title="This Page Intentionally Left Blank 2/2">
<link rel="prev" href="boost__beast__ssl_stream/write_some/overload2.html" title="ssl_stream::write_some (2 of 2 overloads)">
<link rel="next" href="boost__beast__stable_async_base/allocate_stable.html" title="stable_async_base::allocate_stable">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="boost__beast__ssl_stream/write_some/overload2.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../ref.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="boost__beast__stable_async_base/allocate_stable.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="beast.ref.boost__beast__stable_async_base"></a><a class="link" href="boost__beast__stable_async_base.html" title="stable_async_base">stable_async_base</a>
</h4></div></div></div>
<p>
        Base class to provide completion handler boilerplate for composed operations.
      </p>
<h5>
<a name="beast.ref.boost__beast__stable_async_base.h0"></a>
        <span class="phrase"><a name="beast.ref.boost__beast__stable_async_base.synopsis"></a></span><a class="link" href="boost__beast__stable_async_base.html#beast.ref.boost__beast__stable_async_base.synopsis">Synopsis</a>
      </h5>
<p>
        Defined in header <code class="literal">&lt;<a href="../../../../../../boost/beast/core/async_base.hpp" target="_top">boost/beast/core/async_base.hpp</a>&gt;</code>
      </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span>
    <span class="keyword">class</span> <a href="../../../../../../doc/html/boost_asio/reference/Handler.html" target="_top"><span class="emphasis"><em>Handler</em></span></a><span class="special">,</span>
    <span class="keyword">class</span> <a href="../../../../../../doc/html/boost_asio/reference/Executor1.html" target="_top"><span class="emphasis"><em>Executor1</em></span></a><span class="special">,</span>
    <span class="keyword">class</span> <a href="https://en.cppreference.com/w/cpp/named_req/Allocator" target="_top"><span class="emphasis"><em>Allocator</em></span></a> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;&gt;</span>
<span class="keyword">class</span> <span class="identifier">stable_async_base</span> <span class="special">:</span>
    <span class="keyword">public</span> <span class="identifier">async_base</span><span class="special">&lt;</span> <span class="identifier">Handler</span><span class="special">,</span> <span class="identifier">Executor1</span><span class="special">,</span> <span class="identifier">Allocator</span> <span class="special">&gt;</span>
</pre>
<h5>
<a name="beast.ref.boost__beast__stable_async_base.h1"></a>
        <span class="phrase"><a name="beast.ref.boost__beast__stable_async_base.types"></a></span><a class="link" href="boost__beast__stable_async_base.html#beast.ref.boost__beast__stable_async_base.types">Types</a>
      </h5>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                <p>
                  Name
                </p>
              </th>
<th>
                <p>
                  Description
                </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
                <p>
                  <a class="link" href="boost__beast__stable_async_base/allocator_type.html" title="stable_async_base::allocator_type"><span class="bold"><strong>allocator_type</strong></span></a>
                </p>
              </td>
<td>
                <p>
                  The type of allocator associated with this object.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <a class="link" href="boost__beast__stable_async_base/executor_type.html" title="stable_async_base::executor_type"><span class="bold"><strong>executor_type</strong></span></a>
                </p>
              </td>
<td>
                <p>
                  The type of executor associated with this object.
                </p>
              </td>
</tr>
</tbody>
</table></div>
<h5>
<a name="beast.ref.boost__beast__stable_async_base.h2"></a>
        <span class="phrase"><a name="beast.ref.boost__beast__stable_async_base.member_functions"></a></span><a class="link" href="boost__beast__stable_async_base.html#beast.ref.boost__beast__stable_async_base.member_functions">Member
        Functions</a>
      </h5>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                <p>
                  Name
                </p>
              </th>
<th>
                <p>
                  Description
                </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
                <p>
                  <a class="link" href="boost__beast__stable_async_base/complete.html" title="stable_async_base::complete"><span class="bold"><strong>complete</strong></span></a>
                </p>
              </td>
<td>
                <p>
                  Invoke the final completion handler, maybe using post.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <a class="link" href="boost__beast__stable_async_base/complete_now.html" title="stable_async_base::complete_now"><span class="bold"><strong>complete_now</strong></span></a>
                </p>
              </td>
<td>
                <p>
                  Invoke the final completion handler.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <a class="link" href="boost__beast__stable_async_base/get_allocator.html" title="stable_async_base::get_allocator"><span class="bold"><strong>get_allocator</strong></span></a>
                </p>
              </td>
<td>
                <p>
                  Returns the allocator associated with this object.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <a class="link" href="boost__beast__stable_async_base/get_executor.html" title="stable_async_base::get_executor"><span class="bold"><strong>get_executor</strong></span></a>
                </p>
              </td>
<td>
                <p>
                  Returns the executor associated with this object.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <a class="link" href="boost__beast__stable_async_base/handler.html" title="stable_async_base::handler"><span class="bold"><strong>handler</strong></span></a>
                </p>
              </td>
<td>
                <p>
                  Returns the handler associated with this object.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <a class="link" href="boost__beast__stable_async_base/release_handler.html" title="stable_async_base::release_handler"><span class="bold"><strong>release_handler</strong></span></a>
                </p>
              </td>
<td>
                <p>
                  Returns ownership of the handler associated with this object.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <a class="link" href="boost__beast__stable_async_base/stable_async_base.html" title="stable_async_base::stable_async_base"><span class="bold"><strong>stable_async_base</strong></span></a>
                </p>
              </td>
<td>
                <p>
                  Constructor.
                </p>
                <p>
                  Move Constructor.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <a class="link" href="boost__beast__stable_async_base/stable_async_base_dtor_.html" title="stable_async_base::~stable_async_base"><span class="bold"><strong>~stable_async_base</strong></span></a>
                </p>
              </td>
<td>
                <p>
                  Destructor.
                </p>
              </td>
</tr>
</tbody>
</table></div>
<h5>
<a name="beast.ref.boost__beast__stable_async_base.h3"></a>
        <span class="phrase"><a name="beast.ref.boost__beast__stable_async_base.friends"></a></span><a class="link" href="boost__beast__stable_async_base.html#beast.ref.boost__beast__stable_async_base.friends">Friends</a>
      </h5>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                <p>
                  Name
                </p>
              </th>
<th>
                <p>
                  Description
                </p>
              </th>
</tr></thead>
<tbody><tr>
<td>
                <p>
                  <a class="link" href="boost__beast__stable_async_base/allocate_stable.html" title="stable_async_base::allocate_stable"><span class="bold"><strong>allocate_stable</strong></span></a>
                </p>
              </td>
<td>
                <p>
                  Allocate a temporary object to hold operation state.
                </p>
              </td>
</tr></tbody>
</table></div>
<h5>
<a name="beast.ref.boost__beast__stable_async_base.h4"></a>
        <span class="phrase"><a name="beast.ref.boost__beast__stable_async_base.description"></a></span><a class="link" href="boost__beast__stable_async_base.html#beast.ref.boost__beast__stable_async_base.description">Description</a>
      </h5>
<p>
        A function object submitted to intermediate initiating functions during a
        composed operation may derive from this type to inherit all of the boilerplate
        to forward the executor, allocator, and legacy customization points associated
        with the completion handler invoked at the end of the composed operation.
        The composed operation must be typical; that is, associated with one executor
        of an I/O object, and invoking a caller-provided completion handler when
        the operation is finished. Classes derived from <a class="link" href="boost__beast__async_base.html" title="async_base"><code class="computeroutput"><span class="identifier">async_base</span></code></a> will acquire these properties:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            Ownership of the final completion handler provided upon construction.
          </li>
<li class="listitem">
            If the final handler has an associated allocator, this allocator will
            be propagated to the composed operation subclass. Otherwise, the associated
            allocator will be the type specified in the allocator template parameter,
            or the default of <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;</span></code> if the parameter is omitted.
          </li>
<li class="listitem">
            If the final handler has an associated executor, then it will be used
            as the executor associated with the composed operation. Otherwise, the
            specified <code class="computeroutput"><span class="identifier">Executor1</span></code> will
            be the type of executor associated with the composed operation.
          </li>
<li class="listitem">
            An instance of <code class="computeroutput"><span class="identifier">net</span><span class="special">::</span><span class="identifier">executor_work_guard</span></code> for the instance
            of <code class="computeroutput"><span class="identifier">Executor1</span></code> shall be
            maintained until either the final handler is invoked, or the operation
            base is destroyed, whichever comes first.
          </li>
<li class="listitem">
            Calls to the legacy customization points <code class="computeroutput"><span class="identifier">asio_handler_invoke</span></code>,
            <code class="computeroutput"><span class="identifier">asio_handler_allocate</span></code>,
            <code class="computeroutput"><span class="identifier">asio_handler_deallocate</span></code>,
            and <code class="computeroutput"><span class="identifier">asio_handler_is_continuation</span></code>,
            which use argument-dependent lookup, will be forwarded to the legacy
            customization points associated with the handler.
          </li>
</ul></div>
<p>
        Data members of composed operations implemented as completion handlers do
        not have stable addresses, as the composed operation object is move constructed
        upon each call to an initiating function. For most operations this is not
        a problem. For complex operations requiring stable temporary storage, the
        class <a class="link" href="boost__beast__stable_async_base.html" title="stable_async_base"><code class="computeroutput"><span class="identifier">stable_async_base</span></code></a> is provided which
        offers additional functionality:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            The free function <a class="link" href="boost__beast__allocate_stable.html" title="allocate_stable"><code class="computeroutput"><span class="identifier">allocate_stable</span></code></a> may be used
            to allocate one or more temporary objects associated with the composed
            operation.
          </li>
<li class="listitem">
            Memory for stable temporary objects is allocated using the allocator
            associated with the composed operation.
          </li>
<li class="listitem">
            Stable temporary objects are automatically destroyed, and the memory
            freed using the associated allocator, either before the final completion
            handler is invoked (a Networking requirement) or when the composed operation
            is destroyed, whichever occurs first.
          </li>
</ul></div>
<h5>
<a name="beast.ref.boost__beast__stable_async_base.h5"></a>
        <span class="phrase"><a name="beast.ref.boost__beast__stable_async_base.example"></a></span><a class="link" href="boost__beast__stable_async_base.html#beast.ref.boost__beast__stable_async_base.example">Example</a>
      </h5>
<p>
        The following code demonstrates how <a class="link" href="boost__beast__stable_async_base.html" title="stable_async_base"><code class="computeroutput"><span class="identifier">stable_async_base</span></code></a> may be be used
        to assist authoring an asynchronous initiating function, by providing all
        of the boilerplate to manage the final completion handler in a way that maintains
        the allocator and executor associations. Furthermore, the operation shown
        allocates temporary memory using <a class="link" href="boost__beast__allocate_stable.html" title="allocate_stable"><code class="computeroutput"><span class="identifier">allocate_stable</span></code></a> for the timer and
        message, whose addresses must not change between intermediate operations:
      </p>
<pre class="programlisting"><span class="comment">// Asynchronously send a message multiple times, once per second</span>
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">AsyncWriteStream</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">WriteHandler</span><span class="special">&gt;</span>
<span class="keyword">auto</span> <span class="identifier">async_write_messages</span><span class="special">(</span>
    <span class="identifier">AsyncWriteStream</span><span class="special">&amp;</span> <span class="identifier">stream</span><span class="special">,</span>
    <span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">message</span><span class="special">,</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">repeat_count</span><span class="special">,</span>
    <span class="identifier">WriteHandler</span><span class="special">&amp;&amp;</span> <span class="identifier">handler</span><span class="special">)</span> <span class="special">-&gt;</span>
        <span class="keyword">typename</span> <span class="identifier">net</span><span class="special">::</span><span class="identifier">async_result</span><span class="special">&lt;</span>
            <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">decay</span><span class="special">&lt;</span><span class="identifier">WriteHandler</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">,</span>
            <span class="keyword">void</span><span class="special">(</span><span class="identifier">error_code</span><span class="special">)&gt;::</span><span class="identifier">return_type</span>
<span class="special">{</span>
    <span class="keyword">using</span> <span class="identifier">handler_type</span> <span class="special">=</span> <span class="keyword">typename</span> <span class="identifier">net</span><span class="special">::</span><span class="identifier">async_completion</span><span class="special">&lt;</span><span class="identifier">WriteHandler</span><span class="special">,</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">error_code</span><span class="special">)&gt;::</span><span class="identifier">completion_handler_type</span><span class="special">;</span>
    <span class="keyword">using</span> <span class="identifier">base_type</span> <span class="special">=</span> <span class="identifier">stable_async_base</span><span class="special">&lt;</span><span class="identifier">handler_type</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">AsyncWriteStream</span><span class="special">::</span><span class="identifier">executor_type</span><span class="special">&gt;;</span>

    <span class="keyword">struct</span> <span class="identifier">op</span> <span class="special">:</span> <span class="identifier">base_type</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">coroutine</span>
    <span class="special">{</span>
        <span class="comment">// This object must have a stable address</span>
        <span class="keyword">struct</span> <span class="identifier">temporary_data</span>
        <span class="special">{</span>
            <span class="comment">// Although std::string is in theory movable, most implementations</span>
            <span class="comment">// use a "small buffer optimization" which means that we might</span>
            <span class="comment">// be submitting a buffer to the write operation and then</span>
            <span class="comment">// moving the string, invalidating the buffer. To prevent</span>
            <span class="comment">// undefined behavior we store the string object itself at</span>
            <span class="comment">// a stable location.</span>
            <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span> <span class="identifier">message</span><span class="special">;</span>

            <span class="identifier">net</span><span class="special">::</span><span class="identifier">steady_timer</span> <span class="identifier">timer</span><span class="special">;</span>

            <span class="identifier">temporary_data</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">message_</span><span class="special">,</span> <span class="identifier">net</span><span class="special">::</span><span class="identifier">io_context</span><span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span>
                <span class="special">:</span> <span class="identifier">message</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">message_</span><span class="special">))</span>
                <span class="special">,</span> <span class="identifier">timer</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span>
            <span class="special">{</span>
            <span class="special">}</span>
        <span class="special">};</span>

        <span class="identifier">AsyncWriteStream</span><span class="special">&amp;</span> <span class="identifier">stream_</span><span class="special">;</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">repeats_</span><span class="special">;</span>
        <span class="identifier">temporary_data</span><span class="special">&amp;</span> <span class="identifier">data_</span><span class="special">;</span>

        <span class="identifier">op</span><span class="special">(</span><span class="identifier">AsyncWriteStream</span><span class="special">&amp;</span> <span class="identifier">stream</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">repeats</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">message</span><span class="special">,</span> <span class="identifier">handler_type</span><span class="special">&amp;</span> <span class="identifier">handler</span><span class="special">)</span>
            <span class="special">:</span> <span class="identifier">base_type</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">handler</span><span class="special">),</span> <span class="identifier">stream</span><span class="special">.</span><span class="identifier">get_executor</span><span class="special">())</span>
            <span class="special">,</span> <span class="identifier">stream_</span><span class="special">(</span><span class="identifier">stream</span><span class="special">)</span>
            <span class="special">,</span> <span class="identifier">repeats_</span><span class="special">(</span><span class="identifier">repeats</span><span class="special">)</span>
            <span class="special">,</span> <span class="identifier">data_</span><span class="special">(</span><span class="identifier">allocate_stable</span><span class="special">&lt;</span><span class="identifier">temporary_data</span><span class="special">&gt;(*</span><span class="keyword">this</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">message</span><span class="special">),</span> <span class="identifier">stream</span><span class="special">.</span><span class="identifier">get_executor</span><span class="special">().</span><span class="identifier">context</span><span class="special">()))</span>
        <span class="special">{</span>
            <span class="special">(*</span><span class="keyword">this</span><span class="special">)();</span> <span class="comment">// start the operation</span>
        <span class="special">}</span>

        <span class="comment">// Including this file provides the keywords for macro-based coroutines</span>
        <span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">asio</span><span class="special">/</span><span class="identifier">yield</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

        <span class="keyword">void</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">error_code</span> <span class="identifier">ec</span> <span class="special">=</span> <span class="special">{},</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span>
        <span class="special">{</span>
            <span class="identifier">reenter</span><span class="special">(*</span><span class="keyword">this</span><span class="special">)</span>
            <span class="special">{</span>
                <span class="comment">// If repeats starts at 0 then we must complete immediately. But</span>
                <span class="comment">// we can't call the final handler from inside the initiating</span>
                <span class="comment">// function, so we post our intermediate handler first. We use</span>
                <span class="comment">// net::async_write with an empty buffer instead of calling</span>
                <span class="comment">// net::post to avoid an extra function template instantiation, to</span>
                <span class="comment">// keep compile times lower and make the resulting executable smaller.</span>
                <span class="identifier">yield</span> <span class="identifier">net</span><span class="special">::</span><span class="identifier">async_write</span><span class="special">(</span><span class="identifier">stream_</span><span class="special">,</span> <span class="identifier">net</span><span class="special">::</span><span class="identifier">const_buffer</span><span class="special">{},</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(*</span><span class="keyword">this</span><span class="special">));</span>
                <span class="keyword">while</span><span class="special">(!</span> <span class="identifier">ec</span> <span class="special">&amp;&amp;</span> <span class="identifier">repeats_</span><span class="special">--</span> <span class="special">&gt;</span> <span class="number">0</span><span class="special">)</span>
                <span class="special">{</span>
                    <span class="comment">// Send the string. We construct a `const_buffer` here to guarantee</span>
                    <span class="comment">// that we do not create an additional function template instantation</span>
                    <span class="comment">// of net::async_write, since we already instantiated it above for</span>
                    <span class="comment">// net::const_buffer.</span>

                    <span class="identifier">yield</span> <span class="identifier">net</span><span class="special">::</span><span class="identifier">async_write</span><span class="special">(</span><span class="identifier">stream_</span><span class="special">,</span>
                        <span class="identifier">net</span><span class="special">::</span><span class="identifier">const_buffer</span><span class="special">(</span><span class="identifier">net</span><span class="special">::</span><span class="identifier">buffer</span><span class="special">(</span><span class="identifier">data_</span><span class="special">.</span><span class="identifier">message</span><span class="special">)),</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(*</span><span class="keyword">this</span><span class="special">));</span>
                    <span class="keyword">if</span><span class="special">(</span><span class="identifier">ec</span><span class="special">)</span>
                        <span class="keyword">break</span><span class="special">;</span>

                    <span class="comment">// Set the timer and wait</span>
                    <span class="identifier">data_</span><span class="special">.</span><span class="identifier">timer</span><span class="special">.</span><span class="identifier">expires_after</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">seconds</span><span class="special">(</span><span class="number">1</span><span class="special">));</span>
                    <span class="identifier">yield</span> <span class="identifier">data_</span><span class="special">.</span><span class="identifier">timer</span><span class="special">.</span><span class="identifier">async_wait</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(*</span><span class="keyword">this</span><span class="special">));</span>
                <span class="special">}</span>
            <span class="special">}</span>

            <span class="comment">// The base class destroys the temporary data automatically,</span>
            <span class="comment">// before invoking the final completion handler</span>
            <span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">complete_now</span><span class="special">(</span><span class="identifier">ec</span><span class="special">);</span>
        <span class="special">}</span>

        <span class="comment">// Including this file undefines the macros for the coroutines</span>
        <span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">asio</span><span class="special">/</span><span class="identifier">unyield</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
    <span class="special">};</span>

    <span class="identifier">net</span><span class="special">::</span><span class="identifier">async_completion</span><span class="special">&lt;</span><span class="identifier">WriteHandler</span><span class="special">,</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">error_code</span><span class="special">)&gt;</span> <span class="identifier">completion</span><span class="special">(</span><span class="identifier">handler</span><span class="special">);</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostringstream</span> <span class="identifier">os</span><span class="special">;</span>
    <span class="identifier">os</span> <span class="special">&lt;&lt;</span> <span class="identifier">message</span><span class="special">;</span>
    <span class="identifier">op</span><span class="special">(</span><span class="identifier">stream</span><span class="special">,</span> <span class="identifier">repeat_count</span><span class="special">,</span> <span class="identifier">os</span><span class="special">.</span><span class="identifier">str</span><span class="special">(),</span> <span class="identifier">completion</span><span class="special">.</span><span class="identifier">completion_handler</span><span class="special">);</span>
    <span class="keyword">return</span> <span class="identifier">completion</span><span class="special">.</span><span class="identifier">result</span><span class="special">.</span><span class="identifier">get</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<h5>
<a name="beast.ref.boost__beast__stable_async_base.h6"></a>
        <span class="phrase"><a name="beast.ref.boost__beast__stable_async_base.template_parameters"></a></span><a class="link" href="boost__beast__stable_async_base.html#beast.ref.boost__beast__stable_async_base.template_parameters">Template
        Parameters</a>
      </h5>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                <p>
                  Type
                </p>
              </th>
<th>
                <p>
                  Description
                </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">Handler</span></code>
                </p>
              </td>
<td>
                <p>
                  The type of the completion handler to store. This type must meet
                  the requirements of <span class="emphasis"><em>CompletionHandler</em></span>.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">Executor1</span></code>
                </p>
              </td>
<td>
                <p>
                  The type of the executor used when the handler has no associated
                  executor. An instance of this type must be provided upon construction.
                  The implementation will maintain an executor work guard and a copy
                  of this instance.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">Allocator</span></code>
                </p>
              </td>
<td>
                <p>
                  The allocator type to use if the handler does not have an associated
                  allocator. If this parameter is omitted, then <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;</span></code> will be used. If the specified
                  allocator is not default constructible, an instance of the type
                  must be provided upon construction.
                </p>
              </td>
</tr>
</tbody>
</table></div>
<h5>
<a name="beast.ref.boost__beast__stable_async_base.h7"></a>
        <span class="phrase"><a name="beast.ref.boost__beast__stable_async_base.see_also"></a></span><a class="link" href="boost__beast__stable_async_base.html#beast.ref.boost__beast__stable_async_base.see_also">See
        Also</a>
      </h5>
<p>
        <a class="link" href="boost__beast__stable_async_base/allocate_stable.html" title="stable_async_base::allocate_stable"><code class="computeroutput"><span class="identifier">stable_async_base</span><span class="special">::</span><span class="identifier">allocate_stable</span></code></a>, <a class="link" href="boost__beast__async_base.html" title="async_base"><code class="computeroutput"><span class="identifier">async_base</span></code></a>
      </p>
<p>
        Convenience header <code class="literal">&lt;<a href="../../../../../../boost/beast/core.hpp" target="_top">boost/beast/core.hpp</a>&gt;</code>
      </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2016-2019 Vinnie
      Falco<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="boost__beast__ssl_stream/write_some/overload2.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../ref.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="boost__beast__stable_async_base/allocate_stable.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
