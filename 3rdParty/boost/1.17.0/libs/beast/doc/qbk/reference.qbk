[/
    Copyright (c) 2013-2016 Vinnie Falco (vinnie dot falco at gmail dot com)

    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
]

[section:boost__beast__allocate_stable allocate_stable][indexterm1 allocate_stable]
Allocate a temporary object to hold stable asynchronous operation state. [heading Synopsis]Defined in header [include_file boost/beast/core/async_base.hpp]```template<    class State,    class __Handler__,    class __Executor1__,    class __Allocator__,    class... Args>State&allocate_stable(    stable_async_base< Handler, Executor1, Allocator >& base,    Args&&... args);```[heading Description]
The object will be destroyed just before the completion handler is invoked, or when the base is destroyed.
[heading Template Parameters][table [[Type][Description]]  [[`State`][    
The type of object to allocate.  ]]]
[heading Parameters][table [[Name][Description]]  [[`base`][    
The helper to allocate from.  ]]  [[`args`][    
An optional list of parameters to forward to the constructor of the object being allocated.  ]]]
[heading See Also]
[link beast.ref.boost__beast__stable_async_base `stable_async_base`] 
Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__async_base async_base]
Base class to assist writing composed operations. [heading Synopsis]Defined in header [include_file boost/beast/core/async_base.hpp]```template<    class __Handler__,    class __Executor1__,    class __Allocator__ = std::allocator<void>>class async_base```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__async_base.allocator_type [*allocator_type]]]    [      The type of allocator associated with this object.     ]  ]  [    [[link beast.ref.boost__beast__async_base.executor_type [*executor_type]]]    [      The type of executor associated with this object.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__async_base.async_base [*async_base]]]    [      Constructor.       Move Constructor.     ]  ]  [    [[link beast.ref.boost__beast__async_base.complete [*complete]]]    [      Invoke the final completion handler, maybe using post.     ]  ]  [    [[link beast.ref.boost__beast__async_base.complete_now [*complete_now]]]    [      Invoke the final completion handler.     ]  ]  [    [[link beast.ref.boost__beast__async_base.get_allocator [*get_allocator]]]    [      Returns the allocator associated with this object.     ]  ]  [    [[link beast.ref.boost__beast__async_base.get_executor [*get_executor]]]    [      Returns the executor associated with this object.     ]  ]  [    [[link beast.ref.boost__beast__async_base.handler [*handler]]]    [      Returns the handler associated with this object.     ]  ]  [    [[link beast.ref.boost__beast__async_base.release_handler [*release_handler]]]    [      Returns ownership of the handler associated with this object.     ]  ]][heading Description]
A function object submitted to intermediate initiating functions during a composed operation may derive from this type to inherit all of the boilerplate to forward the executor, allocator, and legacy customization points associated with the completion handler invoked at the end of the composed operation.
The composed operation must be typical; that is, associated with one executor of an I/O object, and invoking a caller-provided completion handler when the operation is finished. Classes derived from [link beast.ref.boost__beast__async_base `async_base`] will acquire these properties:

* Ownership of the final completion handler provided upon construction.


* If the final handler has an associated allocator, this allocator will be propagated to the composed operation subclass. Otherwise, the associated allocator will be the type specified in the allocator template parameter, or the default of `std::allocator<void>` if the parameter is omitted.


* If the final handler has an associated executor, then it will be used as the executor associated with the composed operation. Otherwise, the specified `Executor1` will be the type of executor associated with the composed operation.


* An instance of `net::executor_work_guard` for the instance of `Executor1` shall be maintained until either the final handler is invoked, or the operation base is destroyed, whichever comes first.


* Calls to the legacy customization points `asio_handler_invoke`, `asio_handler_allocate`, `asio_handler_deallocate`, and `asio_handler_is_continuation`, which use argument-dependent lookup, will be forwarded to the legacy customization points associated with the handler.

[heading Example]

The following code demonstrates how [link beast.ref.boost__beast__async_base `async_base`] may be be used to assist authoring an asynchronous initiating function, by providing all of the boilerplate to manage the final completion handler in a way that maintains the allocator and executor associations:
```  // Asynchronously read into a buffer until the buffer is full, or an error occurs
  template<class AsyncReadStream, class ReadHandler>
  typename net::async_result<ReadHandler, void(error_code, std::size_t)>::return_type
  async_read(AsyncReadStream& stream, net::mutable_buffer buffer, ReadHandler&& handler)
  {
      using handler_type = BOOST_ASIO_HANDLER_TYPE(ReadHandler, void(error_code, std::size_t));
      using base_type = async_base<handler_type, typename AsyncReadStream::executor_type>;

      struct op : base_type
      {
          AsyncReadStream& stream_;
          net::mutable_buffer buffer_;
          std::size_t total_bytes_transferred_;

          op(
              AsyncReadStream& stream,
              net::mutable_buffer buffer,
              handler_type& handler)
              : base_type(std::move(handler), stream.get_executor())
              , stream_(stream)
              , buffer_(buffer)
              , total_bytes_transferred_(0)
          {
              (*this)({}, 0, false); // start the operation
          }

          void operator()(error_code ec, std::size_t bytes_transferred, bool is_continuation = true)
          {
              // Adjust the count of bytes and advance our buffer
              total_bytes_transferred_ += bytes_transferred;
              buffer_ = buffer_ + bytes_transferred;

              // Keep reading until buffer is full or an error occurs
              if(! ec && buffer_.size() > 0)
                  return stream_.async_read_some(buffer_, std::move(*this));

              // Call the completion handler with the result. If `is_continuation` is
              // false, which happens on the first time through this function, then
              // `net::post` will be used to call the completion handler, otherwise
              // the completion handler will be invoked directly.

              this->invoke(is_continuation, ec, total_bytes_transferred_);
          }
      };

      net::async_completion<ReadHandler, void(error_code, std::size_t)> init{handler};
      op(stream, buffer, init.completion_handler);
      return init.result.get();
  }
```
Data members of composed operations implemented as completion handlers do not have stable addresses, as the composed operation object is move constructed upon each call to an initiating function. For most operations this is not a problem. For complex operations requiring stable temporary storage, the class [link beast.ref.boost__beast__stable_async_base `stable_async_base`] is provided which offers additional functionality:

* The free function [link beast.ref.boost__beast__allocate_stable `allocate_stable`] may be used to allocate one or more temporary objects associated with the composed operation.


* Memory for stable temporary objects is allocated using the allocator associated with the composed operation.


* Stable temporary objects are automatically destroyed, and the memory freed using the associated allocator, either before the final completion handler is invoked (a Networking requirement) or when the composed operation is destroyed, whichever occurs first.

[heading Temporary Storage Example]

The following example demonstrates how a composed operation may store a temporary object.
``````
[heading Template Parameters][table [[Type][Description]]  [[`Handler`][    
The type of the completion handler to store. This type must meet the requirements of ['CompletionHandler].  ]]  [[`Executor1`][    
The type of the executor used when the handler has no associated executor. An instance of this type must be provided upon construction. The implementation will maintain an executor work guard and a copy of this instance.  ]]  [[`Allocator`][    
The allocator type to use if the handler does not have an associated allocator. If this parameter is omitted, then `std::allocator<void>` will be used. If the specified allocator is not default constructible, an instance of the type must be provided upon construction.  ]]]
[heading See Also]
[link beast.ref.boost__beast__stable_async_base `stable_async_base`] 
[section:allocator_type async_base::allocator_type][indexterm2 allocator_type..async_base]
The type of allocator associated with this object. [heading Synopsis]```using allocator_type = net::associated_allocator_t< Handler, Allocator >;```[heading Description]
If a class derived from [link beast.ref.boost__beast__async_base `async_base`] is a completion handler, then the associated allocator of the derived class will be this type. [endsect][section:async_base async_base::async_base][indexterm2 async_base..async_base]
Constructor. ```template<    class __Handler__>``[link beast.ref.boost__beast__async_base.async_base.overload1 async_base]``(    Handler&& handler,    Executor1 const& ex1,    Allocator const& alloc = Allocator());  ``[''''&raquo;''' [link beast.ref.boost__beast__async_base.async_base.overload1 more...]]`````
Move Constructor. `````[link beast.ref.boost__beast__async_base.async_base.overload2 async_base]``(    async_base&& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__async_base.async_base.overload2 more...]]`````[section:overload1 async_base::async_base (1 of 2 overloads)]
Constructor. [heading Synopsis]```template<    class __Handler__>async_base(    Handler&& handler,    Executor1 const& ex1,    Allocator const& alloc = Allocator());```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`handler`][    
The final completion handler. The type of this object must meet the requirements of ['CompletionHandler]. The implementation takes ownership of the handler by performing a decay-copy.  ]]  [[`ex1`][    
The executor associated with the implied I/O object target of the operation. The implementation shall maintain an executor work guard for the lifetime of the operation, or until the final completion handler is invoked, whichever is shorter.  ]]  [[`alloc`][    
The allocator to be associated with objects derived from this class. If `Allocator` is default-constructible, this parameter is optional and may be omitted.   ]]]
[endsect][section:overload2 async_base::async_base (2 of 2 overloads)]
Move Constructor. [heading Synopsis]```async_base(    async_base&& other);```[heading Description][endsect][endsect][section:complete async_base::complete][indexterm2 complete..async_base]
Invoke the final completion handler, maybe using post. [heading Synopsis]```template<    class... Args>voidcomplete(    bool is_continuation,    Args&&... args);```[heading Description]
This invokes the final completion handler with the specified arguments forwarded. It is undefined to call either of [link beast.ref.boost__beast__async_base.complete `async_base::complete`] or [link beast.ref.boost__beast__async_base.complete_now `async_base::complete_now`] more than once.
Any temporary objects allocated with [link beast.ref.boost__beast__allocate_stable `allocate_stable`] will be automatically destroyed before the final completion handler is invoked.
[heading Parameters][table [[Name][Description]]  [[`is_continuation`][    
If this value is `false`, then the handler will be submitted to the executor using `net::post`. Otherwise the handler will be invoked as if by calling [link beast.ref.boost__beast__async_base.complete_now `async_base::complete_now`].  ]]  [[`args`][    
A list of optional parameters to invoke the handler with. The completion handler must be invocable with the parameter list, or else a compilation error will result.   ]]]
[endsect][section:complete_now async_base::complete_now][indexterm2 complete_now..async_base]
Invoke the final completion handler. [heading Synopsis]```template<    class... Args>voidcomplete_now(    Args&&... args);```[heading Description]
This invokes the final completion handler with the specified arguments forwarded. It is undefined to call either of [link beast.ref.boost__beast__async_base.complete `async_base::complete`] or [link beast.ref.boost__beast__async_base.complete_now `async_base::complete_now`] more than once.
Any temporary objects allocated with [link beast.ref.boost__beast__allocate_stable `allocate_stable`] will be automatically destroyed before the final completion handler is invoked.
[heading Parameters][table [[Name][Description]]  [[`args`][    
A list of optional parameters to invoke the handler with. The completion handler must be invocable with the parameter list, or else a compilation error will result.   ]]]
[endsect][section:executor_type async_base::executor_type][indexterm2 executor_type..async_base]
The type of executor associated with this object. [heading Synopsis]```using executor_type = net::associated_executor_t< Handler, Executor1 >;```[heading Description]
If a class derived from [link beast.ref.boost__beast__async_base `async_base`] is a completion handler, then the associated executor of the derived class will be this type. [endsect][section:get_allocator async_base::get_allocator][indexterm2 get_allocator..async_base]
Returns the allocator associated with this object. [heading Synopsis]```allocator_typeget_allocator() const;```[heading Description]
If a class derived from [link beast.ref.boost__beast__async_base `async_base`] is a completion handler, then the object returned from this function will be used as the associated allocator of the derived class. [endsect][section:get_executor async_base::get_executor][indexterm2 get_executor..async_base]
Returns the executor associated with this object. [heading Synopsis]```executor_typeget_executor() const;```[heading Description]
If a class derived from [link beast.ref.boost__beast__async_base `async_base`] is a completion handler, then the object returned from this function will be used as the associated executor of the derived class. [endsect][section:handler async_base::handler][indexterm2 handler..async_base]
Returns the handler associated with this object. [heading Synopsis]```Handler const &handler() const;```[heading Description][endsect][section:release_handler async_base::release_handler][indexterm2 release_handler..async_base]
Returns ownership of the handler associated with this object. [heading Synopsis]```Handlerrelease_handler();```[heading Description]
This function is used to transfer ownership of the handler to the caller, by move-construction. After the move, the only valid operations on the base object are move construction and destruction. [endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__async_detect_ssl async_detect_ssl][indexterm1 async_detect_ssl]
Detect a TLS/SSL handshake asynchronously on a stream. [heading Synopsis]Defined in header [include_file boost/beast/core/detect_ssl.hpp]```template<    class __AsyncReadStream__,    class __DynamicBuffer__,    class __CompletionToken__>``__deduced__``async_detect_ssl(    AsyncReadStream& stream,    DynamicBuffer& buffer,    CompletionToken&& token);```[heading Description]
This function reads asynchronously from a stream to determine if a client handshake message is being received.
This call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:

* A TLS client opening handshake is detected,


* The received data is invalid for a TLS client handshake, or


* An error occurs.

The algorithm, known as a ['composed asynchronous operation], is implemented in terms of calls to the next layer's `async_read_some` function. The program must ensure that no other calls to `async_read_some` are performed until this operation completes.
Bytes read from the stream will be stored in the passed dynamic buffer, which may be used to perform the TLS handshake if the detector returns true, or be otherwise consumed by the caller based on the expected protocol.
[heading Parameters][table [[Name][Description]]  [[`stream`][    
The stream to read from. This type must meet the requirements of ['AsyncReadStream].  ]]  [[`buffer`][    
The dynamic buffer to use. This type must meet the requirements of ['DynamicBuffer].  ]]  [[`token`][    
The completion token used to determine the method used to provide the result of the asynchronous operation. If this is a completion handler, the implementation takes ownership of the handler by performing a decay-copy, and the equivalent function signature of the handler must be: ```  void handler(
      error_code const& error,    // Set to the error, if any
      bool result                 // The result of the detector
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.   ]]]
Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__async_teardown async_teardown][indexterm1 async_teardown]
Start tearing down a `net::ssl::stream`. [heading Synopsis]Defined in header [include_file boost/beast/websocket/ssl.hpp]```template<    class __AsyncStream__,    class TeardownHandler>voidasync_teardown(    role_type role,    net::ssl::stream< AsyncStream >& stream,    TeardownHandler&& handler);```[heading Description]
This begins tearing down a connection asynchronously. The implementation will call the overload of this function based on the `Stream` parameter used to consruct the socket. When `Stream` is a user defined type, and not a `net::ip::tcp::socket` or any `net::ssl::stream`, callers are responsible for providing a suitable overload of this function.
[heading Parameters][table [[Name][Description]]  [[`role`][    
The role of the local endpoint  ]]  [[`stream`][    
The stream to tear down.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      error_code const& error // result of operation
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.   ]]]
Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__basic_flat_buffer basic_flat_buffer]
A dynamic buffer providing buffer sequences of length one. [heading Synopsis]Defined in header [include_file boost/beast/core/flat_buffer.hpp]```template<    class __Allocator__>class basic_flat_buffer```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__basic_flat_buffer.allocator_type [*allocator_type]]]    [      The type of allocator used.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.const_buffers_type [*const_buffers_type]]]    [      The ConstBufferSequence used to represent the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.mutable_buffers_type [*mutable_buffers_type]]]    [      The MutableBufferSequence used to represent the writable bytes.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.mutable_data_type [*mutable_data_type]]]    [      The MutableBufferSequence used to represent the readable bytes.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer [*basic_flat_buffer]]]    [      Constructor.       Move Constructor.       Copy Constructor.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.capacity [*capacity]]]    [      Return the maximum number of bytes, both readable and writable, that can be held without requiring an allocation.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.cdata [*cdata]]]    [      Returns a constant buffer sequence representing the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.clear [*clear]]]    [      Set the size of the readable and writable bytes to zero.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.commit [*commit]]]    [      Append writable bytes to the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.consume [*consume]]]    [      Remove bytes from beginning of the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.data [*data]]]    [      Returns a constant buffer sequence representing the readable bytes.       Returns a mutable buffer sequence representing the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.get_allocator [*get_allocator]]]    [      Returns a copy of the allocator used.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.max_size [*max_size]]]    [      Set the maximum allowed capacity.       Return the maximum number of bytes, both readable and writable, that can ever be held.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.operator_eq_ [*operator=]]]    [      Move Assignment.       Copy Assignment.       Copy assignment.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.prepare [*prepare]]]    [      Returns a mutable buffer sequence representing writable bytes.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.reserve [*reserve]]]    [      Guarantee a minimum capacity.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.shrink_to_fit [*shrink_to_fit]]]    [      Reallocate the buffer to fit the readable bytes exactly.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.size [*size]]]    [      Returns the number of readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer_dtor_ [*~basic_flat_buffer]]]    [      Destructor.     ]  ]][heading Friends][table [[Name][Description]]  [    [[link beast.ref.boost__beast__basic_flat_buffer.swap [*swap]]]    [      Exchange two dynamic buffers.     ]  ]][heading Description]
A dynamic buffer encapsulates memory storage that may be automatically resized as required, where the memory is divided into two regions: readable bytes followed by writable bytes. These memory regions are internal to the dynamic buffer, but direct access to the elements is provided to permit them to be efficiently used with I/O operations.
Objects of this type meet the requirements of ['DynamicBuffer] and have the following additional properties:

* A mutable buffer sequence representing the readable bytes is returned by [link beast.ref.boost__beast__basic_flat_buffer.data `basic_flat_buffer::data`] when `this` is non-const.


* A configurable maximum buffer size may be set upon construction. Attempts to exceed the buffer size will throw `std::length_error`.


* Buffer sequences representing the readable and writable bytes, returned by [link beast.ref.boost__beast__basic_flat_buffer.data `basic_flat_buffer::data`] and [link beast.ref.boost__beast__basic_flat_buffer.prepare `basic_flat_buffer::prepare`], will have length one.

Upon construction, a maximum size for the buffer may be specified. If this limit is exceeded, the `std::length_error` exception will be thrown.
[heading Remarks]
This class is designed for use with algorithms that take dynamic buffers as parameters, and are optimized for the case where the input sequence or output sequence is stored in a single contiguous buffer. 
[section:allocator_type basic_flat_buffer::allocator_type][indexterm2 allocator_type..basic_flat_buffer]
The type of allocator used. [heading Synopsis]```using allocator_type = Allocator;```[heading Description][endsect][section:basic_flat_buffer basic_flat_buffer::basic_flat_buffer][indexterm2 basic_flat_buffer..basic_flat_buffer]
Constructor. `````[link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload1 basic_flat_buffer]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload1 more...]]``explicit``[link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload2 basic_flat_buffer]``(    std::size_t limit);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload2 more...]]``explicit``[link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload3 basic_flat_buffer]``(    Allocator const& alloc);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload3 more...]]````[link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload4 basic_flat_buffer]``(    std::size_t limit,    Allocator const& alloc);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload4 more...]]`````
Move Constructor. `````[link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload5 basic_flat_buffer]``(    basic_flat_buffer&& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload5 more...]]````[link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload6 basic_flat_buffer]``(    basic_flat_buffer&& other,    Allocator const& alloc);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload6 more...]]`````
Copy Constructor. `````[link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload7 basic_flat_buffer]``(    basic_flat_buffer const& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload7 more...]]````[link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload8 basic_flat_buffer]``(    basic_flat_buffer const& other,    Allocator const& alloc);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload8 more...]]``template<    class OtherAlloc>``[link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload9 basic_flat_buffer]``(    basic_flat_buffer< OtherAlloc > const& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload9 more...]]``template<    class OtherAlloc>``[link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload10 basic_flat_buffer]``(    basic_flat_buffer< OtherAlloc > const& other,    Allocator const& alloc);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload10 more...]]`````[section:overload1 basic_flat_buffer::basic_flat_buffer (1 of 10 overloads)]
Constructor. [heading Synopsis]```basic_flat_buffer();```[heading Description]
After construction, [link beast.ref.boost__beast__basic_flat_buffer.capacity `basic_flat_buffer::capacity`] will return zero, and [link beast.ref.boost__beast__basic_flat_buffer.max_size `basic_flat_buffer::max_size`] will return the largest value which may be passed to the allocator's `allocate` function. [endsect][section:overload2 basic_flat_buffer::basic_flat_buffer (2 of 10 overloads)]
Constructor. [heading Synopsis]```basic_flat_buffer(    std::size_t limit);```[heading Description]
After construction, [link beast.ref.boost__beast__basic_flat_buffer.capacity `basic_flat_buffer::capacity`] will return zero, and [link beast.ref.boost__beast__basic_flat_buffer.max_size `basic_flat_buffer::max_size`] will return the specified value of `limit`.
[heading Parameters][table [[Name][Description]]  [[`limit`][    
The desired maximum size.   ]]]
[endsect][section:overload3 basic_flat_buffer::basic_flat_buffer (3 of 10 overloads)]
Constructor. [heading Synopsis]```basic_flat_buffer(    Allocator const& alloc);```[heading Description]
After construction, [link beast.ref.boost__beast__basic_flat_buffer.capacity `basic_flat_buffer::capacity`] will return zero, and [link beast.ref.boost__beast__basic_flat_buffer.max_size `basic_flat_buffer::max_size`] will return the largest value which may be passed to the allocator's `allocate` function.
[heading Parameters][table [[Name][Description]]  [[`alloc`][    
The allocator to use for the object.  ]]]
[heading Exception Safety]

No-throw guarantee. [endsect][section:overload4 basic_flat_buffer::basic_flat_buffer (4 of 10 overloads)]
Constructor. [heading Synopsis]```basic_flat_buffer(    std::size_t limit,    Allocator const& alloc);```[heading Description]
After construction, [link beast.ref.boost__beast__basic_flat_buffer.capacity `basic_flat_buffer::capacity`] will return zero, and [link beast.ref.boost__beast__basic_flat_buffer.max_size `basic_flat_buffer::max_size`] will return the specified value of `limit`.
[heading Parameters][table [[Name][Description]]  [[`limit`][    
The desired maximum size.  ]]  [[`alloc`][    
The allocator to use for the object.  ]]]
[heading Exception Safety]

No-throw guarantee. [endsect][section:overload5 basic_flat_buffer::basic_flat_buffer (5 of 10 overloads)]
Move Constructor. [heading Synopsis]```basic_flat_buffer(    basic_flat_buffer&& other);```[heading Description]
The container is constructed with the contents of `other` using move semantics. The maximum size will be the same as the moved-from object.
Buffer sequences previously obtained from `other` using [link beast.ref.boost__beast__basic_flat_buffer.data `basic_flat_buffer::data`] or [link beast.ref.boost__beast__basic_flat_buffer.prepare `basic_flat_buffer::prepare`] remain valid after the move.
[heading Parameters][table [[Name][Description]]  [[`other`][    
The object to move from. After the move, the moved-from object will have zero capacity, zero readable bytes, and zero writable bytes.  ]]]
[heading Exception Safety]

No-throw guarantee. [endsect][section:overload6 basic_flat_buffer::basic_flat_buffer (6 of 10 overloads)]
Move Constructor. [heading Synopsis]```basic_flat_buffer(    basic_flat_buffer&& other,    Allocator const& alloc);```[heading Description]
Using `alloc` as the allocator for the new container, the contents of `other` are moved. If `alloc != other.get_allocator()`, this results in a copy. The maximum size will be the same as the moved-from object.
Buffer sequences previously obtained from `other` using [link beast.ref.boost__beast__basic_flat_buffer.data `basic_flat_buffer::data`] or [link beast.ref.boost__beast__basic_flat_buffer.prepare `basic_flat_buffer::prepare`] become invalid after the move.
[heading Parameters][table [[Name][Description]]  [[`other`][    
The object to move from. After the move, the moved-from object will have zero capacity, zero readable bytes, and zero writable bytes.  ]]  [[`alloc`][    
The allocator to use for the object.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::length_error`][    
if `other.size()` exceeds the maximum allocation size of `alloc`.   ]]]
[endsect][section:overload7 basic_flat_buffer::basic_flat_buffer (7 of 10 overloads)]
Copy Constructor. [heading Synopsis]```basic_flat_buffer(    basic_flat_buffer const& other);```[heading Description]
This container is constructed with the contents of `other` using copy semantics. The maximum size will be the same as the copied object.
[heading Parameters][table [[Name][Description]]  [[`other`][    
The object to copy from.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::length_error`][    
if `other.size()` exceeds the maximum allocation size of the allocator.   ]]]
[endsect][section:overload8 basic_flat_buffer::basic_flat_buffer (8 of 10 overloads)]
Copy Constructor. [heading Synopsis]```basic_flat_buffer(    basic_flat_buffer const& other,    Allocator const& alloc);```[heading Description]
This container is constructed with the contents of `other` using copy semantics and the specified allocator. The maximum size will be the same as the copied object.
[heading Parameters][table [[Name][Description]]  [[`other`][    
The object to copy from.  ]]  [[`alloc`][    
The allocator to use for the object.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::length_error`][    
if `other.size()` exceeds the maximum allocation size of `alloc`.   ]]]
[endsect][section:overload9 basic_flat_buffer::basic_flat_buffer (9 of 10 overloads)]
Copy Constructor. [heading Synopsis]```template<    class OtherAlloc>basic_flat_buffer(    basic_flat_buffer< OtherAlloc > const& other);```[heading Description]
This container is constructed with the contents of `other` using copy semantics. The maximum size will be the same as the copied object.
[heading Parameters][table [[Name][Description]]  [[`other`][    
The object to copy from.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::length_error`][    
if `other.size()` exceeds the maximum allocation size of the allocator.   ]]]
[endsect][section:overload10 basic_flat_buffer::basic_flat_buffer (10 of 10 overloads)]
Copy Constructor. [heading Synopsis]```template<    class OtherAlloc>basic_flat_buffer(    basic_flat_buffer< OtherAlloc > const& other,    Allocator const& alloc);```[heading Description]
This container is constructed with the contents of `other` using copy semantics. The maximum size will be the same as the copied object.
[heading Parameters][table [[Name][Description]]  [[`other`][    
The object to copy from.  ]]  [[`alloc`][    
The allocator to use for the object.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::length_error`][    
if `other.size()` exceeds the maximum allocation size of `alloc`.   ]]]
[endsect][endsect][section:capacity basic_flat_buffer::capacity][indexterm2 capacity..basic_flat_buffer]
Return the maximum number of bytes, both readable and writable, that can be held without requiring an allocation. [heading Synopsis]```std::size_tcapacity() const;```[heading Description][endsect][section:cdata basic_flat_buffer::cdata][indexterm2 cdata..basic_flat_buffer]
Returns a constant buffer sequence representing the readable bytes. [heading Synopsis]```const_buffers_typecdata() const;```[heading Description][endsect][section:clear basic_flat_buffer::clear][indexterm2 clear..basic_flat_buffer]
Set the size of the readable and writable bytes to zero. [heading Synopsis]```voidclear();```[heading Description]
This clears the buffer without changing capacity. Buffer sequences previously obtained using [link beast.ref.boost__beast__basic_flat_buffer.data `basic_flat_buffer::data`] or [link beast.ref.boost__beast__basic_flat_buffer.prepare `basic_flat_buffer::prepare`] become invalid.
[heading Exception Safety]

No-throw guarantee. [endsect][section:commit basic_flat_buffer::commit][indexterm2 commit..basic_flat_buffer]
Append writable bytes to the readable bytes. [heading Synopsis]```voidcommit(    std::size_t n);```[heading Description]
Appends n bytes from the start of the writable bytes to the end of the readable bytes. The remainder of the writable bytes are discarded. If n is greater than the number of writable bytes, all writable bytes are appended to the readable bytes.
All buffers sequences previously obtained using [link beast.ref.boost__beast__basic_flat_buffer.data `basic_flat_buffer::data`] or [link beast.ref.boost__beast__basic_flat_buffer.prepare `basic_flat_buffer::prepare`] become invalid.
[heading Parameters][table [[Name][Description]]  [[`n`][    
The number of bytes to append. If this number is greater than the number of writable bytes, all writable bytes are appended.  ]]]
[heading Exception Safety]

No-throw guarantee. [endsect][section:const_buffers_type basic_flat_buffer::const_buffers_type][indexterm2 const_buffers_type..basic_flat_buffer]
The ConstBufferSequence used to represent the readable bytes. [heading Synopsis]```using const_buffers_type = net::const_buffer;```[heading Description][endsect][section:consume basic_flat_buffer::consume][indexterm2 consume..basic_flat_buffer]
Remove bytes from beginning of the readable bytes. [heading Synopsis]```voidconsume(    std::size_t n);```[heading Description]
Removes n bytes from the beginning of the readable bytes.
All buffers sequences previously obtained using [link beast.ref.boost__beast__basic_flat_buffer.data `basic_flat_buffer::data`] or [link beast.ref.boost__beast__basic_flat_buffer.prepare `basic_flat_buffer::prepare`] become invalid.
[heading Parameters][table [[Name][Description]]  [[`n`][    
The number of bytes to remove. If this number is greater than the number of readable bytes, all readable bytes are removed.  ]]]
[heading Exception Safety]

No-throw guarantee. [endsect][section:data basic_flat_buffer::data][indexterm2 data..basic_flat_buffer]
Returns a constant buffer sequence representing the readable bytes. ```const_buffers_type``[link beast.ref.boost__beast__basic_flat_buffer.data.overload1 data]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_flat_buffer.data.overload1 more...]]`````
Returns a mutable buffer sequence representing the readable bytes. ```mutable_data_type``[link beast.ref.boost__beast__basic_flat_buffer.data.overload2 data]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_flat_buffer.data.overload2 more...]]`````[section:overload1 basic_flat_buffer::data (1 of 2 overloads)]
Returns a constant buffer sequence representing the readable bytes. [heading Synopsis]```const_buffers_typedata() const;```[heading Description][endsect][section:overload2 basic_flat_buffer::data (2 of 2 overloads)]
Returns a mutable buffer sequence representing the readable bytes. [heading Synopsis]```mutable_data_typedata();```[heading Description][endsect][endsect][section:get_allocator basic_flat_buffer::get_allocator][indexterm2 get_allocator..basic_flat_buffer]
Returns a copy of the allocator used. [heading Synopsis]```allocator_typeget_allocator() const;```[heading Description][endsect][section:max_size basic_flat_buffer::max_size][indexterm2 max_size..basic_flat_buffer]
Set the maximum allowed capacity. ```void``[link beast.ref.boost__beast__basic_flat_buffer.max_size.overload1 max_size]``(    std::size_t n);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_flat_buffer.max_size.overload1 more...]]`````
Return the maximum number of bytes, both readable and writable, that can ever be held. ```std::size_t``[link beast.ref.boost__beast__basic_flat_buffer.max_size.overload2 max_size]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_flat_buffer.max_size.overload2 more...]]`````[section:overload1 basic_flat_buffer::max_size (1 of 2 overloads)]
Set the maximum allowed capacity. [heading Synopsis]```voidmax_size(    std::size_t n);```[heading Description]
This function changes the currently configured upper limit on capacity to the specified value.
[heading Parameters][table [[Name][Description]]  [[`n`][    
The maximum number of bytes ever allowed for capacity.  ]]]
[heading Exception Safety]

No-throw guarantee. [endsect][section:overload2 basic_flat_buffer::max_size (2 of 2 overloads)]
Return the maximum number of bytes, both readable and writable, that can ever be held. [heading Synopsis]```std::size_tmax_size() const;```[heading Description][endsect][endsect][section:mutable_buffers_type basic_flat_buffer::mutable_buffers_type][indexterm2 mutable_buffers_type..basic_flat_buffer]
The MutableBufferSequence used to represent the writable bytes. [heading Synopsis]```using mutable_buffers_type = net::mutable_buffer;```[heading Description][endsect][section:mutable_data_type basic_flat_buffer::mutable_data_type][indexterm2 mutable_data_type..basic_flat_buffer]
The MutableBufferSequence used to represent the readable bytes. [heading Synopsis]```using mutable_data_type = net::mutable_buffer;```[heading Description][endsect][section:operator_eq_ basic_flat_buffer::operator=][indexterm2 operator=..basic_flat_buffer]
Move Assignment. ```basic_flat_buffer&``[link beast.ref.boost__beast__basic_flat_buffer.operator_eq_.overload1 operator=]``(    basic_flat_buffer&& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_flat_buffer.operator_eq_.overload1 more...]]`````
Copy Assignment. ```basic_flat_buffer&``[link beast.ref.boost__beast__basic_flat_buffer.operator_eq_.overload2 operator=]``(    basic_flat_buffer const& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_flat_buffer.operator_eq_.overload2 more...]]`````
Copy assignment. ```template<    class OtherAlloc>basic_flat_buffer&``[link beast.ref.boost__beast__basic_flat_buffer.operator_eq_.overload3 operator=]``(    basic_flat_buffer< OtherAlloc > const& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_flat_buffer.operator_eq_.overload3 more...]]`````[section:overload1 basic_flat_buffer::operator= (1 of 3 overloads)]
Move Assignment. [heading Synopsis]```basic_flat_buffer&operator=(    basic_flat_buffer&& other);```[heading Description]
The container is assigned with the contents of `other` using move semantics. The maximum size will be the same as the moved-from object.
Buffer sequences previously obtained from `other` using [link beast.ref.boost__beast__basic_flat_buffer.data `basic_flat_buffer::data`] or [link beast.ref.boost__beast__basic_flat_buffer.prepare `basic_flat_buffer::prepare`] remain valid after the move.
[heading Parameters][table [[Name][Description]]  [[`other`][    
The object to move from. After the move, the moved-from object will have zero capacity, zero readable bytes, and zero writable bytes.  ]]]
[heading Exception Safety]

No-throw guarantee. [endsect][section:overload2 basic_flat_buffer::operator= (2 of 3 overloads)]
Copy Assignment. [heading Synopsis]```basic_flat_buffer&operator=(    basic_flat_buffer const& other);```[heading Description]
The container is assigned with the contents of `other` using copy semantics. The maximum size will be the same as the copied object.
After the copy, `this` will have zero writable bytes.
[heading Parameters][table [[Name][Description]]  [[`other`][    
The object to copy from.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::length_error`][    
if `other.size()` exceeds the maximum allocation size of the allocator.   ]]]
[endsect][section:overload3 basic_flat_buffer::operator= (3 of 3 overloads)]
Copy assignment. [heading Synopsis]```template<    class OtherAlloc>basic_flat_buffer&operator=(    basic_flat_buffer< OtherAlloc > const& other);```[heading Description]
The container is assigned with the contents of `other` using copy semantics. The maximum size will be the same as the copied object.
After the copy, `this` will have zero writable bytes.
[heading Parameters][table [[Name][Description]]  [[`other`][    
The object to copy from.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::length_error`][    
if `other.size()` exceeds the maximum allocation size of the allocator.   ]]]
[endsect][endsect][section:prepare basic_flat_buffer::prepare][indexterm2 prepare..basic_flat_buffer]
Returns a mutable buffer sequence representing writable bytes. [heading Synopsis]```mutable_buffers_typeprepare(    std::size_t n);```[heading Description]
Returns a mutable buffer sequence representing the writable bytes containing exactly `n` bytes of storage. Memory may be reallocated as needed.
All buffers sequences previously obtained using [link beast.ref.boost__beast__basic_flat_buffer.data `basic_flat_buffer::data`] or [link beast.ref.boost__beast__basic_flat_buffer.prepare `basic_flat_buffer::prepare`] become invalid.
[heading Parameters][table [[Name][Description]]  [[`n`][    
The desired number of bytes in the returned buffer sequence.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::length_error`][    
if `size() + n` exceeds either `max_size()` or the allocator's maximum allocation size.  ]]]
[heading Exception Safety]

Strong guarantee. [endsect][section:reserve basic_flat_buffer::reserve][indexterm2 reserve..basic_flat_buffer]
Guarantee a minimum capacity. [heading Synopsis]```voidreserve(    std::size_t n);```[heading Description]
This function adjusts the internal storage (if necessary) to guarantee space for at least `n` bytes.
Buffer sequences previously obtained using [link beast.ref.boost__beast__basic_flat_buffer.data `basic_flat_buffer::data`] or [link beast.ref.boost__beast__basic_flat_buffer.prepare `basic_flat_buffer::prepare`] become invalid.
[heading Parameters][table [[Name][Description]]  [[`n`][    
The minimum number of byte for the new capacity. If this value is greater than the maximum size, then the maximum size will be adjusted upwards to this value.  ]]]
[heading Exception Safety]

Basic guarantee.
[heading Exceptions][table [[Type][Thrown On]]  [[`std::length_error`][    
if n is larger than the maximum allocation size of the allocator.   ]]]
[endsect][section:shrink_to_fit basic_flat_buffer::shrink_to_fit][indexterm2 shrink_to_fit..basic_flat_buffer]
Reallocate the buffer to fit the readable bytes exactly. [heading Synopsis]```voidshrink_to_fit();```[heading Description]
Buffer sequences previously obtained using [link beast.ref.boost__beast__basic_flat_buffer.data `basic_flat_buffer::data`] or [link beast.ref.boost__beast__basic_flat_buffer.prepare `basic_flat_buffer::prepare`] become invalid.
[heading Exception Safety]

Strong guarantee. [endsect][section:size basic_flat_buffer::size][indexterm2 size..basic_flat_buffer]
Returns the number of readable bytes. [heading Synopsis]```std::size_tsize() const;```[heading Description][endsect][section:swap basic_flat_buffer::swap][indexterm2 swap..basic_flat_buffer]
Exchange two dynamic buffers. [heading Synopsis]Defined in header [include_file boost/beast/core/flat_buffer.hpp]```template<    class Alloc>friend voidswap(    basic_flat_buffer< Alloc >&,    basic_flat_buffer< Alloc >&);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:basic_flat_buffer_dtor_ basic_flat_buffer::~basic_flat_buffer][indexterm2 ~basic_flat_buffer..basic_flat_buffer]
Destructor. [heading Synopsis]```~basic_flat_buffer();```[heading Description][endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__basic_multi_buffer basic_multi_buffer]
A dynamic buffer providing sequences of variable length. [heading Synopsis]Defined in header [include_file boost/beast/core/multi_buffer.hpp]```template<    class __Allocator__>class basic_multi_buffer```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__basic_multi_buffer.allocator_type [*allocator_type]]]    [      The type of allocator used.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.const_buffers_type [*const_buffers_type]]]    [      The ConstBufferSequence used to represent the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.mutable_buffers_type [*mutable_buffers_type]]]    [      The MutableBufferSequence used to represent the writable bytes.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.mutable_data_type [*mutable_data_type]]]    [      The MutableBufferSequence used to represent the readable bytes.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer [*basic_multi_buffer]]]    [      Constructor.       Move Constructor.       Copy Constructor.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.capacity [*capacity]]]    [      Return the maximum number of bytes, both readable and writable, that can be held without requiring an allocation.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.cdata [*cdata]]]    [      Returns a constant buffer sequence representing the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.clear [*clear]]]    [      Set the size of the readable and writable bytes to zero.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.commit [*commit]]]    [      Append writable bytes to the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.consume [*consume]]]    [      Remove bytes from beginning of the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.data [*data]]]    [      Returns a constant buffer sequence representing the readable bytes.       Returns a mutable buffer sequence representing the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.get_allocator [*get_allocator]]]    [      Returns a copy of the allocator used.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.max_size [*max_size]]]    [      Set the maximum allowed capacity.       Return the maximum number of bytes, both readable and writable, that can ever be held.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.operator_eq_ [*operator=]]]    [      Move Assignment.       Copy Assignment.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.prepare [*prepare]]]    [      Returns a mutable buffer sequence representing writable bytes.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.reserve [*reserve]]]    [      Guarantee a minimum capacity.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.shrink_to_fit [*shrink_to_fit]]]    [      Reallocate the buffer to fit the readable bytes exactly.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.size [*size]]]    [      Returns the number of readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer_dtor_ [*~basic_multi_buffer]]]    [      Destructor.     ]  ]][heading Friends][table [[Name][Description]]  [    [[link beast.ref.boost__beast__basic_multi_buffer.swap [*swap]]]    [      Exchange two dynamic buffers.     ]  ]][heading Description]
A dynamic buffer encapsulates memory storage that may be automatically resized as required, where the memory is divided into two regions: readable bytes followed by writable bytes. These memory regions are internal to the dynamic buffer, but direct access to the elements is provided to permit them to be efficiently used with I/O operations.
The implementation uses a sequence of one or more byte arrays of varying sizes to represent the readable and writable bytes. Additional byte array objects are appended to the sequence to accommodate changes in the desired size. The behavior and implementation of this container is most similar to `std::deque`.
Objects of this type meet the requirements of ['DynamicBuffer] and have the following additional properties:

* A mutable buffer sequence representing the readable bytes is returned by [link beast.ref.boost__beast__basic_multi_buffer.data `basic_multi_buffer::data`] when `this` is non-const.


* Buffer sequences representing the readable and writable bytes, returned by [link beast.ref.boost__beast__basic_multi_buffer.data `basic_multi_buffer::data`] and [link beast.ref.boost__beast__basic_multi_buffer.prepare `basic_multi_buffer::prepare`], may have length greater than one.


* A configurable maximum size may be set upon construction and adjusted afterwards. Calls to [link beast.ref.boost__beast__basic_multi_buffer.prepare `basic_multi_buffer::prepare`] that would exceed this size will throw `std::length_error`.


* Sequences previously obtained using [link beast.ref.boost__beast__basic_multi_buffer.data `basic_multi_buffer::data`] remain valid after calls to [link beast.ref.boost__beast__basic_multi_buffer.prepare `basic_multi_buffer::prepare`] or [link beast.ref.boost__beast__basic_multi_buffer.commit `basic_multi_buffer::commit`].

[heading Template Parameters][table [[Type][Description]]  [[`Allocator`][    
The allocator to use for managing memory.   ]]]
[section:allocator_type basic_multi_buffer::allocator_type][indexterm2 allocator_type..basic_multi_buffer]
The type of allocator used. [heading Synopsis]```using allocator_type = Allocator;```[heading Description][endsect][section:basic_multi_buffer basic_multi_buffer::basic_multi_buffer][indexterm2 basic_multi_buffer..basic_multi_buffer]
Constructor. `````[link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload1 basic_multi_buffer]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload1 more...]]``explicit``[link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload2 basic_multi_buffer]``(    std::size_t limit);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload2 more...]]``explicit``[link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload3 basic_multi_buffer]``(    Allocator const& alloc);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload3 more...]]````[link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload4 basic_multi_buffer]``(    std::size_t limit,    Allocator const& alloc);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload4 more...]]`````
Move Constructor. `````[link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload5 basic_multi_buffer]``(    basic_multi_buffer&& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload5 more...]]````[link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload6 basic_multi_buffer]``(    basic_multi_buffer&& other,    Allocator const& alloc);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload6 more...]]`````
Copy Constructor. `````[link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload7 basic_multi_buffer]``(    basic_multi_buffer const& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload7 more...]]````[link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload8 basic_multi_buffer]``(    basic_multi_buffer const& other,    Allocator const& alloc);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload8 more...]]``template<    class OtherAlloc>``[link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload9 basic_multi_buffer]``(    basic_multi_buffer< OtherAlloc > const& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload9 more...]]``template<    class OtherAlloc>``[link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload10 basic_multi_buffer]``(    basic_multi_buffer< OtherAlloc > const& other,    allocator_type const& alloc);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload10 more...]]`````[section:overload1 basic_multi_buffer::basic_multi_buffer (1 of 10 overloads)]
Constructor. [heading Synopsis]```basic_multi_buffer();```[heading Description]
After construction, [link beast.ref.boost__beast__basic_multi_buffer.capacity `basic_multi_buffer::capacity`] will return zero, and [link beast.ref.boost__beast__basic_multi_buffer.max_size `basic_multi_buffer::max_size`] will return the largest value which may be passed to the allocator's `allocate` function. [endsect][section:overload2 basic_multi_buffer::basic_multi_buffer (2 of 10 overloads)]
Constructor. [heading Synopsis]```basic_multi_buffer(    std::size_t limit);```[heading Description]
After construction, [link beast.ref.boost__beast__basic_multi_buffer.capacity `basic_multi_buffer::capacity`] will return zero, and [link beast.ref.boost__beast__basic_multi_buffer.max_size `basic_multi_buffer::max_size`] will return the specified value of `limit`.
[heading Parameters][table [[Name][Description]]  [[`limit`][    
The desired maximum size.   ]]]
[endsect][section:overload3 basic_multi_buffer::basic_multi_buffer (3 of 10 overloads)]
Constructor. [heading Synopsis]```basic_multi_buffer(    Allocator const& alloc);```[heading Description]
After construction, [link beast.ref.boost__beast__basic_multi_buffer.capacity `basic_multi_buffer::capacity`] will return zero, and [link beast.ref.boost__beast__basic_multi_buffer.max_size `basic_multi_buffer::max_size`] will return the largest value which may be passed to the allocator's `allocate` function.
[heading Parameters][table [[Name][Description]]  [[`alloc`][    
The allocator to use for the object.  ]]]
[heading Exception Safety]

No-throw guarantee. [endsect][section:overload4 basic_multi_buffer::basic_multi_buffer (4 of 10 overloads)]
Constructor. [heading Synopsis]```basic_multi_buffer(    std::size_t limit,    Allocator const& alloc);```[heading Description]
After construction, [link beast.ref.boost__beast__basic_multi_buffer.capacity `basic_multi_buffer::capacity`] will return zero, and [link beast.ref.boost__beast__basic_multi_buffer.max_size `basic_multi_buffer::max_size`] will return the specified value of `limit`.
[heading Parameters][table [[Name][Description]]  [[`limit`][    
The desired maximum size.  ]]  [[`alloc`][    
The allocator to use for the object.  ]]]
[heading Exception Safety]

No-throw guarantee. [endsect][section:overload5 basic_multi_buffer::basic_multi_buffer (5 of 10 overloads)]
Move Constructor. [heading Synopsis]```basic_multi_buffer(    basic_multi_buffer&& other);```[heading Description]
The container is constructed with the contents of `other` using move semantics. The maximum size will be the same as the moved-from object.
Buffer sequences previously obtained from `other` using [link beast.ref.boost__beast__basic_multi_buffer.data `basic_multi_buffer::data`] or [link beast.ref.boost__beast__basic_multi_buffer.prepare `basic_multi_buffer::prepare`] remain valid after the move.
[heading Parameters][table [[Name][Description]]  [[`other`][    
The object to move from. After the move, the moved-from object will have zero capacity, zero readable bytes, and zero writable bytes.  ]]]
[heading Exception Safety]

No-throw guarantee. [endsect][section:overload6 basic_multi_buffer::basic_multi_buffer (6 of 10 overloads)]
Move Constructor. [heading Synopsis]```basic_multi_buffer(    basic_multi_buffer&& other,    Allocator const& alloc);```[heading Description]
Using `alloc` as the allocator for the new container, the contents of `other` are moved. If `alloc != other.get_allocator()`, this results in a copy. The maximum size will be the same as the moved-from object.
Buffer sequences previously obtained from `other` using [link beast.ref.boost__beast__basic_multi_buffer.data `basic_multi_buffer::data`] or [link beast.ref.boost__beast__basic_multi_buffer.prepare `basic_multi_buffer::prepare`] become invalid after the move.
[heading Parameters][table [[Name][Description]]  [[`other`][    
The object to move from. After the move, the moved-from object will have zero capacity, zero readable bytes, and zero writable bytes.  ]]  [[`alloc`][    
The allocator to use for the object.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::length_error`][    
if `other.size()` exceeds the maximum allocation size of `alloc`.   ]]]
[endsect][section:overload7 basic_multi_buffer::basic_multi_buffer (7 of 10 overloads)]
Copy Constructor. [heading Synopsis]```basic_multi_buffer(    basic_multi_buffer const& other);```[heading Description]
This container is constructed with the contents of `other` using copy semantics. The maximum size will be the same as the copied object.
[heading Parameters][table [[Name][Description]]  [[`other`][    
The object to copy from.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::length_error`][    
if `other.size()` exceeds the maximum allocation size of the allocator.   ]]]
[endsect][section:overload8 basic_multi_buffer::basic_multi_buffer (8 of 10 overloads)]
Copy Constructor. [heading Synopsis]```basic_multi_buffer(    basic_multi_buffer const& other,    Allocator const& alloc);```[heading Description]
This container is constructed with the contents of `other` using copy semantics and the specified allocator. The maximum size will be the same as the copied object.
[heading Parameters][table [[Name][Description]]  [[`other`][    
The object to copy from.  ]]  [[`alloc`][    
The allocator to use for the object.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::length_error`][    
if `other.size()` exceeds the maximum allocation size of `alloc`.   ]]]
[endsect][section:overload9 basic_multi_buffer::basic_multi_buffer (9 of 10 overloads)]
Copy Constructor. [heading Synopsis]```template<    class OtherAlloc>basic_multi_buffer(    basic_multi_buffer< OtherAlloc > const& other);```[heading Description]
This container is constructed with the contents of `other` using copy semantics. The maximum size will be the same as the copied object.
[heading Parameters][table [[Name][Description]]  [[`other`][    
The object to copy from.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::length_error`][    
if `other.size()` exceeds the maximum allocation size of the allocator.   ]]]
[endsect][section:overload10 basic_multi_buffer::basic_multi_buffer (10 of 10 overloads)]
Copy Constructor. [heading Synopsis]```template<    class OtherAlloc>basic_multi_buffer(    basic_multi_buffer< OtherAlloc > const& other,    allocator_type const& alloc);```[heading Description]
This container is constructed with the contents of `other` using copy semantics. The maximum size will be the same as the copied object.
[heading Parameters][table [[Name][Description]]  [[`other`][    
The object to copy from.  ]]  [[`alloc`][    
The allocator to use for the object.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::length_error`][    
if `other.size()` exceeds the maximum allocation size of `alloc`.   ]]]
[endsect][endsect][section:capacity basic_multi_buffer::capacity][indexterm2 capacity..basic_multi_buffer]
Return the maximum number of bytes, both readable and writable, that can be held without requiring an allocation. [heading Synopsis]```std::size_tcapacity() const;```[heading Description][endsect][section:cdata basic_multi_buffer::cdata][indexterm2 cdata..basic_multi_buffer]
Returns a constant buffer sequence representing the readable bytes. [heading Synopsis]```const_buffers_typecdata() const;```[heading Description]
[heading Remarks]
The sequence may contain multiple contiguous memory regions. 
[endsect][section:clear basic_multi_buffer::clear][indexterm2 clear..basic_multi_buffer]
Set the size of the readable and writable bytes to zero. [heading Synopsis]```voidclear();```[heading Description]
This clears the buffer without changing capacity. Buffer sequences previously obtained using [link beast.ref.boost__beast__basic_multi_buffer.data `basic_multi_buffer::data`] or [link beast.ref.boost__beast__basic_multi_buffer.prepare `basic_multi_buffer::prepare`] become invalid.
[heading Exception Safety]

No-throw guarantee. [endsect][section:commit basic_multi_buffer::commit][indexterm2 commit..basic_multi_buffer]
Append writable bytes to the readable bytes. [heading Synopsis]```voidcommit(    size_type n);```[heading Description]
Appends n bytes from the start of the writable bytes to the end of the readable bytes. The remainder of the writable bytes are discarded. If n is greater than the number of writable bytes, all writable bytes are appended to the readable bytes.
All buffer sequences previously obtained using [link beast.ref.boost__beast__basic_multi_buffer.prepare `basic_multi_buffer::prepare`] are invalidated. Buffer sequences previously obtained using [link beast.ref.boost__beast__basic_multi_buffer.data `basic_multi_buffer::data`] remain valid.
[heading Parameters][table [[Name][Description]]  [[`n`][    
The number of bytes to append. If this number is greater than the number of writable bytes, all writable bytes are appended.  ]]]
[heading Exception Safety]

No-throw guarantee. [endsect][section:const_buffers_type basic_multi_buffer::const_buffers_type][indexterm2 const_buffers_type..basic_multi_buffer]
The ConstBufferSequence used to represent the readable bytes. [heading Synopsis]```using const_buffers_type = ``['implementation-defined]``;```[heading Description][endsect][section:consume basic_multi_buffer::consume][indexterm2 consume..basic_multi_buffer]
Remove bytes from beginning of the readable bytes. [heading Synopsis]```voidconsume(    size_type n);```[heading Description]
Removes n bytes from the beginning of the readable bytes.
All buffers sequences previously obtained using [link beast.ref.boost__beast__basic_multi_buffer.data `basic_multi_buffer::data`] or [link beast.ref.boost__beast__basic_multi_buffer.prepare `basic_multi_buffer::prepare`] are invalidated.
[heading Parameters][table [[Name][Description]]  [[`n`][    
The number of bytes to remove. If this number is greater than the number of readable bytes, all readable bytes are removed.  ]]]
[heading Exception Safety]

No-throw guarantee. [endsect][section:data basic_multi_buffer::data][indexterm2 data..basic_multi_buffer]
Returns a constant buffer sequence representing the readable bytes. ```const_buffers_type``[link beast.ref.boost__beast__basic_multi_buffer.data.overload1 data]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_multi_buffer.data.overload1 more...]]`````
Returns a mutable buffer sequence representing the readable bytes. ```mutable_data_type``[link beast.ref.boost__beast__basic_multi_buffer.data.overload2 data]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_multi_buffer.data.overload2 more...]]`````[section:overload1 basic_multi_buffer::data (1 of 2 overloads)]
Returns a constant buffer sequence representing the readable bytes. [heading Synopsis]```const_buffers_typedata() const;```[heading Description]
[heading Remarks]
The sequence may contain multiple contiguous memory regions. 
[endsect][section:overload2 basic_multi_buffer::data (2 of 2 overloads)]
Returns a mutable buffer sequence representing the readable bytes. [heading Synopsis]```mutable_data_typedata();```[heading Description]
[heading Remarks]
The sequence may contain multiple contiguous memory regions. 
[endsect][endsect][section:get_allocator basic_multi_buffer::get_allocator][indexterm2 get_allocator..basic_multi_buffer]
Returns a copy of the allocator used. [heading Synopsis]```allocator_typeget_allocator() const;```[heading Description][endsect][section:max_size basic_multi_buffer::max_size][indexterm2 max_size..basic_multi_buffer]
Set the maximum allowed capacity. ```void``[link beast.ref.boost__beast__basic_multi_buffer.max_size.overload1 max_size]``(    std::size_t n);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_multi_buffer.max_size.overload1 more...]]`````
Return the maximum number of bytes, both readable and writable, that can ever be held. ```size_type``[link beast.ref.boost__beast__basic_multi_buffer.max_size.overload2 max_size]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_multi_buffer.max_size.overload2 more...]]`````[section:overload1 basic_multi_buffer::max_size (1 of 2 overloads)]
Set the maximum allowed capacity. [heading Synopsis]```voidmax_size(    std::size_t n);```[heading Description]
This function changes the currently configured upper limit on capacity to the specified value.
[heading Parameters][table [[Name][Description]]  [[`n`][    
The maximum number of bytes ever allowed for capacity.  ]]]
[heading Exception Safety]

No-throw guarantee. [endsect][section:overload2 basic_multi_buffer::max_size (2 of 2 overloads)]
Return the maximum number of bytes, both readable and writable, that can ever be held. [heading Synopsis]```size_typemax_size() const;```[heading Description][endsect][endsect][section:mutable_buffers_type basic_multi_buffer::mutable_buffers_type][indexterm2 mutable_buffers_type..basic_multi_buffer]
The MutableBufferSequence used to represent the writable bytes. [heading Synopsis]```using mutable_buffers_type = ``['implementation-defined]``;```[heading Description][endsect][section:mutable_data_type basic_multi_buffer::mutable_data_type][indexterm2 mutable_data_type..basic_multi_buffer]
The MutableBufferSequence used to represent the readable bytes. [heading Synopsis]```using mutable_data_type = ``['implementation-defined]``;```[heading Description][endsect][section:operator_eq_ basic_multi_buffer::operator=][indexterm2 operator=..basic_multi_buffer]
Move Assignment. ```basic_multi_buffer&``[link beast.ref.boost__beast__basic_multi_buffer.operator_eq_.overload1 operator=]``(    basic_multi_buffer&& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_multi_buffer.operator_eq_.overload1 more...]]`````
Copy Assignment. ```basic_multi_buffer&``[link beast.ref.boost__beast__basic_multi_buffer.operator_eq_.overload2 operator=]``(    basic_multi_buffer const& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_multi_buffer.operator_eq_.overload2 more...]]``template<    class OtherAlloc>basic_multi_buffer&``[link beast.ref.boost__beast__basic_multi_buffer.operator_eq_.overload3 operator=]``(    basic_multi_buffer< OtherAlloc > const& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_multi_buffer.operator_eq_.overload3 more...]]`````[section:overload1 basic_multi_buffer::operator= (1 of 3 overloads)]
Move Assignment. [heading Synopsis]```basic_multi_buffer&operator=(    basic_multi_buffer&& other);```[heading Description]
The container is assigned with the contents of `other` using move semantics. The maximum size will be the same as the moved-from object.
Buffer sequences previously obtained from `other` using [link beast.ref.boost__beast__basic_multi_buffer.data `basic_multi_buffer::data`] or [link beast.ref.boost__beast__basic_multi_buffer.prepare `basic_multi_buffer::prepare`] remain valid after the move.
[heading Parameters][table [[Name][Description]]  [[`other`][    
The object to move from. After the move, the moved-from object will have zero capacity, zero readable bytes, and zero writable bytes.   ]]]
[endsect][section:overload2 basic_multi_buffer::operator= (2 of 3 overloads)]
Copy Assignment. [heading Synopsis]```basic_multi_buffer&operator=(    basic_multi_buffer const& other);```[heading Description]
The container is assigned with the contents of `other` using copy semantics. The maximum size will be the same as the copied object.
After the copy, `this` will have zero writable bytes.
[heading Parameters][table [[Name][Description]]  [[`other`][    
The object to copy from.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::length_error`][    
if `other.size()` exceeds the maximum allocation size of the allocator.   ]]]
[endsect][section:overload3 basic_multi_buffer::operator= (3 of 3 overloads)]
Copy Assignment. [heading Synopsis]```template<    class OtherAlloc>basic_multi_buffer&operator=(    basic_multi_buffer< OtherAlloc > const& other);```[heading Description]
The container is assigned with the contents of `other` using copy semantics. The maximum size will be the same as the copied object.
After the copy, `this` will have zero writable bytes.
[heading Parameters][table [[Name][Description]]  [[`other`][    
The object to copy from.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::length_error`][    
if `other.size()` exceeds the maximum allocation size of the allocator.   ]]]
[endsect][endsect][section:prepare basic_multi_buffer::prepare][indexterm2 prepare..basic_multi_buffer]
Returns a mutable buffer sequence representing writable bytes. [heading Synopsis]```mutable_buffers_typeprepare(    size_type n);```[heading Description]
Returns a mutable buffer sequence representing the writable bytes containing exactly `n` bytes of storage. Memory may be reallocated as needed.
All buffer sequences previously obtained using [link beast.ref.boost__beast__basic_multi_buffer.prepare `basic_multi_buffer::prepare`] are invalidated. Buffer sequences previously obtained using [link beast.ref.boost__beast__basic_multi_buffer.data `basic_multi_buffer::data`] remain valid.
[heading Parameters][table [[Name][Description]]  [[`n`][    
The desired number of bytes in the returned buffer sequence.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::length_error`][    
if `size() + n` exceeds `max_size()`.  ]]]
[heading Exception Safety]

Strong guarantee. [endsect][section:reserve basic_multi_buffer::reserve][indexterm2 reserve..basic_multi_buffer]
Guarantee a minimum capacity. [heading Synopsis]```voidreserve(    std::size_t n);```[heading Description]
This function adjusts the internal storage (if necessary) to guarantee space for at least `n` bytes.
Buffer sequences previously obtained using [link beast.ref.boost__beast__basic_multi_buffer.data `basic_multi_buffer::data`] remain valid, while buffer sequences previously obtained using [link beast.ref.boost__beast__basic_multi_buffer.prepare `basic_multi_buffer::prepare`] become invalid.
[heading Parameters][table [[Name][Description]]  [[`n`][    
The minimum number of byte for the new capacity. If this value is greater than the maximum size, then the maximum size will be adjusted upwards to this value.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::length_error`][    
if n is larger than the maximum allocation size of the allocator.  ]]]
[heading Exception Safety]

Strong guarantee. [endsect][section:shrink_to_fit basic_multi_buffer::shrink_to_fit][indexterm2 shrink_to_fit..basic_multi_buffer]
Reallocate the buffer to fit the readable bytes exactly. [heading Synopsis]```voidshrink_to_fit();```[heading Description]
Buffer sequences previously obtained using [link beast.ref.boost__beast__basic_multi_buffer.data `basic_multi_buffer::data`] or [link beast.ref.boost__beast__basic_multi_buffer.prepare `basic_multi_buffer::prepare`] become invalid.
[heading Exception Safety]

Strong guarantee. [endsect][section:size basic_multi_buffer::size][indexterm2 size..basic_multi_buffer]
Returns the number of readable bytes. [heading Synopsis]```size_typesize() const;```[heading Description][endsect][section:swap basic_multi_buffer::swap][indexterm2 swap..basic_multi_buffer]
Exchange two dynamic buffers. [heading Synopsis]Defined in header [include_file boost/beast/core/multi_buffer.hpp]```template<    class Alloc>friend voidswap(    basic_multi_buffer< Alloc >& lhs,    basic_multi_buffer< Alloc >& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:basic_multi_buffer_dtor_ basic_multi_buffer::~basic_multi_buffer][indexterm2 ~basic_multi_buffer..basic_multi_buffer]
Destructor. [heading Synopsis]```~basic_multi_buffer();```[heading Description][endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__basic_multi_buffer__element basic_multi_buffer::element][heading Synopsis]Defined in header [include_file boost/beast/core/multi_buffer.hpp]```class element :    public boost::intrusive::list_base_hook< boost::intrusive::link_mode< boost::intrusive::normal_link > >```[heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__basic_multi_buffer__element.data [*data]]]    [          ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer__element.element [*element]]]    [          ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer__element.size [*size]]]    [          ]  ]][heading Description][section:data basic_multi_buffer::element::data][indexterm2 data..basic_multi_buffer::element][heading Synopsis]```char*data() const;```[heading Description][endsect][section:element basic_multi_buffer::element::element][indexterm2 element..basic_multi_buffer::element]`````[link beast.ref.boost__beast__basic_multi_buffer__element.element.overload1 element]``(    element const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_multi_buffer__element.element.overload1 more...]]``explicit``[link beast.ref.boost__beast__basic_multi_buffer__element.element.overload2 element]``(    size_type n);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_multi_buffer__element.element.overload2 more...]]`````[section:overload1 basic_multi_buffer::element::element (1 of 2 overloads)][heading Synopsis]```element(    element const&);```[heading Description][endsect][section:overload2 basic_multi_buffer::element::element (2 of 2 overloads)][heading Synopsis]```element(    size_type n);```[heading Description][endsect][endsect][section:size basic_multi_buffer::element::size][indexterm2 size..basic_multi_buffer::element][heading Synopsis]```size_typesize() const;```[heading Description][endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__basic_multi_buffer__readable_bytes basic_multi_buffer::readable_bytes][heading Synopsis]Defined in header [include_file boost/beast/core/multi_buffer.hpp]```template<    [role red error.class-detail-template.1][role red error.class-detail-template.2]>class readable_bytes```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__basic_stream basic_stream]
A stream socket wrapper with timeouts, an executor, and a rate limit policy. [heading Synopsis]Defined in header [include_file boost/beast/core/basic_stream.hpp]```template<    class __Protocol__,    class __Executor__ = net::executor,    class __RatePolicy__ = unlimited_rate_policy>class basic_stream```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__basic_stream.endpoint_type [*endpoint_type]]]    [      The endpoint type.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.executor_type [*executor_type]]]    [      The type of the executor associated with the stream.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.protocol_type [*protocol_type]]]    [      The protocol type.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.socket_type [*socket_type]]]    [      The type of the underlying socket.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__basic_stream.async_connect [*async_connect]]]    [      Connect the stream to the specified endpoint asynchronously.       Establishes a connection by trying each endpoint in a sequence asynchronously.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.async_read_some [*async_read_some]]]    [      Read some data asynchronously.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.async_write_some [*async_write_some]]]    [      Write some data asynchronously.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.basic_stream [*basic_stream]]]    [      Constructor.       Move constructor.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.cancel [*cancel]]]    [      Cancel all asynchronous operations associated with the socket.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.close [*close]]]    [      Close the timed stream.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.connect [*connect]]]    [      Connect the stream to the specified endpoint.       Establishes a connection by trying each endpoint in a sequence.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.expires_after [*expires_after]]]    [      Set the timeout for the next logical operation.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.expires_at [*expires_at]]]    [      Set the timeout for the next logical operation.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.expires_never [*expires_never]]]    [      Disable the timeout for the next logical operation.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.get_executor [*get_executor]]]    [      Get the executor associated with the object.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.operator_eq_ [*operator=]]]    [      Move assignment (deleted).     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.rate_policy [*rate_policy]]]    [      Returns the rate policy associated with the object.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.read_some [*read_some]]]    [      Read some data.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.release_socket [*release_socket]]]    [      Release ownership of the underlying socket.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.socket [*socket]]]    [      Return a reference to the underlying socket.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.write_some [*write_some]]]    [      Write some data.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.basic_stream_dtor_ [*~basic_stream]]]    [      Destructor.     ]  ]][heading Description]
This stream wraps a `net::basic_stream_socket` to provide the following features:

* An ['Executor] may be associated with the stream, which will be used to invoke any completion handlers which do not already have an associated executor. This achieves support for [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1322r0.html [P1322R0] Networking TS enhancement to enable custom I/O executors].


* Timeouts may be specified for each logical asynchronous operation performing any reading, writing, or connecting.


* A ['RatePolicy] may be associated with the stream, to implement rate limiting through the policy's interface.

Although the stream supports multiple concurrent outstanding asynchronous operations, the stream object is not thread-safe. The caller is responsible for ensuring that the stream is accessed from only one thread at a time. This includes the times when the stream, and its underlying socket, are accessed by the networking implementation. To meet this thread safety requirement, all asynchronous operations must be performed by the stream within the same implicit strand (only one thread `net::io_context::run`) or within the same explicit strand, such as an instance of `net::strand`.
Completion handlers with explicit associated executors (such as those arising from use of `net::bind_executor`) will be invoked by the stream using the associated executor. Otherwise, the completion handler will be invoked by the executor associated with the stream upon construction. The type of executor used with this stream must meet the following requirements:

* Function objects submitted to the executor shall never run concurrently with each other.

The executor type `net::strand` meets these requirements. Use of a strand as the executor in the stream class template offers an additional notational convenience: the strand does not need to be specified in each individual initiating function call.
Unlike other stream wrappers, the underlying socket is accessed through the [link beast.ref.boost__beast__basic_stream.socket `basic_stream::socket`] member function instead of `next_layer`. This causes the [link beast.ref.boost__beast__basic_stream `basic_stream`] to be returned in calls to [link beast.ref.boost__beast__get_lowest_layer `get_lowest_layer`].
[heading Usage]

To use this stream declare an instance of the class. Then, before each logical operation for which a timeout is desired, call [link beast.ref.boost__beast__basic_stream.expires_after `basic_stream::expires_after`] with a duration, or call [link beast.ref.boost__beast__basic_stream.expires_at `basic_stream::expires_at`] with a time point. Alternatively, call [link beast.ref.boost__beast__basic_stream.expires_never `basic_stream::expires_never`] to disable the timeout for subsequent logical operations. A logical operation is any series of one or more direct or indirect calls to the timeout stream's asynchronous read, asynchronous write, or asynchronous connect functions.
When a timeout is set and a mixed operation is performed (one that includes both reads and writes, for example) the timeout applies to all of the intermediate asynchronous operations used in the enclosing operation. This allows timeouts to be applied to stream algorithms which were not written specifically to allow for timeouts, when those algorithms are passed a timeout stream with a timeout set.
When a timeout occurs the socket will be closed, canceling any pending I/O operations. The completion handlers for these canceled operations will be invoked with the error [link beast.ref.boost__beast__error `timeout`].
[heading Examples]

This function reads an HTTP request with a timeout, then sends the HTTP response with a different timeout.
```  void process_http_1 (tcp_stream& stream, net::yield_context yield)
  {
      flat_buffer buffer;
      http::request<http::empty_body> req;

      // Read the request, with a 15 second timeout
      stream.expires_after(std::chrono::seconds(15));
      http::async_read(stream, buffer, req, yield);

      // Calculate the response
      http::response<http::string_body> res = make_response(req);

      // Send the response, with a 30 second timeout.
      stream.expires_after (std::chrono::seconds(30));
      http::async_write (stream, res, yield);
  }
```
The example above could be expressed using a single timeout with a simple modification. The function that follows first reads an HTTP request then sends the HTTP response, with a single timeout that applies to the entire combined operation of reading and writing:
```  void process_http_2 (tcp_stream& stream, net::yield_context yield)
  {
      flat_buffer buffer;
      http::request<http::empty_body> req;

      // Require that the read and write combined take no longer than 30 seconds
      stream.expires_after(std::chrono::seconds(30));

      http::async_read(stream, buffer, req, yield);

      http::response<http::string_body> res = make_response(req);
      http::async_write (stream, res, yield);
  }
```
Some stream algorithms, such as `ssl::stream::async_handshake` perform both reads and writes. A timeout set before calling the initiating function of such composite stream algorithms will apply to the entire composite operation. For example, a timeout may be set on performing the SSL handshake thusly:
```  void do_ssl_handshake (net::ssl::stream<tcp_stream>& stream, net::yield_context yield)
  {
      // Require that the SSL handshake take no longer than 10 seconds
      stream.expires_after(std::chrono::seconds(10));

      stream.async_handshake(net::ssl::stream_base::client, yield);
  }
```
[heading Blocking I/O]

Synchronous functions behave identically as that of the wrapped `net::basic_stream_socket`. Timeouts are not available when performing blocking calls.
[heading Template Parameters][table [[Type][Description]]  [[`Protocol`][    
A type meeting the requirements of ['Protocol] representing the protocol the protocol to use for the basic stream socket. A common choice is `net::ip::tcp`.  ]]  [[`Executor`][    
A type meeting the requirements of ['Executor] to be used for submitting all completion handlers which do not already have an associated executor. If this type is omitted, the default of `net::executor` will be used.  ]]]
[heading Thread Safety]
['Distinct objects]: Safe.['Shared objects]: Unsafe. The application must also ensure that all asynchronous operations are performed within the same implicit or explicit strand.
[heading See Also]


* [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1322r0.html [P1322R0] Networking TS enhancement to enable custom I/O executors]. 

[section:async_connect basic_stream::async_connect][indexterm2 async_connect..basic_stream]
Connect the stream to the specified endpoint asynchronously. ```template<    class __ConnectHandler__>``__deduced__````[link beast.ref.boost__beast__basic_stream.async_connect.overload1 async_connect]``(    endpoint_type const& ep,    ConnectHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_stream.async_connect.overload1 more...]]`````
Establishes a connection by trying each endpoint in a sequence asynchronously. ```template<    class __EndpointSequence__,    class __RangeConnectHandler__>``__deduced__````[link beast.ref.boost__beast__basic_stream.async_connect.overload2 async_connect]``(    EndpointSequence const& endpoints,    RangeConnectHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_stream.async_connect.overload2 more...]]``template<    class __EndpointSequence__,    class __ConnectCondition__,    class __RangeConnectHandler__>``__deduced__````[link beast.ref.boost__beast__basic_stream.async_connect.overload3 async_connect]``(    EndpointSequence const& endpoints,    ConnectCondition connect_condition,    RangeConnectHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_stream.async_connect.overload3 more...]]``template<    class Iterator,    class __IteratorConnectHandler__>``__deduced__````[link beast.ref.boost__beast__basic_stream.async_connect.overload4 async_connect]``(    Iterator begin,    Iterator end,    IteratorConnectHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_stream.async_connect.overload4 more...]]``template<    class Iterator,    class __ConnectCondition__,    class __IteratorConnectHandler__>``__deduced__````[link beast.ref.boost__beast__basic_stream.async_connect.overload5 async_connect]``(    Iterator begin,    Iterator end,    ConnectCondition connect_condition,    IteratorConnectHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_stream.async_connect.overload5 more...]]`````[section:overload1 basic_stream::async_connect (1 of 5 overloads)]
Connect the stream to the specified endpoint asynchronously. [heading Synopsis]```template<    class __ConnectHandler__>``__deduced__``async_connect(    endpoint_type const& ep,    ConnectHandler&& handler);```[heading Description]
This function is used to asynchronously connect the underlying socket to the specified remote endpoint. The function call always returns immediately. The underlying socket is automatically opened if needed. An automatically opened socket is not returned to the closed state upon failure.
If the timeout timer expires while the operation is outstanding, the operation will be canceled and the completion handler will be invoked with the error [link beast.ref.boost__beast__error `timeout`].
[heading Parameters][table [[Name][Description]]  [[`ep`][    
The remote endpoint to which the underlying socket will be connected. Copies will be made of the endpoint object as required.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      error_code ec         // Result of operation
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.  ]]]
[heading See Also]
[link beast.ref.boost__beast__basic_stream.async_connect `basic_stream::async_connect`] 
[endsect][section:overload2 basic_stream::async_connect (2 of 5 overloads)]
Establishes a connection by trying each endpoint in a sequence asynchronously. [heading Synopsis]```template<    class __EndpointSequence__,    class __RangeConnectHandler__>``__deduced__``async_connect(    EndpointSequence const& endpoints,    RangeConnectHandler&& handler);```[heading Description]
This function attempts to connect the stream to one of a sequence of endpoints by trying each endpoint until a connection is successfully established. The underlying socket is automatically opened if needed. An automatically opened socket is not returned to the closed state upon failure.
The algorithm, known as a ['composed asynchronous operation], is implemented in terms of calls to the underlying socket's `async_connect` function.
If the timeout timer expires while the operation is outstanding, the current connection attempt will be canceled and the completion handler will be invoked with the error [link beast.ref.boost__beast__error `timeout`].
[heading Parameters][table [[Name][Description]]  [[`endpoints`][    
A sequence of endpoints. This this object must meet the requirements of ['EndpointSequence].  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      // Result of operation. if the sequence is empty, set to
      // net::error::not_found. Otherwise, contains the
      // error from the last connection attempt.
      error_code const& error,

      // On success, the successfully connected endpoint.
      // Otherwise, a default-constructed endpoint.
      typename Protocol::endpoint const& endpoint
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.   ]]]
[endsect][section:overload3 basic_stream::async_connect (3 of 5 overloads)]
Establishes a connection by trying each endpoint in a sequence asynchronously. [heading Synopsis]```template<    class __EndpointSequence__,    class __ConnectCondition__,    class __RangeConnectHandler__>``__deduced__``async_connect(    EndpointSequence const& endpoints,    ConnectCondition connect_condition,    RangeConnectHandler&& handler);```[heading Description]
This function attempts to connect the stream to one of a sequence of endpoints by trying each endpoint until a connection is successfully established. The underlying socket is automatically opened if needed. An automatically opened socket is not returned to the closed state upon failure.
The algorithm, known as a ['composed asynchronous operation], is implemented in terms of calls to the underlying socket's `async_connect` function.
If the timeout timer expires while the operation is outstanding, the current connection attempt will be canceled and the completion handler will be invoked with the error [link beast.ref.boost__beast__error `timeout`].
[heading Parameters][table [[Name][Description]]  [[`endpoints`][    
A sequence of endpoints. This this object must meet the requirements of ['EndpointSequence].  ]]  [[`connect_condition`][    
A function object that is called prior to each connection attempt. The signature of the function object must be: ```  bool connect_condition(
      error_code const& ec,
      typename Protocol::endpoint const& next);
```The `ec` parameter contains the result from the most recent connect operation. Before the first connection attempt, `ec` is always set to indicate success. The `next` parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      // Result of operation. if the sequence is empty, set to
      // net::error::not_found. Otherwise, contains the
      // error from the last connection attempt.
      error_code const& error,

      // On success, the successfully connected endpoint.
      // Otherwise, a default-constructed endpoint.
      typename Protocol::endpoint const& endpoint
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.  ]]]
[heading Example]
The following connect condition function object can be used to output information about the individual connection attempts: ```  struct my_connect_condition
  {
      bool operator()(
          error_code const& ec,
          net::ip::tcp::endpoint const& next)
      {
          if (ec)
              std::cout << "Error: " << ec.message() << std::endl;
          std::cout << "Trying: " << next << std::endl;
          return true;
      }
  };
```
[endsect][section:overload4 basic_stream::async_connect (4 of 5 overloads)]
Establishes a connection by trying each endpoint in a sequence asynchronously. [heading Synopsis]```template<    class Iterator,    class __IteratorConnectHandler__>``__deduced__``async_connect(    Iterator begin,    Iterator end,    IteratorConnectHandler&& handler);```[heading Description]
This function attempts to connect the stream to one of a sequence of endpoints by trying each endpoint until a connection is successfully established. The underlying socket is automatically opened if needed. An automatically opened socket is not returned to the closed state upon failure.
The algorithm, known as a ['composed asynchronous operation], is implemented in terms of calls to the underlying socket's `async_connect` function.
If the timeout timer expires while the operation is outstanding, the current connection attempt will be canceled and the completion handler will be invoked with the error [link beast.ref.boost__beast__error `timeout`].
[heading Parameters][table [[Name][Description]]  [[`begin`][    
An iterator pointing to the start of a sequence of endpoints.  ]]  [[`end`][    
An iterator pointing to the end of a sequence of endpoints.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      // Result of operation. if the sequence is empty, set to
      // net::error::not_found. Otherwise, contains the
      // error from the last connection attempt.
      error_code const& error,

      // On success, an iterator denoting the successfully
      // connected endpoint. Otherwise, the end iterator.
      Iterator iterator
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.   ]]]
[endsect][section:overload5 basic_stream::async_connect (5 of 5 overloads)]
Establishes a connection by trying each endpoint in a sequence asynchronously. [heading Synopsis]```template<    class Iterator,    class __ConnectCondition__,    class __IteratorConnectHandler__>``__deduced__``async_connect(    Iterator begin,    Iterator end,    ConnectCondition connect_condition,    IteratorConnectHandler&& handler);```[heading Description]
This function attempts to connect the stream to one of a sequence of endpoints by trying each endpoint until a connection is successfully established. The algorithm, known as a ['composed asynchronous operation], is implemented in terms of calls to the underlying socket's `async_connect` function.
If the timeout timer expires while the operation is outstanding, the current connection attempt will be canceled and the completion handler will be invoked with the error [link beast.ref.boost__beast__error `timeout`].
[heading Parameters][table [[Name][Description]]  [[`begin`][    
An iterator pointing to the start of a sequence of endpoints.  ]]  [[`end`][    
An iterator pointing to the end of a sequence of endpoints.  ]]  [[`connect_condition`][    
A function object that is called prior to each connection attempt. The signature of the function object must be: ```  bool connect_condition(
      error_code const& ec,
      Iterator next);
```  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      // Result of operation. if the sequence is empty, set to
      // net::error::not_found. Otherwise, contains the
      // error from the last connection attempt.
      error_code const& error,

      // On success, an iterator denoting the successfully
      // connected endpoint. Otherwise, the end iterator.
      Iterator iterator
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.   ]]]
[endsect][endsect][section:async_read_some basic_stream::async_read_some][indexterm2 async_read_some..basic_stream]
Read some data asynchronously. [heading Synopsis]```template<    class __MutableBufferSequence__,    class __ReadHandler__>``__deduced__``async_read_some(    MutableBufferSequence const& buffers,    ReadHandler&& handler);```[heading Description]
This function is used to asynchronously read data from the stream.
This call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:

* One or more bytes are read from the stream.


* An error occurs.

The algorithm, known as a ['composed asynchronous operation], is implemented in terms of calls to the next layer's `async_read_some` function. The program must ensure that no other calls to [link beast.ref.boost__beast__basic_stream.read_some `basic_stream::read_some`] or [link beast.ref.boost__beast__basic_stream.async_read_some `basic_stream::async_read_some`] are performed until this operation completes.
If the timeout timer expires while the operation is outstanding, the operation will be canceled and the completion handler will be invoked with the error [link beast.ref.boost__beast__error `timeout`].
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The buffers into which the data will be read. If the size of the buffers is zero bytes, the operation always completes immediately with no error. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      error_code error,               // Result of operation.
      std::size_t bytes_transferred   // Number of bytes read.
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.  ]]]
[heading Remarks]
The `async_read_some` operation may not receive all of the requested number of bytes. Consider using the function `net::async_read` if you need to ensure that the requested amount of data is read before the asynchronous operation completes. 
[endsect][section:async_write_some basic_stream::async_write_some][indexterm2 async_write_some..basic_stream]
Write some data asynchronously. [heading Synopsis]```template<    class __ConstBufferSequence__,    class __WriteHandler__>``__deduced__``async_write_some(    ConstBufferSequence const& buffers,    WriteHandler&& handler);```[heading Description]
This function is used to asynchronously write data to the underlying socket.
This call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:

* One or more bytes are written to the stream.


* An error occurs.

The algorithm, known as a ['composed asynchronous operation], is implemented in terms of calls to the next layer's `async_write_some` function. The program must ensure that no other calls to [link beast.ref.boost__beast__basic_stream.async_write_some `basic_stream::async_write_some`] are performed until this operation completes.
If the timeout timer expires while the operation is outstanding, the operation will be canceled and the completion handler will be invoked with the error [link beast.ref.boost__beast__error `timeout`].
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The buffers from which the data will be written. If the size of the buffers is zero bytes, the operation always completes immediately with no error. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      error_code error,               // Result of operation.
      std::size_t bytes_transferred   // Number of bytes written.
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.  ]]]
[heading Remarks]
The `async_write_some` operation may not transmit all of the requested number of bytes. Consider using the function `net::async_write` if you need to ensure that the requested amount of data is sent before the asynchronous operation completes. 
[endsect][section:basic_stream basic_stream::basic_stream][indexterm2 basic_stream..basic_stream]
Constructor. ```template<    class... Args>explicit``[link beast.ref.boost__beast__basic_stream.basic_stream.overload1 basic_stream]``(    Args&&... args);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_stream.basic_stream.overload1 more...]]``template<    class RatePolicy_,    class... Args>explicit``[link beast.ref.boost__beast__basic_stream.basic_stream.overload2 basic_stream]``(    RatePolicy_&& policy,    Args&&... args);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_stream.basic_stream.overload2 more...]]`````
Move constructor. `````[link beast.ref.boost__beast__basic_stream.basic_stream.overload3 basic_stream]``(    basic_stream&& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_stream.basic_stream.overload3 more...]]`````[section:overload1 basic_stream::basic_stream (1 of 3 overloads)]
Constructor. [heading Synopsis]```template<    class... Args>basic_stream(    Args&&... args);```[heading Description]
This constructor creates the stream by forwarding all arguments to the underlying socket. The socket then needs to be open and connected or accepted before data can be sent or received on it.
[heading Parameters][table [[Name][Description]]  [[`args`][    
A list of parameters forwarded to the constructor of the underlying socket.   ]]]
[endsect][section:overload2 basic_stream::basic_stream (2 of 3 overloads)]
Constructor. [heading Synopsis]```template<    class RatePolicy_,    class... Args>basic_stream(    RatePolicy_&& policy,    Args&&... args);```[heading Description]
This constructor creates the stream with the specified rate policy, and forwards all remaining arguments to the underlying socket. The socket then needs to be open and connected or accepted before data can be sent or received on it.
[heading Parameters][table [[Name][Description]]  [[`policy`][    
The rate policy object to use. The stream will take ownership of this object by decay-copy.  ]]  [[`args`][    
A list of parameters forwarded to the constructor of the underlying socket.   ]]]
[endsect][section:overload3 basic_stream::basic_stream (3 of 3 overloads)]
Move constructor. [heading Synopsis]```basic_stream(    basic_stream&& other);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`other`][    
The other object from which the move will occur.  ]]]
[heading Remarks]
Following the move, the moved-from object is in the same state as if newly constructed. 
[endsect][endsect][section:cancel basic_stream::cancel][indexterm2 cancel..basic_stream]
Cancel all asynchronous operations associated with the socket. [heading Synopsis]```voidcancel();```[heading Description]
This function causes all outstanding asynchronous connect, read, and write operations to finish immediately. Completion handlers for cancelled operations will receive the error `net::error::operation_aborted`. Completion handlers not yet invoked whose operations have completed, will receive the error corresponding to the result of the operation (which may indicate success). [endsect][section:close basic_stream::close][indexterm2 close..basic_stream]
Close the timed stream. [heading Synopsis]```voidclose();```[heading Description]
This cancels all of the outstanding asynchronous operations as if by calling [link beast.ref.boost__beast__basic_stream.cancel `basic_stream::cancel`], and closes the underlying socket. [endsect][section:connect basic_stream::connect][indexterm2 connect..basic_stream]
Connect the stream to the specified endpoint. ```void``[link beast.ref.boost__beast__basic_stream.connect.overload1 connect]``(    endpoint_type const& ep);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_stream.connect.overload1 more...]]``void``[link beast.ref.boost__beast__basic_stream.connect.overload2 connect]``(    endpoint_type const& ep,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_stream.connect.overload2 more...]]`````
Establishes a connection by trying each endpoint in a sequence. ```template<    class __EndpointSequence__>Protocol::endpoint``[link beast.ref.boost__beast__basic_stream.connect.overload3 connect]``(    EndpointSequence const& endpoints);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_stream.connect.overload3 more...]]``template<    class __EndpointSequence__>Protocol::endpoint``[link beast.ref.boost__beast__basic_stream.connect.overload4 connect]``(    EndpointSequence const& endpoints,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_stream.connect.overload4 more...]]``template<    class Iterator>Iterator``[link beast.ref.boost__beast__basic_stream.connect.overload5 connect]``(    Iterator begin,    Iterator end);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_stream.connect.overload5 more...]]``template<    class Iterator>Iterator``[link beast.ref.boost__beast__basic_stream.connect.overload6 connect]``(    Iterator begin,    Iterator end,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_stream.connect.overload6 more...]]``template<    class __EndpointSequence__,    class __ConnectCondition__>Protocol::endpoint``[link beast.ref.boost__beast__basic_stream.connect.overload7 connect]``(    EndpointSequence const& endpoints,    ConnectCondition connect_condition);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_stream.connect.overload7 more...]]``template<    class __EndpointSequence__,    class __ConnectCondition__>Protocol::endpoint``[link beast.ref.boost__beast__basic_stream.connect.overload8 connect]``(    EndpointSequence const& endpoints,    ConnectCondition connect_condition,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_stream.connect.overload8 more...]]``template<    class Iterator,    class __ConnectCondition__>Iterator``[link beast.ref.boost__beast__basic_stream.connect.overload9 connect]``(    Iterator begin,    Iterator end,    ConnectCondition connect_condition);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_stream.connect.overload9 more...]]``template<    class Iterator,    class __ConnectCondition__>Iterator``[link beast.ref.boost__beast__basic_stream.connect.overload10 connect]``(    Iterator begin,    Iterator end,    ConnectCondition connect_condition,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_stream.connect.overload10 more...]]`````[section:overload1 basic_stream::connect (1 of 10 overloads)]
Connect the stream to the specified endpoint. [heading Synopsis]```voidconnect(    endpoint_type const& ep);```[heading Description]
This function is used to connect the underlying socket to the specified remote endpoint. The function call will block until the connection is successfully made or an error occurs. The underlying socket is automatically opened if needed. An automatically opened socket is not returned to the closed state upon failure.
[heading Parameters][table [[Name][Description]]  [[`ep`][    
The remote endpoint to connect to.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    
Thrown on failure.  ]]]
[heading See Also]
[link beast.ref.boost__beast__basic_stream.connect `basic_stream::connect`] 
[endsect][section:overload2 basic_stream::connect (2 of 10 overloads)]
Connect the stream to the specified endpoint. [heading Synopsis]```voidconnect(    endpoint_type const& ep,    error_code& ec);```[heading Description]
This function is used to connect the underlying socket to the specified remote endpoint. The function call will block until the connection is successfully made or an error occurs. The underlying socket is automatically opened if needed. An automatically opened socket is not returned to the closed state upon failure.
[heading Parameters][table [[Name][Description]]  [[`ep`][    
The remote endpoint to connect to.  ]]  [[`ec`][    
Set to indicate what error occurred, if any.  ]]]
[heading See Also]
[link beast.ref.boost__beast__basic_stream.connect `basic_stream::connect`] 
[endsect][section:overload3 basic_stream::connect (3 of 10 overloads)]
Establishes a connection by trying each endpoint in a sequence. [heading Synopsis]```template<    class __EndpointSequence__>Protocol::endpointconnect(    EndpointSequence const& endpoints);```[heading Description]
This function attempts to connect the stream to one of a sequence of endpoints by trying each endpoint until a connection is successfully established. The underlying socket is automatically opened if needed. An automatically opened socket is not returned to the closed state upon failure.
The algorithm, known as a ['composed operation], is implemented in terms of calls to the underlying socket's `connect` function.
[heading Parameters][table [[Name][Description]]  [[`endpoints`][    
A sequence of endpoints.  ]]]
[heading Return Value]
The successfully connected endpoint.
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    
Thrown on failure. If the sequence is empty, the associated error code is `net::error::not_found`. Otherwise, contains the error from the last connection attempt.   ]]]
[endsect][section:overload4 basic_stream::connect (4 of 10 overloads)]
Establishes a connection by trying each endpoint in a sequence. [heading Synopsis]```template<    class __EndpointSequence__>Protocol::endpointconnect(    EndpointSequence const& endpoints,    error_code& ec);```[heading Description]
This function attempts to connect the stream to one of a sequence of endpoints by trying each endpoint until a connection is successfully established. The underlying socket is automatically opened if needed. An automatically opened socket is not returned to the closed state upon failure.
The algorithm, known as a ['composed operation], is implemented in terms of calls to the underlying socket's `connect` function.
[heading Parameters][table [[Name][Description]]  [[`endpoints`][    
A sequence of endpoints.  ]]  [[`ec`][    
Set to indicate what error occurred, if any. If the sequence is empty, set to `net::error::not_found`. Otherwise, contains the error from the last connection attempt.  ]]]
[heading Return Value]
On success, the successfully connected endpoint. Otherwise, a default-constructed endpoint. 
[endsect][section:overload5 basic_stream::connect (5 of 10 overloads)]
Establishes a connection by trying each endpoint in a sequence. [heading Synopsis]```template<    class Iterator>Iteratorconnect(    Iterator begin,    Iterator end);```[heading Description]
This function attempts to connect the stream to one of a sequence of endpoints by trying each endpoint until a connection is successfully established. The underlying socket is automatically opened if needed. An automatically opened socket is not returned to the closed state upon failure.
The algorithm, known as a ['composed operation], is implemented in terms of calls to the underlying socket's `connect` function.
[heading Parameters][table [[Name][Description]]  [[`begin`][    
An iterator pointing to the start of a sequence of endpoints.  ]]  [[`end`][    
An iterator pointing to the end of a sequence of endpoints.  ]]]
[heading Return Value]
An iterator denoting the successfully connected endpoint.
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    
Thrown on failure. If the sequence is empty, the associated error code is `net::error::not_found`. Otherwise, contains the error from the last connection attempt.   ]]]
[endsect][section:overload6 basic_stream::connect (6 of 10 overloads)]
Establishes a connection by trying each endpoint in a sequence. [heading Synopsis]```template<    class Iterator>Iteratorconnect(    Iterator begin,    Iterator end,    error_code& ec);```[heading Description]
This function attempts to connect the stream to one of a sequence of endpoints by trying each endpoint until a connection is successfully established. The underlying socket is automatically opened if needed. An automatically opened socket is not returned to the closed state upon failure.
The algorithm, known as a ['composed operation], is implemented in terms of calls to the underlying socket's `connect` function.
[heading Parameters][table [[Name][Description]]  [[`begin`][    
An iterator pointing to the start of a sequence of endpoints.  ]]  [[`end`][    
An iterator pointing to the end of a sequence of endpoints.  ]]  [[`ec`][    
Set to indicate what error occurred, if any. If the sequence is empty, set to boost::asio::error::not\_found. Otherwise, contains the error from the last connection attempt.  ]]]
[heading Return Value]
On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator. 
[endsect][section:overload7 basic_stream::connect (7 of 10 overloads)]
Establishes a connection by trying each endpoint in a sequence. [heading Synopsis]```template<    class __EndpointSequence__,    class __ConnectCondition__>Protocol::endpointconnect(    EndpointSequence const& endpoints,    ConnectCondition connect_condition);```[heading Description]
This function attempts to connect the stream to one of a sequence of endpoints by trying each endpoint until a connection is successfully established. The underlying socket is automatically opened if needed. An automatically opened socket is not returned to the closed state upon failure.
The algorithm, known as a ['composed operation], is implemented in terms of calls to the underlying socket's `connect` function.
[heading Parameters][table [[Name][Description]]  [[`endpoints`][    
A sequence of endpoints.  ]]  [[`connect_condition`][    
A function object that is called prior to each connection attempt. The signature of the function object must be: ```  bool connect_condition(
      error_code const& ec,
      typename Protocol::endpoint const& next);
```The `ec` parameter contains the result from the most recent connect operation. Before the first connection attempt, `ec` is always set to indicate success. The `next` parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.  ]]]
[heading Return Value]
The successfully connected endpoint.
[heading Exceptions][table [[Type][Thrown On]]  [[`boost::system::system_error`][    
Thrown on failure. If the sequence is empty, the associated error code is `net::error::not_found`. Otherwise, contains the error from the last connection attempt.   ]]]
[endsect][section:overload8 basic_stream::connect (8 of 10 overloads)]
Establishes a connection by trying each endpoint in a sequence. [heading Synopsis]```template<    class __EndpointSequence__,    class __ConnectCondition__>Protocol::endpointconnect(    EndpointSequence const& endpoints,    ConnectCondition connect_condition,    error_code& ec);```[heading Description]
This function attempts to connect the stream to one of a sequence of endpoints by trying each endpoint until a connection is successfully established. The underlying socket is automatically opened if needed. An automatically opened socket is not returned to the closed state upon failure.
The algorithm, known as a ['composed operation], is implemented in terms of calls to the underlying socket's `connect` function.
[heading Parameters][table [[Name][Description]]  [[`endpoints`][    
A sequence of endpoints.  ]]  [[`connect_condition`][    
A function object that is called prior to each connection attempt. The signature of the function object must be: ```  bool connect_condition(
      error_code const& ec,
      typename Protocol::endpoint const& next);
```The `ec` parameter contains the result from the most recent connect operation. Before the first connection attempt, `ec` is always set to indicate success. The `next` parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.  ]]  [[`ec`][    
Set to indicate what error occurred, if any. If the sequence is empty, set to `net::error::not_found`. Otherwise, contains the error from the last connection attempt.  ]]]
[heading Return Value]
On success, the successfully connected endpoint. Otherwise, a default-constructed endpoint. 
[endsect][section:overload9 basic_stream::connect (9 of 10 overloads)]
Establishes a connection by trying each endpoint in a sequence. [heading Synopsis]```template<    class Iterator,    class __ConnectCondition__>Iteratorconnect(    Iterator begin,    Iterator end,    ConnectCondition connect_condition);```[heading Description]
This function attempts to connect the stream to one of a sequence of endpoints by trying each endpoint until a connection is successfully established. The underlying socket is automatically opened if needed. An automatically opened socket is not returned to the closed state upon failure.
The algorithm, known as a ['composed operation], is implemented in terms of calls to the underlying socket's `connect` function.
[heading Parameters][table [[Name][Description]]  [[`begin`][    
An iterator pointing to the start of a sequence of endpoints.  ]]  [[`end`][    
An iterator pointing to the end of a sequence of endpoints.  ]]  [[`connect_condition`][    
A function object that is called prior to each connection attempt. The signature of the function object must be: ```  bool connect_condition(
      error_code const& ec,
      typename Protocol::endpoint const& next);
```The `ec` parameter contains the result from the most recent connect operation. Before the first connection attempt, `ec` is always set to indicate success. The `next` parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.  ]]]
[heading Return Value]
An iterator denoting the successfully connected endpoint.
[heading Exceptions][table [[Type][Thrown On]]  [[`boost::system::system_error`][    
Thrown on failure. If the sequence is empty, the associated `error_code` is `net::error::not_found`. Otherwise, contains the error from the last connection attempt.   ]]]
[endsect][section:overload10 basic_stream::connect (10 of 10 overloads)]
Establishes a connection by trying each endpoint in a sequence. [heading Synopsis]```template<    class Iterator,    class __ConnectCondition__>Iteratorconnect(    Iterator begin,    Iterator end,    ConnectCondition connect_condition,    error_code& ec);```[heading Description]
This function attempts to connect the stream to one of a sequence of endpoints by trying each endpoint until a connection is successfully established. The underlying socket is automatically opened if needed. An automatically opened socket is not returned to the closed state upon failure.
The algorithm, known as a ['composed operation], is implemented in terms of calls to the underlying socket's `connect` function.
[heading Parameters][table [[Name][Description]]  [[`begin`][    
An iterator pointing to the start of a sequence of endpoints.  ]]  [[`end`][    
An iterator pointing to the end of a sequence of endpoints.  ]]  [[`connect_condition`][    
A function object that is called prior to each connection attempt. The signature of the function object must be: ```  bool connect_condition(
      error_code const& ec,
      typename Protocol::endpoint const& next);
```The `ec` parameter contains the result from the most recent connect operation. Before the first connection attempt, `ec` is always set to indicate success. The `next` parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.  ]]  [[`ec`][    
Set to indicate what error occurred, if any. If the sequence is empty, set to `net::error::not_found`. Otherwise, contains the error from the last connection attempt.  ]]]
[heading Return Value]
On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator. 
[endsect][endsect][section:endpoint_type basic_stream::endpoint_type][indexterm2 endpoint_type..basic_stream]
The endpoint type. [heading Synopsis]```using endpoint_type = typename Protocol::endpoint;```[heading Description][endsect][section:executor_type basic_stream::executor_type][indexterm2 executor_type..basic_stream]
The type of the executor associated with the stream. [heading Synopsis]```using executor_type = beast::executor_type< socket_type >;```[heading Description]
This will be the type of executor used to invoke completion handlers which do not have an explicit associated executor. [endsect][section:expires_after basic_stream::expires_after][indexterm2 expires_after..basic_stream]
Set the timeout for the next logical operation. [heading Synopsis]```voidexpires_after(    std::chrono::nanoseconds expiry_time);```[heading Description]
This sets either the read timer, the write timer, or both timers to expire after the specified amount of time has elapsed. If a timer expires when the corresponding asynchronous operation is outstanding, the stream will be closed and any outstanding operations will complete with the error [link beast.ref.boost__beast__error `timeout`]. Otherwise, if the timer expires while no operations are outstanding, and the expiraton is not set again, the next operation will time out immediately.
The timer applies collectively to any asynchronous reads or writes initiated after the expiration is set, until the expiration is set again. A call to [link beast.ref.boost__beast__basic_stream.async_connect `basic_stream::async_connect`] counts as both a read and a write.
[heading Parameters][table [[Name][Description]]  [[`expiry_time`][    
The amount of time after which a logical operation should be considered timed out.   ]]]
[endsect][section:expires_at basic_stream::expires_at][indexterm2 expires_at..basic_stream]
Set the timeout for the next logical operation. [heading Synopsis]```voidexpires_at(    net::steady_timer::time_point expiry_time);```[heading Description]
This sets either the read timer, the write timer, or both timers to expire at the specified time point. If a timer expires when the corresponding asynchronous operation is outstanding, the stream will be closed and any outstanding operations will complete with the error [link beast.ref.boost__beast__error `timeout`]. Otherwise, if the timer expires while no operations are outstanding, and the expiraton is not set again, the next operation will time out immediately.
The timer applies collectively to any asynchronous reads or writes initiated after the expiration is set, until the expiration is set again. A call to [link beast.ref.boost__beast__basic_stream.async_connect `basic_stream::async_connect`] counts as both a read and a write.
[heading Parameters][table [[Name][Description]]  [[`expiry_time`][    
The time point after which a logical operation should be considered timed out.   ]]]
[endsect][section:expires_never basic_stream::expires_never][indexterm2 expires_never..basic_stream]
Disable the timeout for the next logical operation. [heading Synopsis]```voidexpires_never();```[heading Description][endsect][section:get_executor basic_stream::get_executor][indexterm2 get_executor..basic_stream]
Get the executor associated with the object. [heading Synopsis]```executor_typeget_executor();```[heading Description]
This function may be used to obtain the executor object that the stream uses to dispatch completion handlers without an assocaited executor.
[heading Return Value]
A copy of the executor that stream will use to dispatch handlers. 
[endsect][section:operator_eq_ basic_stream::operator=][indexterm2 operator=..basic_stream]
Move assignment (deleted). [heading Synopsis]```basic_stream&operator=(    basic_stream&&);```[heading Description][endsect][section:protocol_type basic_stream::protocol_type][indexterm2 protocol_type..basic_stream]
The protocol type. [heading Synopsis]```using protocol_type = Protocol;```[heading Description][endsect][section:rate_policy basic_stream::rate_policy][indexterm2 rate_policy..basic_stream]
Returns the rate policy associated with the object. ```RatePolicy&``[link beast.ref.boost__beast__basic_stream.rate_policy.overload1 rate_policy]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_stream.rate_policy.overload1 more...]]``RatePolicy const &``[link beast.ref.boost__beast__basic_stream.rate_policy.overload2 rate_policy]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_stream.rate_policy.overload2 more...]]`````[section:overload1 basic_stream::rate_policy (1 of 2 overloads)]
Returns the rate policy associated with the object. [heading Synopsis]```RatePolicy&rate_policy();```[heading Description][endsect][section:overload2 basic_stream::rate_policy (2 of 2 overloads)]
Returns the rate policy associated with the object. [heading Synopsis]```RatePolicy const &rate_policy() const;```[heading Description][endsect][endsect][section:read_some basic_stream::read_some][indexterm2 read_some..basic_stream]
Read some data. ```template<    class __MutableBufferSequence__>std::size_t``[link beast.ref.boost__beast__basic_stream.read_some.overload1 read_some]``(    MutableBufferSequence const& buffers);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_stream.read_some.overload1 more...]]``template<    class __MutableBufferSequence__>std::size_t``[link beast.ref.boost__beast__basic_stream.read_some.overload2 read_some]``(    MutableBufferSequence const& buffers,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_stream.read_some.overload2 more...]]`````[section:overload1 basic_stream::read_some (1 of 2 overloads)]
Read some data. [heading Synopsis]```template<    class __MutableBufferSequence__>std::size_tread_some(    MutableBufferSequence const& buffers);```[heading Description]
This function is used to read some data from the stream.
The call blocks until one of the following is true:

* One or more bytes are read from the stream.


* An error occurs.

[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The buffers into which the data will be read. If the size of the buffers is zero bytes, the call always returns immediately with no error.  ]]]
[heading Return Value]
The number of bytes read.
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    
Thrown on failure.  ]]]
[heading Remarks]
The `read_some` operation may not receive all of the requested number of bytes. Consider using the function `net::read` if you need to ensure that the requested amount of data is read before the blocking operation completes. 
[endsect][section:overload2 basic_stream::read_some (2 of 2 overloads)]
Read some data. [heading Synopsis]```template<    class __MutableBufferSequence__>std::size_tread_some(    MutableBufferSequence const& buffers,    error_code& ec);```[heading Description]
This function is used to read some data from the underlying socket.
The call blocks until one of the following is true:

* One or more bytes are read from the stream.


* An error occurs.

[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The buffers into which the data will be read. If the size of the buffers is zero bytes, the call always returns immediately with no error.  ]]  [[`ec`][    
Set to indicate what error occurred, if any.  ]]]
[heading Return Value]
The number of bytes read.
[heading Remarks]
The `read_some` operation may not receive all of the requested number of bytes. Consider using the function `net::read` if you need to ensure that the requested amount of data is read before the blocking operation completes. 
[endsect][endsect][section:release_socket basic_stream::release_socket][indexterm2 release_socket..basic_stream]
Release ownership of the underlying socket. [heading Synopsis]```socket_typerelease_socket();```[heading Description]
This function causes all outstanding asynchronous connect, read, and write operations to be canceled as if by a call to [link beast.ref.boost__beast__basic_stream.cancel `basic_stream::cancel`]. Ownership of the underlying socket is then transferred to the caller. [endsect][section:socket basic_stream::socket][indexterm2 socket..basic_stream]
Return a reference to the underlying socket. ```socket_type&``[link beast.ref.boost__beast__basic_stream.socket.overload1 socket]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_stream.socket.overload1 more...]]``socket_type const &``[link beast.ref.boost__beast__basic_stream.socket.overload2 socket]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_stream.socket.overload2 more...]]`````[section:overload1 basic_stream::socket (1 of 2 overloads)]
Return a reference to the underlying socket. [heading Synopsis]```socket_type&socket();```[heading Description][endsect][section:overload2 basic_stream::socket (2 of 2 overloads)]
Return a reference to the underlying socket. [heading Synopsis]```socket_type const &socket() const;```[heading Description][endsect][endsect][section:socket_type basic_stream::socket_type][indexterm2 socket_type..basic_stream]
The type of the underlying socket. [heading Synopsis]```using socket_type = net::basic_stream_socket< Protocol, Executor >;```[heading Description][endsect][section:write_some basic_stream::write_some][indexterm2 write_some..basic_stream]
Write some data. ```template<    class __ConstBufferSequence__>std::size_t``[link beast.ref.boost__beast__basic_stream.write_some.overload1 write_some]``(    ConstBufferSequence const& buffers);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_stream.write_some.overload1 more...]]``template<    class __ConstBufferSequence__>std::size_t``[link beast.ref.boost__beast__basic_stream.write_some.overload2 write_some]``(    ConstBufferSequence const& buffers,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_stream.write_some.overload2 more...]]`````[section:overload1 basic_stream::write_some (1 of 2 overloads)]
Write some data. [heading Synopsis]```template<    class __ConstBufferSequence__>std::size_twrite_some(    ConstBufferSequence const& buffers);```[heading Description]
This function is used to write some data to the stream.
The call blocks until one of the following is true:

* One or more bytes are written to the stream.


* An error occurs.

[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The buffers from which the data will be written. If the size of the buffers is zero bytes, the call always returns immediately with no error.  ]]]
[heading Return Value]
The number of bytes written.
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    
Thrown on failure.  ]]]
[heading Remarks]
The `write_some` operation may not transmit all of the requested number of bytes. Consider using the function `net::write` if you need to ensure that the requested amount of data is written before the blocking operation completes. 
[endsect][section:overload2 basic_stream::write_some (2 of 2 overloads)]
Write some data. [heading Synopsis]```template<    class __ConstBufferSequence__>std::size_twrite_some(    ConstBufferSequence const& buffers,    error_code& ec);```[heading Description]
This function is used to write some data to the stream.
The call blocks until one of the following is true:

* One or more bytes are written to the stream.


* An error occurs.

[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The buffers from which the data will be written. If the size of the buffers is zero bytes, the call always returns immediately with no error.  ]]  [[`ec`][    
Set to indicate what error occurred, if any.  ]]]
[heading Return Value]
The number of bytes written.
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    
Thrown on failure.  ]]]
[heading Remarks]
The `write_some` operation may not transmit all of the requested number of bytes. Consider using the function `net::write` if you need to ensure that the requested amount of data is written before the blocking operation completes. 
[endsect][endsect][section:basic_stream_dtor_ basic_stream::~basic_stream][indexterm2 ~basic_stream..basic_stream]
Destructor. [heading Synopsis]```~basic_stream();```[heading Description]
This function destroys the stream, cancelling any outstanding asynchronous operations associated with the socket as if by calling cancel. [endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__basic_stream__impl_type basic_stream::impl_type][heading Synopsis]Defined in header [include_file boost/beast/core/basic_stream.hpp]```struct impl_type :    public boost::enable_shared_from_this< impl_type >,    public boost::empty_value< RatePolicy >```[heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__basic_stream__impl_type.close [*close]]]    [          ]  ]  [    [[link beast.ref.boost__beast__basic_stream__impl_type.ex [*ex]]]    [          ]  ]  [    [[link beast.ref.boost__beast__basic_stream__impl_type.impl_type [*impl_type]]]    [          ]  ]  [    [[link beast.ref.boost__beast__basic_stream__impl_type.on_timer [*on_timer]]]    [          ]  ]  [    [[link beast.ref.boost__beast__basic_stream__impl_type.operator_eq_ [*operator=]]]    [          ]  ]  [    [[link beast.ref.boost__beast__basic_stream__impl_type.policy [*policy]]]    [          ]  ]  [    [[link beast.ref.boost__beast__basic_stream__impl_type.reset [*reset]]]    [          ]  ]][heading Data Members][table [[Name][Description]]  [    [[link beast.ref.boost__beast__basic_stream__impl_type.read [*read]]]    [          ]  ]  [    [[link beast.ref.boost__beast__basic_stream__impl_type.socket [*socket]]]    [          ]  ]  [    [[link beast.ref.boost__beast__basic_stream__impl_type.timer [*timer]]]    [          ]  ]  [    [[link beast.ref.boost__beast__basic_stream__impl_type.waiting [*waiting]]]    [          ]  ]  [    [[link beast.ref.boost__beast__basic_stream__impl_type.write [*write]]]    [          ]  ]][heading Description][section:close basic_stream::impl_type::close][indexterm2 close..basic_stream::impl_type][heading Synopsis]```voidclose();```[heading Description][endsect][section:ex basic_stream::impl_type::ex][indexterm2 ex..basic_stream::impl_type][heading Synopsis]```beast::executor_type< socket_type >ex();```[heading Description][endsect][section:impl_type basic_stream::impl_type::impl_type][indexterm2 impl_type..basic_stream::impl_type]`````[link beast.ref.boost__beast__basic_stream__impl_type.impl_type.overload1 impl_type]``(    impl_type&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_stream__impl_type.impl_type.overload1 more...]]``template<    class... Args>explicit``[link beast.ref.boost__beast__basic_stream__impl_type.impl_type.overload2 impl_type]``(    std::false_type,    Args&& ...);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_stream__impl_type.impl_type.overload2 more...]]``template<    class RatePolicy_,    class... Args>explicit``[link beast.ref.boost__beast__basic_stream__impl_type.impl_type.overload3 impl_type]``(    std::true_type,    RatePolicy_&& policy,    Args&& ...);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_stream__impl_type.impl_type.overload3 more...]]`````[section:overload1 basic_stream::impl_type::impl_type (1 of 3 overloads)][heading Synopsis]```impl_type(    impl_type&&);```[heading Description][endsect][section:overload2 basic_stream::impl_type::impl_type (2 of 3 overloads)][heading Synopsis]```template<    class... Args>impl_type(    std::false_type,    Args&& ...);```[heading Description][endsect][section:overload3 basic_stream::impl_type::impl_type (3 of 3 overloads)][heading Synopsis]```template<    class RatePolicy_,    class... Args>impl_type(    std::true_type,    RatePolicy_&& policy,    Args&& ...);```[heading Description][endsect][endsect][section:on_timer basic_stream::impl_type::on_timer][indexterm2 on_timer..basic_stream::impl_type][heading Synopsis]```template<    class __Executor2__>voidon_timer(    Executor2 const& ex2);```[heading Description][endsect][section:operator_eq_ basic_stream::impl_type::operator=][indexterm2 operator=..basic_stream::impl_type][heading Synopsis]```impl_type&operator=(    impl_type&&);```[heading Description][endsect][section:policy basic_stream::impl_type::policy][indexterm2 policy..basic_stream::impl_type]```RatePolicy&``[link beast.ref.boost__beast__basic_stream__impl_type.policy.overload1 policy]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_stream__impl_type.policy.overload1 more...]]``RatePolicy const &``[link beast.ref.boost__beast__basic_stream__impl_type.policy.overload2 policy]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_stream__impl_type.policy.overload2 more...]]`````[section:overload1 basic_stream::impl_type::policy (1 of 2 overloads)][heading Synopsis]```RatePolicy&policy();```[heading Description][endsect][section:overload2 basic_stream::impl_type::policy (2 of 2 overloads)][heading Synopsis]```RatePolicy const &policy() const;```[heading Description][endsect][endsect][section:read basic_stream::impl_type::read][indexterm2 read..basic_stream::impl_type][heading Synopsis]```op_state read;```[heading Description][endsect][section:reset basic_stream::impl_type::reset][indexterm2 reset..basic_stream::impl_type][heading Synopsis]```voidreset();```[heading Description][endsect][section:socket basic_stream::impl_type::socket][indexterm2 socket..basic_stream::impl_type][heading Synopsis]```net::basic_stream_socket< Protocol, Executor > socket;```[heading Description][endsect][section:timer basic_stream::impl_type::timer][indexterm2 timer..basic_stream::impl_type][heading Synopsis]```net::steady_timer timer;```[heading Description][endsect][section:waiting basic_stream::impl_type::waiting][indexterm2 waiting..basic_stream::impl_type][heading Synopsis]```int waiting = 0;```[heading Description][endsect][section:write basic_stream::impl_type::write][indexterm2 write..basic_stream::impl_type][heading Synopsis]```op_state write;```[heading Description][endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__basic_stream__timeout_handler basic_stream::timeout_handler][heading Synopsis]Defined in header [include_file boost/beast/core/basic_stream.hpp]```template<    class __Executor2__>struct timeout_handler```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__basic_string_view basic_string_view][indexterm1 basic_string_view]
The type of `basic_string_view` used by the library. [heading Synopsis]Defined in header [include_file boost/beast/core/string_type.hpp]```template<    class CharT,    class Traits>using basic_string_view = boost::basic_string_view< CharT, Traits >;```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__beast_close_socket beast_close_socket][indexterm1 beast_close_socket]
Default socket close function. [heading Synopsis]Defined in header [include_file boost/beast/core/stream_traits.hpp]```template<    class __Protocol__,    class __Executor__>voidbeast_close_socket(    net::basic_socket< Protocol, Executor >& sock);```[heading Description]
This function is not meant to be called directly. Instead, it is called automatically when using [link beast.ref.boost__beast__close_socket `close_socket`]. To enable closure of user-defined types or classes derived from a particular user-defined type, this function should be overloaded in the corresponding namespace for the type in question.
[heading See Also]
[link beast.ref.boost__beast__close_socket `close_socket`] 
Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__bind_front_handler bind_front_handler][indexterm1 bind_front_handler]
Bind parameters to a completion handler, creating a new handler. [heading Synopsis]Defined in header [include_file boost/beast/core/bind_handler.hpp]```template<    class __Handler__,    class... Args>``['implementation-defined]``bind_front_handler(    Handler&& handler,    Args&&... args);```[heading Description]
This function creates a new handler which, when invoked, calls the original handler with the list of bound arguments. Any parameters passed in the invocation will be forwarded in the parameter list after the bound arguments.
The passed handler and arguments are forwarded into the returned handler, whose associated allocator and associated executor will will be the same as those of the original handler.
[heading Example]

This function posts the invocation of the specified completion handler with bound arguments:
```  template <class AsyncReadStream, class ReadHandler>
  void
  signal_eof (AsyncReadStream& stream, ReadHandler&& handler)
  {
      net::post(
          stream.get_executor(),
          bind_front_handler (std::forward<ReadHandler> (handler),
              net::error::eof, 0));
  }
```
[heading Parameters][table [[Name][Description]]  [[`handler`][    
The handler to wrap. The implementation takes ownership of the handler by performing a decay-copy.  ]]  [[`args`][    
A list of arguments to bind to the handler. The arguments are forwarded into the returned object.   ]]]
Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__bind_handler bind_handler][indexterm1 bind_handler]
Bind parameters to a completion handler, creating a new handler. [heading Synopsis]Defined in header [include_file boost/beast/core/bind_handler.hpp]```template<    class __Handler__,    class... Args>``['implementation-defined]``bind_handler(    Handler&& handler,    Args&&... args);```[heading Description]
This function creates a new handler which, when invoked, calls the original handler with the list of bound arguments. Any parameters passed in the invocation will be substituted for placeholders present in the list of bound arguments. Parameters which are not matched to placeholders are silently discarded.
The passed handler and arguments are forwarded into the returned handler, whose associated allocator and associated executor will will be the same as those of the original handler.
[heading Example]

This function posts the invocation of the specified completion handler with bound arguments:
```  template <class AsyncReadStream, class ReadHandler>
  void
  signal_aborted (AsyncReadStream& stream, ReadHandler&& handler)
  {
      net::post(
          stream.get_executor(),
          bind_handler (std::forward <ReadHandler> (handler),
              net::error::operation_aborted, 0));
  }
```
[heading Parameters][table [[Name][Description]]  [[`handler`][    
The handler to wrap. The implementation takes ownership of the handler by performing a decay-copy.  ]]  [[`args`][    
A list of arguments to bind to the handler. The arguments are forwarded into the returned object. These arguments may include placeholders, which will operate in a fashion identical to a call to `std::bind`.   ]]]
Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__buffer_bytes buffer_bytes][indexterm1 buffer_bytes]
Return the total number of bytes in a buffer or buffer sequence. [heading Synopsis]Defined in header [include_file boost/beast/core/buffer_traits.hpp]```template<    class __BufferSequence__>std::size_tbuffer_bytes(    BufferSequence const& buffers);```[heading Description]
This function returns the total number of bytes in a buffer, buffer sequence, or object convertible to a buffer. Specifically it may be passed:

* A ['ConstBufferSequence] or ['MutableBufferSequence]


* A `net::const_buffer` or `net::mutable_buffer`


* An object convertible to `net::const_buffer`

This function is designed as an easier-to-use replacement for `net::buffer_size`. It recognizes customization points found through argument-dependent lookup. The call `beast::buffer_bytes(b)` is equivalent to performing: ```  using namespace net;
  buffer_bytes(b);
```In addition this handles types which are convertible to `net::const_buffer`; these are not handled by `net::buffer_size`.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The buffer or buffer sequence to calculate the size of.  ]]]
[heading Return Value]
The total number of bytes in the buffer or sequence. 
Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__buffered_read_stream buffered_read_stream]
A ['Stream] with attached ['DynamicBuffer] to buffer reads. [heading Synopsis]Defined in header [include_file boost/beast/core/buffered_read_stream.hpp]```template<    class __Stream__,    class __DynamicBuffer__>class buffered_read_stream```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__buffered_read_stream.buffer_type [*buffer_type]]]    [      The type of the internal buffer.     ]  ]  [    [[link beast.ref.boost__beast__buffered_read_stream.executor_type [*executor_type]]]    [          ]  ]  [    [[link beast.ref.boost__beast__buffered_read_stream.next_layer_type [*next_layer_type]]]    [      The type of the next layer.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__buffered_read_stream.async_read_some [*async_read_some]]]    [      Start an asynchronous read.     ]  ]  [    [[link beast.ref.boost__beast__buffered_read_stream.async_write_some [*async_write_some]]]    [      Start an asynchronous write.     ]  ]  [    [[link beast.ref.boost__beast__buffered_read_stream.buffer [*buffer]]]    [      Access the internal buffer.     ]  ]  [    [[link beast.ref.boost__beast__buffered_read_stream.buffered_read_stream [*buffered_read_stream]]]    [      Move constructor.       Construct the wrapping stream.     ]  ]  [    [[link beast.ref.boost__beast__buffered_read_stream.capacity [*capacity]]]    [      Set the maximum buffer size.     ]  ]  [    [[link beast.ref.boost__beast__buffered_read_stream.get_executor [*get_executor]]]    [      Get the executor associated with the object.     ]  ]  [    [[link beast.ref.boost__beast__buffered_read_stream.next_layer [*next_layer]]]    [      Get a reference to the next layer.       Get a const reference to the next layer.     ]  ]  [    [[link beast.ref.boost__beast__buffered_read_stream.operator_eq_ [*operator=]]]    [      Move assignment.     ]  ]  [    [[link beast.ref.boost__beast__buffered_read_stream.read_some [*read_some]]]    [      Read some data from the stream.     ]  ]  [    [[link beast.ref.boost__beast__buffered_read_stream.write_some [*write_some]]]    [      Write some data to the stream.     ]  ]][heading Description]
This wraps a ['Stream] implementation so that calls to write are passed through to the underlying stream, while calls to read will first consume the input sequence stored in a ['DynamicBuffer] which is part of the object.
The use-case for this class is different than that of the `net::buffered_read_stream`. It is designed to facilitate the use of `net::read_until`, and to allow buffers acquired during detection of handshakes to be made transparently available to callers. A hypothetical implementation of the buffered version of `net::ssl::stream::async_handshake` could make use of this wrapper.
Uses:

* Transparently leave untouched input acquired in calls to `net::read_until` behind for subsequent callers.


* "Preload" a stream with handshake input data acquired from other sources.

Example: ```  // Process the next HTTP header on the stream,
  // leaving excess bytes behind for the next call.
  //
  template<class Stream, class DynamicBuffer>
  void process_http_message(
      buffered_read_stream<Stream, DynamicBuffer>& stream)
  {
      // Read up to and including the end of the HTTP
      // header, leaving the sequence in the stream's
      // buffer. read_until may read past the end of the
      // headers; the return value will include only the
      // part up to the end of the delimiter.
      //
      std::size_t bytes_transferred =
          net::read_until(
              stream.next_layer(), stream.buffer(), "\r\n\r\n");

      // Use buffers_prefix() to limit the input
      // sequence to only the data up to and including
      // the trailing "\r\n\r\n".
      //
      auto header_buffers = buffers_prefix(
          bytes_transferred, stream.buffer().data());

      ...

      // Discard the portion of the input corresponding
      // to the HTTP headers.
      //
      stream.buffer().consume(bytes_transferred);

      // Everything we read from the stream
      // is part of the content-body.
  }
```
[heading Template Parameters][table [[Type][Description]]  [[`Stream`][    
The type of stream to wrap.  ]]  [[`DynamicBuffer`][    
The type of stream buffer to use.   ]]]
[section:async_read_some buffered_read_stream::async_read_some][indexterm2 async_read_some..buffered_read_stream]
Start an asynchronous read. [heading Synopsis]```template<    class __MutableBufferSequence__,    class __ReadHandler__>``__deduced__``async_read_some(    MutableBufferSequence const& buffers,    ReadHandler&& handler);```[heading Description]
This function is used to asynchronously read data from the stream. The function call always returns immediately.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
One or more buffers into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      error_code const& error,      // result of operation
      std::size_t bytes_transferred // number of bytes transferred
  );
```  ]]]
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`. [endsect][section:async_write_some buffered_read_stream::async_write_some][indexterm2 async_write_some..buffered_read_stream]
Start an asynchronous write. [heading Synopsis]```template<    class __ConstBufferSequence__,    class __WriteHandler__>``__deduced__``async_write_some(    ConstBufferSequence const& buffers,    WriteHandler&& handler);```[heading Description]
This function is used to asynchronously write data from the stream. The function call always returns immediately.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
One or more data buffers to be written to the stream. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      error_code const& error,      // result of operation
      std::size_t bytes_transferred // number of bytes transferred
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.   ]]]
[endsect][section:buffer buffered_read_stream::buffer][indexterm2 buffer..buffered_read_stream]
Access the internal buffer. ```DynamicBuffer&``[link beast.ref.boost__beast__buffered_read_stream.buffer.overload1 buffer]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__buffered_read_stream.buffer.overload1 more...]]``DynamicBuffer const &``[link beast.ref.boost__beast__buffered_read_stream.buffer.overload2 buffer]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__buffered_read_stream.buffer.overload2 more...]]`````[section:overload1 buffered_read_stream::buffer (1 of 2 overloads)]
Access the internal buffer. [heading Synopsis]```DynamicBuffer&buffer();```[heading Description]
The internal buffer is returned. It is possible for the caller to break invariants with this function. For example, by causing the internal buffer size to increase beyond the caller defined maximum. [endsect][section:overload2 buffered_read_stream::buffer (2 of 2 overloads)]
Access the internal buffer. [heading Synopsis]```DynamicBuffer const &buffer() const;```[heading Description][endsect][endsect][section:buffer_type buffered_read_stream::buffer_type][indexterm2 buffer_type..buffered_read_stream]
The type of the internal buffer. [heading Synopsis]```using buffer_type = DynamicBuffer;```[heading Description][endsect][section:buffered_read_stream buffered_read_stream::buffered_read_stream][indexterm2 buffered_read_stream..buffered_read_stream]
Move constructor. `````[link beast.ref.boost__beast__buffered_read_stream.buffered_read_stream.overload1 buffered_read_stream]``(    buffered_read_stream&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffered_read_stream.buffered_read_stream.overload1 more...]]`````
Construct the wrapping stream. ```template<    class... Args>explicit``[link beast.ref.boost__beast__buffered_read_stream.buffered_read_stream.overload2 buffered_read_stream]``(    Args&&... args);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffered_read_stream.buffered_read_stream.overload2 more...]]`````[section:overload1 buffered_read_stream::buffered_read_stream (1 of 2 overloads)]
Move constructor. [heading Synopsis]```buffered_read_stream(    buffered_read_stream&&);```[heading Description]
[heading Remarks]
The behavior of move assignment on or from streams with active or pending operations is undefined. 
[endsect][section:overload2 buffered_read_stream::buffered_read_stream (2 of 2 overloads)]
Construct the wrapping stream. [heading Synopsis]```template<    class... Args>buffered_read_stream(    Args&&... args);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`args`][    
Parameters forwarded to the `Stream` constructor.   ]]]
[endsect][endsect][section:capacity buffered_read_stream::capacity][indexterm2 capacity..buffered_read_stream]
Set the maximum buffer size. [heading Synopsis]```voidcapacity(    std::size_t size);```[heading Description]
This changes the maximum size of the internal buffer used to hold read data. No bytes are discarded by this call. If the buffer size is set to zero, no more data will be buffered.
Thread safety: The caller is responsible for making sure the call is made from the same implicit or explicit strand.
[heading Parameters][table [[Name][Description]]  [[`size`][    
The number of bytes in the read buffer.  ]]]
[heading Remarks]
This is a soft limit. If the new maximum size is smaller than the amount of data in the buffer, no bytes are discarded. 
[endsect][section:executor_type buffered_read_stream::executor_type][indexterm2 executor_type..buffered_read_stream][heading Synopsis]```using executor_type = beast::executor_type< next_layer_type >;```[heading Description][endsect][section:get_executor buffered_read_stream::get_executor][indexterm2 get_executor..buffered_read_stream]
Get the executor associated with the object. [heading Synopsis]```executor_typeget_executor();```[heading Description]
This function may be used to obtain the executor object that the stream uses to dispatch handlers for asynchronous operations.
[heading Return Value]
A copy of the executor that stream will use to dispatch handlers. 
[endsect][section:next_layer buffered_read_stream::next_layer][indexterm2 next_layer..buffered_read_stream]
Get a reference to the next layer. ```next_layer_type&``[link beast.ref.boost__beast__buffered_read_stream.next_layer.overload1 next_layer]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__buffered_read_stream.next_layer.overload1 more...]]`````
Get a const reference to the next layer. ```next_layer_type const &``[link beast.ref.boost__beast__buffered_read_stream.next_layer.overload2 next_layer]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__buffered_read_stream.next_layer.overload2 more...]]`````[section:overload1 buffered_read_stream::next_layer (1 of 2 overloads)]
Get a reference to the next layer. [heading Synopsis]```next_layer_type&next_layer();```[heading Description][endsect][section:overload2 buffered_read_stream::next_layer (2 of 2 overloads)]
Get a const reference to the next layer. [heading Synopsis]```next_layer_type const &next_layer() const;```[heading Description][endsect][endsect][section:next_layer_type buffered_read_stream::next_layer_type][indexterm2 next_layer_type..buffered_read_stream]
The type of the next layer. [heading Synopsis]```using next_layer_type = typename std::remove_reference< Stream >::type;```[heading Description][endsect][section:operator_eq_ buffered_read_stream::operator=][indexterm2 operator=..buffered_read_stream]
Move assignment. [heading Synopsis]```buffered_read_stream&operator=(    buffered_read_stream&&);```[heading Description]
[heading Remarks]
The behavior of move assignment on or from streams with active or pending operations is undefined. 
[endsect][section:read_some buffered_read_stream::read_some][indexterm2 read_some..buffered_read_stream]
Read some data from the stream. ```template<    class __MutableBufferSequence__>std::size_t``[link beast.ref.boost__beast__buffered_read_stream.read_some.overload1 read_some]``(    MutableBufferSequence const& buffers);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffered_read_stream.read_some.overload1 more...]]``template<    class __MutableBufferSequence__>std::size_t``[link beast.ref.boost__beast__buffered_read_stream.read_some.overload2 read_some]``(    MutableBufferSequence const& buffers,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffered_read_stream.read_some.overload2 more...]]`````[section:overload1 buffered_read_stream::read_some (1 of 2 overloads)]
Read some data from the stream. [heading Synopsis]```template<    class __MutableBufferSequence__>std::size_tread_some(    MutableBufferSequence const& buffers);```[heading Description]
This function is used to read data from the stream. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
One or more buffers into which the data will be read.  ]]]
[heading Return Value]
The number of bytes read.
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    
Thrown on failure.   ]]]
[endsect][section:overload2 buffered_read_stream::read_some (2 of 2 overloads)]
Read some data from the stream. [heading Synopsis]```template<    class __MutableBufferSequence__>std::size_tread_some(    MutableBufferSequence const& buffers,    error_code& ec);```[heading Description]
This function is used to read data from the stream. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
One or more buffers into which the data will be read.  ]]  [[`ec`][    
Set to the error, if any occurred.  ]]]
[heading Return Value]
The number of bytes read, or 0 on error. 
[endsect][endsect][section:write_some buffered_read_stream::write_some][indexterm2 write_some..buffered_read_stream]
Write some data to the stream. ```template<    class __ConstBufferSequence__>std::size_t``[link beast.ref.boost__beast__buffered_read_stream.write_some.overload1 write_some]``(    ConstBufferSequence const& buffers);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffered_read_stream.write_some.overload1 more...]]``template<    class __ConstBufferSequence__>std::size_t``[link beast.ref.boost__beast__buffered_read_stream.write_some.overload2 write_some]``(    ConstBufferSequence const& buffers,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffered_read_stream.write_some.overload2 more...]]`````[section:overload1 buffered_read_stream::write_some (1 of 2 overloads)]
Write some data to the stream. [heading Synopsis]```template<    class __ConstBufferSequence__>std::size_twrite_some(    ConstBufferSequence const& buffers);```[heading Description]
This function is used to write data to the stream. The function call will block until one or more bytes of the data has been written successfully, or until an error occurs.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
One or more data buffers to be written to the stream.  ]]]
[heading Return Value]
The number of bytes written.
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    
Thrown on failure.   ]]]
[endsect][section:overload2 buffered_read_stream::write_some (2 of 2 overloads)]
Write some data to the stream. [heading Synopsis]```template<    class __ConstBufferSequence__>std::size_twrite_some(    ConstBufferSequence const& buffers,    error_code& ec);```[heading Description]
This function is used to write data to the stream. The function call will block until one or more bytes of the data has been written successfully, or until an error occurs.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
One or more data buffers to be written to the stream.  ]]  [[`ec`][    
Set to the error, if any occurred.  ]]]
[heading Return Value]
The number of bytes written. 
[endsect][endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__buffers buffers][indexterm1 buffers][heading Synopsis]Defined in header [include_file boost/beast/core/ostream.hpp]```template<    class T>voidbuffers(    T const&);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__buffers_adaptor buffers_adaptor]
Adapts a ['MutableBufferSequence] into a ['DynamicBuffer]. [heading Synopsis]Defined in header [include_file boost/beast/core/buffers_adaptor.hpp]```template<    class __MutableBufferSequence__>class buffers_adaptor```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__buffers_adaptor.const_buffers_type [*const_buffers_type]]]    [      The ConstBufferSequence used to represent the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__buffers_adaptor.mutable_buffers_type [*mutable_buffers_type]]]    [      The MutableBufferSequence used to represent the writable bytes.     ]  ]  [    [[link beast.ref.boost__beast__buffers_adaptor.mutable_data_type [*mutable_data_type]]]    [      The MutableBufferSequence used to represent the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__buffers_adaptor.value_type [*value_type]]]    [      The type of the underlying mutable buffer sequence.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__buffers_adaptor.buffers_adaptor [*buffers_adaptor]]]    [      Construct a buffers adaptor.       Constructor.       Copy Constructor.     ]  ]  [    [[link beast.ref.boost__beast__buffers_adaptor.capacity [*capacity]]]    [      Return the maximum number of bytes, both readable and writable, that can be held without requiring an allocation.     ]  ]  [    [[link beast.ref.boost__beast__buffers_adaptor.cdata [*cdata]]]    [      Returns a constant buffer sequence representing the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__buffers_adaptor.commit [*commit]]]    [      Append writable bytes to the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__buffers_adaptor.consume [*consume]]]    [      Remove bytes from beginning of the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__buffers_adaptor.data [*data]]]    [      Returns a constant buffer sequence representing the readable bytes.       Returns a mutable buffer sequence representing the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__buffers_adaptor.max_size [*max_size]]]    [      Return the maximum number of bytes, both readable and writable, that can ever be held.     ]  ]  [    [[link beast.ref.boost__beast__buffers_adaptor.operator_eq_ [*operator=]]]    [      Copy Assignment.     ]  ]  [    [[link beast.ref.boost__beast__buffers_adaptor.prepare [*prepare]]]    [      Returns a mutable buffer sequence representing writable bytes.     ]  ]  [    [[link beast.ref.boost__beast__buffers_adaptor.size [*size]]]    [      Returns the number of readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__buffers_adaptor.value [*value]]]    [      Returns the original mutable buffer sequence.     ]  ]][heading Description]
This class wraps a ['MutableBufferSequence] to meet the requirements of ['DynamicBuffer]. Upon construction the input and output sequences are empty. A copy of the mutable buffer sequence object is stored; however, ownership of the underlying memory is not transferred. The caller is responsible for making sure that referenced memory remains valid for the duration of any operations.
The size of the mutable buffer sequence determines the maximum number of bytes which may be prepared and committed.
[heading Template Parameters][table [[Type][Description]]  [[`MutableBufferSequence`][    
The type of mutable buffer sequence to adapt.   ]]]
[section:buffers_adaptor buffers_adaptor::buffers_adaptor][indexterm2 buffers_adaptor..buffers_adaptor]
Construct a buffers adaptor. ```explicit``[link beast.ref.boost__beast__buffers_adaptor.buffers_adaptor.overload1 buffers_adaptor]``(    MutableBufferSequence const& buffers);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_adaptor.buffers_adaptor.overload1 more...]]`````
Constructor. ```template<    class... Args>explicit``[link beast.ref.boost__beast__buffers_adaptor.buffers_adaptor.overload2 buffers_adaptor]``(    boost::in_place_init_t,    Args&&... args);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_adaptor.buffers_adaptor.overload2 more...]]`````
Copy Constructor. `````[link beast.ref.boost__beast__buffers_adaptor.buffers_adaptor.overload3 buffers_adaptor]``(    buffers_adaptor const& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_adaptor.buffers_adaptor.overload3 more...]]`````[section:overload1 buffers_adaptor::buffers_adaptor (1 of 3 overloads)]
Construct a buffers adaptor. [heading Synopsis]```buffers_adaptor(    MutableBufferSequence const& buffers);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The mutable buffer sequence to wrap. A copy of the object will be made, but ownership of the memory is not transferred.   ]]]
[endsect][section:overload2 buffers_adaptor::buffers_adaptor (2 of 3 overloads)]
Constructor. [heading Synopsis]```template<    class... Args>buffers_adaptor(    boost::in_place_init_t,    Args&&... args);```[heading Description]
This constructs the buffer adaptor in-place from a list of arguments.
[heading Parameters][table [[Name][Description]]  [[`args`][    
Arguments forwarded to the buffers constructor.   ]]]
[endsect][section:overload3 buffers_adaptor::buffers_adaptor (3 of 3 overloads)]
Copy Constructor. [heading Synopsis]```buffers_adaptor(    buffers_adaptor const& other);```[heading Description][endsect][endsect][section:capacity buffers_adaptor::capacity][indexterm2 capacity..buffers_adaptor]
Return the maximum number of bytes, both readable and writable, that can be held without requiring an allocation. [heading Synopsis]```std::size_tcapacity() const;```[heading Description][endsect][section:cdata buffers_adaptor::cdata][indexterm2 cdata..buffers_adaptor]
Returns a constant buffer sequence representing the readable bytes. [heading Synopsis]```const_buffers_typecdata() const;```[heading Description][endsect][section:commit buffers_adaptor::commit][indexterm2 commit..buffers_adaptor]
Append writable bytes to the readable bytes. [heading Synopsis]```voidcommit(    std::size_t n);```[heading Description]
Appends n bytes from the start of the writable bytes to the end of the readable bytes. The remainder of the writable bytes are discarded. If n is greater than the number of writable bytes, all writable bytes are appended to the readable bytes.
All buffer sequences previously obtained using [link beast.ref.boost__beast__buffers_adaptor.prepare `buffers_adaptor::prepare`] are invalidated. Buffer sequences previously obtained using [link beast.ref.boost__beast__buffers_adaptor.data `buffers_adaptor::data`] remain valid.
[heading Parameters][table [[Name][Description]]  [[`n`][    
The number of bytes to append. If this number is greater than the number of writable bytes, all writable bytes are appended.  ]]]
[heading Exception Safety]

No-throw guarantee. [endsect][section:const_buffers_type buffers_adaptor::const_buffers_type][indexterm2 const_buffers_type..buffers_adaptor]
The ConstBufferSequence used to represent the readable bytes. [heading Synopsis]```using const_buffers_type = ``['implementation-defined]``;```[heading Description][endsect][section:consume buffers_adaptor::consume][indexterm2 consume..buffers_adaptor]
Remove bytes from beginning of the readable bytes. [heading Synopsis]```voidconsume(    std::size_t n);```[heading Description]
Removes n bytes from the beginning of the readable bytes.
All buffers sequences previously obtained using [link beast.ref.boost__beast__buffers_adaptor.data `buffers_adaptor::data`] or [link beast.ref.boost__beast__buffers_adaptor.prepare `buffers_adaptor::prepare`] are invalidated.
[heading Parameters][table [[Name][Description]]  [[`n`][    
The number of bytes to remove. If this number is greater than the number of readable bytes, all readable bytes are removed.  ]]]
[heading Exception Safety]

No-throw guarantee. [endsect][section:data buffers_adaptor::data][indexterm2 data..buffers_adaptor]
Returns a constant buffer sequence representing the readable bytes. ```const_buffers_type``[link beast.ref.boost__beast__buffers_adaptor.data.overload1 data]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_adaptor.data.overload1 more...]]`````
Returns a mutable buffer sequence representing the readable bytes. ```mutable_data_type``[link beast.ref.boost__beast__buffers_adaptor.data.overload2 data]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_adaptor.data.overload2 more...]]`````[section:overload1 buffers_adaptor::data (1 of 2 overloads)]
Returns a constant buffer sequence representing the readable bytes. [heading Synopsis]```const_buffers_typedata() const;```[heading Description][endsect][section:overload2 buffers_adaptor::data (2 of 2 overloads)]
Returns a mutable buffer sequence representing the readable bytes. [heading Synopsis]```mutable_data_typedata();```[heading Description][endsect][endsect][section:max_size buffers_adaptor::max_size][indexterm2 max_size..buffers_adaptor]
Return the maximum number of bytes, both readable and writable, that can ever be held. [heading Synopsis]```std::size_tmax_size() const;```[heading Description][endsect][section:mutable_buffers_type buffers_adaptor::mutable_buffers_type][indexterm2 mutable_buffers_type..buffers_adaptor]
The MutableBufferSequence used to represent the writable bytes. [heading Synopsis]```using mutable_buffers_type = ``['implementation-defined]``;```[heading Description][endsect][section:mutable_data_type buffers_adaptor::mutable_data_type][indexterm2 mutable_data_type..buffers_adaptor]
The MutableBufferSequence used to represent the readable bytes. [heading Synopsis]```using mutable_data_type = ``['implementation-defined]``;```[heading Description][endsect][section:operator_eq_ buffers_adaptor::operator=][indexterm2 operator=..buffers_adaptor]
Copy Assignment. [heading Synopsis]```buffers_adaptor&operator=(    buffers_adaptor const&);```[heading Description][endsect][section:prepare buffers_adaptor::prepare][indexterm2 prepare..buffers_adaptor]
Returns a mutable buffer sequence representing writable bytes. [heading Synopsis]```mutable_buffers_typeprepare(    std::size_t n);```[heading Description]
Returns a mutable buffer sequence representing the writable bytes containing exactly `n` bytes of storage. This function does not allocate memory. Instead, the storage comes from the underlying mutable buffer sequence.
All buffer sequences previously obtained using [link beast.ref.boost__beast__buffers_adaptor.prepare `buffers_adaptor::prepare`] are invalidated. Buffer sequences previously obtained using [link beast.ref.boost__beast__buffers_adaptor.data `buffers_adaptor::data`] remain valid.
[heading Parameters][table [[Name][Description]]  [[`n`][    
The desired number of bytes in the returned buffer sequence.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::length_error`][    
if `size() + n` exceeds `max_size()`.  ]]]
[heading Exception Safety]

Strong guarantee. [endsect][section:size buffers_adaptor::size][indexterm2 size..buffers_adaptor]
Returns the number of readable bytes. [heading Synopsis]```std::size_tsize() const;```[heading Description][endsect][section:value buffers_adaptor::value][indexterm2 value..buffers_adaptor]
Returns the original mutable buffer sequence. [heading Synopsis]```value_type const &value() const;```[heading Description][endsect][section:value_type buffers_adaptor::value_type][indexterm2 value_type..buffers_adaptor]
The type of the underlying mutable buffer sequence. [heading Synopsis]```using value_type = MutableBufferSequence;```[heading Description][endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__buffers_adaptor__readable_bytes buffers_adaptor::readable_bytes][heading Synopsis]Defined in header [include_file boost/beast/core/buffers_adaptor.hpp]```template<    [role red error.class-detail-template.1][role red error.class-detail-template.2]>class readable_bytes```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__buffers_cat buffers_cat][indexterm1 buffers_cat]
Concatenate 1 or more buffer sequences. [heading Synopsis]Defined in header [include_file boost/beast/core/buffers_cat.hpp]```template<    class... __BufferSequence__>buffers_cat_view< BufferSequence... >buffers_cat(    BufferSequence const&... buffers);```[heading Description]
This function returns a constant or mutable buffer sequence which, when iterated, efficiently concatenates the input buffer sequences. Copies of the arguments passed will be made; however, the returned object does not take ownership of the underlying memory. The application is still responsible for managing the lifetime of the referenced memory. [heading Parameters][table [[Name][Description]]  [[`buffers`][    
The list of buffer sequences to concatenate.   ]]]
[heading Return Value]
A new buffer sequence that represents the concatenation of the input buffer sequences. This buffer sequence will be a ['MutableBufferSequence] if each of the passed buffer sequences is also a ['MutableBufferSequence]; otherwise the returned buffer sequence will be a ['ConstBufferSequence]. 
[heading See Also]
[link beast.ref.boost__beast__buffers_cat_view `buffers_cat_view`] 
Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__buffers_cat_view buffers_cat_view]
A buffer sequence representing a concatenation of buffer sequences. [heading Synopsis]Defined in header [include_file boost/beast/core/buffers_cat.hpp]```template<    class... Buffers>class buffers_cat_view```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__buffers_cat_view.value_type [*value_type]]]    [      The type of buffer returned when dereferencing an iterator.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__buffers_cat_view.begin [*begin]]]    [      Returns an iterator to the first buffer in the sequence.     ]  ]  [    [[link beast.ref.boost__beast__buffers_cat_view.buffers_cat_view [*buffers_cat_view]]]    [      Copy Constructor.       Constructor.     ]  ]  [    [[link beast.ref.boost__beast__buffers_cat_view.end [*end]]]    [      Returns an iterator to one past the last buffer in the sequence.     ]  ]  [    [[link beast.ref.boost__beast__buffers_cat_view.operator_eq_ [*operator=]]]    [      Copy Assignment.     ]  ]][heading Description]
[heading See Also]
[link beast.ref.boost__beast__buffers_cat `buffers_cat`] 
[section:begin buffers_cat_view::begin][indexterm2 begin..buffers_cat_view]
Returns an iterator to the first buffer in the sequence. [heading Synopsis]```const_iteratorbegin() const;```[heading Description][endsect][section:buffers_cat_view buffers_cat_view::buffers_cat_view][indexterm2 buffers_cat_view..buffers_cat_view]
Copy Constructor. `````[link beast.ref.boost__beast__buffers_cat_view.buffers_cat_view.overload1 buffers_cat_view]``(    buffers_cat_view const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_cat_view.buffers_cat_view.overload1 more...]]`````
Constructor. ```explicit``[link beast.ref.boost__beast__buffers_cat_view.buffers_cat_view.overload2 buffers_cat_view]``(    Buffers const&... buffers);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_cat_view.buffers_cat_view.overload2 more...]]`````[section:overload1 buffers_cat_view::buffers_cat_view (1 of 2 overloads)]
Copy Constructor. [heading Synopsis]```buffers_cat_view(    buffers_cat_view const&);```[heading Description][endsect][section:overload2 buffers_cat_view::buffers_cat_view (2 of 2 overloads)]
Constructor. [heading Synopsis]```buffers_cat_view(    Buffers const&... buffers);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The list of buffer sequences to concatenate. Copies of the arguments will be maintained for the lifetime of the concatenated sequence; however, the ownership of the memory buffers themselves is not transferred.   ]]]
[endsect][endsect][section:end buffers_cat_view::end][indexterm2 end..buffers_cat_view]
Returns an iterator to one past the last buffer in the sequence. [heading Synopsis]```const_iteratorend() const;```[heading Description][endsect][section:operator_eq_ buffers_cat_view::operator=][indexterm2 operator=..buffers_cat_view]
Copy Assignment. [heading Synopsis]```buffers_cat_view&operator=(    buffers_cat_view const&);```[heading Description][endsect][section:value_type buffers_cat_view::value_type][indexterm2 value_type..buffers_cat_view]
The type of buffer returned when dereferencing an iterator. [heading Synopsis]```using value_type = ``['see-below]``;```[heading Description]
If every buffer sequence in the view is a ['MutableBufferSequence], then `value_type` will be `net::mutable_buffer`. Otherwise, `value_type` will be `net::const_buffer`. [endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__buffers_front buffers_front][indexterm1 buffers_front]
Returns the first buffer in a buffer sequence. [heading Synopsis]Defined in header [include_file boost/beast/core/buffers_prefix.hpp]```template<    class __BufferSequence__>buffers_type< BufferSequence >buffers_front(    BufferSequence const& buffers);```[heading Description]
This returns the first buffer in the buffer sequence. If the buffer sequence is an empty range, the returned buffer will have a zero buffer size.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The buffer sequence. If the sequence is mutable, the returned buffer sequence will also be mutable. Otherwise, the returned buffer sequence will be constant.   ]]]
Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__buffers_iterator_type buffers_iterator_type][indexterm1 buffers_iterator_type]
Type alias for the iterator type of a buffer sequence type. [heading Synopsis]Defined in header [include_file boost/beast/core/buffer_traits.hpp]```template<    class __BufferSequence__>using buffers_iterator_type = ``['see-below]``;```[heading Description]
This metafunction is used to determine the type of iterator used by a particular buffer sequence.
[heading Template Parameters][table [[Type][Description]]  [[`T`][    
The buffer sequence type to use. The resulting type alias will be equal to the iterator type used by the buffer sequence.   ]]]
Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__buffers_prefix buffers_prefix][indexterm1 buffers_prefix]
Returns a prefix of a constant or mutable buffer sequence. [heading Synopsis]Defined in header [include_file boost/beast/core/buffers_prefix.hpp]```template<    class __BufferSequence__>buffers_prefix_view< BufferSequence >buffers_prefix(    std::size_t size,    BufferSequence const& buffers);```[heading Description]
The returned buffer sequence points to the same memory as the passed buffer sequence, but with a size that is equal to or smaller. No memory allocations are performed; the resulting sequence is calculated as a lazy range.
[heading Parameters][table [[Name][Description]]  [[`size`][    
The maximum size of the returned buffer sequence in bytes. If this is greater than or equal to the size of the passed buffer sequence, the result will have the same size as the original buffer sequence.  ]]  [[`buffers`][    
An object whose type meets the requirements of ['BufferSequence]. The returned value will maintain a copy of the passed buffers for its lifetime; however, ownership of the underlying memory is not transferred.  ]]]
[heading Return Value]
A constant buffer sequence that represents the prefix of the original buffer sequence. If the original buffer sequence also meets the requirements of ['MutableBufferSequence], then the returned value will also be a mutable buffer sequence. 
Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__buffers_prefix_view buffers_prefix_view]
A buffer sequence adaptor that shortens the sequence size. [heading Synopsis]Defined in header [include_file boost/beast/core/buffers_prefix.hpp]```template<    class __BufferSequence__>class buffers_prefix_view```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__buffers_prefix_view.const_iterator [*const_iterator]]]    [      A bidirectional iterator type that may be used to read elements.     ]  ]  [    [[link beast.ref.boost__beast__buffers_prefix_view.value_type [*value_type]]]    [      The type for each element in the list of buffers.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__buffers_prefix_view.begin [*begin]]]    [      Returns an iterator to the first buffer in the sequence.     ]  ]  [    [[link beast.ref.boost__beast__buffers_prefix_view.buffers_prefix_view [*buffers_prefix_view]]]    [      Copy Constructor.       Construct a buffer sequence prefix.       Construct a buffer sequence prefix in-place.     ]  ]  [    [[link beast.ref.boost__beast__buffers_prefix_view.end [*end]]]    [      Returns an iterator to one past the last buffer in the sequence.     ]  ]  [    [[link beast.ref.boost__beast__buffers_prefix_view.operator_eq_ [*operator=]]]    [      Copy Assignment.     ]  ]][heading Description]
The class adapts a buffer sequence to efficiently represent a shorter subset of the original list of buffers starting with the first byte of the original sequence.
[heading Template Parameters][table [[Type][Description]]  [[`BufferSequence`][    
The buffer sequence to adapt.   ]]]
[section:begin buffers_prefix_view::begin][indexterm2 begin..buffers_prefix_view]
Returns an iterator to the first buffer in the sequence. [heading Synopsis]```const_iteratorbegin() const;```[heading Description][endsect][section:buffers_prefix_view buffers_prefix_view::buffers_prefix_view][indexterm2 buffers_prefix_view..buffers_prefix_view]
Copy Constructor. `````[link beast.ref.boost__beast__buffers_prefix_view.buffers_prefix_view.overload1 buffers_prefix_view]``(    buffers_prefix_view const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_prefix_view.buffers_prefix_view.overload1 more...]]`````
Construct a buffer sequence prefix. `````[link beast.ref.boost__beast__buffers_prefix_view.buffers_prefix_view.overload2 buffers_prefix_view]``(    std::size_t size,    BufferSequence const& buffers);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_prefix_view.buffers_prefix_view.overload2 more...]]`````
Construct a buffer sequence prefix in-place. ```template<    class... Args>``[link beast.ref.boost__beast__buffers_prefix_view.buffers_prefix_view.overload3 buffers_prefix_view]``(    std::size_t size,    boost::in_place_init_t,    Args&&... args);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_prefix_view.buffers_prefix_view.overload3 more...]]`````[section:overload1 buffers_prefix_view::buffers_prefix_view (1 of 3 overloads)]
Copy Constructor. [heading Synopsis]```buffers_prefix_view(    buffers_prefix_view const&);```[heading Description][endsect][section:overload2 buffers_prefix_view::buffers_prefix_view (2 of 3 overloads)]
Construct a buffer sequence prefix. [heading Synopsis]```buffers_prefix_view(    std::size_t size,    BufferSequence const& buffers);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`size`][    
The maximum number of bytes in the prefix. If this is larger than the size of passed buffers, the resulting sequence will represent the entire input sequence.  ]]  [[`buffers`][    
The buffer sequence to adapt. A copy of the sequence will be made, but ownership of the underlying memory is not transferred. The copy is maintained for the lifetime of the view.   ]]]
[endsect][section:overload3 buffers_prefix_view::buffers_prefix_view (3 of 3 overloads)]
Construct a buffer sequence prefix in-place. [heading Synopsis]```template<    class... Args>buffers_prefix_view(    std::size_t size,    boost::in_place_init_t,    Args&&... args);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`size`][    
The maximum number of bytes in the prefix. If this is larger than the size of passed buffers, the resulting sequence will represent the entire input sequence.  ]]  [[`args`][    
Arguments forwarded to the contained buffer's constructor.   ]]]
[endsect][endsect][section:const_iterator buffers_prefix_view::const_iterator][indexterm2 const_iterator..buffers_prefix_view]
A bidirectional iterator type that may be used to read elements. [heading Synopsis]```using const_iterator = ``['implementation-defined]``;```[heading Description][endsect][section:end buffers_prefix_view::end][indexterm2 end..buffers_prefix_view]
Returns an iterator to one past the last buffer in the sequence. [heading Synopsis]```const_iteratorend() const;```[heading Description][endsect][section:operator_eq_ buffers_prefix_view::operator=][indexterm2 operator=..buffers_prefix_view]
Copy Assignment. [heading Synopsis]```buffers_prefix_view&operator=(    buffers_prefix_view const&);```[heading Description][endsect][section:value_type buffers_prefix_view::value_type][indexterm2 value_type..buffers_prefix_view]
The type for each element in the list of buffers. [heading Synopsis]```using value_type = ``['see-below]``;```[heading Description]
If the type `BufferSequence` meets the requirements of ['MutableBufferSequence], then `value_type` is `net::mutable_buffer`. Otherwise, `value_type` is `net::const_buffer`.
[heading See Also]
[link beast.ref.boost__beast__buffers_type `buffers_type`] 
[endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__buffers_range buffers_range][indexterm1 buffers_range]
Returns an iterable range representing a buffer sequence. [heading Synopsis]Defined in header [include_file boost/beast/core/buffers_range.hpp]```template<    class __BufferSequence__>``['implementation-defined]``buffers_range(    BufferSequence const& buffers);```[heading Description]
This function returns an iterable range representing the passed buffer sequence. The values obtained when iterating the range will be `net::const_buffer`, unless the underlying buffer sequence is a ['MutableBufferSequence], in which case the value obtained when iterating will be a `net::mutable_buffer`.
[heading Example]

The following function returns the total number of bytes in the specified buffer sequence. A copy of the buffer sequence is maintained for the lifetime of the range object:
```  template <class BufferSequence>
  std::size_t buffer_sequence_size (BufferSequence const& buffers)
  {
      std::size_t size = 0;
      for (auto const buffer : buffers_range (buffers))
          size += buffer.size();
      return size;
  }
```
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The buffer sequence to adapt into a range. The range object returned from this function will contain a copy of the passed buffer sequence.  ]]]
[heading Return Value]
An object of unspecified type which meets the requirements of ['ConstBufferSequence]. If `buffers` is a mutable buffer sequence, the returned object will also meet the requirements of ['MutableBufferSequence].
[heading See Also]
[link beast.ref.boost__beast__buffers_range_ref `buffers_range_ref`] 
Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__buffers_range_ref buffers_range_ref][indexterm1 buffers_range_ref]
Returns an iterable range representing a buffer sequence. [heading Synopsis]Defined in header [include_file boost/beast/core/buffers_range.hpp]```template<    class __BufferSequence__>``['implementation-defined]``buffers_range_ref(    BufferSequence const& buffers);```[heading Description]
This function returns an iterable range representing the passed buffer sequence. The values obtained when iterating the range will be `net::const_buffer`, unless the underlying buffer sequence is a ['MutableBufferSequence], in which case the value obtained when iterating will be a `net::mutable_buffer`.
[heading Example]

The following function returns the total number of bytes in the specified buffer sequence. A reference to the original buffers is maintained for the lifetime of the range object:
```  template <class BufferSequence>
  std::size_t buffer_sequence_size_ref (BufferSequence const& buffers)
  {
      std::size_t size = 0;
      for (auto const buffer : buffers_range_ref (buffers))
          size += buffer.size();
      return size;
  }
```
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The buffer sequence to adapt into a range. The range returned from this function will maintain a reference to these buffers. The application is responsible for ensuring that the lifetime of the referenced buffers extends until the range object is destroyed.  ]]]
[heading Return Value]
An object of unspecified type which meets the requirements of ['ConstBufferSequence]. If `buffers` is a mutable buffer sequence, the returned object will also meet the requirements of ['MutableBufferSequence].
[heading See Also]
[link beast.ref.boost__beast__buffers_range `buffers_range`] 
Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__buffers_suffix buffers_suffix]
Adaptor to progressively trim the front of a ['BufferSequence]. [heading Synopsis]Defined in header [include_file boost/beast/core/buffers_suffix.hpp]```template<    class __BufferSequence__>class buffers_suffix```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__buffers_suffix.const_iterator [*const_iterator]]]    [      A bidirectional iterator type that may be used to read elements.     ]  ]  [    [[link beast.ref.boost__beast__buffers_suffix.value_type [*value_type]]]    [      The type for each element in the list of buffers.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__buffers_suffix.begin [*begin]]]    [      Get a bidirectional iterator to the first element.     ]  ]  [    [[link beast.ref.boost__beast__buffers_suffix.buffers_suffix [*buffers_suffix]]]    [      Constructor.       Copy Constructor.     ]  ]  [    [[link beast.ref.boost__beast__buffers_suffix.consume [*consume]]]    [      Remove bytes from the beginning of the sequence.     ]  ]  [    [[link beast.ref.boost__beast__buffers_suffix.end [*end]]]    [      Get a bidirectional iterator to one past the last element.     ]  ]  [    [[link beast.ref.boost__beast__buffers_suffix.operator_eq_ [*operator=]]]    [      Copy Assignment.     ]  ]][heading Description]
This adaptor wraps a buffer sequence to create a new sequence which may be incrementally consumed. Bytes consumed are removed from the front of the buffer. The underlying memory is not changed, instead the adaptor efficiently iterates through a subset of the buffers wrapped.
The wrapped buffer is not modified, a copy is made instead. Ownership of the underlying memory is not transferred, the application is still responsible for managing its lifetime.
[heading Template Parameters][table [[Type][Description]]  [[`BufferSequence`][    
The buffer sequence to wrap.  ]]]
[heading Example]

This function writes the entire contents of a buffer sequence to the specified stream.
```  template<class SyncWriteStream, class ConstBufferSequence>
  void send(SyncWriteStream& stream, ConstBufferSequence const& buffers)
  {
      buffers_suffix<ConstBufferSequence> bs{buffers};
      while(buffer_bytes(bs) > 0)
          bs.consume(stream.write_some(bs));
  }
```[section:begin buffers_suffix::begin][indexterm2 begin..buffers_suffix]
Get a bidirectional iterator to the first element. [heading Synopsis]```const_iteratorbegin() const;```[heading Description][endsect][section:buffers_suffix buffers_suffix::buffers_suffix][indexterm2 buffers_suffix..buffers_suffix]
Constructor. `````[link beast.ref.boost__beast__buffers_suffix.buffers_suffix.overload1 buffers_suffix]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_suffix.buffers_suffix.overload1 more...]]`````
Copy Constructor. `````[link beast.ref.boost__beast__buffers_suffix.buffers_suffix.overload2 buffers_suffix]``(    buffers_suffix const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_suffix.buffers_suffix.overload2 more...]]``explicit``[link beast.ref.boost__beast__buffers_suffix.buffers_suffix.overload3 buffers_suffix]``(    BufferSequence const& buffers);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_suffix.buffers_suffix.overload3 more...]]``template<    class... Args>explicit``[link beast.ref.boost__beast__buffers_suffix.buffers_suffix.overload4 buffers_suffix]``(    boost::in_place_init_t,    Args&&... args);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_suffix.buffers_suffix.overload4 more...]]`````[section:overload1 buffers_suffix::buffers_suffix (1 of 4 overloads)]
Constructor. [heading Synopsis]```buffers_suffix();```[heading Description][endsect][section:overload2 buffers_suffix::buffers_suffix (2 of 4 overloads)]
Copy Constructor. [heading Synopsis]```buffers_suffix(    buffers_suffix const&);```[heading Description][endsect][section:overload3 buffers_suffix::buffers_suffix (3 of 4 overloads)]
Constructor. [heading Synopsis]```buffers_suffix(    BufferSequence const& buffers);```[heading Description]
A copy of the buffer sequence is made. Ownership of the underlying memory is not transferred or copied. [endsect][section:overload4 buffers_suffix::buffers_suffix (4 of 4 overloads)]
Constructor. [heading Synopsis]```template<    class... Args>buffers_suffix(    boost::in_place_init_t,    Args&&... args);```[heading Description]
This constructs the buffer sequence in-place from a list of arguments.
[heading Parameters][table [[Name][Description]]  [[`args`][    
Arguments forwarded to the buffers constructor.   ]]]
[endsect][endsect][section:const_iterator buffers_suffix::const_iterator][indexterm2 const_iterator..buffers_suffix]
A bidirectional iterator type that may be used to read elements. [heading Synopsis]```using const_iterator = ``['implementation-defined]``;```[heading Description][endsect][section:consume buffers_suffix::consume][indexterm2 consume..buffers_suffix]
Remove bytes from the beginning of the sequence. [heading Synopsis]```voidconsume(    std::size_t amount);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`amount`][    
The number of bytes to remove. If this is larger than the number of bytes remaining, all the bytes remaining are removed.   ]]]
[endsect][section:end buffers_suffix::end][indexterm2 end..buffers_suffix]
Get a bidirectional iterator to one past the last element. [heading Synopsis]```const_iteratorend() const;```[heading Description][endsect][section:operator_eq_ buffers_suffix::operator=][indexterm2 operator=..buffers_suffix]
Copy Assignment. [heading Synopsis]```buffers_suffix&operator=(    buffers_suffix const&);```[heading Description][endsect][section:value_type buffers_suffix::value_type][indexterm2 value_type..buffers_suffix]
The type for each element in the list of buffers. [heading Synopsis]```using value_type = ``['see-below]``;```[heading Description]
If ['BufferSequence] meets the requirements of ['MutableBufferSequence], then this type will be `net::mutable_buffer`, otherwise this type will be `net::const_buffer`. [endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__buffers_to_string buffers_to_string][indexterm1 buffers_to_string]
Return a string representing the contents of a buffer sequence. [heading Synopsis]Defined in header [include_file boost/beast/core/buffers_to_string.hpp]```template<    class __ConstBufferSequence__>std::stringbuffers_to_string(    ConstBufferSequence const& buffers);```[heading Description]
This function returns a string representing an entire buffer sequence. Nulls and unprintable characters in the buffer sequence are inserted to the resulting string as-is. No character conversions are performed.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The buffer sequence to convert  ]]]
[heading Example]

This function writes a buffer sequence converted to a string to `std::cout`.
```  template<class ConstBufferSequence>
  void print(ConstBufferSequence const& buffers)
  {
      std::cout << buffers_to_string(buffers) << std::endl;
  }
```Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__buffers_type buffers_type][indexterm1 buffers_type]
Type alias for the underlying buffer type of a list of buffer sequence types. [heading Synopsis]Defined in header [include_file boost/beast/core/buffer_traits.hpp]```template<    class... __BufferSequence__>using buffers_type = ``['see-below]``;```[heading Description]
This metafunction is used to determine the underlying buffer type for a list of buffer sequence. The equivalent type of the alias will vary depending on the template type argument:

* If every type in the list is a ['MutableBufferSequence], the resulting type alias will be `net::mutable_buffer`, otherwise


* The resulting type alias will be `net::const_buffer`.

[heading Example]
The following code returns the first buffer in a buffer sequence, or generates a compilation error if the argument is not a buffer sequence: ```  template <class BufferSequence>
  buffers_type <BufferSequence>
  buffers_front (BufferSequence const& buffers)
  {
      static_assert(
          net::is_const_buffer_sequence<BufferSequence>::value,
          "BufferSequence type requirements not met");
      auto const first = net::buffer_sequence_begin (buffers);
      if (first == net::buffer_sequence_end (buffers))
          return {};
      return *first;
  }
```
[heading Template Parameters][table [[Type][Description]]  [[`BufferSequence`][    
A list of zero or more types to check. If this list is empty, the resulting type alias will be `net::mutable_buffer`.   ]]]
Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__close_socket close_socket][indexterm1 close_socket]
Close a socket or socket-like object. [heading Synopsis]Defined in header [include_file boost/beast/core/stream_traits.hpp]```template<    class Socket>voidclose_socket(    Socket& sock);```[heading Description]
This function attempts to close an object representing a socket. In this context, a socket is an object for which an unqualified call to the function `void beast_close_socket(Socket&)` is well-defined. The function `beast_close_socket` is a ['customization point], allowing user-defined types to provide an algorithm for performing the close operation by overloading this function for the type in question.
Since the customization point is a function call, the normal rules for finding the correct overload are applied including the rules for argument-dependent lookup ("ADL"). This permits classes derived from a type for which a customization is provided to inherit the customization point.
An overload for the networking class template `net::basic_socket` is provided, which implements the close algorithm for all socket-like objects (hence the name of this customization point). When used in conjunction with [link beast.ref.boost__beast__get_lowest_layer `get_lowest_layer`], a generic algorithm operating on a layered stream can perform a closure of the underlying socket without knowing the exact list of concrete types.
[heading Example 1]
The following generic function synchronously sends a message on the stream, then closes the socket. ```  template <class WriteStream>
  void hello_and_close (WriteStream& stream)
  {
      net::write(stream, net::const_buffer("Hello, world!", 13));
      close_socket(get_lowest_layer(stream));
  }
```
To enable closure of user defined types, it is necessary to provide an overload of the function `beast_close_socket` for the type.
[heading Example 2]
The following code declares a user-defined type which contains a private socket, and provides an overload of the customization point which closes the private socket. ```  class my_socket
  {
      net::ip::tcp::socket sock_;

  public:
      my_socket(net::io_context& ioc)
          : sock_(ioc)
      {
      }

      friend void beast_close_socket(my_socket& s)
      {
          error_code ec;
          s.sock_.close(ec);
          // ignore the error
      }
  };
```
[heading Parameters][table [[Name][Description]]  [[`sock`][    
The socket to close. If the customization point is not defined for the type of this object, or one of its base classes, then a compiler error results.  ]]]
[heading See Also]
[link beast.ref.boost__beast__beast_close_socket `beast_close_socket`] 
Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__condition condition][indexterm1 condition]
Error conditions corresponding to sets of library error codes. [heading Synopsis]Defined in header [include_file boost/beast/core/error.hpp]```enum condition```[indexterm2 timeout..condition][heading Values][table [[Name][Description]]  [[[^timeout]][The operation timed out. This error indicates that an operation took took too long.
 ]]][heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__detect_ssl detect_ssl][indexterm1 detect_ssl]
Detect a TLS client handshake on a stream. [heading Synopsis]Defined in header [include_file boost/beast/core/detect_ssl.hpp]```template<    class __SyncReadStream__,    class __DynamicBuffer__>booldetect_ssl(    SyncReadStream& stream,    DynamicBuffer& buffer,    error_code& ec);```[heading Description]
This function reads from a stream to determine if a client handshake message is being received.
The call blocks until one of the following is true:

* A TLS client opening handshake is detected,


* The received data is invalid for a TLS client handshake, or


* An error occurs.

The algorithm, known as a ['composed operation], is implemented in terms of calls to the next layer's `read_some` function.
Bytes read from the stream will be stored in the passed dynamic buffer, which may be used to perform the TLS handshake if the detector returns true, or be otherwise consumed by the caller based on the expected protocol.
[heading Parameters][table [[Name][Description]]  [[`stream`][    
The stream to read from. This type must meet the requirements of ['SyncReadStream].  ]]  [[`buffer`][    
The dynamic buffer to use. This type must meet the requirements of ['DynamicBuffer].  ]]  [[`ec`][    
Set to the error if any occurred.  ]]]
[heading Return Value]
`true` if the buffer contains a TLS client handshake and no error occurred, otherwise `false`. 
Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__errc errc][indexterm1 errc]
The set of constants used for cross-platform error codes. [heading Synopsis]Defined in header [include_file boost/beast/core/error.hpp]```enum errc```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__error error][indexterm1 error]
Error codes returned from library operations. [heading Synopsis]Defined in header [include_file boost/beast/core/error.hpp]```enum error```[indexterm2 timeout..error][heading Values][table [[Name][Description]]  [[[^timeout]][The socket was closed due to a timeout. This error indicates that a socket was closed due to a
a timeout detected during an operation.

Error codes with this value will compare equal to @ref condition::timeout.
 ]]][heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__error_category error_category][indexterm1 error_category]
The type of error category used by the library. [heading Synopsis]Defined in header [include_file boost/beast/core/error.hpp]```using error_category = boost::system::error_category;```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__error_code error_code][indexterm1 error_code]
The type of error code used by the library. [heading Synopsis]Defined in header [include_file boost/beast/core/error.hpp]```using error_code = boost::system::error_code;```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__error_condition error_condition][indexterm1 error_condition]
The type of error condition used by the library. [heading Synopsis]Defined in header [include_file boost/beast/core/error.hpp]```using error_condition = boost::system::error_condition;```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__executor_type executor_type][indexterm1 executor_type]
A trait to determine the return type of get\_executor. [heading Synopsis]Defined in header [include_file boost/beast/core/stream_traits.hpp]```template<    class T>using executor_type = ``['see-below]``;```[heading Description]
This type alias will be the type of values returned by by calling member `get_exector` on an object of type `T&`.
[heading Parameters][table [[Name][Description]]  [[`T`][    
The type to query  ]]]
[heading Return Value]
The type of values returned from `get_executor`. 
Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__file file]
An implementation of File. [heading Synopsis]Defined in header [include_file boost/beast/core/file.hpp]```struct file :    public file_stdio```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__file.native_handle_type [*native_handle_type]]]    [      The type of the underlying file handle.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__file.close [*close]]]    [      Close the file if open.     ]  ]  [    [[link beast.ref.boost__beast__file.is_open [*is_open]]]    [      Returns true if the file is open.     ]  ]  [    [[link beast.ref.boost__beast__file.native_handle [*native_handle]]]    [      Returns the native handle associated with the file.       Set the native handle associated with the file.     ]  ]  [    [[link beast.ref.boost__beast__file.open [*open]]]    [      Open a file at the given path with the specified mode.     ]  ]  [    [[link beast.ref.boost__beast__file.pos [*pos]]]    [      Return the current position in the open file.     ]  ]  [    [[link beast.ref.boost__beast__file.read [*read]]]    [      Read from the open file.     ]  ]  [    [[link beast.ref.boost__beast__file.seek [*seek]]]    [      Adjust the current position in the open file.     ]  ]  [    [[link beast.ref.boost__beast__file.size [*size]]]    [      Return the size of the open file.     ]  ]  [    [[link beast.ref.boost__beast__file.write [*write]]]    [      Write to the open file.     ]  ]][heading Description]
This alias is set to the best available implementation of ['File] given the platform and build settings. [section:close file::close](Inherited from `file_stdio`)[indexterm2 close..file]
Close the file if open. [heading Synopsis]```voidclose(    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`ec`][    
Set to the error, if any occurred.   ]]]
[endsect][section:is_open file::is_open](Inherited from `file_stdio`)[indexterm2 is_open..file]
Returns `true` if the file is open. [heading Synopsis]```boolis_open() const;```[heading Description][endsect][section:native_handle file::native_handle][indexterm2 native_handle..file]
Returns the native handle associated with the file. ```FILE*``[link beast.ref.boost__beast__file.native_handle.overload1 native_handle]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__file.native_handle.overload1 more...]]`````
Set the native handle associated with the file. ```void``[link beast.ref.boost__beast__file.native_handle.overload2 native_handle]``(    FILE* f);  ``[''''&raquo;''' [link beast.ref.boost__beast__file.native_handle.overload2 more...]]`````[section:overload1 file::native_handle (1 of 2 overloads)](Inherited from `file_stdio`)
Returns the native handle associated with the file. [heading Synopsis]```FILE*native_handle() const;```[heading Description][endsect][section:overload2 file::native_handle (2 of 2 overloads)](Inherited from `file_stdio`)
Set the native handle associated with the file. [heading Synopsis]```voidnative_handle(    FILE* f);```[heading Description]
If the file is open it is first closed.
[heading Parameters][table [[Name][Description]]  [[`f`][    
The native file handle to assign.   ]]]
[endsect][endsect][section:native_handle_type file::native_handle_type](Inherited from `file_stdio`)[indexterm2 native_handle_type..file]
The type of the underlying file handle. [heading Synopsis]```using native_handle_type = FILE*;```[heading Description]
This is platform-specific. [endsect][section:open file::open](Inherited from `file_stdio`)[indexterm2 open..file]
Open a file at the given path with the specified mode. [heading Synopsis]```voidopen(    char const* path,    file_mode mode,    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`path`][    
The utf-8 encoded path to the file  ]]  [[`mode`][    
The file mode to use  ]]  [[`ec`][    
Set to the error, if any occurred   ]]]
[endsect][section:pos file::pos](Inherited from `file_stdio`)[indexterm2 pos..file]
Return the current position in the open file. [heading Synopsis]```std::uint64_tpos(    error_code& ec) const;```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`ec`][    
Set to the error, if any occurred  ]]]
[heading Return Value]
The offset in bytes from the beginning of the file 
[endsect][section:read file::read](Inherited from `file_stdio`)[indexterm2 read..file]
Read from the open file. [heading Synopsis]```std::size_tread(    void* buffer,    std::size_t n,    error_code& ec) const;```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`buffer`][    
The buffer for storing the result of the read  ]]  [[`n`][    
The number of bytes to read  ]]  [[`ec`][    
Set to the error, if any occurred   ]]]
[endsect][section:seek file::seek](Inherited from `file_stdio`)[indexterm2 seek..file]
Adjust the current position in the open file. [heading Synopsis]```voidseek(    std::uint64_t offset,    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`offset`][    
The offset in bytes from the beginning of the file  ]]  [[`ec`][    
Set to the error, if any occurred   ]]]
[endsect][section:size file::size](Inherited from `file_stdio`)[indexterm2 size..file]
Return the size of the open file. [heading Synopsis]```std::uint64_tsize(    error_code& ec) const;```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`ec`][    
Set to the error, if any occurred  ]]]
[heading Return Value]
The size in bytes 
[endsect][section:write file::write](Inherited from `file_stdio`)[indexterm2 write..file]
Write to the open file. [heading Synopsis]```std::size_twrite(    void const* buffer,    std::size_t n,    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`buffer`][    
The buffer holding the data to write  ]]  [[`n`][    
The number of bytes to write  ]]  [[`ec`][    
Set to the error, if any occurred   ]]]
[endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__file_mode file_mode][indexterm1 file_mode]
File open modes. [heading Synopsis]Defined in header [include_file boost/beast/core/file_base.hpp]```enum file_mode```[indexterm2 read..file_mode][indexterm2 scan..file_mode][indexterm2 write..file_mode][indexterm2 write_new..file_mode][indexterm2 write_existing..file_mode][indexterm2 append..file_mode][indexterm2 append_existing..file_mode][heading Values][table [[Name][Description]]  [[[^read]][Random read-only access to an existing file. ]]  [[[^scan]][Sequential read-only access to an existing file. ]]  [[[^write]][Random reading and writing to a new or truncated file. This mode permits random-access reading and writing
for the specified file. If the file does not exist
prior to the function call, it is created with an
initial size of zero bytes. Otherwise if the file
already exists, the size is truncated to zero bytes.
 ]]  [[[^write_new]][Random reading and writing to a new file only. This mode permits random-access reading and writing
for the specified file. The file will be created with
an initial size of zero bytes. If the file already exists
prior to the function call, an error is returned and
no file is opened.
 ]]  [[[^write_existing]][Random write-only access to existing file. If the file does not exist, an error is generated.
 ]]  [[[^append]][Appending to a new or truncated file. The current file position shall be set to the end of
the file prior to each write.

@li If the file does not exist, it is created.

@li If the file exists, it is truncated to
zero size upon opening.
 ]]  [[[^append_existing]][Appending to an existing file. The current file position shall be set to the end of
the file prior to each write.

If the file does not exist, an error is generated.
 ]]][heading Description]
These modes are used when opening files using instances of the ['File] concept.
[heading See Also]
[link beast.ref.boost__beast__file_stdio `file_stdio`] 
Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__file_posix file_posix]
An implementation of File for POSIX systems. [heading Synopsis]Defined in header [include_file boost/beast/core/file_posix.hpp]```class file_posix```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__file_posix.native_handle_type [*native_handle_type]]]    [      The type of the underlying file handle.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__file_posix.close [*close]]]    [      Close the file if open.     ]  ]  [    [[link beast.ref.boost__beast__file_posix.file_posix [*file_posix]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__file_posix.is_open [*is_open]]]    [      Returns true if the file is open.     ]  ]  [    [[link beast.ref.boost__beast__file_posix.native_handle [*native_handle]]]    [      Returns the native handle associated with the file.       Set the native handle associated with the file.     ]  ]  [    [[link beast.ref.boost__beast__file_posix.open [*open]]]    [      Open a file at the given path with the specified mode.     ]  ]  [    [[link beast.ref.boost__beast__file_posix.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__file_posix.pos [*pos]]]    [      Return the current position in the open file.     ]  ]  [    [[link beast.ref.boost__beast__file_posix.read [*read]]]    [      Read from the open file.     ]  ]  [    [[link beast.ref.boost__beast__file_posix.seek [*seek]]]    [      Adjust the current position in the open file.     ]  ]  [    [[link beast.ref.boost__beast__file_posix.size [*size]]]    [      Return the size of the open file.     ]  ]  [    [[link beast.ref.boost__beast__file_posix.write [*write]]]    [      Write to the open file.     ]  ]  [    [[link beast.ref.boost__beast__file_posix.file_posix_dtor_ [*~file_posix]]]    [      Destructor.     ]  ]][heading Description]
This class implements a ['File] using POSIX interfaces. [section:close file_posix::close][indexterm2 close..file_posix]
Close the file if open. [heading Synopsis]```voidclose(    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`ec`][    
Set to the error, if any occurred.   ]]]
[endsect][section:file_posix file_posix::file_posix][indexterm2 file_posix..file_posix]
Constructor. `````[link beast.ref.boost__beast__file_posix.file_posix.overload1 file_posix]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__file_posix.file_posix.overload1 more...]]````[link beast.ref.boost__beast__file_posix.file_posix.overload2 file_posix]``(    file_posix&& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__file_posix.file_posix.overload2 more...]]`````[section:overload1 file_posix::file_posix (1 of 2 overloads)]
Constructor. [heading Synopsis]```file_posix();```[heading Description]
There is no open file initially. [endsect][section:overload2 file_posix::file_posix (2 of 2 overloads)]
Constructor. [heading Synopsis]```file_posix(    file_posix&& other);```[heading Description]
The moved-from object behaves as if default constructed. [endsect][endsect][section:is_open file_posix::is_open][indexterm2 is_open..file_posix]
Returns `true` if the file is open. [heading Synopsis]```boolis_open() const;```[heading Description][endsect][section:native_handle file_posix::native_handle][indexterm2 native_handle..file_posix]
Returns the native handle associated with the file. ```native_handle_type``[link beast.ref.boost__beast__file_posix.native_handle.overload1 native_handle]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__file_posix.native_handle.overload1 more...]]`````
Set the native handle associated with the file. ```void``[link beast.ref.boost__beast__file_posix.native_handle.overload2 native_handle]``(    native_handle_type fd);  ``[''''&raquo;''' [link beast.ref.boost__beast__file_posix.native_handle.overload2 more...]]`````[section:overload1 file_posix::native_handle (1 of 2 overloads)]
Returns the native handle associated with the file. [heading Synopsis]```native_handle_typenative_handle() const;```[heading Description][endsect][section:overload2 file_posix::native_handle (2 of 2 overloads)]
Set the native handle associated with the file. [heading Synopsis]```voidnative_handle(    native_handle_type fd);```[heading Description]
If the file is open it is first closed.
[heading Parameters][table [[Name][Description]]  [[`fd`][    
The native file handle to assign.   ]]]
[endsect][endsect][section:native_handle_type file_posix::native_handle_type][indexterm2 native_handle_type..file_posix]
The type of the underlying file handle. [heading Synopsis]```using native_handle_type = int;```[heading Description]
This is platform-specific. [endsect][section:open file_posix::open][indexterm2 open..file_posix]
Open a file at the given path with the specified mode. [heading Synopsis]```voidopen(    char const* path,    file_mode mode,    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`path`][    
The utf-8 encoded path to the file  ]]  [[`mode`][    
The file mode to use  ]]  [[`ec`][    
Set to the error, if any occurred   ]]]
[endsect][section:operator_eq_ file_posix::operator=][indexterm2 operator=..file_posix]
Assignment. [heading Synopsis]```file_posix&operator=(    file_posix&& other);```[heading Description]
The moved-from object behaves as if default constructed. [endsect][section:pos file_posix::pos][indexterm2 pos..file_posix]
Return the current position in the open file. [heading Synopsis]```std::uint64_tpos(    error_code& ec) const;```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`ec`][    
Set to the error, if any occurred  ]]]
[heading Return Value]
The offset in bytes from the beginning of the file 
[endsect][section:read file_posix::read][indexterm2 read..file_posix]
Read from the open file. [heading Synopsis]```std::size_tread(    void* buffer,    std::size_t n,    error_code& ec) const;```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`buffer`][    
The buffer for storing the result of the read  ]]  [[`n`][    
The number of bytes to read  ]]  [[`ec`][    
Set to the error, if any occurred   ]]]
[endsect][section:seek file_posix::seek][indexterm2 seek..file_posix]
Adjust the current position in the open file. [heading Synopsis]```voidseek(    std::uint64_t offset,    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`offset`][    
The offset in bytes from the beginning of the file  ]]  [[`ec`][    
Set to the error, if any occurred   ]]]
[endsect][section:size file_posix::size][indexterm2 size..file_posix]
Return the size of the open file. [heading Synopsis]```std::uint64_tsize(    error_code& ec) const;```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`ec`][    
Set to the error, if any occurred  ]]]
[heading Return Value]
The size in bytes 
[endsect][section:write file_posix::write][indexterm2 write..file_posix]
Write to the open file. [heading Synopsis]```std::size_twrite(    void const* buffer,    std::size_t n,    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`buffer`][    
The buffer holding the data to write  ]]  [[`n`][    
The number of bytes to write  ]]  [[`ec`][    
Set to the error, if any occurred   ]]]
[endsect][section:file_posix_dtor_ file_posix::~file_posix][indexterm2 ~file_posix..file_posix]
Destructor. [heading Synopsis]```~file_posix();```[heading Description]
If the file is open it is first closed. [endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__file_stdio file_stdio]
An implementation of File which uses cstdio. [heading Synopsis]Defined in header [include_file boost/beast/core/file_stdio.hpp]```class file_stdio```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__file_stdio.native_handle_type [*native_handle_type]]]    [      The type of the underlying file handle.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__file_stdio.close [*close]]]    [      Close the file if open.     ]  ]  [    [[link beast.ref.boost__beast__file_stdio.file_stdio [*file_stdio]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__file_stdio.is_open [*is_open]]]    [      Returns true if the file is open.     ]  ]  [    [[link beast.ref.boost__beast__file_stdio.native_handle [*native_handle]]]    [      Returns the native handle associated with the file.       Set the native handle associated with the file.     ]  ]  [    [[link beast.ref.boost__beast__file_stdio.open [*open]]]    [      Open a file at the given path with the specified mode.     ]  ]  [    [[link beast.ref.boost__beast__file_stdio.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__file_stdio.pos [*pos]]]    [      Return the current position in the open file.     ]  ]  [    [[link beast.ref.boost__beast__file_stdio.read [*read]]]    [      Read from the open file.     ]  ]  [    [[link beast.ref.boost__beast__file_stdio.seek [*seek]]]    [      Adjust the current position in the open file.     ]  ]  [    [[link beast.ref.boost__beast__file_stdio.size [*size]]]    [      Return the size of the open file.     ]  ]  [    [[link beast.ref.boost__beast__file_stdio.write [*write]]]    [      Write to the open file.     ]  ]  [    [[link beast.ref.boost__beast__file_stdio.file_stdio_dtor_ [*~file_stdio]]]    [      Destructor.     ]  ]][heading Description]
This class implements a file using the interfaces present in the C++ Standard Library, in `<stdio>`. [section:close file_stdio::close][indexterm2 close..file_stdio]
Close the file if open. [heading Synopsis]```voidclose(    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`ec`][    
Set to the error, if any occurred.   ]]]
[endsect][section:file_stdio file_stdio::file_stdio][indexterm2 file_stdio..file_stdio]
Constructor. `````[link beast.ref.boost__beast__file_stdio.file_stdio.overload1 file_stdio]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__file_stdio.file_stdio.overload1 more...]]````[link beast.ref.boost__beast__file_stdio.file_stdio.overload2 file_stdio]``(    file_stdio&& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__file_stdio.file_stdio.overload2 more...]]`````[section:overload1 file_stdio::file_stdio (1 of 2 overloads)]
Constructor. [heading Synopsis]```file_stdio();```[heading Description]
There is no open file initially. [endsect][section:overload2 file_stdio::file_stdio (2 of 2 overloads)]
Constructor. [heading Synopsis]```file_stdio(    file_stdio&& other);```[heading Description]
The moved-from object behaves as if default constructed. [endsect][endsect][section:is_open file_stdio::is_open][indexterm2 is_open..file_stdio]
Returns `true` if the file is open. [heading Synopsis]```boolis_open() const;```[heading Description][endsect][section:native_handle file_stdio::native_handle][indexterm2 native_handle..file_stdio]
Returns the native handle associated with the file. ```FILE*``[link beast.ref.boost__beast__file_stdio.native_handle.overload1 native_handle]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__file_stdio.native_handle.overload1 more...]]`````
Set the native handle associated with the file. ```void``[link beast.ref.boost__beast__file_stdio.native_handle.overload2 native_handle]``(    FILE* f);  ``[''''&raquo;''' [link beast.ref.boost__beast__file_stdio.native_handle.overload2 more...]]`````[section:overload1 file_stdio::native_handle (1 of 2 overloads)]
Returns the native handle associated with the file. [heading Synopsis]```FILE*native_handle() const;```[heading Description][endsect][section:overload2 file_stdio::native_handle (2 of 2 overloads)]
Set the native handle associated with the file. [heading Synopsis]```voidnative_handle(    FILE* f);```[heading Description]
If the file is open it is first closed.
[heading Parameters][table [[Name][Description]]  [[`f`][    
The native file handle to assign.   ]]]
[endsect][endsect][section:native_handle_type file_stdio::native_handle_type][indexterm2 native_handle_type..file_stdio]
The type of the underlying file handle. [heading Synopsis]```using native_handle_type = FILE*;```[heading Description]
This is platform-specific. [endsect][section:open file_stdio::open][indexterm2 open..file_stdio]
Open a file at the given path with the specified mode. [heading Synopsis]```voidopen(    char const* path,    file_mode mode,    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`path`][    
The utf-8 encoded path to the file  ]]  [[`mode`][    
The file mode to use  ]]  [[`ec`][    
Set to the error, if any occurred   ]]]
[endsect][section:operator_eq_ file_stdio::operator=][indexterm2 operator=..file_stdio]
Assignment. [heading Synopsis]```file_stdio&operator=(    file_stdio&& other);```[heading Description]
The moved-from object behaves as if default constructed. [endsect][section:pos file_stdio::pos][indexterm2 pos..file_stdio]
Return the current position in the open file. [heading Synopsis]```std::uint64_tpos(    error_code& ec) const;```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`ec`][    
Set to the error, if any occurred  ]]]
[heading Return Value]
The offset in bytes from the beginning of the file 
[endsect][section:read file_stdio::read][indexterm2 read..file_stdio]
Read from the open file. [heading Synopsis]```std::size_tread(    void* buffer,    std::size_t n,    error_code& ec) const;```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`buffer`][    
The buffer for storing the result of the read  ]]  [[`n`][    
The number of bytes to read  ]]  [[`ec`][    
Set to the error, if any occurred   ]]]
[endsect][section:seek file_stdio::seek][indexterm2 seek..file_stdio]
Adjust the current position in the open file. [heading Synopsis]```voidseek(    std::uint64_t offset,    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`offset`][    
The offset in bytes from the beginning of the file  ]]  [[`ec`][    
Set to the error, if any occurred   ]]]
[endsect][section:size file_stdio::size][indexterm2 size..file_stdio]
Return the size of the open file. [heading Synopsis]```std::uint64_tsize(    error_code& ec) const;```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`ec`][    
Set to the error, if any occurred  ]]]
[heading Return Value]
The size in bytes 
[endsect][section:write file_stdio::write][indexterm2 write..file_stdio]
Write to the open file. [heading Synopsis]```std::size_twrite(    void const* buffer,    std::size_t n,    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`buffer`][    
The buffer holding the data to write  ]]  [[`n`][    
The number of bytes to write  ]]  [[`ec`][    
Set to the error, if any occurred   ]]]
[endsect][section:file_stdio_dtor_ file_stdio::~file_stdio][indexterm2 ~file_stdio..file_stdio]
Destructor. [heading Synopsis]```~file_stdio();```[heading Description]
If the file is open it is first closed. [endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__file_win32 file_win32]
An implementation of File for Win32. [heading Synopsis]Defined in header [include_file boost/beast/core/file_win32.hpp]```class file_win32```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__file_win32.native_handle_type [*native_handle_type]]]    [      The type of the underlying file handle.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__file_win32.close [*close]]]    [      Close the file if open.     ]  ]  [    [[link beast.ref.boost__beast__file_win32.file_win32 [*file_win32]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__file_win32.is_open [*is_open]]]    [      Returns true if the file is open.     ]  ]  [    [[link beast.ref.boost__beast__file_win32.native_handle [*native_handle]]]    [      Returns the native handle associated with the file.       Set the native handle associated with the file.     ]  ]  [    [[link beast.ref.boost__beast__file_win32.open [*open]]]    [      Open a file at the given path with the specified mode.     ]  ]  [    [[link beast.ref.boost__beast__file_win32.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__file_win32.pos [*pos]]]    [      Return the current position in the open file.     ]  ]  [    [[link beast.ref.boost__beast__file_win32.read [*read]]]    [      Read from the open file.     ]  ]  [    [[link beast.ref.boost__beast__file_win32.seek [*seek]]]    [      Adjust the current position in the open file.     ]  ]  [    [[link beast.ref.boost__beast__file_win32.size [*size]]]    [      Return the size of the open file.     ]  ]  [    [[link beast.ref.boost__beast__file_win32.write [*write]]]    [      Write to the open file.     ]  ]  [    [[link beast.ref.boost__beast__file_win32.file_win32_dtor_ [*~file_win32]]]    [      Destructor.     ]  ]][heading Description]
This class implements a ['File] using Win32 native interfaces. [section:close file_win32::close][indexterm2 close..file_win32]
Close the file if open. [heading Synopsis]```voidclose(    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`ec`][    
Set to the error, if any occurred.   ]]]
[endsect][section:file_win32 file_win32::file_win32][indexterm2 file_win32..file_win32]
Constructor. `````[link beast.ref.boost__beast__file_win32.file_win32.overload1 file_win32]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__file_win32.file_win32.overload1 more...]]````[link beast.ref.boost__beast__file_win32.file_win32.overload2 file_win32]``(    file_win32&& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__file_win32.file_win32.overload2 more...]]`````[section:overload1 file_win32::file_win32 (1 of 2 overloads)]
Constructor. [heading Synopsis]```file_win32();```[heading Description]
There is no open file initially. [endsect][section:overload2 file_win32::file_win32 (2 of 2 overloads)]
Constructor. [heading Synopsis]```file_win32(    file_win32&& other);```[heading Description]
The moved-from object behaves as if default constructed. [endsect][endsect][section:is_open file_win32::is_open][indexterm2 is_open..file_win32]
Returns `true` if the file is open. [heading Synopsis]```boolis_open() const;```[heading Description][endsect][section:native_handle file_win32::native_handle][indexterm2 native_handle..file_win32]
Returns the native handle associated with the file. ```native_handle_type``[link beast.ref.boost__beast__file_win32.native_handle.overload1 native_handle]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__file_win32.native_handle.overload1 more...]]`````
Set the native handle associated with the file. ```void``[link beast.ref.boost__beast__file_win32.native_handle.overload2 native_handle]``(    native_handle_type h);  ``[''''&raquo;''' [link beast.ref.boost__beast__file_win32.native_handle.overload2 more...]]`````[section:overload1 file_win32::native_handle (1 of 2 overloads)]
Returns the native handle associated with the file. [heading Synopsis]```native_handle_typenative_handle();```[heading Description][endsect][section:overload2 file_win32::native_handle (2 of 2 overloads)]
Set the native handle associated with the file. [heading Synopsis]```voidnative_handle(    native_handle_type h);```[heading Description]
If the file is open it is first closed.
[heading Parameters][table [[Name][Description]]  [[`h`][    
The native file handle to assign.   ]]]
[endsect][endsect][section:native_handle_type file_win32::native_handle_type][indexterm2 native_handle_type..file_win32]
The type of the underlying file handle. [heading Synopsis]```using native_handle_type = HANDLE;```[heading Description]
This is platform-specific. [endsect][section:open file_win32::open][indexterm2 open..file_win32]
Open a file at the given path with the specified mode. [heading Synopsis]```voidopen(    char const* path,    file_mode mode,    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`path`][    
The utf-8 encoded path to the file  ]]  [[`mode`][    
The file mode to use  ]]  [[`ec`][    
Set to the error, if any occurred   ]]]
[endsect][section:operator_eq_ file_win32::operator=][indexterm2 operator=..file_win32]
Assignment. [heading Synopsis]```file_win32&operator=(    file_win32&& other);```[heading Description]
The moved-from object behaves as if default constructed. [endsect][section:pos file_win32::pos][indexterm2 pos..file_win32]
Return the current position in the open file. [heading Synopsis]```std::uint64_tpos(    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`ec`][    
Set to the error, if any occurred  ]]]
[heading Return Value]
The offset in bytes from the beginning of the file 
[endsect][section:read file_win32::read][indexterm2 read..file_win32]
Read from the open file. [heading Synopsis]```std::size_tread(    void* buffer,    std::size_t n,    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`buffer`][    
The buffer for storing the result of the read  ]]  [[`n`][    
The number of bytes to read  ]]  [[`ec`][    
Set to the error, if any occurred   ]]]
[endsect][section:seek file_win32::seek][indexterm2 seek..file_win32]
Adjust the current position in the open file. [heading Synopsis]```voidseek(    std::uint64_t offset,    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`offset`][    
The offset in bytes from the beginning of the file  ]]  [[`ec`][    
Set to the error, if any occurred   ]]]
[endsect][section:size file_win32::size][indexterm2 size..file_win32]
Return the size of the open file. [heading Synopsis]```std::uint64_tsize(    error_code& ec) const;```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`ec`][    
Set to the error, if any occurred  ]]]
[heading Return Value]
The size in bytes 
[endsect][section:write file_win32::write][indexterm2 write..file_win32]
Write to the open file. [heading Synopsis]```std::size_twrite(    void const* buffer,    std::size_t n,    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`buffer`][    
The buffer holding the data to write  ]]  [[`n`][    
The number of bytes to write  ]]  [[`ec`][    
Set to the error, if any occurred   ]]]
[endsect][section:file_win32_dtor_ file_win32::~file_win32][indexterm2 ~file_win32..file_win32]
Destructor. [heading Synopsis]```~file_win32();```[heading Description]
If the file is open it is first closed. [endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__flat_buffer flat_buffer][indexterm1 flat_buffer]
A flat buffer which uses the default allocator. [heading Synopsis]Defined in header [include_file boost/beast/core/flat_buffer.hpp]```using flat_buffer = basic_flat_buffer< std::allocator< char > >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__basic_flat_buffer.allocator_type [*allocator_type]]]    [      The type of allocator used.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.const_buffers_type [*const_buffers_type]]]    [      The ConstBufferSequence used to represent the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.mutable_buffers_type [*mutable_buffers_type]]]    [      The MutableBufferSequence used to represent the writable bytes.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.mutable_data_type [*mutable_data_type]]]    [      The MutableBufferSequence used to represent the readable bytes.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer [*basic_flat_buffer]]]    [      Constructor.       Move Constructor.       Copy Constructor.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.capacity [*capacity]]]    [      Return the maximum number of bytes, both readable and writable, that can be held without requiring an allocation.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.cdata [*cdata]]]    [      Returns a constant buffer sequence representing the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.clear [*clear]]]    [      Set the size of the readable and writable bytes to zero.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.commit [*commit]]]    [      Append writable bytes to the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.consume [*consume]]]    [      Remove bytes from beginning of the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.data [*data]]]    [      Returns a constant buffer sequence representing the readable bytes.       Returns a mutable buffer sequence representing the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.get_allocator [*get_allocator]]]    [      Returns a copy of the allocator used.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.max_size [*max_size]]]    [      Set the maximum allowed capacity.       Return the maximum number of bytes, both readable and writable, that can ever be held.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.operator_eq_ [*operator=]]]    [      Move Assignment.       Copy Assignment.       Copy assignment.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.prepare [*prepare]]]    [      Returns a mutable buffer sequence representing writable bytes.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.reserve [*reserve]]]    [      Guarantee a minimum capacity.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.shrink_to_fit [*shrink_to_fit]]]    [      Reallocate the buffer to fit the readable bytes exactly.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.size [*size]]]    [      Returns the number of readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer_dtor_ [*~basic_flat_buffer]]]    [      Destructor.     ]  ]][heading Friends][table [[Name][Description]]  [    [[link beast.ref.boost__beast__basic_flat_buffer.swap [*swap]]]    [      Exchange two dynamic buffers.     ]  ]]
A dynamic buffer encapsulates memory storage that may be automatically resized as required, where the memory is divided into two regions: readable bytes followed by writable bytes. These memory regions are internal to the dynamic buffer, but direct access to the elements is provided to permit them to be efficiently used with I/O operations.
Objects of this type meet the requirements of ['DynamicBuffer] and have the following additional properties:

* A mutable buffer sequence representing the readable bytes is returned by [link beast.ref.boost__beast__basic_flat_buffer.data `basic_flat_buffer::data`] when `this` is non-const.


* A configurable maximum buffer size may be set upon construction. Attempts to exceed the buffer size will throw `std::length_error`.


* Buffer sequences representing the readable and writable bytes, returned by [link beast.ref.boost__beast__basic_flat_buffer.data `basic_flat_buffer::data`] and [link beast.ref.boost__beast__basic_flat_buffer.prepare `basic_flat_buffer::prepare`], will have length one.

Upon construction, a maximum size for the buffer may be specified. If this limit is exceeded, the `std::length_error` exception will be thrown.
[heading Remarks]
This class is designed for use with algorithms that take dynamic buffers as parameters, and are optimized for the case where the input sequence or output sequence is stored in a single contiguous buffer. 
[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__flat_static_buffer flat_static_buffer]
A ['DynamicBuffer] with a fixed size internal buffer. [heading Synopsis]Defined in header [include_file boost/beast/core/flat_static_buffer.hpp]```template<    std::size_t N>class flat_static_buffer :    public flat_static_buffer_base```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__flat_static_buffer.const_buffers_type [*const_buffers_type]]]    [      The ConstBufferSequence used to represent the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer.mutable_buffers_type [*mutable_buffers_type]]]    [      The MutableBufferSequence used to represent the writable bytes.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer.mutable_data_type [*mutable_data_type]]]    [      The MutableBufferSequence used to represent the readable bytes.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__flat_static_buffer.base [*base]]]    [      Returns the flat_static_buffer_base portion of this object.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer.capacity [*capacity]]]    [      Return the maximum sum of input and output sizes that can be held without an allocation.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer.cdata [*cdata]]]    [      Returns a constant buffer sequence representing the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer.clear [*clear]]]    [      Clear the readable and writable bytes to zero.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer.commit [*commit]]]    [      Append writable bytes to the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer.consume [*consume]]]    [      Remove bytes from beginning of the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer.data [*data]]]    [      Returns a constant buffer sequence representing the readable bytes.       Returns a mutable buffer sequence representing the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer.flat_static_buffer [*flat_static_buffer]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer.max_size [*max_size]]]    [      Return the maximum sum of the input and output sequence sizes.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer.prepare [*prepare]]]    [      Returns a mutable buffer sequence representing writable bytes.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer.size [*size]]]    [      Returns the number of readable bytes.     ]  ]][heading Protected Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__flat_static_buffer.reset [*reset]]]    [      Reset the pointed-to buffer.     ]  ]][heading Description]
Buffer sequences returned by [link beast.ref.boost__beast__flat_static_buffer.data `flat_static_buffer::data`] and [link beast.ref.boost__beast__flat_static_buffer.prepare `flat_static_buffer::prepare`] will always be of length one. This implements a dynamic buffer using no memory allocations.
[heading Template Parameters][table [[Type][Description]]  [[`N`][    
The number of bytes in the internal buffer.  ]]]
[heading Remarks]
To reduce the number of template instantiations when passing objects of this type in a deduced context, the signature of the receiving function should use [link beast.ref.boost__beast__flat_static_buffer_base `flat_static_buffer_base`] instead.
[heading See Also]
[link beast.ref.boost__beast__flat_static_buffer_base `flat_static_buffer_base`] 
[section:base flat_static_buffer::base][indexterm2 base..flat_static_buffer]
Returns the [link beast.ref.boost__beast__flat_static_buffer_base `flat_static_buffer_base`] portion of this object. ```flat_static_buffer_base&``[link beast.ref.boost__beast__flat_static_buffer.base.overload1 base]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__flat_static_buffer.base.overload1 more...]]``flat_static_buffer_base const &``[link beast.ref.boost__beast__flat_static_buffer.base.overload2 base]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__flat_static_buffer.base.overload2 more...]]`````[section:overload1 flat_static_buffer::base (1 of 2 overloads)]
Returns the [link beast.ref.boost__beast__flat_static_buffer_base `flat_static_buffer_base`] portion of this object. [heading Synopsis]```flat_static_buffer_base&base();```[heading Description][endsect][section:overload2 flat_static_buffer::base (2 of 2 overloads)]
Returns the [link beast.ref.boost__beast__flat_static_buffer_base `flat_static_buffer_base`] portion of this object. [heading Synopsis]```flat_static_buffer_base const &base() const;```[heading Description][endsect][endsect][section:capacity flat_static_buffer::capacity][indexterm2 capacity..flat_static_buffer]
Return the maximum sum of input and output sizes that can be held without an allocation. [heading Synopsis]```std::size_t constexprcapacity() const;```[heading Description][endsect][section:cdata flat_static_buffer::cdata][indexterm2 cdata..flat_static_buffer]
Returns a constant buffer sequence representing the readable bytes. [heading Synopsis]```const_buffers_typecdata() const;```[heading Description][endsect][section:clear flat_static_buffer::clear][indexterm2 clear..flat_static_buffer]
Clear the readable and writable bytes to zero. [heading Synopsis]```voidclear();```[heading Description]
This function causes the readable and writable bytes to become empty. The capacity is not changed.
Buffer sequences previously obtained using [link beast.ref.boost__beast__flat_static_buffer.data `flat_static_buffer::data`] or [link beast.ref.boost__beast__flat_static_buffer.prepare `flat_static_buffer::prepare`] become invalid.
[heading Exception Safety]

No-throw guarantee. [endsect][section:commit flat_static_buffer::commit][indexterm2 commit..flat_static_buffer]
Append writable bytes to the readable bytes. [heading Synopsis]```voidcommit(    std::size_t n);```[heading Description]
Appends n bytes from the start of the writable bytes to the end of the readable bytes. The remainder of the writable bytes are discarded. If n is greater than the number of writable bytes, all writable bytes are appended to the readable bytes.
All buffers sequences previously obtained using [link beast.ref.boost__beast__flat_static_buffer.data `flat_static_buffer::data`] or [link beast.ref.boost__beast__flat_static_buffer.prepare `flat_static_buffer::prepare`] are invalidated.
[heading Parameters][table [[Name][Description]]  [[`n`][    
The number of bytes to append. If this number is greater than the number of writable bytes, all writable bytes are appended.  ]]]
[heading Exception Safety]

No-throw guarantee. [endsect][section:const_buffers_type flat_static_buffer::const_buffers_type][indexterm2 const_buffers_type..flat_static_buffer]
The ConstBufferSequence used to represent the readable bytes. [heading Synopsis]```using const_buffers_type = net::const_buffer;```[heading Description][endsect][section:consume flat_static_buffer::consume][indexterm2 consume..flat_static_buffer]
Remove bytes from beginning of the readable bytes. [heading Synopsis]```voidconsume(    std::size_t n);```[heading Description]
Removes n bytes from the beginning of the readable bytes.
All buffers sequences previously obtained using [link beast.ref.boost__beast__flat_static_buffer.data `flat_static_buffer::data`] or [link beast.ref.boost__beast__flat_static_buffer.prepare `flat_static_buffer::prepare`] are invalidated.
[heading Parameters][table [[Name][Description]]  [[`n`][    
The number of bytes to remove. If this number is greater than the number of readable bytes, all readable bytes are removed.  ]]]
[heading Exception Safety]

No-throw guarantee. [endsect][section:data flat_static_buffer::data][indexterm2 data..flat_static_buffer]
Returns a constant buffer sequence representing the readable bytes. ```const_buffers_type``[link beast.ref.boost__beast__flat_static_buffer.data.overload1 data]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__flat_static_buffer.data.overload1 more...]]`````
Returns a mutable buffer sequence representing the readable bytes. ```mutable_data_type``[link beast.ref.boost__beast__flat_static_buffer.data.overload2 data]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__flat_static_buffer.data.overload2 more...]]`````[section:overload1 flat_static_buffer::data (1 of 2 overloads)]
Returns a constant buffer sequence representing the readable bytes. [heading Synopsis]```const_buffers_typedata() const;```[heading Description][endsect][section:overload2 flat_static_buffer::data (2 of 2 overloads)]
Returns a mutable buffer sequence representing the readable bytes. [heading Synopsis]```mutable_data_typedata();```[heading Description][endsect][endsect][section:flat_static_buffer flat_static_buffer::flat_static_buffer][indexterm2 flat_static_buffer..flat_static_buffer]
Constructor. `````[link beast.ref.boost__beast__flat_static_buffer.flat_static_buffer.overload1 flat_static_buffer]``(    flat_static_buffer const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__flat_static_buffer.flat_static_buffer.overload1 more...]]````[link beast.ref.boost__beast__flat_static_buffer.flat_static_buffer.overload2 flat_static_buffer]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__flat_static_buffer.flat_static_buffer.overload2 more...]]`````[section:overload1 flat_static_buffer::flat_static_buffer (1 of 2 overloads)]
Constructor. [heading Synopsis]```flat_static_buffer(    flat_static_buffer const&);```[heading Description][endsect][section:overload2 flat_static_buffer::flat_static_buffer (2 of 2 overloads)]
Constructor. [heading Synopsis]```flat_static_buffer();```[heading Description][endsect][endsect][section:max_size flat_static_buffer::max_size][indexterm2 max_size..flat_static_buffer]
Return the maximum sum of the input and output sequence sizes. [heading Synopsis]```std::size_t constexprmax_size() const;```[heading Description][endsect][section:mutable_buffers_type flat_static_buffer::mutable_buffers_type][indexterm2 mutable_buffers_type..flat_static_buffer]
The MutableBufferSequence used to represent the writable bytes. [heading Synopsis]```using mutable_buffers_type = net::mutable_buffer;```[heading Description][endsect][section:mutable_data_type flat_static_buffer::mutable_data_type][indexterm2 mutable_data_type..flat_static_buffer]
The MutableBufferSequence used to represent the readable bytes. [heading Synopsis]```using mutable_data_type = net::mutable_buffer;```[heading Description][endsect][section:operator_eq_ flat_static_buffer::operator=][indexterm2 operator=..flat_static_buffer]
Assignment. [heading Synopsis]```flat_static_buffer&operator=(    flat_static_buffer const&);```[heading Description][endsect][section:prepare flat_static_buffer::prepare][indexterm2 prepare..flat_static_buffer]
Returns a mutable buffer sequence representing writable bytes. [heading Synopsis]```mutable_buffers_typeprepare(    std::size_t n);```[heading Description]
Returns a mutable buffer sequence representing the writable bytes containing exactly `n` bytes of storage.
All buffers sequences previously obtained using [link beast.ref.boost__beast__flat_static_buffer.data `flat_static_buffer::data`] or [link beast.ref.boost__beast__flat_static_buffer.prepare `flat_static_buffer::prepare`] are invalidated.
[heading Parameters][table [[Name][Description]]  [[`n`][    
The desired number of bytes in the returned buffer sequence.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::length_error`][    
if `size() + n` exceeds `max_size()`.  ]]]
[heading Exception Safety]

Strong guarantee. [endsect][section:reset flat_static_buffer::reset][indexterm2 reset..flat_static_buffer]
Reset the pointed-to buffer. [heading Synopsis]```voidreset(    void* p,    std::size_t n);```[heading Description]
This function resets the internal state to the buffer provided. All input and output sequences are invalidated. This function allows the derived class to construct its members before initializing the static buffer.
[heading Parameters][table [[Name][Description]]  [[`p`][    
A pointer to valid storage of at least `n` bytes.  ]]  [[`n`][    
The number of valid bytes pointed to by `p`.  ]]]
[heading Exception Safety]

No-throw guarantee. [endsect][section:size flat_static_buffer::size][indexterm2 size..flat_static_buffer]
Returns the number of readable bytes. [heading Synopsis]```std::size_tsize() const;```[heading Description][endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__flat_static_buffer_base flat_static_buffer_base]
A dynamic buffer using a fixed size internal buffer. [heading Synopsis]Defined in header [include_file boost/beast/core/flat_static_buffer.hpp]```class flat_static_buffer_base```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__flat_static_buffer_base.const_buffers_type [*const_buffers_type]]]    [      The ConstBufferSequence used to represent the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer_base.mutable_buffers_type [*mutable_buffers_type]]]    [      The MutableBufferSequence used to represent the writable bytes.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer_base.mutable_data_type [*mutable_data_type]]]    [      The MutableBufferSequence used to represent the readable bytes.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__flat_static_buffer_base.capacity [*capacity]]]    [      Return the maximum number of bytes, both readable and writable, that can be held without requiring an allocation.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer_base.cdata [*cdata]]]    [      Returns a constant buffer sequence representing the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer_base.clear [*clear]]]    [      Clear the readable and writable bytes to zero.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer_base.commit [*commit]]]    [      Append writable bytes to the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer_base.consume [*consume]]]    [      Remove bytes from beginning of the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer_base.data [*data]]]    [      Returns a constant buffer sequence representing the readable bytes.       Returns a mutable buffer sequence representing the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer_base.flat_static_buffer_base [*flat_static_buffer_base]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer_base.max_size [*max_size]]]    [      Return the maximum number of bytes, both readable and writable, that can ever be held.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer_base.prepare [*prepare]]]    [      Returns a mutable buffer sequence representing writable bytes.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer_base.size [*size]]]    [      Returns the number of readable bytes.     ]  ]][heading Protected Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__flat_static_buffer_base.flat_static_buffer_base [*flat_static_buffer_base]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer_base.reset [*reset]]]    [      Reset the pointed-to buffer.     ]  ]][heading Description]
A dynamic buffer encapsulates memory storage that may be automatically resized as required, where the memory is divided into two regions: readable bytes followed by writable bytes. These memory regions are internal to the dynamic buffer, but direct access to the elements is provided to permit them to be efficiently used with I/O operations.
Objects of this type meet the requirements of ['DynamicBuffer] and have the following additional properties:

* A mutable buffer sequence representing the readable bytes is returned by [link beast.ref.boost__beast__flat_static_buffer.data `flat_static_buffer::data`] when `this` is non-const.


* Buffer sequences representing the readable and writable bytes, returned by [link beast.ref.boost__beast__flat_static_buffer.data `flat_static_buffer::data`] and [link beast.ref.boost__beast__flat_static_buffer.prepare `flat_static_buffer::prepare`], will have length one.


* Ownership of the underlying storage belongs to the derived class.

[heading Remarks]
Variables are usually declared using the template class [link beast.ref.boost__beast__flat_static_buffer `flat_static_buffer`]; however, to reduce the number of template instantiations, objects should be passed `flat_static_buffer_base&`.
[heading See Also]
[link beast.ref.boost__beast__flat_static_buffer `flat_static_buffer`] 
[section:capacity flat_static_buffer_base::capacity][indexterm2 capacity..flat_static_buffer_base]
Return the maximum number of bytes, both readable and writable, that can be held without requiring an allocation. [heading Synopsis]```std::size_tcapacity() const;```[heading Description][endsect][section:cdata flat_static_buffer_base::cdata][indexterm2 cdata..flat_static_buffer_base]
Returns a constant buffer sequence representing the readable bytes. [heading Synopsis]```const_buffers_typecdata() const;```[heading Description][endsect][section:clear flat_static_buffer_base::clear][indexterm2 clear..flat_static_buffer_base]
Clear the readable and writable bytes to zero. [heading Synopsis]```voidclear();```[heading Description]
This function causes the readable and writable bytes to become empty. The capacity is not changed.
Buffer sequences previously obtained using [link beast.ref.boost__beast__flat_static_buffer.data `flat_static_buffer::data`] or [link beast.ref.boost__beast__flat_static_buffer.prepare `flat_static_buffer::prepare`] become invalid.
[heading Exception Safety]

No-throw guarantee. [endsect][section:commit flat_static_buffer_base::commit][indexterm2 commit..flat_static_buffer_base]
Append writable bytes to the readable bytes. [heading Synopsis]```voidcommit(    std::size_t n);```[heading Description]
Appends n bytes from the start of the writable bytes to the end of the readable bytes. The remainder of the writable bytes are discarded. If n is greater than the number of writable bytes, all writable bytes are appended to the readable bytes.
All buffers sequences previously obtained using [link beast.ref.boost__beast__flat_static_buffer.data `flat_static_buffer::data`] or [link beast.ref.boost__beast__flat_static_buffer.prepare `flat_static_buffer::prepare`] are invalidated.
[heading Parameters][table [[Name][Description]]  [[`n`][    
The number of bytes to append. If this number is greater than the number of writable bytes, all writable bytes are appended.  ]]]
[heading Exception Safety]

No-throw guarantee. [endsect][section:const_buffers_type flat_static_buffer_base::const_buffers_type][indexterm2 const_buffers_type..flat_static_buffer_base]
The ConstBufferSequence used to represent the readable bytes. [heading Synopsis]```using const_buffers_type = net::const_buffer;```[heading Description][endsect][section:consume flat_static_buffer_base::consume][indexterm2 consume..flat_static_buffer_base]
Remove bytes from beginning of the readable bytes. [heading Synopsis]```voidconsume(    std::size_t n);```[heading Description]
Removes n bytes from the beginning of the readable bytes.
All buffers sequences previously obtained using [link beast.ref.boost__beast__flat_static_buffer.data `flat_static_buffer::data`] or [link beast.ref.boost__beast__flat_static_buffer.prepare `flat_static_buffer::prepare`] are invalidated.
[heading Parameters][table [[Name][Description]]  [[`n`][    
The number of bytes to remove. If this number is greater than the number of readable bytes, all readable bytes are removed.  ]]]
[heading Exception Safety]

No-throw guarantee. [endsect][section:data flat_static_buffer_base::data][indexterm2 data..flat_static_buffer_base]
Returns a constant buffer sequence representing the readable bytes. ```const_buffers_type``[link beast.ref.boost__beast__flat_static_buffer_base.data.overload1 data]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__flat_static_buffer_base.data.overload1 more...]]`````
Returns a mutable buffer sequence representing the readable bytes. ```mutable_data_type``[link beast.ref.boost__beast__flat_static_buffer_base.data.overload2 data]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__flat_static_buffer_base.data.overload2 more...]]`````[section:overload1 flat_static_buffer_base::data (1 of 2 overloads)]
Returns a constant buffer sequence representing the readable bytes. [heading Synopsis]```const_buffers_typedata() const;```[heading Description][endsect][section:overload2 flat_static_buffer_base::data (2 of 2 overloads)]
Returns a mutable buffer sequence representing the readable bytes. [heading Synopsis]```mutable_data_typedata();```[heading Description][endsect][endsect][section:flat_static_buffer_base flat_static_buffer_base::flat_static_buffer_base][indexterm2 flat_static_buffer_base..flat_static_buffer_base]
Constructor. [heading Synopsis]```flat_static_buffer_base(    void* p,    std::size_t n);```[heading Description]
This creates a dynamic buffer using the provided storage area.
[heading Parameters][table [[Name][Description]]  [[`p`][    
A pointer to valid storage of at least `n` bytes.  ]]  [[`n`][    
The number of valid bytes pointed to by `p`.   ]]]
[endsect][section:flat_static_buffer_base flat_static_buffer_base::flat_static_buffer_base][indexterm2 flat_static_buffer_base..flat_static_buffer_base]
Constructor. [heading Synopsis]```flat_static_buffer_base();```[heading Description]
The buffer will be in an undefined state. It is necessary for the derived class to call [link beast.ref.boost__beast__flat_static_buffer.reset `flat_static_buffer::reset`] with a pointer and size in order to initialize the object. [endsect][section:max_size flat_static_buffer_base::max_size][indexterm2 max_size..flat_static_buffer_base]
Return the maximum number of bytes, both readable and writable, that can ever be held. [heading Synopsis]```std::size_tmax_size() const;```[heading Description][endsect][section:mutable_buffers_type flat_static_buffer_base::mutable_buffers_type][indexterm2 mutable_buffers_type..flat_static_buffer_base]
The MutableBufferSequence used to represent the writable bytes. [heading Synopsis]```using mutable_buffers_type = net::mutable_buffer;```[heading Description][endsect][section:mutable_data_type flat_static_buffer_base::mutable_data_type][indexterm2 mutable_data_type..flat_static_buffer_base]
The MutableBufferSequence used to represent the readable bytes. [heading Synopsis]```using mutable_data_type = net::mutable_buffer;```[heading Description][endsect][section:prepare flat_static_buffer_base::prepare][indexterm2 prepare..flat_static_buffer_base]
Returns a mutable buffer sequence representing writable bytes. [heading Synopsis]```mutable_buffers_typeprepare(    std::size_t n);```[heading Description]
Returns a mutable buffer sequence representing the writable bytes containing exactly `n` bytes of storage.
All buffers sequences previously obtained using [link beast.ref.boost__beast__flat_static_buffer.data `flat_static_buffer::data`] or [link beast.ref.boost__beast__flat_static_buffer.prepare `flat_static_buffer::prepare`] are invalidated.
[heading Parameters][table [[Name][Description]]  [[`n`][    
The desired number of bytes in the returned buffer sequence.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::length_error`][    
if `size() + n` exceeds `max_size()`.  ]]]
[heading Exception Safety]

Strong guarantee. [endsect][section:reset flat_static_buffer_base::reset][indexterm2 reset..flat_static_buffer_base]
Reset the pointed-to buffer. [heading Synopsis]```voidreset(    void* p,    std::size_t n);```[heading Description]
This function resets the internal state to the buffer provided. All input and output sequences are invalidated. This function allows the derived class to construct its members before initializing the static buffer.
[heading Parameters][table [[Name][Description]]  [[`p`][    
A pointer to valid storage of at least `n` bytes.  ]]  [[`n`][    
The number of valid bytes pointed to by `p`.  ]]]
[heading Exception Safety]

No-throw guarantee. [endsect][section:size flat_static_buffer_base::size][indexterm2 size..flat_static_buffer_base]
Returns the number of readable bytes. [heading Synopsis]```std::size_tsize() const;```[heading Description][endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__flat_stream flat_stream]
Stream wrapper to improve write performance. [heading Synopsis]Defined in header [include_file boost/beast/core/flat_stream.hpp]```template<    class NextLayer>class flat_stream```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__flat_stream.executor_type [*executor_type]]]    [      The type of the executor associated with the object.     ]  ]  [    [[link beast.ref.boost__beast__flat_stream.next_layer_type [*next_layer_type]]]    [      The type of the next layer.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__flat_stream.async_read_some [*async_read_some]]]    [      Start an asynchronous read.     ]  ]  [    [[link beast.ref.boost__beast__flat_stream.async_write_some [*async_write_some]]]    [      Start an asynchronous write.     ]  ]  [    [[link beast.ref.boost__beast__flat_stream.flat_stream [*flat_stream]]]    [            Constructor.     ]  ]  [    [[link beast.ref.boost__beast__flat_stream.get_executor [*get_executor]]]    [      Get the executor associated with the object.     ]  ]  [    [[link beast.ref.boost__beast__flat_stream.next_layer [*next_layer]]]    [      Get a reference to the next layer.     ]  ]  [    [[link beast.ref.boost__beast__flat_stream.operator_eq_ [*operator=]]]    [          ]  ]  [    [[link beast.ref.boost__beast__flat_stream.read_some [*read_some]]]    [      Read some data from the stream.     ]  ]  [    [[link beast.ref.boost__beast__flat_stream.write_some [*write_some]]]    [      Write some data to the stream.     ]  ]  [    [[link beast.ref.boost__beast__flat_stream.flat_stream_dtor_ [*~flat_stream]]]    [      Destructor.     ]  ]][heading Description]
This wrapper flattens writes for buffer sequences having length greater than 1 and total size below a predefined amount, using a dynamic memory allocation. It is primarily designed to overcome a performance limitation of the current version of `net::ssl::stream`, which does not use OpenSSL's scatter/gather interface for its low-level read some and write some operations.
It is normally not necessary to use this class directly if you are already using [link beast.ref.boost__beast__ssl_stream `ssl_stream`]. The following examples shows how to use this class with the ssl stream that comes with networking:
[heading Example]

To use the [link beast.ref.boost__beast__flat_stream `flat_stream`] template with SSL streams, declare a variable of the correct type. Parameters passed to the constructor will be forwarded to the next layer's constructor:
```  flat_stream<net::ssl::stream<ip::tcp::socket>> fs{ioc, ctx};
```Alternatively you can write ```  ssl::stream<ip::tcp::socket> ss{ioc, ctx};
  flat_stream<net::ssl::stream<ip::tcp::socket>&> fs{ss};
```
The resulting stream may be passed to any stream algorithms which operate on synchronous or asynchronous read or write streams, examples include:

* `net::read`, `net::async_read`


* `net::write`, `net::async_write`


* `net::read_until`, `net::async_read_until`

The stream may also be used as a template parameter in other stream wrappers, such as for websocket: ```  websocket::stream<flat_stream<net::ssl::stream<ip::tcp::socket>>> ws{ioc, ctx};
```
[heading Template Parameters][table [[Type][Description]]  [[`NextLayer`][    
The type representing the next layer, to which data will be read and written during operations. For synchronous operations, the type must support the [*SyncStream] concept. For asynchronous operations, the type must support the [*AsyncStream] concept. This type will usually be some variation of `net::ssl::stream`.  ]]]
[heading Concepts]

* SyncStream 
* AsyncStream


[heading See Also]

* [@https://github.com/boostorg/asio/issues/100 https://github.com/boostorg/asio/issues/100] 
* [@https://github.com/boostorg/beast/issues/1108 https://github.com/boostorg/beast/issues/1108] 
* [@https://stackoverflow.com/questions/38198638/openssl-ssl-write-from-multiple-buffers-ssl-writev https://stackoverflow.com/questions/38198638/openssl-ssl-write-from-multiple-buffers-ssl-writev] 
* [@https://stackoverflow.com/questions/50026167/performance-drop-on-port-from-beast-1-0-0-b66-to-boost-1-67-0-beast https://stackoverflow.com/questions/50026167/performance-drop-on-port-from-beast-1-0-0-b66-to-boost-1-67-0-beast] 


[section:async_read_some flat_stream::async_read_some][indexterm2 async_read_some..flat_stream]
Start an asynchronous read. [heading Synopsis]```template<    class __MutableBufferSequence__,    class __ReadHandler__>``__deduced__``async_read_some(    MutableBufferSequence const& buffers,    ReadHandler&& handler);```[heading Description]
This function is used to asynchronously read one or more bytes of data from the stream. The function call always returns immediately.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The buffers into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying buffers is retained by the caller, which must guarantee that they remain valid until the handler is called.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      error_code const& error,        // Result of operation.
      std::size_t bytes_transferred   // Number of bytes read.
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.  ]]]
[heading Remarks]
The `read_some` operation may not read all of the requested number of bytes. Consider using the function `net::async_read` if you need to ensure that the requested amount of data is read before the asynchronous operation completes. 
[endsect][section:async_write_some flat_stream::async_write_some][indexterm2 async_write_some..flat_stream]
Start an asynchronous write. [heading Synopsis]```template<    class __ConstBufferSequence__,    class __WriteHandler__>``__deduced__``async_write_some(    ConstBufferSequence const& buffers,    WriteHandler&& handler);```[heading Description]
This function is used to asynchronously write one or more bytes of data to the stream. The function call always returns immediately.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The data to be written to the stream. Although the buffers object may be copied as necessary, ownership of the underlying buffers is retained by the caller, which must guarantee that they remain valid until the handler is called.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      error_code const& ec,           // Result of operation.
      std::size_t bytes_transferred   // Number of bytes written.
  );
```  ]]]
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.
[heading Remarks]
The `async_write_some` operation may not transmit all of the data to the peer. Consider using the function `net::async_write` if you need to ensure that all data is written before the asynchronous operation completes. 
[endsect][section:executor_type flat_stream::executor_type][indexterm2 executor_type..flat_stream]
The type of the executor associated with the object. [heading Synopsis]```using executor_type = beast::executor_type< next_layer_type >;```[heading Description][endsect][section:flat_stream flat_stream::flat_stream][indexterm2 flat_stream..flat_stream]`````[link beast.ref.boost__beast__flat_stream.flat_stream.overload1 flat_stream]``(    flat_stream&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__flat_stream.flat_stream.overload1 more...]]````[link beast.ref.boost__beast__flat_stream.flat_stream.overload2 flat_stream]``(    flat_stream const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__flat_stream.flat_stream.overload2 more...]]`````
Constructor. ```template<    class... Args>explicit``[link beast.ref.boost__beast__flat_stream.flat_stream.overload3 flat_stream]``(    Args&&... args);  ``[''''&raquo;''' [link beast.ref.boost__beast__flat_stream.flat_stream.overload3 more...]]`````[section:overload1 flat_stream::flat_stream (1 of 3 overloads)][heading Synopsis]```flat_stream(    flat_stream&&);```[heading Description][endsect][section:overload2 flat_stream::flat_stream (2 of 3 overloads)][heading Synopsis]```flat_stream(    flat_stream const&);```[heading Description][endsect][section:overload3 flat_stream::flat_stream (3 of 3 overloads)]
Constructor. [heading Synopsis]```template<    class... Args>flat_stream(    Args&&... args);```[heading Description]
Arguments, if any, are forwarded to the next layer's constructor. [endsect][endsect][section:get_executor flat_stream::get_executor][indexterm2 get_executor..flat_stream]
Get the executor associated with the object. [heading Synopsis]```executor_typeget_executor();```[heading Description]
This function may be used to obtain the executor object that the stream uses to dispatch handlers for asynchronous operations.
[heading Return Value]
A copy of the executor that stream will use to dispatch handlers. 
[endsect][section:next_layer flat_stream::next_layer][indexterm2 next_layer..flat_stream]
Get a reference to the next layer. ```next_layer_type&``[link beast.ref.boost__beast__flat_stream.next_layer.overload1 next_layer]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__flat_stream.next_layer.overload1 more...]]``next_layer_type const &``[link beast.ref.boost__beast__flat_stream.next_layer.overload2 next_layer]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__flat_stream.next_layer.overload2 more...]]`````[section:overload1 flat_stream::next_layer (1 of 2 overloads)]
Get a reference to the next layer. [heading Synopsis]```next_layer_type&next_layer();```[heading Description]
This function returns a reference to the next layer in a stack of stream layers.
[heading Return Value]
A reference to the next layer in the stack of stream layers. 
[endsect][section:overload2 flat_stream::next_layer (2 of 2 overloads)]
Get a reference to the next layer. [heading Synopsis]```next_layer_type const &next_layer() const;```[heading Description]
This function returns a reference to the next layer in a stack of stream layers.
[heading Return Value]
A reference to the next layer in the stack of stream layers. 
[endsect][endsect][section:next_layer_type flat_stream::next_layer_type][indexterm2 next_layer_type..flat_stream]
The type of the next layer. [heading Synopsis]```using next_layer_type = typename std::remove_reference< NextLayer >::type;```[heading Description][endsect][section:operator_eq_ flat_stream::operator=][indexterm2 operator=..flat_stream]```flat_stream&``[link beast.ref.boost__beast__flat_stream.operator_eq_.overload1 operator=]``(    flat_stream&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__flat_stream.operator_eq_.overload1 more...]]``flat_stream&``[link beast.ref.boost__beast__flat_stream.operator_eq_.overload2 operator=]``(    flat_stream const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__flat_stream.operator_eq_.overload2 more...]]`````[section:overload1 flat_stream::operator= (1 of 2 overloads)][heading Synopsis]```flat_stream&operator=(    flat_stream&&);```[heading Description][endsect][section:overload2 flat_stream::operator= (2 of 2 overloads)][heading Synopsis]```flat_stream&operator=(    flat_stream const&);```[heading Description][endsect][endsect][section:read_some flat_stream::read_some][indexterm2 read_some..flat_stream]
Read some data from the stream. ```template<    class __MutableBufferSequence__>std::size_t``[link beast.ref.boost__beast__flat_stream.read_some.overload1 read_some]``(    MutableBufferSequence const& buffers);  ``[''''&raquo;''' [link beast.ref.boost__beast__flat_stream.read_some.overload1 more...]]``template<    class __MutableBufferSequence__>std::size_t``[link beast.ref.boost__beast__flat_stream.read_some.overload2 read_some]``(    MutableBufferSequence const& buffers,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__flat_stream.read_some.overload2 more...]]`````[section:overload1 flat_stream::read_some (1 of 2 overloads)]
Read some data from the stream. [heading Synopsis]```template<    class __MutableBufferSequence__>std::size_tread_some(    MutableBufferSequence const& buffers);```[heading Description]
This function is used to read data from the stream. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The buffers into which the data will be read.  ]]]
[heading Return Value]
The number of bytes read.
[heading Exceptions][table [[Type][Thrown On]]  [[`boost::system::system_error`][    
Thrown on failure.  ]]]
[heading Remarks]
The `read_some` operation may not read all of the requested number of bytes. Consider using the function `net::read` if you need to ensure that the requested amount of data is read before the blocking operation completes. 
[endsect][section:overload2 flat_stream::read_some (2 of 2 overloads)]
Read some data from the stream. [heading Synopsis]```template<    class __MutableBufferSequence__>std::size_tread_some(    MutableBufferSequence const& buffers,    error_code& ec);```[heading Description]
This function is used to read data from the stream. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The buffers into which the data will be read.  ]]  [[`ec`][    
Set to indicate what error occurred, if any.  ]]]
[heading Return Value]
The number of bytes read.
[heading Remarks]
The `read_some` operation may not read all of the requested number of bytes. Consider using the function `net::read` if you need to ensure that the requested amount of data is read before the blocking operation completes. 
[endsect][endsect][section:write_some flat_stream::write_some][indexterm2 write_some..flat_stream]
Write some data to the stream. ```template<    class __ConstBufferSequence__>std::size_t``[link beast.ref.boost__beast__flat_stream.write_some.overload1 write_some]``(    ConstBufferSequence const& buffers);  ``[''''&raquo;''' [link beast.ref.boost__beast__flat_stream.write_some.overload1 more...]]``template<    class __ConstBufferSequence__>std::size_t``[link beast.ref.boost__beast__flat_stream.write_some.overload2 write_some]``(    ConstBufferSequence const& buffers,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__flat_stream.write_some.overload2 more...]]`````[section:overload1 flat_stream::write_some (1 of 2 overloads)]
Write some data to the stream. [heading Synopsis]```template<    class __ConstBufferSequence__>std::size_twrite_some(    ConstBufferSequence const& buffers);```[heading Description]
This function is used to write data on the stream. The function call will block until one or more bytes of data has been written successfully, or until an error occurs.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The data to be written.  ]]]
[heading Return Value]
The number of bytes written.
[heading Exceptions][table [[Type][Thrown On]]  [[`boost::system::system_error`][    
Thrown on failure.  ]]]
[heading Remarks]
The `write_some` operation may not transmit all of the data to the peer. Consider using the function `net::write` if you need to ensure that all data is written before the blocking operation completes. 
[endsect][section:overload2 flat_stream::write_some (2 of 2 overloads)]
Write some data to the stream. [heading Synopsis]```template<    class __ConstBufferSequence__>std::size_twrite_some(    ConstBufferSequence const& buffers,    error_code& ec);```[heading Description]
This function is used to write data on the stream. The function call will block until one or more bytes of data has been written successfully, or until an error occurs.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The data to be written.  ]]  [[`ec`][    
Set to indicate what error occurred, if any.  ]]]
[heading Return Value]
The number of bytes written.
[heading Remarks]
The `write_some` operation may not transmit all of the data to the peer. Consider using the function `net::write` if you need to ensure that all data is written before the blocking operation completes. 
[endsect][endsect][section:flat_stream_dtor_ flat_stream::~flat_stream][indexterm2 ~flat_stream..flat_stream]
Destructor. [heading Synopsis]```~flat_stream();```[heading Description]
The treatment of pending operations will be the same as that of the next layer. [endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__generic_category generic_category][indexterm1 generic_category]
A function to return the generic error category used by the library. [heading Synopsis]Defined in header [include_file boost/beast/core/error.hpp]```error_category const &generic_category();```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__get_lowest_layer get_lowest_layer][indexterm1 get_lowest_layer]
Return the lowest layer in a stack of stream layers. [heading Synopsis]Defined in header [include_file boost/beast/core/stream_traits.hpp]```template<    class T>lowest_layer_type< T >&get_lowest_layer(    T& t);```[heading Description]
If `t.next_layer()` is well-defined, returns `get_lowest_layer(t.next_layer())`. Otherwise, it returns `t`.
A stream layer is an object of class type which wraps another object through composition, and meets some or all of the named requirements of the wrapped type while optionally changing behavior. Examples of stream layers include `net::ssl::stream` or [link beast.ref.boost__beast__websocket__stream `websocket::stream`]. The owner of a stream layer can interact directly with the wrapper, by passing it to stream algorithms. Or, the owner can obtain a reference to the wrapped object by calling `next_layer()` and accessing its members. This is necessary when it is desired to access functionality in the next layer which is not available in the wrapper. For example, [link beast.ref.boost__beast__websocket__stream `websocket::stream`] permits reading and writing, but in order to establish the underlying connection, members of the wrapped stream (such as `connect`) must be invoked directly.
Usually the last object in the chain of composition is the concrete socket object (for example, a `net::basic_socket` or a class derived from it). The function [link beast.ref.boost__beast__get_lowest_layer `get_lowest_layer`] exists to easily obtain the concrete socket when it is desired to perform an action that is not prescribed by a named requirement, such as changing a socket option, cancelling all pending asynchronous I/O, or closing the socket (perhaps by using [link beast.ref.boost__beast__close_socket `close_socket`]).
[heading Example]
```  // Set non-blocking mode on a stack of stream
  // layers with a regular socket at the lowest layer.
  template <class Stream>
  void set_non_blocking (Stream& stream)
  {
      error_code ec;
      // A compile error here means your lowest layer is not the right type!
      get_lowest_layer(stream).non_blocking(true, ec);
      if(ec)
          throw system_error{ec};
  }
```
[heading Parameters][table [[Name][Description]]  [[`t`][    
The layer in a stack of layered objects for which the lowest layer is returned.  ]]]
[heading See Also]
[link beast.ref.boost__beast__close_socket `close_socket`], [link beast.ref.boost__beast__lowest_layer_type `lowest_layer_type`] 
Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__has_get_executor has_get_executor][indexterm1 has_get_executor]
Determine if `T` has the `get_executor` member function. [heading Synopsis]Defined in header [include_file boost/beast/core/stream_traits.hpp]```template<    class T>using has_get_executor = ``['see-below]``;```[heading Description]
Metafunctions are used to perform compile time checking of template types. This type will be `std::true_type` if `T` has the member function with the correct signature, else type will be `std::false_type`.
[heading Example]

Use with tag dispatching:
```  template<class T>
  void maybe_hello(T const& t, std::true_type)
  {
      net::post(
          t.get_executor(),
          []
          {
              std::cout << "Hello, world!" << std::endl;
          });
  }

  template<class T>
  void maybe_hello(T const&, std::false_type)
  {
      // T does not have get_executor
  }

  template<class T>
  void maybe_hello(T const& t)
  {
      maybe_hello(t, has_get_executor<T>{});
  }
```
Use with `static_assert`:
```  struct stream
  {
      using executor_type = net::io_context::executor_type;
      executor_type get_executor() noexcept;
  };

  static_assert(has_get_executor<stream>::value, "Missing get_executor member");
```Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__http__async_read http::async_read][indexterm1 http::async_read]
Read a complete message asynchronously from a stream using a parser. ```template<    class __AsyncReadStream__,    class __DynamicBuffer__,    bool isRequest,    class __ReadHandler__>``__deduced__````[link beast.ref.boost__beast__http__async_read.overload1 async_read]``(    AsyncReadStream& stream,    DynamicBuffer& buffer,    basic_parser< isRequest >& parser,    ReadHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__async_read.overload1 more...]]`````
Read a complete message asynchronously from a stream. ```template<    class __AsyncReadStream__,    class __DynamicBuffer__,    bool isRequest,    class __Body__,    class __Allocator__,    class __ReadHandler__>``__deduced__````[link beast.ref.boost__beast__http__async_read.overload2 async_read]``(    AsyncReadStream& stream,    DynamicBuffer& buffer,    message< isRequest, Body, basic_fields< Allocator >>& msg,    ReadHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__async_read.overload2 more...]]`````[section:overload1 http::async_read (1 of 2 overloads)]
Read a complete message asynchronously from a stream using a parser. [heading Synopsis]Defined in header [include_file boost/beast/http/read.hpp]```template<    class __AsyncReadStream__,    class __DynamicBuffer__,    bool isRequest,    class __ReadHandler__>``__deduced__``async_read(    AsyncReadStream& stream,    DynamicBuffer& buffer,    basic_parser< isRequest >& parser,    ReadHandler&& handler);```[heading Description]
This function is used to asynchronously read a complete message from a stream into an instance of [link beast.ref.boost__beast__http__basic_parser `http::basic_parser`]. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:

* [link beast.ref.boost__beast__http__basic_parser.is_done `http::basic_parser::is_done`] returns `true`


* An error occurs.

This operation is implemented in terms of zero or more calls to the next layer's `async_read_some` function, and is known as a ['composed operation]. The program must ensure that the stream performs no other reads until this operation completes. The implementation may read additional bytes from the stream that lie past the end of the message being read. These additional bytes are stored in the dynamic buffer, which must be preserved for subsequent reads.
If the end of file error is received while reading from the stream, then the error returned from this function will be:

* [link beast.ref.boost__beast__http__error `http::end_of_stream`] if no bytes were parsed, or


* [link beast.ref.boost__beast__http__error `http::partial_message`] if any bytes were parsed but the message was incomplete, otherwise:


* A successful result. The next attempt to read will return [link beast.ref.boost__beast__http__error `http::end_of_stream`]

[heading Parameters][table [[Name][Description]]  [[`stream`][    
The stream from which the data is to be read. The type must meet the ['AsyncReadStream] requirements.  ]]  [[`buffer`][    
Storage for additional bytes read by the implementation from the stream. This is both an input and an output parameter; on entry, the parser will be presented with any remaining data in the dynamic buffer's readable bytes sequence first. The type must meet the ['DynamicBuffer] requirements. The object must remain valid at least until the handler is called; ownership is not transferred.  ]]  [[`parser`][    
The parser to use. The object must remain valid at least until the handler is called; ownership is not transferred.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      error_code const& error,        // result of operation
      std::size_t bytes_transferred   // the total number of bytes transferred from the stream
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.  ]]]
[heading Remarks]
The completion handler will receive as a parameter the total number of bytes transferred from the stream. This may be zero for the case where there is sufficient pre-existing message data in the dynamic buffer. The implementation will call [link beast.ref.boost__beast__http__basic_parser.eager `http::basic_parser::eager`] with the value `true` on the parser passed in. 
Convenience header [include_file boost/beast/http.hpp][endsect][section:overload2 http::async_read (2 of 2 overloads)]
Read a complete message asynchronously from a stream. [heading Synopsis]Defined in header [include_file boost/beast/http/read.hpp]```template<    class __AsyncReadStream__,    class __DynamicBuffer__,    bool isRequest,    class __Body__,    class __Allocator__,    class __ReadHandler__>``__deduced__``async_read(    AsyncReadStream& stream,    DynamicBuffer& buffer,    message< isRequest, Body, basic_fields< Allocator >>& msg,    ReadHandler&& handler);```[heading Description]
This function is used to asynchronously read a complete message from a stream into an instance of [link beast.ref.boost__beast__http__message `http::message`]. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:

* The entire message is read in.


* An error occurs.

This operation is implemented in terms of zero or more calls to the next layer's `async_read_some` function, and is known as a ['composed operation]. The program must ensure that the stream performs no other reads until this operation completes. The implementation may read additional bytes from the stream that lie past the end of the message being read. These additional bytes are stored in the dynamic buffer, which must be preserved for subsequent reads.
If the end of file error is received while reading from the stream, then the error returned from this function will be:

* [link beast.ref.boost__beast__http__error `http::end_of_stream`] if no bytes were parsed, or


* [link beast.ref.boost__beast__http__error `http::partial_message`] if any bytes were parsed but the message was incomplete, otherwise:


* A successful result. The next attempt to read will return [link beast.ref.boost__beast__http__error `http::end_of_stream`]

[heading Parameters][table [[Name][Description]]  [[`stream`][    
The stream from which the data is to be read. The type must meet the ['AsyncReadStream] requirements.  ]]  [[`buffer`][    
Storage for additional bytes read by the implementation from the stream. This is both an input and an output parameter; on entry, the parser will be presented with any remaining data in the dynamic buffer's readable bytes sequence first. The type must meet the ['DynamicBuffer] requirements. The object must remain valid at least until the handler is called; ownership is not transferred.  ]]  [[`msg`][    
The container in which to store the message contents. This message container should not have previous contents, otherwise the behavior is undefined. The type must be meet the ['MoveAssignable] and ['MoveConstructible] requirements. The object must remain valid at least until the handler is called; ownership is not transferred.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      error_code const& error,        // result of operation
      std::size_t bytes_transferred   // the total number of bytes transferred from the stream
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.  ]]]
[heading Remarks]
The completion handler will receive as a parameter the total number of bytes transferred from the stream. This may be zero for the case where there is sufficient pre-existing message data in the dynamic buffer. The implementation will call [link beast.ref.boost__beast__http__basic_parser.eager `http::basic_parser::eager`] with the value `true` on the parser passed in. 
Convenience header [include_file boost/beast/http.hpp][endsect][endsect][section:boost__beast__http__async_read_header http::async_read_header][indexterm1 http::async_read_header]
Read a complete message header asynchronously from a stream using a parser. [heading Synopsis]Defined in header [include_file boost/beast/http/read.hpp]```template<    class __AsyncReadStream__,    class __DynamicBuffer__,    bool isRequest,    class __ReadHandler__>``__deduced__``async_read_header(    AsyncReadStream& stream,    DynamicBuffer& buffer,    basic_parser< isRequest >& parser,    ReadHandler&& handler);```[heading Description]
This function is used to asynchronously read a complete message header from a stream into an instance of [link beast.ref.boost__beast__http__basic_parser `http::basic_parser`]. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:

* [link beast.ref.boost__beast__http__basic_parser.is_header_done `http::basic_parser::is_header_done`] returns `true`


* An error occurs.

This operation is implemented in terms of zero or more calls to the next layer's `async_read_some` function, and is known as a ['composed operation]. The program must ensure that the stream performs no other reads until this operation completes. The implementation may read additional bytes from the stream that lie past the end of the message being read. These additional bytes are stored in the dynamic buffer, which must be preserved for subsequent reads.
If the end of file error is received while reading from the stream, then the error returned from this function will be:

* [link beast.ref.boost__beast__http__error `http::end_of_stream`] if no bytes were parsed, or


* [link beast.ref.boost__beast__http__error `http::partial_message`] if any bytes were parsed but the message was incomplete, otherwise:


* A successful result. The next attempt to read will return [link beast.ref.boost__beast__http__error `http::end_of_stream`]

[heading Parameters][table [[Name][Description]]  [[`stream`][    
The stream from which the data is to be read. The type must meet the ['AsyncReadStream] requirements.  ]]  [[`buffer`][    
Storage for additional bytes read by the implementation from the stream. This is both an input and an output parameter; on entry, the parser will be presented with any remaining data in the dynamic buffer's readable bytes sequence first. The type must meet the ['DynamicBuffer] requirements. The object must remain valid at least until the handler is called; ownership is not transferred.  ]]  [[`parser`][    
The parser to use. The object must remain valid at least until the handler is called; ownership is not transferred.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      error_code const& error,        // result of operation
      std::size_t bytes_transferred   // the total number of bytes transferred from the stream
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.  ]]]
[heading Remarks]
The completion handler will receive as a parameter the total number of bytes transferred from the stream. This may be zero for the case where there is sufficient pre-existing message data in the dynamic buffer. The implementation will call [link beast.ref.boost__beast__http__basic_parser.eager `http::basic_parser::eager`] with the value `false` on the parser passed in. 
Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__async_read_some http::async_read_some][indexterm1 http::async_read_some]
Read part of a message asynchronously from a stream using a parser. [heading Synopsis]Defined in header [include_file boost/beast/http/read.hpp]```template<    class __AsyncReadStream__,    class __DynamicBuffer__,    bool isRequest,    class __ReadHandler__>``__deduced__``async_read_some(    AsyncReadStream& stream,    DynamicBuffer& buffer,    basic_parser< isRequest >& parser,    ReadHandler&& handler);```[heading Description]
This function is used to asynchronously read part of a message from a stream into an instance of [link beast.ref.boost__beast__http__basic_parser `http::basic_parser`]. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:

* A call to [link beast.ref.boost__beast__http__basic_parser.put `http::basic_parser::put`] with a non-empty buffer sequence is successful.


* An error occurs.

This operation is implemented in terms of zero or more calls to the next layer's `async_read_some` function, and is known as a ['composed operation]. The program must ensure that the stream performs no other reads until this operation completes. The implementation may read additional bytes from the stream that lie past the end of the message being read. These additional bytes are stored in the dynamic buffer, which must be preserved for subsequent reads.
If the end of file error is received while reading from the stream, then the error returned from this function will be:

* [link beast.ref.boost__beast__http__error `http::end_of_stream`] if no bytes were parsed, or


* [link beast.ref.boost__beast__http__error `http::partial_message`] if any bytes were parsed but the message was incomplete, otherwise:


* A successful result. The next attempt to read will return [link beast.ref.boost__beast__http__error `http::end_of_stream`]

[heading Parameters][table [[Name][Description]]  [[`stream`][    
The stream from which the data is to be read. The type must meet the ['AsyncReadStream] requirements.  ]]  [[`buffer`][    
Storage for additional bytes read by the implementation from the stream. This is both an input and an output parameter; on entry, the parser will be presented with any remaining data in the dynamic buffer's readable bytes sequence first. The type must meet the ['DynamicBuffer] requirements. The object must remain valid at least until the handler is called; ownership is not transferred.  ]]  [[`parser`][    
The parser to use. The object must remain valid at least until the handler is called; ownership is not transferred.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      error_code const& error,        // result of operation
      std::size_t bytes_transferred   // the total number of bytes transferred from the stream
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.  ]]]
[heading Remarks]
The completion handler will receive as a parameter the total number of bytes transferred from the stream. This may be zero for the case where there is sufficient pre-existing message data in the dynamic buffer. 
Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__async_write http::async_write][indexterm1 http::async_write]
Write a complete message to a stream asynchronously using a serializer. ```template<    class __AsyncWriteStream__,    bool isRequest,    class __Body__,    class __Fields__,    class __WriteHandler__>``__deduced__````[link beast.ref.boost__beast__http__async_write.overload1 async_write]``(    AsyncWriteStream& stream,    serializer< isRequest, Body, Fields >& sr,    WriteHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__async_write.overload1 more...]]`````
Write a complete message to a stream asynchronously. ```template<    class __AsyncWriteStream__,    bool isRequest,    class __Body__,    class __Fields__,    class __WriteHandler__>``__deduced__````[link beast.ref.boost__beast__http__async_write.overload2 async_write]``(    AsyncWriteStream& stream,    message< isRequest, Body, Fields >& msg,    WriteHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__async_write.overload2 more...]]``template<    class __AsyncWriteStream__,    bool isRequest,    class __Body__,    class __Fields__,    class __WriteHandler__>``__deduced__````[link beast.ref.boost__beast__http__async_write.overload3 async_write]``(    AsyncWriteStream& stream,    message< isRequest, Body, Fields > const& msg,    WriteHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__async_write.overload3 more...]]`````[section:overload1 http::async_write (1 of 3 overloads)]
Write a complete message to a stream asynchronously using a serializer. [heading Synopsis]Defined in header [include_file boost/beast/http/write.hpp]```template<    class __AsyncWriteStream__,    bool isRequest,    class __Body__,    class __Fields__,    class __WriteHandler__>``__deduced__``async_write(    AsyncWriteStream& stream,    serializer< isRequest, Body, Fields >& sr,    WriteHandler&& handler);```[heading Description]
This function is used to write a complete message to a stream asynchronously using a caller-provided HTTP/1 serializer. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:

* The function [link beast.ref.boost__beast__http__serializer.is_done `http::serializer::is_done`] returns `true`


* An error occurs.

This operation is implemented in terms of zero or more calls to the stream's `async_write_some` function, and is known as a ['composed operation]. The program must ensure that the stream performs no other writes until this operation completes.
[heading Parameters][table [[Name][Description]]  [[`stream`][    
The stream to which the data is to be written. The type must support the ['AsyncWriteStream] concept.  ]]  [[`sr`][    
The serializer to use. The object must remain valid at least until the handler is called; ownership is not transferred.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      error_code const& error,        // result of operation
      std::size_t bytes_transferred   // the number of bytes written to the stream
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.  ]]]
[heading See Also]
[link beast.ref.boost__beast__http__serializer `http::serializer`] 
Convenience header [include_file boost/beast/http.hpp][endsect][section:overload2 http::async_write (2 of 3 overloads)]
Write a complete message to a stream asynchronously. [heading Synopsis]Defined in header [include_file boost/beast/http/write.hpp]```template<    class __AsyncWriteStream__,    bool isRequest,    class __Body__,    class __Fields__,    class __WriteHandler__>``__deduced__``async_write(    AsyncWriteStream& stream,    message< isRequest, Body, Fields >& msg,    WriteHandler&& handler);```[heading Description]
This function is used to write a complete message to a stream asynchronously using HTTP/1. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:

* The entire message is written.


* An error occurs.

This operation is implemented in terms of zero or more calls to the stream's `async_write_some` function, and is known as a ['composed operation]. The program must ensure that the stream performs no other writes until this operation completes. The algorithm will use a temporary [link beast.ref.boost__beast__http__serializer `http::serializer`] with an empty chunk decorator to produce buffers.
[heading Remarks]
This function only participates in overload resolution if [link beast.ref.boost__beast__http__is_mutable_body_writer `http::is_mutable_body_writer`] for ['Body] returns `true`.
[heading Parameters][table [[Name][Description]]  [[`stream`][    
The stream to which the data is to be written. The type must support the ['AsyncWriteStream] concept.  ]]  [[`msg`][    
The message to write. The object must remain valid at least until the handler is called; ownership is not transferred.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      error_code const& error,        // result of operation
      std::size_t bytes_transferred   // the number of bytes written to the stream
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.  ]]]
[heading See Also]
[link beast.ref.boost__beast__http__message `http::message`] 
Convenience header [include_file boost/beast/http.hpp][endsect][section:overload3 http::async_write (3 of 3 overloads)]
Write a complete message to a stream asynchronously. [heading Synopsis]Defined in header [include_file boost/beast/http/write.hpp]```template<    class __AsyncWriteStream__,    bool isRequest,    class __Body__,    class __Fields__,    class __WriteHandler__>``__deduced__``async_write(    AsyncWriteStream& stream,    message< isRequest, Body, Fields > const& msg,    WriteHandler&& handler);```[heading Description]
This function is used to write a complete message to a stream asynchronously using HTTP/1. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:

* The entire message is written.


* An error occurs.

This operation is implemented in terms of zero or more calls to the stream's `async_write_some` function, and is known as a ['composed operation]. The program must ensure that the stream performs no other writes until this operation completes. The algorithm will use a temporary [link beast.ref.boost__beast__http__serializer `http::serializer`] with an empty chunk decorator to produce buffers.
[heading Remarks]
This function only participates in overload resolution if [link beast.ref.boost__beast__http__is_mutable_body_writer `http::is_mutable_body_writer`] for ['Body] returns `false`.
[heading Parameters][table [[Name][Description]]  [[`stream`][    
The stream to which the data is to be written. The type must support the ['AsyncWriteStream] concept.  ]]  [[`msg`][    
The message to write. The object must remain valid at least until the handler is called; ownership is not transferred.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      error_code const& error,        // result of operation
      std::size_t bytes_transferred   // the number of bytes written to the stream
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.  ]]]
[heading See Also]
[link beast.ref.boost__beast__http__message `http::message`] 
Convenience header [include_file boost/beast/http.hpp][endsect][endsect][section:boost__beast__http__async_write_header http::async_write_header][indexterm1 http::async_write_header]
Write a header to a stream asynchronously using a serializer. [heading Synopsis]Defined in header [include_file boost/beast/http/write.hpp]```template<    class __AsyncWriteStream__,    bool isRequest,    class __Body__,    class __Fields__,    class __WriteHandler__>``__deduced__``async_write_header(    AsyncWriteStream& stream,    serializer< isRequest, Body, Fields >& sr,    WriteHandler&& handler);```[heading Description]
This function is used to write a header to a stream asynchronously using a caller-provided HTTP/1 serializer. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:

* The function [link beast.ref.boost__beast__http__serializer.is_header_done `http::serializer::is_header_done`] returns `true`


* An error occurs.

This operation is implemented in terms of zero or more calls to the stream's `async_write_some` function, and is known as a ['composed operation]. The program must ensure that the stream performs no other writes until this operation completes.
[heading Parameters][table [[Name][Description]]  [[`stream`][    
The stream to which the data is to be written. The type must support the ['AsyncWriteStream] concept.  ]]  [[`sr`][    
The serializer to use. The object must remain valid at least until the handler is called; ownership is not transferred.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      error_code const& error,        // result of operation
      std::size_t bytes_transferred   // the number of bytes written to the stream
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.  ]]]
[heading Remarks]
The implementation will call [link beast.ref.boost__beast__http__serializer.split `http::serializer::split`] with the value `true` on the serializer passed in.
[heading See Also]
[link beast.ref.boost__beast__http__serializer `http::serializer`] 
Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__async_write_some http::async_write_some][indexterm1 http::async_write_some]
Write part of a message to a stream asynchronously using a serializer. [heading Synopsis]Defined in header [include_file boost/beast/http/write.hpp]```template<    class __AsyncWriteStream__,    bool isRequest,    class __Body__,    class __Fields__,    class __WriteHandler__>``__deduced__``async_write_some(    AsyncWriteStream& stream,    serializer< isRequest, Body, Fields >& sr,    WriteHandler&& handler);```[heading Description]
This function is used to write part of a message to a stream asynchronously using a caller-provided HTTP/1 serializer. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:

* One or more bytes have been transferred.


* The function [link beast.ref.boost__beast__http__serializer.is_done `http::serializer::is_done`] returns `true`


* An error occurs on the stream.

This operation is implemented in terms of zero or more calls to the stream's `async_write_some` function, and is known as a ['composed operation]. The program must ensure that the stream performs no other writes until this operation completes.
The amount of data actually transferred is controlled by the behavior of the underlying stream, subject to the buffer size limit of the serializer obtained or set through a call to [link beast.ref.boost__beast__http__serializer.limit `http::serializer::limit`]. Setting a limit and performing bounded work helps applications set reasonable timeouts. It also allows application-level flow control to function correctly. For example when using a TCP/IP based stream.
[heading Parameters][table [[Name][Description]]  [[`stream`][    
The stream to which the data is to be written. The type must support the ['AsyncWriteStream] concept.  ]]  [[`sr`][    
The serializer to use. The object must remain valid at least until the handler is called; ownership is not transferred.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      error_code const& error,        // result of operation
      std::size_t bytes_transferred   // the number of bytes written to the stream
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.  ]]]
[heading See Also]
[link beast.ref.boost__beast__http__serializer `http::serializer`] 
Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__basic_chunk_extensions http::basic_chunk_extensions]
A set of chunk extensions. [heading Synopsis]Defined in header [include_file boost/beast/http/chunk_encode.hpp]```template<    class __Allocator__>class basic_chunk_extensions```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_chunk_extensions.value_type [*value_type]]]    [      The type of value when iterating.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_chunk_extensions.basic_chunk_extensions [*basic_chunk_extensions]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_chunk_extensions.begin [*begin]]]    [          ]  ]  [    [[link beast.ref.boost__beast__http__basic_chunk_extensions.clear [*clear]]]    [      Clear the chunk extensions.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_chunk_extensions.end [*end]]]    [          ]  ]  [    [[link beast.ref.boost__beast__http__basic_chunk_extensions.insert [*insert]]]    [      Insert an extension name with an empty value.       Insert an extension value.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_chunk_extensions.parse [*parse]]]    [      Parse a set of chunk extensions.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_chunk_extensions.str [*str]]]    [      Return the serialized representation of the chunk extension.     ]  ]][heading Description]
This container stores a set of chunk extensions suited for use with [link beast.ref.boost__beast__http__chunk_header `http::chunk_header`] and [link beast.ref.boost__beast__http__chunk_body `http::chunk_body`]. The container may be iterated to access the extensions in their structured form.
Meets the requirements of ChunkExtensions [section:basic_chunk_extensions http::basic_chunk_extensions::basic_chunk_extensions][indexterm2 basic_chunk_extensions..http::basic_chunk_extensions]
Constructor. `````[link beast.ref.boost__beast__http__basic_chunk_extensions.basic_chunk_extensions.overload1 basic_chunk_extensions]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_chunk_extensions.basic_chunk_extensions.overload1 more...]]````[link beast.ref.boost__beast__http__basic_chunk_extensions.basic_chunk_extensions.overload2 basic_chunk_extensions]``(    basic_chunk_extensions&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_chunk_extensions.basic_chunk_extensions.overload2 more...]]````[link beast.ref.boost__beast__http__basic_chunk_extensions.basic_chunk_extensions.overload3 basic_chunk_extensions]``(    basic_chunk_extensions const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_chunk_extensions.basic_chunk_extensions.overload3 more...]]``explicit``[link beast.ref.boost__beast__http__basic_chunk_extensions.basic_chunk_extensions.overload4 basic_chunk_extensions]``(    Allocator const& allocator);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_chunk_extensions.basic_chunk_extensions.overload4 more...]]`````[section:overload1 http::basic_chunk_extensions::basic_chunk_extensions (1 of 4 overloads)]
Constructor. [heading Synopsis]```basic_chunk_extensions();```[heading Description][endsect][section:overload2 http::basic_chunk_extensions::basic_chunk_extensions (2 of 4 overloads)]
Constructor. [heading Synopsis]```basic_chunk_extensions(    basic_chunk_extensions&&);```[heading Description][endsect][section:overload3 http::basic_chunk_extensions::basic_chunk_extensions (3 of 4 overloads)]
Constructor. [heading Synopsis]```basic_chunk_extensions(    basic_chunk_extensions const&);```[heading Description][endsect][section:overload4 http::basic_chunk_extensions::basic_chunk_extensions (4 of 4 overloads)]
Constructor. [heading Synopsis]```basic_chunk_extensions(    Allocator const& allocator);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`allocator`][    
The allocator to use for storing the serialized extension   ]]]
[endsect][endsect][section:begin http::basic_chunk_extensions::begin][indexterm2 begin..http::basic_chunk_extensions][heading Synopsis]```const_iteratorbegin() const;```[heading Description][endsect][section:clear http::basic_chunk_extensions::clear][indexterm2 clear..http::basic_chunk_extensions]
Clear the chunk extensions. [heading Synopsis]```voidclear();```[heading Description]
This preserves the capacity of the internal string used to hold the serialized representation. [endsect][section:end http::basic_chunk_extensions::end][indexterm2 end..http::basic_chunk_extensions][heading Synopsis]```const_iteratorend() const;```[heading Description][endsect][section:insert http::basic_chunk_extensions::insert][indexterm2 insert..http::basic_chunk_extensions]
Insert an extension name with an empty value. ```void``[link beast.ref.boost__beast__http__basic_chunk_extensions.insert.overload1 insert]``(    string_view name);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_chunk_extensions.insert.overload1 more...]]`````
Insert an extension value. ```void``[link beast.ref.boost__beast__http__basic_chunk_extensions.insert.overload2 insert]``(    string_view name,    string_view value);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_chunk_extensions.insert.overload2 more...]]`````[section:overload1 http::basic_chunk_extensions::insert (1 of 2 overloads)]
Insert an extension name with an empty value. [heading Synopsis]```voidinsert(    string_view name);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`name`][    
The name of the extension   ]]]
[endsect][section:overload2 http::basic_chunk_extensions::insert (2 of 2 overloads)]
Insert an extension value. [heading Synopsis]```voidinsert(    string_view name,    string_view value);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`name`][    
The name of the extension  ]]  [[`value`][    
The value to insert. Depending on the contents, the serialized extension may use a quoted string.   ]]]
[endsect][endsect][section:parse http::basic_chunk_extensions::parse][indexterm2 parse..http::basic_chunk_extensions]
Parse a set of chunk extensions. [heading Synopsis]```voidparse(    string_view s,    error_code& ec);```[heading Description]
Any previous extensions will be cleared [endsect][section:str http::basic_chunk_extensions::str][indexterm2 str..http::basic_chunk_extensions]
Return the serialized representation of the chunk extension. [heading Synopsis]```string_viewstr() const;```[heading Description][endsect][section:value_type http::basic_chunk_extensions::value_type][indexterm2 value_type..http::basic_chunk_extensions]
The type of value when iterating. [heading Synopsis]```using value_type = std::pair< string_view, string_view >;```[heading Description]
The first element of the pair is the name, and the second element is the value which may be empty. The value is stored in its raw representation, without quotes or escapes. [endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__basic_dynamic_body http::basic_dynamic_body]
A ['Body] using a ['DynamicBuffer] [heading Synopsis]Defined in header [include_file boost/beast/http/basic_dynamic_body.hpp]```template<    class __DynamicBuffer__>struct basic_dynamic_body```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_dynamic_body.reader [*reader]]]    [      The algorithm for parsing the body.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_dynamic_body.value_type [*value_type]]]    [      The type of container used for the body.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_dynamic_body.writer [*writer]]]    [      The algorithm for serializing the body.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_dynamic_body.size [*size]]]    [      Returns the payload size of the body.     ]  ]][heading Description]
This body uses a ['DynamicBuffer] as a memory-based container for holding message payloads. Messages using this body type may be serialized and parsed. [section:reader http::basic_dynamic_body::reader][indexterm2 reader..http::basic_dynamic_body]
The algorithm for parsing the body. [heading Synopsis]```using reader = ``['implementation-defined]``;```[heading Description]
Meets the requirements of ['BodyReader]. [endsect][section:size http::basic_dynamic_body::size][indexterm2 size..http::basic_dynamic_body]
Returns the payload size of the body. [heading Synopsis]```staticstd::uint64_tsize(    value_type const& v);```[heading Description]
When this body is used with [link beast.ref.boost__beast__http__message.prepare_payload `http::message::prepare_payload`], the Content-Length will be set to the payload size, and any chunked Transfer-Encoding will be removed. [endsect][section:value_type http::basic_dynamic_body::value_type][indexterm2 value_type..http::basic_dynamic_body]
The type of container used for the body. [heading Synopsis]```using value_type = DynamicBuffer;```[heading Description]
This determines the type of [link beast.ref.boost__beast__http__message.body `http::message::body`] when this body type is used with a message container. [endsect][section:writer http::basic_dynamic_body::writer][indexterm2 writer..http::basic_dynamic_body]
The algorithm for serializing the body. [heading Synopsis]```using writer = ``['implementation-defined]``;```[heading Description]
Meets the requirements of ['BodyWriter]. [endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__basic_fields http::basic_fields]
A container for storing HTTP header fields. [heading Synopsis]Defined in header [include_file boost/beast/http/fields.hpp]```template<    class __Allocator__>class basic_fields```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_fields.allocator_type [*allocator_type]]]    [      The type of allocator used.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields__value_type [*value_type]]]    [      The type of element used to represent a field.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.const_iterator [*const_iterator]]]    [      A constant iterator to the field sequence.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.iterator [*iterator]]]    [      A constant iterator to the field sequence.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.key_compare [*key_compare]]]    [      A strictly less predicate for comparing keys, using a case-insensitive comparison.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.writer [*writer]]]    [      The algorithm used to serialize the header.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_fields.at [*at]]]    [      Returns the value for a field, or throws an exception.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.basic_fields [*basic_fields]]]    [      Constructor.       Move constructor.       Copy constructor.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.begin [*begin]]]    [      Return a const iterator to the beginning of the field sequence.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.cbegin [*cbegin]]]    [      Return a const iterator to the beginning of the field sequence.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.cend [*cend]]]    [      Return a const iterator to the end of the field sequence.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.clear [*clear]]]    [      Remove all fields from the container.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.count [*count]]]    [      Return the number of fields with the specified name.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.end [*end]]]    [      Return a const iterator to the end of the field sequence.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.equal_range [*equal_range]]]    [      Returns a range of iterators to the fields with the specified name.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.erase [*erase]]]    [      Remove a field.       Remove all fields with the specified name.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.find [*find]]]    [      Returns an iterator to the case-insensitive matching field.       Returns an iterator to the case-insensitive matching field name.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.get_allocator [*get_allocator]]]    [      Return a copy of the allocator associated with the container.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.insert [*insert]]]    [      Insert a field.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.key_comp [*key_comp]]]    [      Returns a copy of the key comparison function.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.operator_eq_ [*operator=]]]    [      Move assignment.       Copy assignment.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.operator_lb__rb_ [*operator\[\]]]]    [      Returns the value for a field, or "" if it does not exist.       Returns the value for a case-insensitive matching header, or "" if it does not exist.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.set [*set]]]    [      Set a field value, removing any other instances of that field.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.swap [*swap]]]    [      Return a buffer sequence representing the trailers.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.basic_fields_dtor_ [*~basic_fields]]]    [      Destructor.     ]  ]][heading Protected Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_fields.get_chunked_impl [*get_chunked_impl]]]    [      Returns the chunked Transfer-Encoding setting.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.get_keep_alive_impl [*get_keep_alive_impl]]]    [      Returns the keep-alive setting.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.get_method_impl [*get_method_impl]]]    [      Returns the request-method string.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.get_reason_impl [*get_reason_impl]]]    [      Returns the response reason-phrase string.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.get_target_impl [*get_target_impl]]]    [      Returns the request-target string.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.has_content_length_impl [*has_content_length_impl]]]    [      Returns true if the Content-Length field is present.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.set_chunked_impl [*set_chunked_impl]]]    [      Adjusts the chunked Transfer-Encoding value.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.set_content_length_impl [*set_content_length_impl]]]    [      Sets or clears the Content-Length field.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.set_keep_alive_impl [*set_keep_alive_impl]]]    [      Adjusts the Connection field.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.set_method_impl [*set_method_impl]]]    [      Set or clear the method string.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.set_reason_impl [*set_reason_impl]]]    [      Set or clear the reason string.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.set_target_impl [*set_target_impl]]]    [      Set or clear the target string.     ]  ]][heading Friends][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_fields.swap [*swap]]]    [      Swap two field containers.     ]  ]][heading Description]
This container is designed to store the field value pairs that make up the fields and trailers in an HTTP message. Objects of this type are iterable, with each element holding the field name and field value.
Field names are stored as-is, but comparisons are case-insensitive. The container behaves as a `std::multiset`; there will be a separate value for each occurrence of the same field name. When the container is iterated the fields are presented in the order of insertion, with fields having the same name following each other consecutively.
Meets the requirements of ['Fields]
[heading Template Parameters][table [[Type][Description]]  [[`Allocator`][    
The allocator to use.   ]]]
[section:allocator_type http::basic_fields::allocator_type][indexterm2 allocator_type..http::basic_fields]
The type of allocator used. [heading Synopsis]```using allocator_type = Allocator;```[heading Description][endsect][section:at http::basic_fields::at][indexterm2 at..http::basic_fields]
Returns the value for a field, or throws an exception. ```string_view const``[link beast.ref.boost__beast__http__basic_fields.at.overload1 at]``(    field name) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.at.overload1 more...]]``string_view const``[link beast.ref.boost__beast__http__basic_fields.at.overload2 at]``(    string_view name) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.at.overload2 more...]]`````[section:overload1 http::basic_fields::at (1 of 2 overloads)]
Returns the value for a field, or throws an exception. [heading Synopsis]```string_view constat(    field name) const;```[heading Description]
If more than one field with the specified name exists, the first field defined by insertion order is returned.
[heading Parameters][table [[Name][Description]]  [[`name`][    
The name of the field.  ]]]
[heading Return Value]
The field value.
[heading Exceptions][table [[Type][Thrown On]]  [[`std::out_of_range`][    
if the field is not found.   ]]]
[endsect][section:overload2 http::basic_fields::at (2 of 2 overloads)]
Returns the value for a field, or throws an exception. [heading Synopsis]```string_view constat(    string_view name) const;```[heading Description]
If more than one field with the specified name exists, the first field defined by insertion order is returned.
[heading Parameters][table [[Name][Description]]  [[`name`][    
The name of the field.  ]]]
[heading Return Value]
The field value.
[heading Exceptions][table [[Type][Thrown On]]  [[`std::out_of_range`][    
if the field is not found.   ]]]
[endsect][endsect][section:basic_fields http::basic_fields::basic_fields][indexterm2 basic_fields..http::basic_fields]
Constructor. `````[link beast.ref.boost__beast__http__basic_fields.basic_fields.overload1 basic_fields]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.basic_fields.overload1 more...]]``explicit``[link beast.ref.boost__beast__http__basic_fields.basic_fields.overload2 basic_fields]``(    Allocator const& alloc);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.basic_fields.overload2 more...]]`````
Move constructor. `````[link beast.ref.boost__beast__http__basic_fields.basic_fields.overload3 basic_fields]``(    basic_fields&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.basic_fields.overload3 more...]]````[link beast.ref.boost__beast__http__basic_fields.basic_fields.overload4 basic_fields]``(    basic_fields&&,    Allocator const& alloc);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.basic_fields.overload4 more...]]`````
Copy constructor. `````[link beast.ref.boost__beast__http__basic_fields.basic_fields.overload5 basic_fields]``(    basic_fields const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.basic_fields.overload5 more...]]````[link beast.ref.boost__beast__http__basic_fields.basic_fields.overload6 basic_fields]``(    basic_fields const&,    Allocator const& alloc);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.basic_fields.overload6 more...]]``template<    class OtherAlloc>``[link beast.ref.boost__beast__http__basic_fields.basic_fields.overload7 basic_fields]``(    basic_fields< OtherAlloc > const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.basic_fields.overload7 more...]]``template<    class OtherAlloc>``[link beast.ref.boost__beast__http__basic_fields.basic_fields.overload8 basic_fields]``(    basic_fields< OtherAlloc > const&,    Allocator const& alloc);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.basic_fields.overload8 more...]]`````[section:overload1 http::basic_fields::basic_fields (1 of 8 overloads)]
Constructor. [heading Synopsis]```basic_fields();```[heading Description][endsect][section:overload2 http::basic_fields::basic_fields (2 of 8 overloads)]
Constructor. [heading Synopsis]```basic_fields(    Allocator const& alloc);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`alloc`][    
The allocator to use.   ]]]
[endsect][section:overload3 http::basic_fields::basic_fields (3 of 8 overloads)]
Move constructor. [heading Synopsis]```basic_fields(    basic_fields&&);```[heading Description]
The state of the moved-from object is as if constructed using the same allocator. [endsect][section:overload4 http::basic_fields::basic_fields (4 of 8 overloads)]
Move constructor. [heading Synopsis]```basic_fields(    basic_fields&&,    Allocator const& alloc);```[heading Description]
The state of the moved-from object is as if constructed using the same allocator.
[heading Parameters][table [[Name][Description]]  [[`alloc`][    
The allocator to use.   ]]]
[endsect][section:overload5 http::basic_fields::basic_fields (5 of 8 overloads)]
Copy constructor. [heading Synopsis]```basic_fields(    basic_fields const&);```[heading Description][endsect][section:overload6 http::basic_fields::basic_fields (6 of 8 overloads)]
Copy constructor. [heading Synopsis]```basic_fields(    basic_fields const&,    Allocator const& alloc);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`alloc`][    
The allocator to use.   ]]]
[endsect][section:overload7 http::basic_fields::basic_fields (7 of 8 overloads)]
Copy constructor. [heading Synopsis]```template<    class OtherAlloc>basic_fields(    basic_fields< OtherAlloc > const&);```[heading Description][endsect][section:overload8 http::basic_fields::basic_fields (8 of 8 overloads)]
Copy constructor. [heading Synopsis]```template<    class OtherAlloc>basic_fields(    basic_fields< OtherAlloc > const&,    Allocator const& alloc);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`alloc`][    
The allocator to use.   ]]]
[endsect][endsect][section:begin http::basic_fields::begin][indexterm2 begin..http::basic_fields]
Return a const iterator to the beginning of the field sequence. [heading Synopsis]```const_iteratorbegin() const;```[heading Description][endsect][section:cbegin http::basic_fields::cbegin][indexterm2 cbegin..http::basic_fields]
Return a const iterator to the beginning of the field sequence. [heading Synopsis]```const_iteratorcbegin() const;```[heading Description][endsect][section:cend http::basic_fields::cend][indexterm2 cend..http::basic_fields]
Return a const iterator to the end of the field sequence. [heading Synopsis]```const_iteratorcend() const;```[heading Description][endsect][section:clear http::basic_fields::clear][indexterm2 clear..http::basic_fields]
Remove all fields from the container. [heading Synopsis]```voidclear();```[heading Description]
All references, pointers, or iterators referring to contained elements are invalidated. All past-the-end iterators are also invalidated.
[heading Postconditions:]
```  std::distance(this->begin(), this->end()) == 0
```
[endsect][section:const_iterator http::basic_fields::const_iterator][indexterm2 const_iterator..http::basic_fields]
A constant iterator to the field sequence. [heading Synopsis]```using const_iterator = ``['implementation-defined]``;```[heading Description][endsect][section:count http::basic_fields::count][indexterm2 count..http::basic_fields]
Return the number of fields with the specified name. ```std::size_t``[link beast.ref.boost__beast__http__basic_fields.count.overload1 count]``(    field name) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.count.overload1 more...]]``std::size_t``[link beast.ref.boost__beast__http__basic_fields.count.overload2 count]``(    string_view name) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.count.overload2 more...]]`````[section:overload1 http::basic_fields::count (1 of 2 overloads)]
Return the number of fields with the specified name. [heading Synopsis]```std::size_tcount(    field name) const;```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`name`][    
The field name.   ]]]
[endsect][section:overload2 http::basic_fields::count (2 of 2 overloads)]
Return the number of fields with the specified name. [heading Synopsis]```std::size_tcount(    string_view name) const;```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`name`][    
The field name.   ]]]
[endsect][endsect][section:end http::basic_fields::end][indexterm2 end..http::basic_fields]
Return a const iterator to the end of the field sequence. [heading Synopsis]```const_iteratorend() const;```[heading Description][endsect][section:equal_range http::basic_fields::equal_range][indexterm2 equal_range..http::basic_fields]
Returns a range of iterators to the fields with the specified name. ```std::pair< const_iterator, const_iterator >``[link beast.ref.boost__beast__http__basic_fields.equal_range.overload1 equal_range]``(    field name) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.equal_range.overload1 more...]]``std::pair< const_iterator, const_iterator >``[link beast.ref.boost__beast__http__basic_fields.equal_range.overload2 equal_range]``(    string_view name) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.equal_range.overload2 more...]]`````[section:overload1 http::basic_fields::equal_range (1 of 2 overloads)]
Returns a range of iterators to the fields with the specified name. [heading Synopsis]```std::pair< const_iterator, const_iterator >equal_range(    field name) const;```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`name`][    
The field name.  ]]]
[heading Return Value]
A range of iterators to fields with the same name, otherwise an empty range. 
[endsect][section:overload2 http::basic_fields::equal_range (2 of 2 overloads)]
Returns a range of iterators to the fields with the specified name. [heading Synopsis]```std::pair< const_iterator, const_iterator >equal_range(    string_view name) const;```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`name`][    
The field name.  ]]]
[heading Return Value]
A range of iterators to fields with the same name, otherwise an empty range. 
[endsect][endsect][section:erase http::basic_fields::erase][indexterm2 erase..http::basic_fields]
Remove a field. ```const_iterator``[link beast.ref.boost__beast__http__basic_fields.erase.overload1 erase]``(    const_iterator pos);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.erase.overload1 more...]]`````
Remove all fields with the specified name. ```std::size_t``[link beast.ref.boost__beast__http__basic_fields.erase.overload2 erase]``(    field name);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.erase.overload2 more...]]``std::size_t``[link beast.ref.boost__beast__http__basic_fields.erase.overload3 erase]``(    string_view name);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.erase.overload3 more...]]`````[section:overload1 http::basic_fields::erase (1 of 3 overloads)]
Remove a field. [heading Synopsis]```const_iteratorerase(    const_iterator pos);```[heading Description]
References and iterators to the erased elements are invalidated. Other references and iterators are not affected.
[heading Parameters][table [[Name][Description]]  [[`pos`][    
An iterator to the element to remove.  ]]]
[heading Return Value]
An iterator following the last removed element. If the iterator refers to the last element, the [link beast.ref.boost__beast__http__basic_fields.end `http::basic_fields::end()`] iterator is returned. 
[endsect][section:overload2 http::basic_fields::erase (2 of 3 overloads)]
Remove all fields with the specified name. [heading Synopsis]```std::size_terase(    field name);```[heading Description]
All fields with the same field name are erased from the container. References and iterators to the erased elements are invalidated. Other references and iterators are not affected.
[heading Parameters][table [[Name][Description]]  [[`name`][    
The field name.  ]]]
[heading Return Value]
The number of fields removed. 
[endsect][section:overload3 http::basic_fields::erase (3 of 3 overloads)]
Remove all fields with the specified name. [heading Synopsis]```std::size_terase(    string_view name);```[heading Description]
All fields with the same field name are erased from the container. References and iterators to the erased elements are invalidated. Other references and iterators are not affected.
[heading Parameters][table [[Name][Description]]  [[`name`][    
The field name.  ]]]
[heading Return Value]
The number of fields removed. 
[endsect][endsect][section:find http::basic_fields::find][indexterm2 find..http::basic_fields]
Returns an iterator to the case-insensitive matching field. ```const_iterator``[link beast.ref.boost__beast__http__basic_fields.find.overload1 find]``(    field name) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.find.overload1 more...]]`````
Returns an iterator to the case-insensitive matching field name. ```const_iterator``[link beast.ref.boost__beast__http__basic_fields.find.overload2 find]``(    string_view name) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.find.overload2 more...]]`````[section:overload1 http::basic_fields::find (1 of 2 overloads)]
Returns an iterator to the case-insensitive matching field. [heading Synopsis]```const_iteratorfind(    field name) const;```[heading Description]
If more than one field with the specified name exists, the first field defined by insertion order is returned.
[heading Parameters][table [[Name][Description]]  [[`name`][    
The field name.  ]]]
[heading Return Value]
An iterator to the matching field, or `end()` if no match was found. 
[endsect][section:overload2 http::basic_fields::find (2 of 2 overloads)]
Returns an iterator to the case-insensitive matching field name. [heading Synopsis]```const_iteratorfind(    string_view name) const;```[heading Description]
If more than one field with the specified name exists, the first field defined by insertion order is returned.
[heading Parameters][table [[Name][Description]]  [[`name`][    
The field name.  ]]]
[heading Return Value]
An iterator to the matching field, or `end()` if no match was found. 
[endsect][endsect][section:get_allocator http::basic_fields::get_allocator][indexterm2 get_allocator..http::basic_fields]
Return a copy of the allocator associated with the container. [heading Synopsis]```allocator_typeget_allocator() const;```[heading Description][endsect][section:get_chunked_impl http::basic_fields::get_chunked_impl][indexterm2 get_chunked_impl..http::basic_fields]
Returns the chunked Transfer-Encoding setting. [heading Synopsis]```boolget_chunked_impl() const;```[heading Description][endsect][section:get_keep_alive_impl http::basic_fields::get_keep_alive_impl][indexterm2 get_keep_alive_impl..http::basic_fields]
Returns the keep-alive setting. [heading Synopsis]```boolget_keep_alive_impl(    unsigned version) const;```[heading Description][endsect][section:get_method_impl http::basic_fields::get_method_impl][indexterm2 get_method_impl..http::basic_fields]
Returns the request-method string. [heading Synopsis]```string_viewget_method_impl() const;```[heading Description]
[heading Remarks]
Only called for requests. 
[endsect][section:get_reason_impl http::basic_fields::get_reason_impl][indexterm2 get_reason_impl..http::basic_fields]
Returns the response reason-phrase string. [heading Synopsis]```string_viewget_reason_impl() const;```[heading Description]
[heading Remarks]
Only called for responses. 
[endsect][section:get_target_impl http::basic_fields::get_target_impl][indexterm2 get_target_impl..http::basic_fields]
Returns the request-target string. [heading Synopsis]```string_viewget_target_impl() const;```[heading Description]
[heading Remarks]
Only called for requests. 
[endsect][section:has_content_length_impl http::basic_fields::has_content_length_impl][indexterm2 has_content_length_impl..http::basic_fields]
Returns `true` if the Content-Length field is present. [heading Synopsis]```boolhas_content_length_impl() const;```[heading Description][endsect][section:insert http::basic_fields::insert][indexterm2 insert..http::basic_fields]
Insert a field. ```void``[link beast.ref.boost__beast__http__basic_fields.insert.overload1 insert]``(    field name,    string_param const& value);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.insert.overload1 more...]]``void``[link beast.ref.boost__beast__http__basic_fields.insert.overload2 insert]``(    string_view name,    string_param const& value);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.insert.overload2 more...]]``void``[link beast.ref.boost__beast__http__basic_fields.insert.overload3 insert]``(    field name,    string_view name_string,    string_param const& value);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.insert.overload3 more...]]`````[section:overload1 http::basic_fields::insert (1 of 3 overloads)]
Insert a field. [heading Synopsis]```voidinsert(    field name,    string_param const& value);```[heading Description]
If one or more fields with the same name already exist, the new field will be inserted after the last field with the matching name, in serialization order.
[heading Parameters][table [[Name][Description]]  [[`name`][    
The field name.  ]]  [[`value`][    
The value of the field, as a [link beast.ref.boost__beast__string_param `string_param`]   ]]]
[endsect][section:overload2 http::basic_fields::insert (2 of 3 overloads)]
Insert a field. [heading Synopsis]```voidinsert(    string_view name,    string_param const& value);```[heading Description]
If one or more fields with the same name already exist, the new field will be inserted after the last field with the matching name, in serialization order.
[heading Parameters][table [[Name][Description]]  [[`name`][    
The field name.  ]]  [[`value`][    
The value of the field, as a [link beast.ref.boost__beast__string_param `string_param`]   ]]]
[endsect][section:overload3 http::basic_fields::insert (3 of 3 overloads)]
Insert a field. [heading Synopsis]```voidinsert(    field name,    string_view name_string,    string_param const& value);```[heading Description]
If one or more fields with the same name already exist, the new field will be inserted after the last field with the matching name, in serialization order.
[heading Parameters][table [[Name][Description]]  [[`name`][    
The field name.  ]]  [[`name_string`][    
The literal text corresponding to the field name. If `name != field::unknown`, then this value must be equal to `to_string(name)` using a case-insensitive comparison, otherwise the behavior is undefined.  ]]  [[`value`][    
The value of the field, as a [link beast.ref.boost__beast__string_param `string_param`]   ]]]
[endsect][endsect][section:iterator http::basic_fields::iterator][indexterm2 iterator..http::basic_fields]
A constant iterator to the field sequence. [heading Synopsis]```using iterator = const_iterator;```[heading Description][endsect][section:key_comp http::basic_fields::key_comp][indexterm2 key_comp..http::basic_fields]
Returns a copy of the key comparison function. [heading Synopsis]```key_comparekey_comp() const;```[heading Description][endsect][section:key_compare http::basic_fields::key_compare][indexterm2 key_compare..http::basic_fields]
A strictly less predicate for comparing keys, using a case-insensitive comparison. [heading Synopsis]```using key_compare = ``['implementation-defined]``;```[heading Description]
The case-comparison operation is defined only for low-ASCII characters. [endsect][section:operator_eq_ http::basic_fields::operator=][indexterm2 operator=..http::basic_fields]
Move assignment. ```basic_fields&``[link beast.ref.boost__beast__http__basic_fields.operator_eq_.overload1 operator=]``(    basic_fields&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.operator_eq_.overload1 more...]]`````
Copy assignment. ```basic_fields&``[link beast.ref.boost__beast__http__basic_fields.operator_eq_.overload2 operator=]``(    basic_fields const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.operator_eq_.overload2 more...]]``template<    class OtherAlloc>basic_fields&``[link beast.ref.boost__beast__http__basic_fields.operator_eq_.overload3 operator=]``(    basic_fields< OtherAlloc > const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.operator_eq_.overload3 more...]]`````[section:overload1 http::basic_fields::operator= (1 of 3 overloads)]
Move assignment. [heading Synopsis]```basic_fields&operator=(    basic_fields&&);```[heading Description]
The state of the moved-from object is as if constructed using the same allocator. [endsect][section:overload2 http::basic_fields::operator= (2 of 3 overloads)]
Copy assignment. [heading Synopsis]```basic_fields&operator=(    basic_fields const&);```[heading Description][endsect][section:overload3 http::basic_fields::operator= (3 of 3 overloads)]
Copy assignment. [heading Synopsis]```template<    class OtherAlloc>basic_fields&operator=(    basic_fields< OtherAlloc > const&);```[heading Description][endsect][endsect][section:operator_lb__rb_ http::basic_fields::operator\[\]][indexterm2 operator\[\]..http::basic_fields]
Returns the value for a field, or `""` if it does not exist. ```string_view const``[link beast.ref.boost__beast__http__basic_fields.operator_lb__rb_.overload1 operator[]]``(    field name) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.operator_lb__rb_.overload1 more...]]`````
Returns the value for a case-insensitive matching header, or `""` if it does not exist. ```string_view const``[link beast.ref.boost__beast__http__basic_fields.operator_lb__rb_.overload2 operator[]]``(    string_view name) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.operator_lb__rb_.overload2 more...]]`````[section:overload1 http::basic_fields::operator\[\] (1 of 2 overloads)]
Returns the value for a field, or `""` if it does not exist. [heading Synopsis]```string_view constoperator[](    field name) const;```[heading Description]
If more than one field with the specified name exists, the first field defined by insertion order is returned.
[heading Parameters][table [[Name][Description]]  [[`name`][    
The name of the field.   ]]]
[endsect][section:overload2 http::basic_fields::operator\[\] (2 of 2 overloads)]
Returns the value for a case-insensitive matching header, or `""` if it does not exist. [heading Synopsis]```string_view constoperator[](    string_view name) const;```[heading Description]
If more than one field with the specified name exists, the first field defined by insertion order is returned.
[heading Parameters][table [[Name][Description]]  [[`name`][    
The name of the field.   ]]]
[endsect][endsect][section:set http::basic_fields::set][indexterm2 set..http::basic_fields]
Set a field value, removing any other instances of that field. ```void``[link beast.ref.boost__beast__http__basic_fields.set.overload1 set]``(    field name,    string_param const& value);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.set.overload1 more...]]``void``[link beast.ref.boost__beast__http__basic_fields.set.overload2 set]``(    string_view name,    string_param const& value);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.set.overload2 more...]]`````[section:overload1 http::basic_fields::set (1 of 2 overloads)]
Set a field value, removing any other instances of that field. [heading Synopsis]```voidset(    field name,    string_param const& value);```[heading Description]
First removes any values with matching field names, then inserts the new field value.
[heading Parameters][table [[Name][Description]]  [[`name`][    
The field name.  ]]  [[`value`][    
The value of the field, as a [link beast.ref.boost__beast__string_param `string_param`]  ]]]
[heading Return Value]
The field value. 
[endsect][section:overload2 http::basic_fields::set (2 of 2 overloads)]
Set a field value, removing any other instances of that field. [heading Synopsis]```voidset(    string_view name,    string_param const& value);```[heading Description]
First removes any values with matching field names, then inserts the new field value.
[heading Parameters][table [[Name][Description]]  [[`name`][    
The field name.  ]]  [[`value`][    
The value of the field, as a [link beast.ref.boost__beast__string_param `string_param`]   ]]]
[endsect][endsect][section:set_chunked_impl http::basic_fields::set_chunked_impl][indexterm2 set_chunked_impl..http::basic_fields]
Adjusts the chunked Transfer-Encoding value. [heading Synopsis]```voidset_chunked_impl(    bool value);```[heading Description][endsect][section:set_content_length_impl http::basic_fields::set_content_length_impl][indexterm2 set_content_length_impl..http::basic_fields]
Sets or clears the Content-Length field. [heading Synopsis]```voidset_content_length_impl(    boost::optional< std::uint64_t > const& value);```[heading Description][endsect][section:set_keep_alive_impl http::basic_fields::set_keep_alive_impl][indexterm2 set_keep_alive_impl..http::basic_fields]
Adjusts the Connection field. [heading Synopsis]```voidset_keep_alive_impl(    unsigned version,    bool keep_alive);```[heading Description][endsect][section:set_method_impl http::basic_fields::set_method_impl][indexterm2 set_method_impl..http::basic_fields]
Set or clear the method string. [heading Synopsis]```voidset_method_impl(    string_view s);```[heading Description]
[heading Remarks]
Only called for requests. 
[endsect][section:set_reason_impl http::basic_fields::set_reason_impl][indexterm2 set_reason_impl..http::basic_fields]
Set or clear the reason string. [heading Synopsis]```voidset_reason_impl(    string_view s);```[heading Description]
[heading Remarks]
Only called for responses. 
[endsect][section:set_target_impl http::basic_fields::set_target_impl][indexterm2 set_target_impl..http::basic_fields]
Set or clear the target string. [heading Synopsis]```voidset_target_impl(    string_view s);```[heading Description]
[heading Remarks]
Only called for requests. 
[endsect][section:swap http::basic_fields::swap][indexterm2 swap..http::basic_fields]
Swap two field containers. [heading Synopsis]Defined in header [include_file boost/beast/http/fields.hpp]```template<    class Alloc>friend voidswap(    basic_fields< Alloc >& lhs,    basic_fields< Alloc >& rhs);```[heading Description]Convenience header [include_file boost/beast/http.hpp][endsect][section:swap http::basic_fields::swap][indexterm2 swap..http::basic_fields]
Return a buffer sequence representing the trailers. [heading Synopsis]```voidswap(    basic_fields& other);```[heading Description]
This function returns a buffer sequence holding the serialized representation of the trailer fields promised in the Accept field. Before calling this function the Accept field must contain the exact trailer fields desired. Each field must also exist.Swap this container with another [endsect][section:writer http::basic_fields::writer][indexterm2 writer..http::basic_fields]
The algorithm used to serialize the header. [heading Synopsis]```using writer = ``['implementation-defined]``;```[heading Description][endsect][section:basic_fields_dtor_ http::basic_fields::~basic_fields][indexterm2 ~basic_fields..http::basic_fields]
Destructor. [heading Synopsis]```~basic_fields();```[heading Description][endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__basic_fields__element http::basic_fields::element][heading Synopsis]Defined in header [include_file boost/beast/http/fields.hpp]```struct element :    public boost::intrusive::list_base_hook< boost::intrusive::link_mode< boost::intrusive::normal_link > >,    public boost::intrusive::set_base_hook< boost::intrusive::link_mode< boost::intrusive::normal_link > >,    public http::basic_fields< Allocator >::value_type```[heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_fields__element.element [*element]]]    [          ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields__element.name [*name]]]    [      Returns the field enum, which can be field::unknown.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields__element.name_string [*name_string]]]    [      Returns the field name as a string.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields__element.value [*value]]]    [      Returns the value of the field.     ]  ]][heading Description][section:element http::basic_fields::element::element][indexterm2 element..http::basic_fields::element][heading Synopsis]```element(    field name,    string_view sname,    string_view value);```[heading Description][endsect][section:name http::basic_fields::element::name](Inherited from `http::basic_fields`)[indexterm2 name..http::basic_fields::element]
Returns the field enum, which can be [link beast.ref.boost__beast__http__field `http::unknown`]. [heading Synopsis]```fieldname() const;```[heading Description][endsect][section:name_string http::basic_fields::element::name_string](Inherited from `http::basic_fields`)[indexterm2 name_string..http::basic_fields::element]
Returns the field name as a string. [heading Synopsis]```string_view constname_string() const;```[heading Description][endsect][section:value http::basic_fields::element::value](Inherited from `http::basic_fields`)[indexterm2 value..http::basic_fields::element]
Returns the value of the field. [heading Synopsis]```string_view constvalue() const;```[heading Description][endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__basic_fields__value_type http::basic_fields::value_type]
The type of element used to represent a field. [heading Synopsis]Defined in header [include_file boost/beast/http/fields.hpp]```class value_type```[heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_fields__value_type.name [*name]]]    [      Returns the field enum, which can be field::unknown.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields__value_type.name_string [*name_string]]]    [      Returns the field name as a string.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields__value_type.operator_eq_ [*operator=]]]    [      Assignment (deleted)     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields__value_type.value [*value]]]    [      Returns the value of the field.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields__value_type.value_type [*value_type]]]    [      Constructor (deleted)     ]  ]][heading Protected Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_fields__value_type.value_type [*value_type]]]    [          ]  ]][heading Description][section:name http::basic_fields::value_type::name][indexterm2 name..http::basic_fields::value_type]
Returns the field enum, which can be [link beast.ref.boost__beast__http__field `http::unknown`]. [heading Synopsis]```fieldname() const;```[heading Description][endsect][section:name_string http::basic_fields::value_type::name_string][indexterm2 name_string..http::basic_fields::value_type]
Returns the field name as a string. [heading Synopsis]```string_view constname_string() const;```[heading Description][endsect][section:operator_eq_ http::basic_fields::value_type::operator=][indexterm2 operator=..http::basic_fields::value_type]
Assignment (deleted) [heading Synopsis]```value_type&operator=(    value_type const&);```[heading Description][endsect][section:value http::basic_fields::value_type::value][indexterm2 value..http::basic_fields::value_type]
Returns the value of the field. [heading Synopsis]```string_view constvalue() const;```[heading Description][endsect][section:value_type http::basic_fields::value_type::value_type][indexterm2 value_type..http::basic_fields::value_type][heading Synopsis]```value_type(    field name,    string_view sname,    string_view value);```[heading Description][endsect][section:value_type http::basic_fields::value_type::value_type][indexterm2 value_type..http::basic_fields::value_type]
Constructor (deleted) [heading Synopsis]```value_type(    value_type const&);```[heading Description][endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__basic_file_body http::basic_file_body]
A message body represented by a file on the filesystem. [heading Synopsis]Defined in header [include_file boost/beast/http/basic_file_body.hpp]```template<    class File>struct basic_file_body```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_file_body__reader [*reader]]]    [      Algorithm for storing buffers when parsing.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body__value_type [*value_type]]]    [      The type of the message::body member.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body__writer [*writer]]]    [      Algorithm for retrieving buffers when serializing.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body.file_type [*file_type]]]    [      The type of File this body uses.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_file_body.size [*size]]]    [      Returns the size of the body.     ]  ]][heading Description]
Messages with this type have bodies represented by a file on the file system. When parsing a message using this body type, the data is stored in the file pointed to by the path, which must be writable. When serializing, the implementation will read the file and present those octets as the body content. This may be used to serve content from a directory as part of a web service.
[heading Template Parameters][table [[Type][Description]]  [[`File`][    
The implementation to use for accessing files. This type must meet the requirements of ['File].   ]]]
[section:file_type http::basic_file_body::file_type][indexterm2 file_type..http::basic_file_body]
The type of File this body uses. [heading Synopsis]```using file_type = File;```[heading Description][endsect][section:size http::basic_file_body::size][indexterm2 size..http::basic_file_body]
Returns the size of the body. [heading Synopsis]```staticstd::uint64_tsize(    value_type const& body);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`body`][    
The file body to use   ]]]
[endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__basic_file_body__reader http::basic_file_body::reader]
Algorithm for storing buffers when parsing. [heading Synopsis]Defined in header [include_file boost/beast/http/basic_file_body.hpp]```class reader```[heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_file_body__reader.finish [*finish]]]    [          ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body__reader.init [*init]]]    [          ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body__reader.put [*put]]]    [          ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body__reader.reader [*reader]]]    [          ]  ]][heading Description]
Objects of this type are created during parsing to store incoming buffers representing the body. [section:finish http::basic_file_body::reader::finish][indexterm2 finish..http::basic_file_body::reader][heading Synopsis]```voidfinish(    error_code& ec);```[heading Description][endsect][section:init http::basic_file_body::reader::init][indexterm2 init..http::basic_file_body::reader][heading Synopsis]```voidinit(    boost::optional< std::uint64_t > const&,    error_code& ec);```[heading Description][endsect][section:put http::basic_file_body::reader::put][indexterm2 put..http::basic_file_body::reader][heading Synopsis]```template<    class __ConstBufferSequence__>std::size_tput(    ConstBufferSequence const& buffers,    error_code& ec);```[heading Description][endsect][section:reader http::basic_file_body::reader::reader][indexterm2 reader..http::basic_file_body::reader][heading Synopsis]```template<    bool isRequest,    class __Fields__>reader(    header< isRequest, Fields >& h,    value_type& b);```[heading Description][endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__basic_file_body__value_type http::basic_file_body::value_type]
The type of the [link beast.ref.boost__beast__http__message.body `http::message::body`] member. [heading Synopsis]Defined in header [include_file boost/beast/http/basic_file_body.hpp]```class value_type```[heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_file_body__value_type.close [*close]]]    [      Close the file if open.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body__value_type.is_open [*is_open]]]    [      Returns true if the file is open.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body__value_type.open [*open]]]    [      Open a file at the given path with the specified mode.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body__value_type.operator_eq_ [*operator=]]]    [      Move assignment.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body__value_type.reset [*reset]]]    [      Set the open file.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body__value_type.size [*size]]]    [      Returns the size of the file if open.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body__value_type.value_type [*value_type]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body__value_type.value_type_dtor_ [*~value_type]]]    [      Destructor.     ]  ]][heading Friends][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_file_body__value_type.basic_file_body [*basic_file_body]]]    [          ]  ]][heading Description]
Messages declared using `basic_file_body` will have this type for the body member. This rich class interface allow the file to be opened with the file handle maintained directly in the object, which is attached to the message. [section:basic_file_body http::basic_file_body::value_type::basic_file_body][indexterm2 basic_file_body..http::basic_file_body::value_type][heading Synopsis]Defined in header [include_file boost/beast/http/basic_file_body.hpp]```friend structbasic_file_body();```[heading Description]Convenience header [include_file boost/beast/http.hpp][endsect][section:close http::basic_file_body::value_type::close][indexterm2 close..http::basic_file_body::value_type]
Close the file if open. [heading Synopsis]```voidclose();```[heading Description][endsect][section:is_open http::basic_file_body::value_type::is_open][indexterm2 is_open..http::basic_file_body::value_type]
Returns `true` if the file is open. [heading Synopsis]```boolis_open() const;```[heading Description][endsect][section:open http::basic_file_body::value_type::open][indexterm2 open..http::basic_file_body::value_type]
Open a file at the given path with the specified mode. [heading Synopsis]```voidopen(    char const* path,    file_mode mode,    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`path`][    
The utf-8 encoded path to the file  ]]  [[`mode`][    
The file mode to use  ]]  [[`ec`][    
Set to the error, if any occurred   ]]]
[endsect][section:operator_eq_ http::basic_file_body::value_type::operator=][indexterm2 operator=..http::basic_file_body::value_type]
Move assignment. [heading Synopsis]```value_type&operator=(    value_type&& other);```[heading Description][endsect][section:reset http::basic_file_body::value_type::reset][indexterm2 reset..http::basic_file_body::value_type]
Set the open file. [heading Synopsis]```voidreset(    File&& file,    error_code& ec);```[heading Description]
This function is used to set the open file. Any previously set file will be closed.
[heading Parameters][table [[Name][Description]]  [[`file`][    
The file to set. The file must be open or else an error occurs  ]]  [[`ec`][    
Set to the error, if any occurred   ]]]
[endsect][section:size http::basic_file_body::value_type::size][indexterm2 size..http::basic_file_body::value_type]
Returns the size of the file if open. [heading Synopsis]```std::uint64_tsize() const;```[heading Description][endsect][section:value_type http::basic_file_body::value_type::value_type][indexterm2 value_type..http::basic_file_body::value_type]
Constructor. `````[link beast.ref.boost__beast__http__basic_file_body__value_type.value_type.overload1 value_type]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_file_body__value_type.value_type.overload1 more...]]````[link beast.ref.boost__beast__http__basic_file_body__value_type.value_type.overload2 value_type]``(    value_type&& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_file_body__value_type.value_type.overload2 more...]]`````[section:overload1 http::basic_file_body::value_type::value_type (1 of 2 overloads)]
Constructor. [heading Synopsis]```value_type();```[heading Description][endsect][section:overload2 http::basic_file_body::value_type::value_type (2 of 2 overloads)]
Constructor. [heading Synopsis]```value_type(    value_type&& other);```[heading Description][endsect][endsect][section:value_type_dtor_ http::basic_file_body::value_type::~value_type][indexterm2 ~value_type..http::basic_file_body::value_type]
Destructor. [heading Synopsis]```~value_type();```[heading Description]
If the file is open, it is closed first. [endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__basic_file_body__writer http::basic_file_body::writer]
Algorithm for retrieving buffers when serializing. [heading Synopsis]Defined in header [include_file boost/beast/http/basic_file_body.hpp]```class writer```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_file_body__writer.const_buffers_type [*const_buffers_type]]]    [          ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_file_body__writer.get [*get]]]    [          ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body__writer.init [*init]]]    [          ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body__writer.writer [*writer]]]    [          ]  ]][heading Description]
Objects of this type are created during serialization to extract the buffers representing the body. [section:const_buffers_type http::basic_file_body::writer::const_buffers_type][indexterm2 const_buffers_type..http::basic_file_body::writer][heading Synopsis]```using const_buffers_type = net::const_buffer;```[heading Description][endsect][section:get http::basic_file_body::writer::get][indexterm2 get..http::basic_file_body::writer][heading Synopsis]```boost::optional< std::pair< const_buffers_type, bool > >get(    error_code& ec);```[heading Description][endsect][section:init http::basic_file_body::writer::init][indexterm2 init..http::basic_file_body::writer][heading Synopsis]```voidinit(    error_code& ec);```[heading Description][endsect][section:writer http::basic_file_body::writer::writer][indexterm2 writer..http::basic_file_body::writer][heading Synopsis]```template<    bool isRequest,    class __Fields__>writer(    header< isRequest, Fields >& h,    value_type& b);```[heading Description][endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__basic_parser http::basic_parser]
A parser for decoding HTTP/1 wire format messages. [heading Synopsis]Defined in header [include_file boost/beast/http/basic_parser.hpp]```template<    bool isRequest>class basic_parser :    private basic_parser_base```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_parser.is_request [*is_request]]]    [      true if this parser parses requests, false for responses.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_parser.basic_parser [*basic_parser]]]    [      Copy constructor.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.body_limit [*body_limit]]]    [      Set the limit on the payload body.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.chunked [*chunked]]]    [      Returns true if the last value for Transfer-Encoding is "chunked".     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.content_length [*content_length]]]    [      Returns the optional value of Content-Length if known.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.content_length_remaining [*content_length_remaining]]]    [      Returns the remaining content length if known.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.eager [*eager]]]    [      Returns true if the eager parse option is set.       Set the eager parse option.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.got_some [*got_some]]]    [      Returns true if the parser has received at least one byte of input.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.header_limit [*header_limit]]]    [      Set a limit on the total size of the header.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.is_done [*is_done]]]    [      Returns true if the message is complete.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.is_header_done [*is_header_done]]]    [      Returns true if a the parser has produced the full header.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.keep_alive [*keep_alive]]]    [      Returns true if the message has keep-alive connection semantics.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.need_eof [*need_eof]]]    [      Returns true if the message semantics require an end of file.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.operator_eq_ [*operator=]]]    [      Copy assignment.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.put [*put]]]    [      Write a buffer sequence to the parser.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.put_eof [*put_eof]]]    [      Inform the parser that the end of stream was reached.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.skip [*skip]]]    [      Returns true if the skip parse option is set.       Set the skip parse option.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.upgrade [*upgrade]]]    [      Returns true if the message is an upgrade message.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.basic_parser_dtor_ [*~basic_parser]]]    [      Destructor.     ]  ]][heading Protected Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_parser.basic_parser [*basic_parser]]]    [      Default constructor.       Move constructor.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.on_body_impl [*on_body_impl]]]    [      Called each time additional data is received representing the content body.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.on_body_init_impl [*on_body_init_impl]]]    [      Called once before the body is processed.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.on_chunk_body_impl [*on_chunk_body_impl]]]    [      Called each time additional data is received representing part of a body chunk.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.on_chunk_header_impl [*on_chunk_header_impl]]]    [      Called each time a new chunk header of a chunk encoded body is received.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.on_field_impl [*on_field_impl]]]    [      Called once for each complete field in the HTTP header.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.on_finish_impl [*on_finish_impl]]]    [      Called once when the complete message is received.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.on_header_impl [*on_header_impl]]]    [      Called once after the complete HTTP header is received.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.on_request_impl [*on_request_impl]]]    [      Called after receiving the request-line.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.on_response_impl [*on_response_impl]]]    [      Called after receiving the status-line.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.operator_eq_ [*operator=]]]    [      Move assignment.     ]  ]][heading Description]
This parser is designed to efficiently parse messages in the HTTP/1 wire format. It allocates no memory when input is presented as a single contiguous buffer, and uses minimal state. It will handle chunked encoding and it understands the semantics of the Connection, Content-Length, and Upgrade fields. The parser is optimized for the case where the input buffer sequence consists of a single contiguous buffer. The [link beast.ref.boost__beast__basic_flat_buffer `basic_flat_buffer`] class is provided, which guarantees that the input sequence of the stream buffer will be represented by exactly one contiguous buffer. To ensure the optimum performance of the parser, use [link beast.ref.boost__beast__basic_flat_buffer `basic_flat_buffer`] with HTTP algorithms such as [link beast.ref.boost__beast__http__read `http::read`], [link beast.ref.boost__beast__http__read_some `http::read_some`], [link beast.ref.boost__beast__http__async_read `http::async_read`], and [link beast.ref.boost__beast__http__async_read_some `http::async_read_some`]. Alternatively, the caller may use custom techniques to ensure that the structured portion of the HTTP message (header or chunk header) is contained in a linear buffer.
The interface to the parser uses virtual member functions. To use this class, derive your type from [link beast.ref.boost__beast__http__basic_parser `http::basic_parser`]. When bytes are presented, the implementation will make a series of zero or more calls to virtual functions, which the derived class must implement.
Every virtual function must be provided by the derived class, or else a compilation error will be generated. The implementation will make sure that `ec` is clear before each virtual function is invoked. If a virtual function sets an error, it is propagated out of the parser to the caller.
[heading Template Parameters][table [[Type][Description]]  [[`isRequest`][    
A `bool` indicating whether the parser will be presented with request or response message.  ]]]
[heading Remarks]
If the parser encounters a field value with obs-fold longer than 4 kilobytes in length, an error is generated. 
[section:basic_parser http::basic_parser::basic_parser][indexterm2 basic_parser..http::basic_parser]
Default constructor. `````[link beast.ref.boost__beast__http__basic_parser.basic_parser.overload1 basic_parser]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_parser.basic_parser.overload1 more...]]`````
Move constructor. `````[link beast.ref.boost__beast__http__basic_parser.basic_parser.overload2 basic_parser]``(    basic_parser&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_parser.basic_parser.overload2 more...]]`````[section:overload1 http::basic_parser::basic_parser (1 of 2 overloads)]
Default constructor. [heading Synopsis]```basic_parser();```[heading Description][endsect][section:overload2 http::basic_parser::basic_parser (2 of 2 overloads)]
Move constructor. [heading Synopsis]```basic_parser(    basic_parser&&);```[heading Description]
[heading Remarks]

After the move, the only valid operation on the moved-from object is destruction. [endsect][endsect][section:basic_parser http::basic_parser::basic_parser][indexterm2 basic_parser..http::basic_parser]
Copy constructor. [heading Synopsis]```basic_parser(    basic_parser const&);```[heading Description][endsect][section:body_limit http::basic_parser::body_limit][indexterm2 body_limit..http::basic_parser]
Set the limit on the payload body. [heading Synopsis]```voidbody_limit(    std::uint64_t v);```[heading Description]
This function sets the maximum allowed size of the payload body, before any encodings except chunked have been removed. Depending on the message semantics, one of these cases will apply:

* The Content-Length is specified and exceeds the limit. In this case the result [link beast.ref.boost__beast__http__error `http::body_limit`] is returned immediately after the header is parsed.


* The Content-Length is unspecified and the chunked encoding is not specified as the last encoding. In this case the end of message is determined by the end of file indicator on the associated stream or input source. If a sufficient number of body payload octets are presented to the parser to exceed the configured limit, the parse fails with the result [link beast.ref.boost__beast__http__error `http::body_limit`]


* The Transfer-Encoding specifies the chunked encoding as the last encoding. In this case, when the number of payload body octets produced by removing the chunked encoding exceeds the configured limit, the parse fails with the result [link beast.ref.boost__beast__http__error `http::body_limit`].

Setting the limit after any body octets have been parsed results in undefined behavior.
The default limit is 1MB for requests and 8MB for responses.
[heading Parameters][table [[Name][Description]]  [[`v`][    
The payload body limit to set   ]]]
[endsect][section:chunked http::basic_parser::chunked][indexterm2 chunked..http::basic_parser]
Returns `true` if the last value for Transfer-Encoding is "chunked". [heading Synopsis]```boolchunked() const;```[heading Description]
[heading Remarks]
The return value is undefined unless [link beast.ref.boost__beast__http__basic_parser.is_header_done `http::basic_parser::is_header_done`] would return `true`. 
[endsect][section:content_length http::basic_parser::content_length][indexterm2 content_length..http::basic_parser]
Returns the optional value of Content-Length if known. [heading Synopsis]```boost::optional< std::uint64_t >content_length() const;```[heading Description]
[heading Remarks]
The return value is undefined unless [link beast.ref.boost__beast__http__basic_parser.is_header_done `http::basic_parser::is_header_done`] would return `true`. 
[endsect][section:content_length_remaining http::basic_parser::content_length_remaining][indexterm2 content_length_remaining..http::basic_parser]
Returns the remaining content length if known. [heading Synopsis]```boost::optional< std::uint64_t >content_length_remaining() const;```[heading Description]
If the message header specifies a Content-Length, the return value will be the number of bytes remaining in the payload body have not yet been parsed.
[heading Remarks]
The return value is undefined unless [link beast.ref.boost__beast__http__basic_parser.is_header_done `http::basic_parser::is_header_done`] would return `true`. 
[endsect][section:eager http::basic_parser::eager][indexterm2 eager..http::basic_parser]
Returns `true` if the eager parse option is set. ```bool``[link beast.ref.boost__beast__http__basic_parser.eager.overload1 eager]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_parser.eager.overload1 more...]]`````
Set the eager parse option. ```void``[link beast.ref.boost__beast__http__basic_parser.eager.overload2 eager]``(    bool v);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_parser.eager.overload2 more...]]`````[section:overload1 http::basic_parser::eager (1 of 2 overloads)]
Returns `true` if the eager parse option is set. [heading Synopsis]```booleager() const;```[heading Description][endsect][section:overload2 http::basic_parser::eager (2 of 2 overloads)]
Set the eager parse option. [heading Synopsis]```voideager(    bool v);```[heading Description]
Normally the parser returns after successfully parsing a structured element (header, chunk header, or chunk body) even if there are octets remaining in the input. This is necessary when attempting to parse the header first, or when the caller wants to inspect information which may be invalidated by subsequent parsing, such as a chunk extension. The `eager` option controls whether the parser keeps going after parsing structured element if there are octets remaining in the buffer and no error occurs. This option is automatically set or cleared during certain stream operations to improve performance with no change in functionality.
The default setting is `false`.
[heading Parameters][table [[Name][Description]]  [[`v`][    
`true` to set the eager parse option or `false` to disable it.   ]]]
[endsect][endsect][section:got_some http::basic_parser::got_some][indexterm2 got_some..http::basic_parser]
Returns `true` if the parser has received at least one byte of input. [heading Synopsis]```boolgot_some() const;```[heading Description][endsect][section:header_limit http::basic_parser::header_limit][indexterm2 header_limit..http::basic_parser]
Set a limit on the total size of the header. [heading Synopsis]```voidheader_limit(    std::uint32_t v);```[heading Description]
This function sets the maximum allowed size of the header including all field name, value, and delimiter characters and also including the CRLF sequences in the serialized input. If the end of the header is not found within the limit of the header size, the error [link beast.ref.boost__beast__http__error `http::header_limit`] is returned by [link beast.ref.boost__beast__http__basic_parser.put `http::basic_parser::put`].
Setting the limit after any header octets have been parsed results in undefined behavior. [endsect][section:is_done http::basic_parser::is_done][indexterm2 is_done..http::basic_parser]
Returns `true` if the message is complete. [heading Synopsis]```boolis_done() const;```[heading Description]
The message is complete after the full header is prduced and one of the following is true:

* The skip body option was set.


* The semantics of the message indicate there is no body.


* The semantics of the message indicate a body is expected, and the entire body was parsed. 

[endsect][section:is_header_done http::basic_parser::is_header_done][indexterm2 is_header_done..http::basic_parser]
Returns `true` if a the parser has produced the full header. [heading Synopsis]```boolis_header_done() const;```[heading Description][endsect][section:is_request http::basic_parser::is_request][indexterm2 is_request..http::basic_parser]
`true` if this parser parses requests, `false` for responses. [heading Synopsis]```using is_request = std::integral_constant< bool, isRequest >;```[heading Description][endsect][section:keep_alive http::basic_parser::keep_alive][indexterm2 keep_alive..http::basic_parser]
Returns `true` if the message has keep-alive connection semantics. [heading Synopsis]```boolkeep_alive() const;```[heading Description]
This function always returns `false` if [link beast.ref.boost__beast__http__basic_parser.need_eof `http::basic_parser::need_eof`] would return `false`.
[heading Remarks]
The return value is undefined unless [link beast.ref.boost__beast__http__basic_parser.is_header_done `http::basic_parser::is_header_done`] would return `true`. 
[endsect][section:need_eof http::basic_parser::need_eof][indexterm2 need_eof..http::basic_parser]
Returns `true` if the message semantics require an end of file. [heading Synopsis]```boolneed_eof() const;```[heading Description]
Depending on the contents of the header, the parser may require and end of file notification to know where the end of the body lies. If this function returns `true` it will be necessary to call [link beast.ref.boost__beast__http__basic_parser.put_eof `http::basic_parser::put_eof`] when there will never be additional data from the input. [endsect][section:on_body_impl http::basic_parser::on_body_impl][indexterm2 on_body_impl..http::basic_parser]
Called each time additional data is received representing the content body. [heading Synopsis]```std::size_ton_body_impl(    string_view body,    error_code& ec);```[heading Description]
This virtual function is invoked for each piece of the body which is received while parsing of a message. This function is only used when no chunked transfer encoding is present.
[heading Parameters][table [[Name][Description]]  [[`body`][    
A string holding the additional body contents. This may contain nulls or unprintable characters.  ]]  [[`ec`][    
An output parameter which the function may set to indicate an error. The error will be clear before this function is invoked.  ]]]
[heading See Also]
[link beast.ref.boost__beast__http__basic_parser.on_chunk_body_impl `http::basic_parser::on_chunk_body_impl`] 
[endsect][section:on_body_init_impl http::basic_parser::on_body_init_impl][indexterm2 on_body_init_impl..http::basic_parser]
Called once before the body is processed. [heading Synopsis]```voidon_body_init_impl(    boost::optional< std::uint64_t > const& content_length,    error_code& ec);```[heading Description]
This virtual function is invoked once, before the content body is processed (but after the complete header is received).
[heading Parameters][table [[Name][Description]]  [[`content_length`][    
A value representing the content length in bytes if the length is known (this can include a zero length). Otherwise, the value will be `boost::none`.  ]]  [[`ec`][    
An output parameter which the function may set to indicate an error. The error will be clear before this function is invoked.   ]]]
[endsect][section:on_chunk_body_impl http::basic_parser::on_chunk_body_impl][indexterm2 on_chunk_body_impl..http::basic_parser]
Called each time additional data is received representing part of a body chunk. [heading Synopsis]```std::size_ton_chunk_body_impl(    std::uint64_t remain,    string_view body,    error_code& ec);```[heading Description]
This virtual function is invoked for each piece of the body which is received while parsing of a message. This function is only used when no chunked transfer encoding is present.
[heading Parameters][table [[Name][Description]]  [[`remain`][    
The number of bytes remaining in this chunk. This includes the contents of passed `body`. If this value is zero, then this represents the final chunk.  ]]  [[`body`][    
A string holding the additional body contents. This may contain nulls or unprintable characters.  ]]  [[`ec`][    
An output parameter which the function may set to indicate an error. The error will be clear before this function is invoked.  ]]]
[heading Return Value]
This function should return the number of bytes actually consumed from the `body` value. Any bytes that are not consumed on this call will be presented in a subsequent call.
[heading See Also]
[link beast.ref.boost__beast__http__basic_parser.on_body_impl `http::basic_parser::on_body_impl`] 
[endsect][section:on_chunk_header_impl http::basic_parser::on_chunk_header_impl][indexterm2 on_chunk_header_impl..http::basic_parser]
Called each time a new chunk header of a chunk encoded body is received. [heading Synopsis]```voidon_chunk_header_impl(    std::uint64_t size,    string_view extensions,    error_code& ec);```[heading Description]
This function is invoked each time a new chunk header is received. The function is only used when the chunked transfer encoding is present.
[heading Parameters][table [[Name][Description]]  [[`size`][    
The size of this chunk, in bytes.  ]]  [[`extensions`][    
A string containing the entire chunk extensions. This may be empty, indicating no extensions are present.  ]]  [[`ec`][    
An output parameter which the function may set to indicate an error. The error will be clear before this function is invoked.   ]]]
[endsect][section:on_field_impl http::basic_parser::on_field_impl][indexterm2 on_field_impl..http::basic_parser]
Called once for each complete field in the HTTP header. [heading Synopsis]```voidon_field_impl(    field name,    string_view name_string,    string_view value,    error_code& ec);```[heading Description]
This virtual function is invoked for each field that is received while parsing an HTTP message.
[heading Parameters][table [[Name][Description]]  [[`name`][    
The known field enum value. If the name of the field is not recognized, this value will be [link beast.ref.boost__beast__http__field `http::unknown`].  ]]  [[`name_string`][    
The exact name of the field as received from the input, represented as a string.  ]]  [[`value`][    
A string holding the value of the field.  ]]  [[`ec`][    
An output parameter which the function may set to indicate an error. The error will be clear before this function is invoked.   ]]]
[endsect][section:on_finish_impl http::basic_parser::on_finish_impl][indexterm2 on_finish_impl..http::basic_parser]
Called once when the complete message is received. [heading Synopsis]```voidon_finish_impl(    error_code& ec);```[heading Description]
This virtual function is invoked once, after successfully parsing a complete HTTP message.
[heading Parameters][table [[Name][Description]]  [[`ec`][    
An output parameter which the function may set to indicate an error. The error will be clear before this function is invoked.   ]]]
[endsect][section:on_header_impl http::basic_parser::on_header_impl][indexterm2 on_header_impl..http::basic_parser]
Called once after the complete HTTP header is received. [heading Synopsis]```voidon_header_impl(    error_code& ec);```[heading Description]
This virtual function is invoked once, after the complete HTTP header is received while parsing a message.
[heading Parameters][table [[Name][Description]]  [[`ec`][    
An output parameter which the function may set to indicate an error. The error will be clear before this function is invoked.   ]]]
[endsect][section:on_request_impl http::basic_parser::on_request_impl][indexterm2 on_request_impl..http::basic_parser]
Called after receiving the request-line. [heading Synopsis]```voidon_request_impl(    verb method,    string_view method_str,    string_view target,    int version,    error_code& ec);```[heading Description]
This virtual function is invoked after receiving a request-line when parsing HTTP requests. It can only be called when `isRequest == true`.
[heading Parameters][table [[Name][Description]]  [[`method`][    
The verb enumeration. If the method string is not one of the predefined strings, this value will be [link beast.ref.boost__beast__http__field `http::unknown`].  ]]  [[`method_str`][    
The unmodified string representing the verb.  ]]  [[`target`][    
The request-target.  ]]  [[`version`][    
The HTTP-version. This will be 10 for HTTP/1.0, and 11 for HTTP/1.1.  ]]  [[`ec`][    
An output parameter which the function may set to indicate an error. The error will be clear before this function is invoked.   ]]]
[endsect][section:on_response_impl http::basic_parser::on_response_impl][indexterm2 on_response_impl..http::basic_parser]
Called after receiving the status-line. [heading Synopsis]```voidon_response_impl(    int code,    string_view reason,    int version,    error_code& ec);```[heading Description]
This virtual function is invoked after receiving a status-line when parsing HTTP responses. It can only be called when `isRequest == false`.
[heading Parameters][table [[Name][Description]]  [[`code`][    
The numeric status code.  ]]  [[`reason`][    
The reason-phrase. Note that this value is now obsolete, and only provided for historical or diagnostic purposes.  ]]  [[`version`][    
The HTTP-version. This will be 10 for HTTP/1.0, and 11 for HTTP/1.1.  ]]  [[`ec`][    
An output parameter which the function may set to indicate an error. The error will be clear before this function is invoked.   ]]]
[endsect][section:operator_eq_ http::basic_parser::operator=][indexterm2 operator=..http::basic_parser]
Move assignment. [heading Synopsis]```basic_parser&operator=(    basic_parser&&);```[heading Description][endsect][section:operator_eq_ http::basic_parser::operator=][indexterm2 operator=..http::basic_parser]
Copy assignment. [heading Synopsis]```basic_parser&operator=(    basic_parser const&);```[heading Description][endsect][section:put http::basic_parser::put][indexterm2 put..http::basic_parser]
Write a buffer sequence to the parser. [heading Synopsis]```template<    class __ConstBufferSequence__>std::size_tput(    ConstBufferSequence const& buffers,    error_code& ec);```[heading Description]
This function attempts to incrementally parse the HTTP message data stored in the caller provided buffers. Upon success, a positive return value indicates that the parser made forward progress, consuming that number of bytes.
In some cases there may be an insufficient number of octets in the input buffer in order to make forward progress. This is indicated by the code [link beast.ref.boost__beast__http__error `http::need_more`]. When this happens, the caller should place additional bytes into the buffer sequence and call [link beast.ref.boost__beast__http__basic_parser.put `http::basic_parser::put`] again.
The error code [link beast.ref.boost__beast__http__error `http::need_more`] is special. When this error is returned, a subsequent call to [link beast.ref.boost__beast__http__basic_parser.put `http::basic_parser::put`] may succeed if the buffers have been updated. Otherwise, upon error the parser may not be restarted.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
An object meeting the requirements of ['ConstBufferSequence] that represents the next chunk of message data. If the length of this buffer sequence is one, the implementation will not allocate additional memory. The class [link beast.ref.boost__beast__basic_flat_buffer `basic_flat_buffer`] is provided as one way to meet this requirement  ]]  [[`ec`][    
Set to the error, if any occurred.  ]]]
[heading Return Value]
The number of octets consumed in the buffer sequence. The caller should remove these octets even if the error is set. 
[endsect][section:put_eof http::basic_parser::put_eof][indexterm2 put_eof..http::basic_parser]
Inform the parser that the end of stream was reached. [heading Synopsis]```voidput_eof(    error_code& ec);```[heading Description]
In certain cases, HTTP needs to know where the end of the stream is. For example, sometimes servers send responses without Content-Length and expect the client to consume input (for the body) until EOF. Callbacks and errors will still be processed as usual.
This is typically called when a read from the underlying stream object sets the error code to `net::error::eof`.
[heading Remarks]
Only valid after parsing a complete header.
[heading Parameters][table [[Name][Description]]  [[`ec`][    
Set to the error, if any occurred.   ]]]
[endsect][section:skip http::basic_parser::skip][indexterm2 skip..http::basic_parser]
Returns `true` if the skip parse option is set. ```bool``[link beast.ref.boost__beast__http__basic_parser.skip.overload1 skip]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_parser.skip.overload1 more...]]`````
Set the skip parse option. ```void``[link beast.ref.boost__beast__http__basic_parser.skip.overload2 skip]``(    bool v);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_parser.skip.overload2 more...]]`````[section:overload1 http::basic_parser::skip (1 of 2 overloads)]
Returns `true` if the skip parse option is set. [heading Synopsis]```boolskip() const;```[heading Description][endsect][section:overload2 http::basic_parser::skip (2 of 2 overloads)]
Set the skip parse option. [heading Synopsis]```voidskip(    bool v);```[heading Description]
This option controls whether or not the parser expects to see an HTTP body, regardless of the presence or absence of certain fields such as Content-Length or a chunked Transfer-Encoding. Depending on the request, some responses do not carry a body. For example, a 200 response to a CONNECT request from a tunneling proxy, or a response to a HEAD request. In these cases, callers may use this function inform the parser that no body is expected. The parser will consider the message complete after the header has been received.
[heading Parameters][table [[Name][Description]]  [[`v`][    
`true` to set the skip body option or `false` to disable it.  ]]]
[heading Remarks]
This function must called before any bytes are processed. 
[endsect][endsect][section:upgrade http::basic_parser::upgrade][indexterm2 upgrade..http::basic_parser]
Returns `true` if the message is an upgrade message. [heading Synopsis]```boolupgrade() const;```[heading Description]
[heading Remarks]
The return value is undefined unless [link beast.ref.boost__beast__http__basic_parser.is_header_done `http::basic_parser::is_header_done`] would return `true`. 
[endsect][section:basic_parser_dtor_ http::basic_parser::~basic_parser][indexterm2 ~basic_parser..http::basic_parser]
Destructor. [heading Synopsis]```virtual~basic_parser();```[heading Description][endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__basic_string_body http::basic_string_body]
A ['Body] using `std::basic_string` [heading Synopsis]Defined in header [include_file boost/beast/http/string_body.hpp]```template<    class CharT,    class Traits = std::char_traits<CharT>,    class __Allocator__ = std::allocator<CharT>>struct basic_string_body```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_string_body.reader [*reader]]]    [      The algorithm for parsing the body.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_string_body.value_type [*value_type]]]    [      The type of container used for the body.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_string_body.writer [*writer]]]    [      The algorithm for serializing the body.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_string_body.size [*size]]]    [      Returns the payload size of the body.     ]  ]][heading Description]
This body uses `std::basic_string` as a memory-based container for holding message payloads. Messages using this body type may be serialized and parsed. [section:reader http::basic_string_body::reader][indexterm2 reader..http::basic_string_body]
The algorithm for parsing the body. [heading Synopsis]```using reader = ``['implementation-defined]``;```[heading Description]
Meets the requirements of ['BodyReader]. [endsect][section:size http::basic_string_body::size][indexterm2 size..http::basic_string_body]
Returns the payload size of the body. [heading Synopsis]```staticstd::uint64_tsize(    value_type const& body);```[heading Description]
When this body is used with [link beast.ref.boost__beast__http__message.prepare_payload `http::message::prepare_payload`], the Content-Length will be set to the payload size, and any chunked Transfer-Encoding will be removed. [endsect][section:value_type http::basic_string_body::value_type][indexterm2 value_type..http::basic_string_body]
The type of container used for the body. [heading Synopsis]```using value_type = std::basic_string< CharT, Traits, Allocator >;```[heading Description]
This determines the type of [link beast.ref.boost__beast__http__message.body `http::message::body`] when this body type is used with a message container. [endsect][section:writer http::basic_string_body::writer][indexterm2 writer..http::basic_string_body]
The algorithm for serializing the body. [heading Synopsis]```using writer = ``['implementation-defined]``;```[heading Description]
Meets the requirements of ['BodyWriter]. [endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__buffer_body http::buffer_body]
A ['Body] using a caller provided buffer. [heading Synopsis]Defined in header [include_file boost/beast/http/buffer_body.hpp]```struct buffer_body```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__buffer_body__value_type [*value_type]]]    [      The type of the body member when used in a message.     ]  ]  [    [[link beast.ref.boost__beast__http__buffer_body.reader [*reader]]]    [      The algorithm for parsing the body.     ]  ]  [    [[link beast.ref.boost__beast__http__buffer_body.writer [*writer]]]    [      The algorithm for serializing the body.     ]  ]][heading Description]
Messages using this body type may be serialized and parsed. To use this class, the caller must initialize the members of [link beast.ref.boost__beast__http__buffer_body__value_type `http::buffer_body::value_type`] to appropriate values before each call to read or write during a stream operation. [section:reader http::buffer_body::reader][indexterm2 reader..http::buffer_body]
The algorithm for parsing the body. [heading Synopsis]```using reader = ``['implementation-defined]``;```[heading Description]
Meets the requirements of ['BodyReader]. [endsect][section:writer http::buffer_body::writer][indexterm2 writer..http::buffer_body]
The algorithm for serializing the body. [heading Synopsis]```using writer = ``['implementation-defined]``;```[heading Description]
Meets the requirements of ['BodyWriter]. [endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__buffer_body__value_type http::buffer_body::value_type]
The type of the body member when used in a message. [heading Synopsis]Defined in header [include_file boost/beast/http/buffer_body.hpp]```struct value_type```[heading Data Members][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__buffer_body__value_type.data [*data]]]    [      A pointer to a contiguous area of memory of size octets, else nullptr.     ]  ]  [    [[link beast.ref.boost__beast__http__buffer_body__value_type.more [*more]]]    [      true if this is not the last buffer.     ]  ]  [    [[link beast.ref.boost__beast__http__buffer_body__value_type.size [*size]]]    [      The number of octets in the buffer pointed to by data.     ]  ]][heading Description][section:data http::buffer_body::value_type::data][indexterm2 data..http::buffer_body::value_type]
A pointer to a contiguous area of memory of [link beast.ref.boost__beast__http__buffer_body__value_type.size `http::buffer_body::value_type::size`] octets, else `nullptr`. [heading Synopsis]```void * data = nullptr;```[heading Description]
[heading When Serializing]

If this is `nullptr` and `more` is `true`, the error [link beast.ref.boost__beast__http__error `http::need_buffer`] will be returned from [link beast.ref.boost__beast__http__serializer.get `http::serializer::get`] Otherwise, the serializer will use the memory pointed to by `data` having `size` octets of valid storage as the next buffer representing the body.
[heading When Parsing]

If this is `nullptr`, the error [link beast.ref.boost__beast__http__error `http::need_buffer`] will be returned from [link beast.ref.boost__beast__http__basic_parser.put `http::basic_parser::put`]. Otherwise, the parser will store body octets into the memory pointed to by `data` having `size` octets of valid storage. After octets are stored, the `data` and `size` members are adjusted: `data` is incremented to point to the next octet after the data written, while `size` is decremented to reflect the remaining space at the memory location pointed to by `data`. [endsect][section:more http::buffer_body::value_type::more][indexterm2 more..http::buffer_body::value_type]
`true` if this is not the last buffer. [heading Synopsis]```bool more = true;```[heading Description]
[heading When Serializing]

If this is `true` and `data` is `nullptr`, the error [link beast.ref.boost__beast__http__error `http::need_buffer`] will be returned from [link beast.ref.boost__beast__http__serializer.get `http::serializer::get`]
[heading When Parsing]

This field is not used during parsing. [endsect][section:size http::buffer_body::value_type::size][indexterm2 size..http::buffer_body::value_type]
The number of octets in the buffer pointed to by [link beast.ref.boost__beast__http__buffer_body__value_type.data `http::buffer_body::value_type::data`]. [heading Synopsis]```std::size_t size = 0;```[heading Description]
[heading When Serializing]

If `data` is `nullptr` during serialization, this value is ignored. Otherwise, it represents the number of valid body octets pointed to by `data`.
[heading When Parsing]

The value of this field will be decremented during parsing to indicate the number of remaining free octets in the buffer pointed to by `data`. When it reaches zero, the parser will return [link beast.ref.boost__beast__http__error `http::need_buffer`], indicating to the caller that the values of `data` and `size` should be updated to point to a new memory buffer. [endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__chunk_body http::chunk_body]
A ['chunk]. [heading Synopsis]Defined in header [include_file boost/beast/http/chunk_encode.hpp]```template<    class __ConstBufferSequence__>class chunk_body```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__chunk_body.const_iterator [*const_iterator]]]    [      Required for ConstBufferSequence     ]  ]  [    [[link beast.ref.boost__beast__http__chunk_body.value_type [*value_type]]]    [      Required for ConstBufferSequence     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__chunk_body.begin [*begin]]]    [      Required for ConstBufferSequence     ]  ]  [    [[link beast.ref.boost__beast__http__chunk_body.chunk_body [*chunk_body]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__http__chunk_body.end [*end]]]    [      Required for ConstBufferSequence     ]  ]][heading Description]
This implements a ['ConstBufferSequence] representing a ['chunk]. The serialized format is as follows: ```  chunk           = chunk-size [ chunk-ext ] CRLF chunk-data CRLF
  chunk-size      = 1*HEXDIG
  chunk-ext       = *( ";" chunk-ext-name [ "=" chunk-ext-val ] )
  chunk-ext-name  = token
  chunk-ext-val   = token / quoted-string
  chunk-data      = 1*OCTET ; a sequence of chunk-size octets
```The chunk extension is optional.
To use this class, pass an instance of it to a stream algorithm as the buffer sequence.
[heading See Also]
[@https://tools.ietf.org/html/rfc7230#section-4.1 https://tools.ietf.org/html/rfc7230#section-4.1] 
[section:begin http::chunk_body::begin][indexterm2 begin..http::chunk_body]
Required for ['ConstBufferSequence] [heading Synopsis]```const_iteratorbegin() const;```[heading Description][endsect][section:chunk_body http::chunk_body::chunk_body][indexterm2 chunk_body..http::chunk_body]
Constructor. ```explicit``[link beast.ref.boost__beast__http__chunk_body.chunk_body.overload1 chunk_body]``(    ConstBufferSequence const& buffers);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__chunk_body.chunk_body.overload1 more...]]````[link beast.ref.boost__beast__http__chunk_body.chunk_body.overload2 chunk_body]``(    ConstBufferSequence const& buffers,    string_view extensions);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__chunk_body.chunk_body.overload2 more...]]``template<    class ChunkExtensions>``[link beast.ref.boost__beast__http__chunk_body.chunk_body.overload3 chunk_body]``(    ConstBufferSequence const& buffers,    ChunkExtensions&& extensions);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__chunk_body.chunk_body.overload3 more...]]``template<    class ChunkExtensions,    class __Allocator__>``[link beast.ref.boost__beast__http__chunk_body.chunk_body.overload4 chunk_body]``(    ConstBufferSequence const& buffers,    ChunkExtensions&& extensions,    Allocator const& allocator);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__chunk_body.chunk_body.overload4 more...]]`````[section:overload1 http::chunk_body::chunk_body (1 of 4 overloads)]
Constructor. [heading Synopsis]```chunk_body(    ConstBufferSequence const& buffers);```[heading Description]
This constructs buffers representing a complete ['chunk] with no chunk extensions and having the size and contents of the specified buffer sequence.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
A buffer sequence representing the chunk body. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid while this object is in use.  ]]]
[heading See Also]
[@https://tools.ietf.org/html/rfc7230#section-4.1 https://tools.ietf.org/html/rfc7230#section-4.1] 
[endsect][section:overload2 http::chunk_body::chunk_body (2 of 4 overloads)]
Constructor. [heading Synopsis]```chunk_body(    ConstBufferSequence const& buffers,    string_view extensions);```[heading Description]
This constructs buffers representing a complete ['chunk] with the passed chunk extensions and having the size and contents of the specified buffer sequence.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
A buffer sequence representing the chunk body. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid while this object is in use.  ]]  [[`extensions`][    
The chunk extensions string. This string must be formatted correctly as per rfc7230, using this BNF syntax: ```  chunk-ext       = *( ";" chunk-ext-name [ "=" chunk-ext-val ] )
  chunk-ext-name  = token
  chunk-ext-val   = token / quoted-string
```The data pointed to by this string view must remain valid for the lifetime of any operations performed on the object.  ]]]
[heading See Also]
[@https://tools.ietf.org/html/rfc7230#section-4.1.1 https://tools.ietf.org/html/rfc7230#section-4.1.1] 
[endsect][section:overload3 http::chunk_body::chunk_body (3 of 4 overloads)]
Constructor. [heading Synopsis]```template<    class ChunkExtensions>chunk_body(    ConstBufferSequence const& buffers,    ChunkExtensions&& extensions);```[heading Description]
This constructs buffers representing a complete ['chunk] with the passed chunk extensions and having the size and contents of the specified buffer sequence. The default allocator is used to provide storage for the extensions object.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
A buffer sequence representing the chunk body. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid while this object is in use.  ]]  [[`extensions`][    
The chunk extensions object. The expression `extensions.str()` must be valid, and the return type must be convertible to [link beast.ref.boost__beast__string_view `string_view`]. This object will be copied or moved as needed to ensure that the chunk header object retains ownership of the buffers provided by the chunk extensions object.  ]]]
[heading Remarks]
This function participates in overload resolution only if [*ChunkExtensions] meets the requirements stated above.
[heading See Also]
[@https://tools.ietf.org/html/rfc7230#section-4.1 https://tools.ietf.org/html/rfc7230#section-4.1] 
[endsect][section:overload4 http::chunk_body::chunk_body (4 of 4 overloads)]
Constructor. [heading Synopsis]```template<    class ChunkExtensions,    class __Allocator__>chunk_body(    ConstBufferSequence const& buffers,    ChunkExtensions&& extensions,    Allocator const& allocator);```[heading Description]
This constructs buffers representing a complete ['chunk] with the passed chunk extensions and having the size and contents of the specified buffer sequence. The specified allocator is used to provide storage for the extensions object.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
A buffer sequence representing the chunk body. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid while this object is in use.  ]]  [[`extensions`][    
The chunk extensions object. The expression `extensions.str()` must be valid, and the return type must be convertible to [link beast.ref.boost__beast__string_view `string_view`]. This object will be copied or moved as needed to ensure that the chunk header object retains ownership of the buffers provided by the chunk extensions object.  ]]  [[`allocator`][    
The allocator to provide storage for the moved or copied extensions object.  ]]]
[heading Remarks]
This function participates in overload resolution only if [*ChunkExtensions] meets the requirements stated above.
[heading See Also]
[@https://tools.ietf.org/html/rfc7230#section-4.1 https://tools.ietf.org/html/rfc7230#section-4.1] 
[endsect][endsect][section:const_iterator http::chunk_body::const_iterator][indexterm2 const_iterator..http::chunk_body]
Required for ['ConstBufferSequence] [heading Synopsis]```using const_iterator = ``['implementation-defined]``;```[heading Description][endsect][section:end http::chunk_body::end][indexterm2 end..http::chunk_body]
Required for ['ConstBufferSequence] [heading Synopsis]```const_iteratorend() const;```[heading Description][endsect][section:value_type http::chunk_body::value_type][indexterm2 value_type..http::chunk_body]
Required for ['ConstBufferSequence] [heading Synopsis]```using value_type = ``['implementation-defined]``;```[heading Description][endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__chunk_crlf http::chunk_crlf]
A chunked encoding crlf. [heading Synopsis]Defined in header [include_file boost/beast/http/chunk_encode.hpp]```struct chunk_crlf```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__chunk_crlf.const_iterator [*const_iterator]]]    [      Required for ConstBufferSequence     ]  ]  [    [[link beast.ref.boost__beast__http__chunk_crlf.value_type [*value_type]]]    [      Required for ConstBufferSequence     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__chunk_crlf.begin [*begin]]]    [      Required for ConstBufferSequence     ]  ]  [    [[link beast.ref.boost__beast__http__chunk_crlf.chunk_crlf [*chunk_crlf]]]    [      Constructor.       Required for ConstBufferSequence     ]  ]  [    [[link beast.ref.boost__beast__http__chunk_crlf.end [*end]]]    [      Required for ConstBufferSequence     ]  ]][heading Description]
This implements a ['ConstBufferSequence] holding the CRLF (`"\r\n"`) used as a delimiter in a ['chunk].
To use this class, pass an instance of it to a stream algorithm as the buffer sequence: ```  // writes "\r\n"
  net::write(stream, chunk_crlf{});
```
[heading See Also]
[@https://tools.ietf.org/html/rfc7230#section-4.1 https://tools.ietf.org/html/rfc7230#section-4.1] 
[section:begin http::chunk_crlf::begin][indexterm2 begin..http::chunk_crlf]
Required for ['ConstBufferSequence] [heading Synopsis]```const_iteratorbegin() const;```[heading Description][endsect][section:chunk_crlf http::chunk_crlf::chunk_crlf][indexterm2 chunk_crlf..http::chunk_crlf]
Constructor. `````[link beast.ref.boost__beast__http__chunk_crlf.chunk_crlf.overload1 chunk_crlf]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__chunk_crlf.chunk_crlf.overload1 more...]]`````
Required for ['ConstBufferSequence] `````[link beast.ref.boost__beast__http__chunk_crlf.chunk_crlf.overload2 chunk_crlf]``(    chunk_crlf const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__chunk_crlf.chunk_crlf.overload2 more...]]`````[section:overload1 http::chunk_crlf::chunk_crlf (1 of 2 overloads)]
Constructor. [heading Synopsis]```chunk_crlf();```[heading Description][endsect][section:overload2 http::chunk_crlf::chunk_crlf (2 of 2 overloads)]
Required for ['ConstBufferSequence] [heading Synopsis]```chunk_crlf(    chunk_crlf const&);```[heading Description][endsect][endsect][section:const_iterator http::chunk_crlf::const_iterator][indexterm2 const_iterator..http::chunk_crlf]
Required for ['ConstBufferSequence] [heading Synopsis]```using const_iterator = value_type const *;```[heading Description][endsect][section:end http::chunk_crlf::end][indexterm2 end..http::chunk_crlf]
Required for ['ConstBufferSequence] [heading Synopsis]```const_iteratorend() const;```[heading Description][endsect][section:value_type http::chunk_crlf::value_type][indexterm2 value_type..http::chunk_crlf]
Required for ['ConstBufferSequence] [heading Synopsis]```using value_type = ``['implementation-defined]``;```[heading Description][endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__chunk_extensions http::chunk_extensions][indexterm1 http::chunk_extensions]
A set of chunk extensions. [heading Synopsis]Defined in header [include_file boost/beast/http/chunk_encode.hpp]```using chunk_extensions = basic_chunk_extensions< std::allocator< char > >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_chunk_extensions.value_type [*value_type]]]    [      The type of value when iterating.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_chunk_extensions.basic_chunk_extensions [*basic_chunk_extensions]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_chunk_extensions.begin [*begin]]]    [          ]  ]  [    [[link beast.ref.boost__beast__http__basic_chunk_extensions.clear [*clear]]]    [      Clear the chunk extensions.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_chunk_extensions.end [*end]]]    [          ]  ]  [    [[link beast.ref.boost__beast__http__basic_chunk_extensions.insert [*insert]]]    [      Insert an extension name with an empty value.       Insert an extension value.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_chunk_extensions.parse [*parse]]]    [      Parse a set of chunk extensions.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_chunk_extensions.str [*str]]]    [      Return the serialized representation of the chunk extension.     ]  ]]
This container stores a set of chunk extensions suited for use with [link beast.ref.boost__beast__http__chunk_header `http::chunk_header`] and [link beast.ref.boost__beast__http__chunk_body `http::chunk_body`]. The container may be iterated to access the extensions in their structured form.
Meets the requirements of ChunkExtensions [heading Description]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__chunk_header http::chunk_header]
A ['chunk] header. [heading Synopsis]Defined in header [include_file boost/beast/http/chunk_encode.hpp]```class chunk_header```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__chunk_header.const_iterator [*const_iterator]]]    [      Required for ConstBufferSequence     ]  ]  [    [[link beast.ref.boost__beast__http__chunk_header.value_type [*value_type]]]    [      Required for ConstBufferSequence     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__chunk_header.begin [*begin]]]    [      Required for ConstBufferSequence     ]  ]  [    [[link beast.ref.boost__beast__http__chunk_header.chunk_header [*chunk_header]]]    [      Constructor.       Required for ConstBufferSequence     ]  ]  [    [[link beast.ref.boost__beast__http__chunk_header.end [*end]]]    [      Required for ConstBufferSequence     ]  ]][heading Description]
This implements a ['ConstBufferSequence] representing the header of a ['chunk]. The serialized format is as follows: ```  chunk-header    = 1*HEXDIG chunk-ext CRLF       
  chunk-ext       = *( ";" chunk-ext-name [ "=" chunk-ext-val ] )
  chunk-ext-name  = token
  chunk-ext-val   = token / quoted-string
```The chunk extension is optional. After the header and chunk body have been serialized, it is the callers responsibility to also serialize the final CRLF (`"\r\n"`).
This class allows the caller to emit piecewise chunk bodies, by first serializing the chunk header using this class and then serializing the chunk body in a series of one or more calls to a stream write operation.
To use this class, pass an instance of it to a stream algorithm as the buffer sequence: ```  // writes "400;x\r\n"
  net::write(stream, chunk_header{1024, "x"});
```
[heading See Also]
[@https://tools.ietf.org/html/rfc7230#section-4.1 https://tools.ietf.org/html/rfc7230#section-4.1] 
[section:begin http::chunk_header::begin][indexterm2 begin..http::chunk_header]
Required for ['ConstBufferSequence] [heading Synopsis]```const_iteratorbegin() const;```[heading Description][endsect][section:chunk_header http::chunk_header::chunk_header][indexterm2 chunk_header..http::chunk_header]
Constructor. ```explicit``[link beast.ref.boost__beast__http__chunk_header.chunk_header.overload1 chunk_header]``(    std::size_t size);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__chunk_header.chunk_header.overload1 more...]]````[link beast.ref.boost__beast__http__chunk_header.chunk_header.overload2 chunk_header]``(    std::size_t size,    string_view extensions);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__chunk_header.chunk_header.overload2 more...]]``template<    class ChunkExtensions>``[link beast.ref.boost__beast__http__chunk_header.chunk_header.overload3 chunk_header]``(    std::size_t size,    ChunkExtensions&& extensions);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__chunk_header.chunk_header.overload3 more...]]``template<    class ChunkExtensions,    class __Allocator__>``[link beast.ref.boost__beast__http__chunk_header.chunk_header.overload4 chunk_header]``(    std::size_t size,    ChunkExtensions&& extensions,    Allocator const& allocator);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__chunk_header.chunk_header.overload4 more...]]`````
Required for ['ConstBufferSequence] `````[link beast.ref.boost__beast__http__chunk_header.chunk_header.overload5 chunk_header]``(    chunk_header const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__chunk_header.chunk_header.overload5 more...]]`````[section:overload1 http::chunk_header::chunk_header (1 of 5 overloads)]
Constructor. [heading Synopsis]```chunk_header(    std::size_t size);```[heading Description]
This constructs a buffer sequence representing a ['chunked-body] size and terminating CRLF (`"\r\n"`) with no chunk extensions.
[heading Parameters][table [[Name][Description]]  [[`size`][    
The size of the chunk body that follows. The value must be greater than zero.  ]]]
[heading See Also]
[@https://tools.ietf.org/html/rfc7230#section-4.1 https://tools.ietf.org/html/rfc7230#section-4.1] 
[endsect][section:overload2 http::chunk_header::chunk_header (2 of 5 overloads)]
Constructor. [heading Synopsis]```chunk_header(    std::size_t size,    string_view extensions);```[heading Description]
This constructs a buffer sequence representing a ['chunked-body] size and terminating CRLF (`"\r\n"`) with provided chunk extensions.
[heading Parameters][table [[Name][Description]]  [[`size`][    
The size of the chunk body that follows. The value must be greater than zero.  ]]  [[`extensions`][    
The chunk extensions string. This string must be formatted correctly as per rfc7230, using this BNF syntax: ```  chunk-ext       = *( ";" chunk-ext-name [ "=" chunk-ext-val ] )
  chunk-ext-name  = token
  chunk-ext-val   = token / quoted-string
```The data pointed to by this string view must remain valid for the lifetime of any operations performed on the object.  ]]]
[heading See Also]
[@https://tools.ietf.org/html/rfc7230#section-4.1.1 https://tools.ietf.org/html/rfc7230#section-4.1.1] 
[endsect][section:overload3 http::chunk_header::chunk_header (3 of 5 overloads)]
Constructor. [heading Synopsis]```template<    class ChunkExtensions>chunk_header(    std::size_t size,    ChunkExtensions&& extensions);```[heading Description]
This constructs a buffer sequence representing a ['chunked-body] size and terminating CRLF (`"\r\n"`) with provided chunk extensions. The default allocator is used to provide storage for the extensions object.
[heading Parameters][table [[Name][Description]]  [[`size`][    
The size of the chunk body that follows. The value must be greater than zero.  ]]  [[`extensions`][    
The chunk extensions object. The expression `extensions.str()` must be valid, and the return type must be convertible to [link beast.ref.boost__beast__string_view `string_view`]. This object will be copied or moved as needed to ensure that the chunk header object retains ownership of the buffers provided by the chunk extensions object.  ]]]
[heading Remarks]
This function participates in overload resolution only if [*ChunkExtensions] meets the requirements stated above.
[heading See Also]
[@https://tools.ietf.org/html/rfc7230#section-4.1 https://tools.ietf.org/html/rfc7230#section-4.1] 
[endsect][section:overload4 http::chunk_header::chunk_header (4 of 5 overloads)]
Constructor. [heading Synopsis]```template<    class ChunkExtensions,    class __Allocator__>chunk_header(    std::size_t size,    ChunkExtensions&& extensions,    Allocator const& allocator);```[heading Description]
This constructs a buffer sequence representing a ['chunked-body] size and terminating CRLF (`"\r\n"`) with provided chunk extensions. The specified allocator is used to provide storage for the extensions object.
[heading Parameters][table [[Name][Description]]  [[`size`][    
The size of the chunk body that follows. The value be greater than zero.  ]]  [[`extensions`][    
The chunk extensions object. The expression `extensions.str()` must be valid, and the return type must be convertible to [link beast.ref.boost__beast__string_view `string_view`]. This object will be copied or moved as needed to ensure that the chunk header object retains ownership of the buffers provided by the chunk extensions object.  ]]  [[`allocator`][    
The allocator to provide storage for the moved or copied extensions object.  ]]]
[heading Remarks]
This function participates in overload resolution only if [*ChunkExtensions] meets the requirements stated above.
[heading See Also]
[@https://tools.ietf.org/html/rfc7230#section-4.1 https://tools.ietf.org/html/rfc7230#section-4.1] 
[endsect][section:overload5 http::chunk_header::chunk_header (5 of 5 overloads)]
Required for ['ConstBufferSequence] [heading Synopsis]```chunk_header(    chunk_header const&);```[heading Description][endsect][endsect][section:const_iterator http::chunk_header::const_iterator][indexterm2 const_iterator..http::chunk_header]
Required for ['ConstBufferSequence] [heading Synopsis]```using const_iterator = ``['implementation-defined]``;```[heading Description][endsect][section:end http::chunk_header::end][indexterm2 end..http::chunk_header]
Required for ['ConstBufferSequence] [heading Synopsis]```const_iteratorend() const;```[heading Description][endsect][section:value_type http::chunk_header::value_type][indexterm2 value_type..http::chunk_header]
Required for ['ConstBufferSequence] [heading Synopsis]```using value_type = ``['implementation-defined]``;```[heading Description][endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__chunk_last http::chunk_last]
A chunked-encoding last chunk. [heading Synopsis]Defined in header [include_file boost/beast/http/chunk_encode.hpp]```template<    class Trailer = chunk_crlf>class chunk_last```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__chunk_last.const_iterator [*const_iterator]]]    [      Required for ConstBufferSequence     ]  ]  [    [[link beast.ref.boost__beast__http__chunk_last.value_type [*value_type]]]    [      Required for ConstBufferSequence     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__chunk_last.begin [*begin]]]    [      Required for ConstBufferSequence     ]  ]  [    [[link beast.ref.boost__beast__http__chunk_last.chunk_last [*chunk_last]]]    [      Constructor.       Required for ConstBufferSequence     ]  ]  [    [[link beast.ref.boost__beast__http__chunk_last.end [*end]]]    [      Required for ConstBufferSequence     ]  ]][heading Description][section:begin http::chunk_last::begin][indexterm2 begin..http::chunk_last]
Required for ['ConstBufferSequence] [heading Synopsis]```const_iteratorbegin() const;```[heading Description][endsect][section:chunk_last http::chunk_last::chunk_last][indexterm2 chunk_last..http::chunk_last]
Constructor. `````[link beast.ref.boost__beast__http__chunk_last.chunk_last.overload1 chunk_last]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__chunk_last.chunk_last.overload1 more...]]``explicit``[link beast.ref.boost__beast__http__chunk_last.chunk_last.overload2 chunk_last]``(    Trailer const& trailer);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__chunk_last.chunk_last.overload2 more...]]``template<    class __Allocator__>``[link beast.ref.boost__beast__http__chunk_last.chunk_last.overload3 chunk_last]``(    Trailer const& trailer,    Allocator const& allocator);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__chunk_last.chunk_last.overload3 more...]]`````
Required for ['ConstBufferSequence] `````[link beast.ref.boost__beast__http__chunk_last.chunk_last.overload4 chunk_last]``(    chunk_last const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__chunk_last.chunk_last.overload4 more...]]`````[section:overload1 http::chunk_last::chunk_last (1 of 4 overloads)]
Constructor. [heading Synopsis]```chunk_last();```[heading Description]
The last chunk will have an empty trailer [endsect][section:overload2 http::chunk_last::chunk_last (2 of 4 overloads)]
Constructor. [heading Synopsis]```chunk_last(    Trailer const& trailer);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`trailer`][    
The trailer to use. This may be a type meeting the requirements of either Fields or ConstBufferSequence. If it is a ConstBufferSequence, the trailer must be formatted correctly as per rfc7230 including a CRLF on its own line to denote the end of the trailer.   ]]]
[endsect][section:overload3 http::chunk_last::chunk_last (3 of 4 overloads)]
Constructor. [heading Synopsis]```template<    class __Allocator__>chunk_last(    Trailer const& trailer,    Allocator const& allocator);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`trailer`][    
The trailer to use. This type must meet the requirements of Fields.  ]]  [[`allocator`][    
The allocator to use for storing temporary data associated with the serialized trailer buffers.   ]]]
[endsect][section:overload4 http::chunk_last::chunk_last (4 of 4 overloads)]
Required for ['ConstBufferSequence] [heading Synopsis]```chunk_last(    chunk_last const&);```[heading Description][endsect][endsect][section:const_iterator http::chunk_last::const_iterator][indexterm2 const_iterator..http::chunk_last]
Required for ['ConstBufferSequence] [heading Synopsis]```using const_iterator = ``['implementation-defined]``;```[heading Description][endsect][section:end http::chunk_last::end][indexterm2 end..http::chunk_last]
Required for ['ConstBufferSequence] [heading Synopsis]```const_iteratorend() const;```[heading Description][endsect][section:value_type http::chunk_last::value_type][indexterm2 value_type..http::chunk_last]
Required for ['ConstBufferSequence] [heading Synopsis]```using value_type = ``['implementation-defined]``;```[heading Description][endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__dynamic_body http::dynamic_body][indexterm1 http::dynamic_body]
A dynamic message body represented by a [link beast.ref.boost__beast__multi_buffer `multi_buffer`]. [heading Synopsis]Defined in header [include_file boost/beast/http/dynamic_body.hpp]```using dynamic_body = basic_dynamic_body< multi_buffer >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_dynamic_body.reader [*reader]]]    [      The algorithm for parsing the body.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_dynamic_body.value_type [*value_type]]]    [      The type of container used for the body.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_dynamic_body.writer [*writer]]]    [      The algorithm for serializing the body.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_dynamic_body.size [*size]]]    [      Returns the payload size of the body.     ]  ]]
This body uses a ['DynamicBuffer] as a memory-based container for holding message payloads. Messages using this body type may be serialized and parsed. [heading Description]
Meets the requirements of ['Body]. Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__empty_body http::empty_body]
An empty ['Body] [heading Synopsis]Defined in header [include_file boost/beast/http/empty_body.hpp]```struct empty_body```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__empty_body__value_type [*value_type]]]    [      The type of container used for the body.     ]  ]  [    [[link beast.ref.boost__beast__http__empty_body.reader [*reader]]]    [      The algorithm for parsing the body.     ]  ]  [    [[link beast.ref.boost__beast__http__empty_body.writer [*writer]]]    [      The algorithm for serializing the body.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__empty_body.size [*size]]]    [      Returns the payload size of the body.     ]  ]][heading Description]
This body is used to represent messages which do not have a message body. If this body is used with a parser, and the parser encounters octets corresponding to a message body, the parser will fail with the error [link beast.ref.boost__beast__http__error `http::unexpected_body`].
The Content-Length of this body is always 0. [section:reader http::empty_body::reader][indexterm2 reader..http::empty_body]
The algorithm for parsing the body. [heading Synopsis]```using reader = ``['implementation-defined]``;```[heading Description]
Meets the requirements of ['BodyReader]. [endsect][section:size http::empty_body::size][indexterm2 size..http::empty_body]
Returns the payload size of the body. [heading Synopsis]```staticstd::uint64_tsize(    value_type);```[heading Description]
When this body is used with [link beast.ref.boost__beast__http__message.prepare_payload `http::message::prepare_payload`], the Content-Length will be set to the payload size, and any chunked Transfer-Encoding will be removed. [endsect][section:writer http::empty_body::writer][indexterm2 writer..http::empty_body]
The algorithm for serializing the body. [heading Synopsis]```using writer = ``['implementation-defined]``;```[heading Description]
Meets the requirements of ['BodyWriter]. [endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__empty_body__value_type http::empty_body::value_type]
The type of container used for the body. [heading Synopsis]Defined in header [include_file boost/beast/http/empty_body.hpp]```struct value_type```[heading Description]
This determines the type of [link beast.ref.boost__beast__http__message.body `http::message::body`] when this body type is used with a message container. Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__error http::error][indexterm1 http::error]
Error codes returned from HTTP algorithms and operations. [heading Synopsis]Defined in header [include_file boost/beast/http/error.hpp]```enum error```[indexterm2 end_of_stream..http::error][indexterm2 partial_message..http::error][indexterm2 need_more..http::error][indexterm2 unexpected_body..http::error][indexterm2 need_buffer..http::error][indexterm2 end_of_chunk..http::error][indexterm2 buffer_overflow..http::error][indexterm2 header_limit..http::error][indexterm2 body_limit..http::error][indexterm2 bad_alloc..http::error][indexterm2 bad_line_ending..http::error][indexterm2 bad_method..http::error][indexterm2 bad_target..http::error][indexterm2 bad_version..http::error][indexterm2 bad_status..http::error][indexterm2 bad_reason..http::error][indexterm2 bad_field..http::error][indexterm2 bad_value..http::error][indexterm2 bad_content_length..http::error][indexterm2 bad_transfer_encoding..http::error][indexterm2 bad_chunk..http::error][indexterm2 bad_chunk_extension..http::error][indexterm2 bad_obs_fold..http::error][indexterm2 stale_parser..http::error][heading Values][table [[Name][Description]]  [[[^end_of_stream]][The end of the stream was reached. This error is returned when attempting to read HTTP data,
and the stream returns the error `net::error::eof`
before any octets corresponding to a new HTTP message have
been received.
 ]]  [[[^partial_message]][The incoming message is incomplete. This happens when the end of stream is reached during
parsing and some octets have been received, but not the
entire message.
 ]]  [[[^need_more]][Additional buffers are required. This error is returned during parsing when additional
octets are needed. The caller should append more data
to the existing buffer and retry the parse operaetion.
 ]]  [[[^unexpected_body]][An unexpected body was encountered during parsing. This error is returned when attempting to parse body
octets into a message container which has the
@ref empty_body body type.

@see empty_body
 ]]  [[[^need_buffer]][Additional buffers are required. This error is returned under the following conditions:

@li During serialization when using @ref buffer_body.
The caller should update the body to point to a new
buffer or indicate that there are no more octets in
the body.

@li During parsing when using @ref buffer_body.
The caller should update the body to point to a new
storage area to receive additional body octets.
 ]]  [[[^end_of_chunk]][The end of a chunk was reached. ]]  [[[^buffer_overflow]][Buffer maximum exceeded. This error is returned when reading HTTP content
into a dynamic buffer, and the operation would
exceed the maximum size of the buffer.
 ]]  [[[^header_limit]][Header limit exceeded. The parser detected an incoming message header which
exceeded a configured limit.
 ]]  [[[^body_limit]][Body limit exceeded. The parser detected an incoming message body which
exceeded a configured limit.
 ]]  [[[^bad_alloc]][A memory allocation failed. When basic_fields throws std::bad_alloc, it is
converted into this error by @ref parser.
 ]]  [[[^bad_line_ending]][The line ending was malformed. ]]  [[[^bad_method]][The method is invalid. ]]  [[[^bad_target]][The request-target is invalid. ]]  [[[^bad_version]][The HTTP-version is invalid. ]]  [[[^bad_status]][The status-code is invalid. ]]  [[[^bad_reason]][The reason-phrase is invalid. ]]  [[[^bad_field]][The field name is invalid. ]]  [[[^bad_value]][The field value is invalid. ]]  [[[^bad_content_length]][The Content-Length is invalid. ]]  [[[^bad_transfer_encoding]][The Transfer-Encoding is invalid. ]]  [[[^bad_chunk]][The chunk syntax is invalid. ]]  [[[^bad_chunk_extension]][The chunk extension is invalid. ]]  [[[^bad_obs_fold]][An obs-fold exceeded an internal limit. ]]  [[[^stale_parser]][The parser is stale. This happens when attempting to re-use a parser that has
already completed parsing a message. Programs must construct
a new parser for each message. This can be easily done by
storing the parser in an boost or std::optional container.
 ]]][heading Description]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__ext_list http::ext_list]
A list of extensions in a comma separated HTTP field value. [heading Synopsis]Defined in header [include_file boost/beast/http/rfc7230.hpp]```class ext_list```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__ext_list.const_iterator [*const_iterator]]]    [      A constant iterator to the list.     ]  ]  [    [[link beast.ref.boost__beast__http__ext_list.value_type [*value_type]]]    [      The type of each element in the list.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__ext_list.begin [*begin]]]    [      Return a const iterator to the beginning of the list.     ]  ]  [    [[link beast.ref.boost__beast__http__ext_list.cbegin [*cbegin]]]    [      Return a const iterator to the beginning of the list.     ]  ]  [    [[link beast.ref.boost__beast__http__ext_list.cend [*cend]]]    [      Return a const iterator to the end of the list.     ]  ]  [    [[link beast.ref.boost__beast__http__ext_list.end [*end]]]    [      Return a const iterator to the end of the list.     ]  ]  [    [[link beast.ref.boost__beast__http__ext_list.exists [*exists]]]    [      Return true if a token is present in the list.     ]  ]  [    [[link beast.ref.boost__beast__http__ext_list.ext_list [*ext_list]]]    [      Construct a list.     ]  ]  [    [[link beast.ref.boost__beast__http__ext_list.find [*find]]]    [      Find a token in the list.     ]  ]][heading Description]
This container allows iteration of the extensions in an HTTP field value. The extension list is a comma separated list of token parameter list pairs.
If a parsing error is encountered while iterating the string, the behavior of the container will be as if a string containing only characters up to but excluding the first invalid character was used to construct the list.
[heading BNF]
```  ext-list    = *( "," OWS ) ext *( OWS "," [ OWS ext ] )
  ext         = token param-list
  param-list  = *( OWS ";" OWS param )
  param       = token OWS [ "=" OWS ( token / quoted-string ) ]
```
To use this class, construct with the string to be parsed and then use [link beast.ref.boost__beast__http__ext_list.begin `http::ext_list::begin`] and [link beast.ref.boost__beast__http__ext_list.end `http::ext_list::end`], or range-for to iterate each item:
[heading Example]
```  for(auto const& ext : ext_list{"none, 7z;level=9, zip;no_context_takeover;bits=15"})
  {
      std::cout << ext.first << "\n";
      for(auto const& param : ext.second)
      {
          std::cout << ";" << param.first;
          if(! param.second.empty())
              std::cout << "=" << param.second;
          std::cout << "\n";
      }
  }
```
[section:begin http::ext_list::begin][indexterm2 begin..http::ext_list]
Return a const iterator to the beginning of the list. [heading Synopsis]```const_iteratorbegin() const;```[heading Description][endsect][section:cbegin http::ext_list::cbegin][indexterm2 cbegin..http::ext_list]
Return a const iterator to the beginning of the list. [heading Synopsis]```const_iteratorcbegin() const;```[heading Description][endsect][section:cend http::ext_list::cend][indexterm2 cend..http::ext_list]
Return a const iterator to the end of the list. [heading Synopsis]```const_iteratorcend() const;```[heading Description][endsect][section:const_iterator http::ext_list::const_iterator][indexterm2 const_iterator..http::ext_list]
A constant iterator to the list. [heading Synopsis]```using const_iterator = ``['implementation-defined]``;```[heading Description][endsect][section:end http::ext_list::end][indexterm2 end..http::ext_list]
Return a const iterator to the end of the list. [heading Synopsis]```const_iteratorend() const;```[heading Description][endsect][section:exists http::ext_list::exists][indexterm2 exists..http::ext_list]
Return `true` if a token is present in the list. [heading Synopsis]```boolexists(    string_view const& s);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`s`][    
The token to find. A case-insensitive comparison is used.   ]]]
[endsect][section:ext_list http::ext_list::ext_list][indexterm2 ext_list..http::ext_list]
Construct a list. [heading Synopsis]```ext_list(    string_view s);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`s`][    
A string containing the list contents. The string must remain valid for the lifetime of the container.   ]]]
[endsect][section:find http::ext_list::find][indexterm2 find..http::ext_list]
Find a token in the list. [heading Synopsis]```const_iteratorfind(    string_view const& s);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`s`][    
The token to find. A case-insensitive comparison is used.  ]]]
[heading Return Value]
An iterator to the matching token, or `end()` if no token exists. 
[endsect][section:value_type http::ext_list::value_type][indexterm2 value_type..http::ext_list]
The type of each element in the list. [heading Synopsis]```using value_type = std::pair< string_view, param_list >;```[heading Description]
The first element of the pair is the extension token, and the second element of the pair is an iterable container holding the extension's name/value parameters. [endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__field http::field][indexterm1 http::field][heading Synopsis]Defined in header [include_file boost/beast/http/field.hpp]```enum field```[indexterm2 unknown..http::field][indexterm2 a_im..http::field][indexterm2 accept..http::field][indexterm2 accept_additions..http::field][indexterm2 accept_charset..http::field][indexterm2 accept_datetime..http::field][indexterm2 accept_encoding..http::field][indexterm2 accept_features..http::field][indexterm2 accept_language..http::field][indexterm2 accept_patch..http::field][indexterm2 accept_post..http::field][indexterm2 accept_ranges..http::field][indexterm2 access_control..http::field][indexterm2 access_control_allow_credentials..http::field][indexterm2 access_control_allow_headers..http::field][indexterm2 access_control_allow_methods..http::field][indexterm2 access_control_allow_origin..http::field][indexterm2 access_control_expose_headers..http::field][indexterm2 access_control_max_age..http::field][indexterm2 access_control_request_headers..http::field][indexterm2 access_control_request_method..http::field][indexterm2 age..http::field][indexterm2 allow..http::field][indexterm2 alpn..http::field][indexterm2 also_control..http::field][indexterm2 alt_svc..http::field][indexterm2 alt_used..http::field][indexterm2 alternate_recipient..http::field][indexterm2 alternates..http::field][indexterm2 apparently_to..http::field][indexterm2 apply_to_redirect_ref..http::field][indexterm2 approved..http::field][indexterm2 archive..http::field][indexterm2 archived_at..http::field][indexterm2 article_names..http::field][indexterm2 article_updates..http::field][indexterm2 authentication_control..http::field][indexterm2 authentication_info..http::field][indexterm2 authentication_results..http::field][indexterm2 authorization..http::field][indexterm2 auto_submitted..http::field][indexterm2 autoforwarded..http::field][indexterm2 autosubmitted..http::field][indexterm2 base..http::field][indexterm2 bcc..http::field][indexterm2 body..http::field][indexterm2 c_ext..http::field][indexterm2 c_man..http::field][indexterm2 c_opt..http::field][indexterm2 c_pep..http::field][indexterm2 c_pep_info..http::field][indexterm2 cache_control..http::field][indexterm2 caldav_timezones..http::field][indexterm2 cancel_key..http::field][indexterm2 cancel_lock..http::field][indexterm2 cc..http::field][indexterm2 close..http::field][indexterm2 comments..http::field][indexterm2 compliance..http::field][indexterm2 connection..http::field][indexterm2 content_alternative..http::field][indexterm2 content_base..http::field][indexterm2 content_description..http::field][indexterm2 content_disposition..http::field][indexterm2 content_duration..http::field][indexterm2 content_encoding..http::field][indexterm2 content_features..http::field][indexterm2 content_id..http::field][indexterm2 content_identifier..http::field][indexterm2 content_language..http::field][indexterm2 content_length..http::field][indexterm2 content_location..http::field][indexterm2 content_md5..http::field][indexterm2 content_range..http::field][indexterm2 content_return..http::field][indexterm2 content_script_type..http::field][indexterm2 content_style_type..http::field][indexterm2 content_transfer_encoding..http::field][indexterm2 content_type..http::field][indexterm2 content_version..http::field][indexterm2 control..http::field][indexterm2 conversion..http::field][indexterm2 conversion_with_loss..http::field][indexterm2 cookie..http::field][indexterm2 cookie2..http::field][indexterm2 cost..http::field][indexterm2 dasl..http::field][indexterm2 date..http::field][indexterm2 date_received..http::field][indexterm2 dav..http::field][indexterm2 default_style..http::field][indexterm2 deferred_delivery..http::field][indexterm2 delivery_date..http::field][indexterm2 delta_base..http::field][indexterm2 depth..http::field][indexterm2 derived_from..http::field][indexterm2 destination..http::field][indexterm2 differential_id..http::field][indexterm2 digest..http::field][indexterm2 discarded_x400_ipms_extensions..http::field][indexterm2 discarded_x400_mts_extensions..http::field][indexterm2 disclose_recipients..http::field][indexterm2 disposition_notification_options..http::field][indexterm2 disposition_notification_to..http::field][indexterm2 distribution..http::field][indexterm2 dkim_signature..http::field][indexterm2 dl_expansion_history..http::field][indexterm2 downgraded_bcc..http::field][indexterm2 downgraded_cc..http::field][indexterm2 downgraded_disposition_notification_to..http::field][indexterm2 downgraded_final_recipient..http::field][indexterm2 downgraded_from..http::field][indexterm2 downgraded_in_reply_to..http::field][indexterm2 downgraded_mail_from..http::field][indexterm2 downgraded_message_id..http::field][indexterm2 downgraded_original_recipient..http::field][indexterm2 downgraded_rcpt_to..http::field][indexterm2 downgraded_references..http::field][indexterm2 downgraded_reply_to..http::field][indexterm2 downgraded_resent_bcc..http::field][indexterm2 downgraded_resent_cc..http::field][indexterm2 downgraded_resent_from..http::field][indexterm2 downgraded_resent_reply_to..http::field][indexterm2 downgraded_resent_sender..http::field][indexterm2 downgraded_resent_to..http::field][indexterm2 downgraded_return_path..http::field][indexterm2 downgraded_sender..http::field][indexterm2 downgraded_to..http::field][indexterm2 ediint_features..http::field][indexterm2 eesst_version..http::field][indexterm2 encoding..http::field][indexterm2 encrypted..http::field][indexterm2 errors_to..http::field][indexterm2 etag..http::field][indexterm2 expect..http::field][indexterm2 expires..http::field][indexterm2 expiry_date..http::field][indexterm2 ext..http::field][indexterm2 followup_to..http::field][indexterm2 forwarded..http::field][indexterm2 from..http::field][indexterm2 generate_delivery_report..http::field][indexterm2 getprofile..http::field][indexterm2 hobareg..http::field][indexterm2 host..http::field][indexterm2 http2_settings..http::field][indexterm2 if_..http::field][indexterm2 if_match..http::field][indexterm2 if_modified_since..http::field][indexterm2 if_none_match..http::field][indexterm2 if_range..http::field][indexterm2 if_schedule_tag_match..http::field][indexterm2 if_unmodified_since..http::field][indexterm2 im..http::field][indexterm2 importance..http::field][indexterm2 in_reply_to..http::field][indexterm2 incomplete_copy..http::field][indexterm2 injection_date..http::field][indexterm2 injection_info..http::field][indexterm2 jabber_id..http::field][indexterm2 keep_alive..http::field][indexterm2 keywords..http::field][indexterm2 label..http::field][indexterm2 language..http::field][indexterm2 last_modified..http::field][indexterm2 latest_delivery_time..http::field][indexterm2 lines..http::field][indexterm2 link..http::field][indexterm2 list_archive..http::field][indexterm2 list_help..http::field][indexterm2 list_id..http::field][indexterm2 list_owner..http::field][indexterm2 list_post..http::field][indexterm2 list_subscribe..http::field][indexterm2 list_unsubscribe..http::field][indexterm2 list_unsubscribe_post..http::field][indexterm2 location..http::field][indexterm2 lock_token..http::field][indexterm2 man..http::field][indexterm2 max_forwards..http::field][indexterm2 memento_datetime..http::field][indexterm2 message_context..http::field][indexterm2 message_id..http::field][indexterm2 message_type..http::field][indexterm2 meter..http::field][indexterm2 method_check..http::field][indexterm2 method_check_expires..http::field][indexterm2 mime_version..http::field][indexterm2 mmhs_acp127_message_identifier..http::field][indexterm2 mmhs_authorizing_users..http::field][indexterm2 mmhs_codress_message_indicator..http::field][indexterm2 mmhs_copy_precedence..http::field][indexterm2 mmhs_exempted_address..http::field][indexterm2 mmhs_extended_authorisation_info..http::field][indexterm2 mmhs_handling_instructions..http::field][indexterm2 mmhs_message_instructions..http::field][indexterm2 mmhs_message_type..http::field][indexterm2 mmhs_originator_plad..http::field][indexterm2 mmhs_originator_reference..http::field][indexterm2 mmhs_other_recipients_indicator_cc..http::field][indexterm2 mmhs_other_recipients_indicator_to..http::field][indexterm2 mmhs_primary_precedence..http::field][indexterm2 mmhs_subject_indicator_codes..http::field][indexterm2 mt_priority..http::field][indexterm2 negotiate..http::field][indexterm2 newsgroups..http::field][indexterm2 nntp_posting_date..http::field][indexterm2 nntp_posting_host..http::field][indexterm2 non_compliance..http::field][indexterm2 obsoletes..http::field][indexterm2 opt..http::field][indexterm2 optional..http::field][indexterm2 optional_www_authenticate..http::field][indexterm2 ordering_type..http::field][indexterm2 organization..http::field][indexterm2 origin..http::field][indexterm2 original_encoded_information_types..http::field][indexterm2 original_from..http::field][indexterm2 original_message_id..http::field][indexterm2 original_recipient..http::field][indexterm2 original_sender..http::field][indexterm2 original_subject..http::field][indexterm2 originator_return_address..http::field][indexterm2 overwrite..http::field][indexterm2 p3p..http::field][indexterm2 path..http::field][indexterm2 pep..http::field][indexterm2 pep_info..http::field][indexterm2 pics_label..http::field][indexterm2 position..http::field][indexterm2 posting_version..http::field][indexterm2 pragma..http::field][indexterm2 prefer..http::field][indexterm2 preference_applied..http::field][indexterm2 prevent_nondelivery_report..http::field][indexterm2 priority..http::field][indexterm2 privicon..http::field][indexterm2 profileobject..http::field][indexterm2 protocol..http::field][indexterm2 protocol_info..http::field][indexterm2 protocol_query..http::field][indexterm2 protocol_request..http::field][indexterm2 proxy_authenticate..http::field][indexterm2 proxy_authentication_info..http::field][indexterm2 proxy_authorization..http::field][indexterm2 proxy_connection..http::field][indexterm2 proxy_features..http::field][indexterm2 proxy_instruction..http::field][indexterm2 public_..http::field][indexterm2 public_key_pins..http::field][indexterm2 public_key_pins_report_only..http::field][indexterm2 range..http::field][indexterm2 received..http::field][indexterm2 received_spf..http::field][indexterm2 redirect_ref..http::field][indexterm2 references..http::field][indexterm2 referer..http::field][indexterm2 referer_root..http::field][indexterm2 relay_version..http::field][indexterm2 reply_by..http::field][indexterm2 reply_to..http::field][indexterm2 require_recipient_valid_since..http::field][indexterm2 resent_bcc..http::field][indexterm2 resent_cc..http::field][indexterm2 resent_date..http::field][indexterm2 resent_from..http::field][indexterm2 resent_message_id..http::field][indexterm2 resent_reply_to..http::field][indexterm2 resent_sender..http::field][indexterm2 resent_to..http::field][indexterm2 resolution_hint..http::field][indexterm2 resolver_location..http::field][indexterm2 retry_after..http::field][indexterm2 return_path..http::field][indexterm2 safe..http::field][indexterm2 schedule_reply..http::field][indexterm2 schedule_tag..http::field][indexterm2 sec_websocket_accept..http::field][indexterm2 sec_websocket_extensions..http::field][indexterm2 sec_websocket_key..http::field][indexterm2 sec_websocket_protocol..http::field][indexterm2 sec_websocket_version..http::field][indexterm2 security_scheme..http::field][indexterm2 see_also..http::field][indexterm2 sender..http::field][indexterm2 sensitivity..http::field][indexterm2 server..http::field][indexterm2 set_cookie..http::field][indexterm2 set_cookie2..http::field][indexterm2 setprofile..http::field][indexterm2 sio_label..http::field][indexterm2 sio_label_history..http::field][indexterm2 slug..http::field][indexterm2 soapaction..http::field][indexterm2 solicitation..http::field][indexterm2 status_uri..http::field][indexterm2 strict_transport_security..http::field][indexterm2 subject..http::field][indexterm2 subok..http::field][indexterm2 subst..http::field][indexterm2 summary..http::field][indexterm2 supersedes..http::field][indexterm2 surrogate_capability..http::field][indexterm2 surrogate_control..http::field][indexterm2 tcn..http::field][indexterm2 te..http::field][indexterm2 timeout..http::field][indexterm2 title..http::field][indexterm2 to..http::field][indexterm2 topic..http::field][indexterm2 trailer..http::field][indexterm2 transfer_encoding..http::field][indexterm2 ttl..http::field][indexterm2 ua_color..http::field][indexterm2 ua_media..http::field][indexterm2 ua_pixels..http::field][indexterm2 ua_resolution..http::field][indexterm2 ua_windowpixels..http::field][indexterm2 upgrade..http::field][indexterm2 urgency..http::field][indexterm2 uri..http::field][indexterm2 user_agent..http::field][indexterm2 variant_vary..http::field][indexterm2 vary..http::field][indexterm2 vbr_info..http::field][indexterm2 version..http::field][indexterm2 via..http::field][indexterm2 want_digest..http::field][indexterm2 warning..http::field][indexterm2 www_authenticate..http::field][indexterm2 x_archived_at..http::field][indexterm2 x_device_accept..http::field][indexterm2 x_device_accept_charset..http::field][indexterm2 x_device_accept_encoding..http::field][indexterm2 x_device_accept_language..http::field][indexterm2 x_device_user_agent..http::field][indexterm2 x_frame_options..http::field][indexterm2 x_mittente..http::field][indexterm2 x_pgp_sig..http::field][indexterm2 x_ricevuta..http::field][indexterm2 x_riferimento_message_id..http::field][indexterm2 x_tiporicevuta..http::field][indexterm2 x_trasporto..http::field][indexterm2 x_verificasicurezza..http::field][indexterm2 x400_content_identifier..http::field][indexterm2 x400_content_return..http::field][indexterm2 x400_content_type..http::field][indexterm2 x400_mts_identifier..http::field][indexterm2 x400_originator..http::field][indexterm2 x400_received..http::field][indexterm2 x400_recipients..http::field][indexterm2 x400_trace..http::field][indexterm2 xref..http::field][heading Values][table [[Name][Description]]  [[[^unknown]][]]  [[[^a_im]][]]  [[[^accept]][]]  [[[^accept_additions]][]]  [[[^accept_charset]][]]  [[[^accept_datetime]][]]  [[[^accept_encoding]][]]  [[[^accept_features]][]]  [[[^accept_language]][]]  [[[^accept_patch]][]]  [[[^accept_post]][]]  [[[^accept_ranges]][]]  [[[^access_control]][]]  [[[^access_control_allow_credentials]][]]  [[[^access_control_allow_headers]][]]  [[[^access_control_allow_methods]][]]  [[[^access_control_allow_origin]][]]  [[[^access_control_expose_headers]][]]  [[[^access_control_max_age]][]]  [[[^access_control_request_headers]][]]  [[[^access_control_request_method]][]]  [[[^age]][]]  [[[^allow]][]]  [[[^alpn]][]]  [[[^also_control]][]]  [[[^alt_svc]][]]  [[[^alt_used]][]]  [[[^alternate_recipient]][]]  [[[^alternates]][]]  [[[^apparently_to]][]]  [[[^apply_to_redirect_ref]][]]  [[[^approved]][]]  [[[^archive]][]]  [[[^archived_at]][]]  [[[^article_names]][]]  [[[^article_updates]][]]  [[[^authentication_control]][]]  [[[^authentication_info]][]]  [[[^authentication_results]][]]  [[[^authorization]][]]  [[[^auto_submitted]][]]  [[[^autoforwarded]][]]  [[[^autosubmitted]][]]  [[[^base]][]]  [[[^bcc]][]]  [[[^body]][]]  [[[^c_ext]][]]  [[[^c_man]][]]  [[[^c_opt]][]]  [[[^c_pep]][]]  [[[^c_pep_info]][]]  [[[^cache_control]][]]  [[[^caldav_timezones]][]]  [[[^cancel_key]][]]  [[[^cancel_lock]][]]  [[[^cc]][]]  [[[^close]][]]  [[[^comments]][]]  [[[^compliance]][]]  [[[^connection]][]]  [[[^content_alternative]][]]  [[[^content_base]][]]  [[[^content_description]][]]  [[[^content_disposition]][]]  [[[^content_duration]][]]  [[[^content_encoding]][]]  [[[^content_features]][]]  [[[^content_id]][]]  [[[^content_identifier]][]]  [[[^content_language]][]]  [[[^content_length]][]]  [[[^content_location]][]]  [[[^content_md5]][]]  [[[^content_range]][]]  [[[^content_return]][]]  [[[^content_script_type]][]]  [[[^content_style_type]][]]  [[[^content_transfer_encoding]][]]  [[[^content_type]][]]  [[[^content_version]][]]  [[[^control]][]]  [[[^conversion]][]]  [[[^conversion_with_loss]][]]  [[[^cookie]][]]  [[[^cookie2]][]]  [[[^cost]][]]  [[[^dasl]][]]  [[[^date]][]]  [[[^date_received]][]]  [[[^dav]][]]  [[[^default_style]][]]  [[[^deferred_delivery]][]]  [[[^delivery_date]][]]  [[[^delta_base]][]]  [[[^depth]][]]  [[[^derived_from]][]]  [[[^destination]][]]  [[[^differential_id]][]]  [[[^digest]][]]  [[[^discarded_x400_ipms_extensions]][]]  [[[^discarded_x400_mts_extensions]][]]  [[[^disclose_recipients]][]]  [[[^disposition_notification_options]][]]  [[[^disposition_notification_to]][]]  [[[^distribution]][]]  [[[^dkim_signature]][]]  [[[^dl_expansion_history]][]]  [[[^downgraded_bcc]][]]  [[[^downgraded_cc]][]]  [[[^downgraded_disposition_notification_to]][]]  [[[^downgraded_final_recipient]][]]  [[[^downgraded_from]][]]  [[[^downgraded_in_reply_to]][]]  [[[^downgraded_mail_from]][]]  [[[^downgraded_message_id]][]]  [[[^downgraded_original_recipient]][]]  [[[^downgraded_rcpt_to]][]]  [[[^downgraded_references]][]]  [[[^downgraded_reply_to]][]]  [[[^downgraded_resent_bcc]][]]  [[[^downgraded_resent_cc]][]]  [[[^downgraded_resent_from]][]]  [[[^downgraded_resent_reply_to]][]]  [[[^downgraded_resent_sender]][]]  [[[^downgraded_resent_to]][]]  [[[^downgraded_return_path]][]]  [[[^downgraded_sender]][]]  [[[^downgraded_to]][]]  [[[^ediint_features]][]]  [[[^eesst_version]][]]  [[[^encoding]][]]  [[[^encrypted]][]]  [[[^errors_to]][]]  [[[^etag]][]]  [[[^expect]][]]  [[[^expires]][]]  [[[^expiry_date]][]]  [[[^ext]][]]  [[[^followup_to]][]]  [[[^forwarded]][]]  [[[^from]][]]  [[[^generate_delivery_report]][]]  [[[^getprofile]][]]  [[[^hobareg]][]]  [[[^host]][]]  [[[^http2_settings]][]]  [[[^if_]][]]  [[[^if_match]][]]  [[[^if_modified_since]][]]  [[[^if_none_match]][]]  [[[^if_range]][]]  [[[^if_schedule_tag_match]][]]  [[[^if_unmodified_since]][]]  [[[^im]][]]  [[[^importance]][]]  [[[^in_reply_to]][]]  [[[^incomplete_copy]][]]  [[[^injection_date]][]]  [[[^injection_info]][]]  [[[^jabber_id]][]]  [[[^keep_alive]][]]  [[[^keywords]][]]  [[[^label]][]]  [[[^language]][]]  [[[^last_modified]][]]  [[[^latest_delivery_time]][]]  [[[^lines]][]]  [[[^link]][]]  [[[^list_archive]][]]  [[[^list_help]][]]  [[[^list_id]][]]  [[[^list_owner]][]]  [[[^list_post]][]]  [[[^list_subscribe]][]]  [[[^list_unsubscribe]][]]  [[[^list_unsubscribe_post]][]]  [[[^location]][]]  [[[^lock_token]][]]  [[[^man]][]]  [[[^max_forwards]][]]  [[[^memento_datetime]][]]  [[[^message_context]][]]  [[[^message_id]][]]  [[[^message_type]][]]  [[[^meter]][]]  [[[^method_check]][]]  [[[^method_check_expires]][]]  [[[^mime_version]][]]  [[[^mmhs_acp127_message_identifier]][]]  [[[^mmhs_authorizing_users]][]]  [[[^mmhs_codress_message_indicator]][]]  [[[^mmhs_copy_precedence]][]]  [[[^mmhs_exempted_address]][]]  [[[^mmhs_extended_authorisation_info]][]]  [[[^mmhs_handling_instructions]][]]  [[[^mmhs_message_instructions]][]]  [[[^mmhs_message_type]][]]  [[[^mmhs_originator_plad]][]]  [[[^mmhs_originator_reference]][]]  [[[^mmhs_other_recipients_indicator_cc]][]]  [[[^mmhs_other_recipients_indicator_to]][]]  [[[^mmhs_primary_precedence]][]]  [[[^mmhs_subject_indicator_codes]][]]  [[[^mt_priority]][]]  [[[^negotiate]][]]  [[[^newsgroups]][]]  [[[^nntp_posting_date]][]]  [[[^nntp_posting_host]][]]  [[[^non_compliance]][]]  [[[^obsoletes]][]]  [[[^opt]][]]  [[[^optional]][]]  [[[^optional_www_authenticate]][]]  [[[^ordering_type]][]]  [[[^organization]][]]  [[[^origin]][]]  [[[^original_encoded_information_types]][]]  [[[^original_from]][]]  [[[^original_message_id]][]]  [[[^original_recipient]][]]  [[[^original_sender]][]]  [[[^original_subject]][]]  [[[^originator_return_address]][]]  [[[^overwrite]][]]  [[[^p3p]][]]  [[[^path]][]]  [[[^pep]][]]  [[[^pep_info]][]]  [[[^pics_label]][]]  [[[^position]][]]  [[[^posting_version]][]]  [[[^pragma]][]]  [[[^prefer]][]]  [[[^preference_applied]][]]  [[[^prevent_nondelivery_report]][]]  [[[^priority]][]]  [[[^privicon]][]]  [[[^profileobject]][]]  [[[^protocol]][]]  [[[^protocol_info]][]]  [[[^protocol_query]][]]  [[[^protocol_request]][]]  [[[^proxy_authenticate]][]]  [[[^proxy_authentication_info]][]]  [[[^proxy_authorization]][]]  [[[^proxy_connection]][]]  [[[^proxy_features]][]]  [[[^proxy_instruction]][]]  [[[^public_]][]]  [[[^public_key_pins]][]]  [[[^public_key_pins_report_only]][]]  [[[^range]][]]  [[[^received]][]]  [[[^received_spf]][]]  [[[^redirect_ref]][]]  [[[^references]][]]  [[[^referer]][]]  [[[^referer_root]][]]  [[[^relay_version]][]]  [[[^reply_by]][]]  [[[^reply_to]][]]  [[[^require_recipient_valid_since]][]]  [[[^resent_bcc]][]]  [[[^resent_cc]][]]  [[[^resent_date]][]]  [[[^resent_from]][]]  [[[^resent_message_id]][]]  [[[^resent_reply_to]][]]  [[[^resent_sender]][]]  [[[^resent_to]][]]  [[[^resolution_hint]][]]  [[[^resolver_location]][]]  [[[^retry_after]][]]  [[[^return_path]][]]  [[[^safe]][]]  [[[^schedule_reply]][]]  [[[^schedule_tag]][]]  [[[^sec_websocket_accept]][]]  [[[^sec_websocket_extensions]][]]  [[[^sec_websocket_key]][]]  [[[^sec_websocket_protocol]][]]  [[[^sec_websocket_version]][]]  [[[^security_scheme]][]]  [[[^see_also]][]]  [[[^sender]][]]  [[[^sensitivity]][]]  [[[^server]][]]  [[[^set_cookie]][]]  [[[^set_cookie2]][]]  [[[^setprofile]][]]  [[[^sio_label]][]]  [[[^sio_label_history]][]]  [[[^slug]][]]  [[[^soapaction]][]]  [[[^solicitation]][]]  [[[^status_uri]][]]  [[[^strict_transport_security]][]]  [[[^subject]][]]  [[[^subok]][]]  [[[^subst]][]]  [[[^summary]][]]  [[[^supersedes]][]]  [[[^surrogate_capability]][]]  [[[^surrogate_control]][]]  [[[^tcn]][]]  [[[^te]][]]  [[[^timeout]][]]  [[[^title]][]]  [[[^to]][]]  [[[^topic]][]]  [[[^trailer]][]]  [[[^transfer_encoding]][]]  [[[^ttl]][]]  [[[^ua_color]][]]  [[[^ua_media]][]]  [[[^ua_pixels]][]]  [[[^ua_resolution]][]]  [[[^ua_windowpixels]][]]  [[[^upgrade]][]]  [[[^urgency]][]]  [[[^uri]][]]  [[[^user_agent]][]]  [[[^variant_vary]][]]  [[[^vary]][]]  [[[^vbr_info]][]]  [[[^version]][]]  [[[^via]][]]  [[[^want_digest]][]]  [[[^warning]][]]  [[[^www_authenticate]][]]  [[[^x_archived_at]][]]  [[[^x_device_accept]][]]  [[[^x_device_accept_charset]][]]  [[[^x_device_accept_encoding]][]]  [[[^x_device_accept_language]][]]  [[[^x_device_user_agent]][]]  [[[^x_frame_options]][]]  [[[^x_mittente]][]]  [[[^x_pgp_sig]][]]  [[[^x_ricevuta]][]]  [[[^x_riferimento_message_id]][]]  [[[^x_tiporicevuta]][]]  [[[^x_trasporto]][]]  [[[^x_verificasicurezza]][]]  [[[^x400_content_identifier]][]]  [[[^x400_content_return]][]]  [[[^x400_content_type]][]]  [[[^x400_mts_identifier]][]]  [[[^x400_originator]][]]  [[[^x400_received]][]]  [[[^x400_recipients]][]]  [[[^x400_trace]][]]  [[[^xref]][]]][heading Description]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__fields http::fields][indexterm1 http::fields]
A typical HTTP header fields container. [heading Synopsis]Defined in header [include_file boost/beast/http/fields.hpp]```using fields = basic_fields< std::allocator< char > >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_fields.allocator_type [*allocator_type]]]    [      The type of allocator used.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields__value_type [*value_type]]]    [      The type of element used to represent a field.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.const_iterator [*const_iterator]]]    [      A constant iterator to the field sequence.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.iterator [*iterator]]]    [      A constant iterator to the field sequence.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.key_compare [*key_compare]]]    [      A strictly less predicate for comparing keys, using a case-insensitive comparison.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.writer [*writer]]]    [      The algorithm used to serialize the header.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_fields.at [*at]]]    [      Returns the value for a field, or throws an exception.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.basic_fields [*basic_fields]]]    [      Constructor.       Move constructor.       Copy constructor.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.begin [*begin]]]    [      Return a const iterator to the beginning of the field sequence.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.cbegin [*cbegin]]]    [      Return a const iterator to the beginning of the field sequence.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.cend [*cend]]]    [      Return a const iterator to the end of the field sequence.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.clear [*clear]]]    [      Remove all fields from the container.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.count [*count]]]    [      Return the number of fields with the specified name.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.end [*end]]]    [      Return a const iterator to the end of the field sequence.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.equal_range [*equal_range]]]    [      Returns a range of iterators to the fields with the specified name.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.erase [*erase]]]    [      Remove a field.       Remove all fields with the specified name.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.find [*find]]]    [      Returns an iterator to the case-insensitive matching field.       Returns an iterator to the case-insensitive matching field name.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.get_allocator [*get_allocator]]]    [      Return a copy of the allocator associated with the container.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.insert [*insert]]]    [      Insert a field.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.key_comp [*key_comp]]]    [      Returns a copy of the key comparison function.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.operator_eq_ [*operator=]]]    [      Move assignment.       Copy assignment.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.operator_lb__rb_ [*operator\[\]]]]    [      Returns the value for a field, or "" if it does not exist.       Returns the value for a case-insensitive matching header, or "" if it does not exist.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.set [*set]]]    [      Set a field value, removing any other instances of that field.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.swap [*swap]]]    [      Return a buffer sequence representing the trailers.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.basic_fields_dtor_ [*~basic_fields]]]    [      Destructor.     ]  ]][heading Protected Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_fields.get_chunked_impl [*get_chunked_impl]]]    [      Returns the chunked Transfer-Encoding setting.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.get_keep_alive_impl [*get_keep_alive_impl]]]    [      Returns the keep-alive setting.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.get_method_impl [*get_method_impl]]]    [      Returns the request-method string.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.get_reason_impl [*get_reason_impl]]]    [      Returns the response reason-phrase string.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.get_target_impl [*get_target_impl]]]    [      Returns the request-target string.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.has_content_length_impl [*has_content_length_impl]]]    [      Returns true if the Content-Length field is present.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.set_chunked_impl [*set_chunked_impl]]]    [      Adjusts the chunked Transfer-Encoding value.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.set_content_length_impl [*set_content_length_impl]]]    [      Sets or clears the Content-Length field.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.set_keep_alive_impl [*set_keep_alive_impl]]]    [      Adjusts the Connection field.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.set_method_impl [*set_method_impl]]]    [      Set or clear the method string.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.set_reason_impl [*set_reason_impl]]]    [      Set or clear the reason string.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.set_target_impl [*set_target_impl]]]    [      Set or clear the target string.     ]  ]][heading Friends][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_fields.swap [*swap]]]    [      Swap two field containers.     ]  ]]
This container is designed to store the field value pairs that make up the fields and trailers in an HTTP message. Objects of this type are iterable, with each element holding the field name and field value.
Field names are stored as-is, but comparisons are case-insensitive. The container behaves as a `std::multiset`; there will be a separate value for each occurrence of the same field name. When the container is iterated the fields are presented in the order of insertion, with fields having the same name following each other consecutively.
Meets the requirements of ['Fields]
[heading Template Parameters][table [[Type][Description]]  [[`Allocator`][    
The allocator to use.   ]]]
[heading Description]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__file_body http::file_body][indexterm1 http::file_body]
A message body represented by a file on the filesystem. [heading Synopsis]Defined in header [include_file boost/beast/http/file_body.hpp]```using file_body = basic_file_body< file >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_file_body__reader [*reader]]]    [      Algorithm for storing buffers when parsing.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body__value_type [*value_type]]]    [      The type of the message::body member.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body__writer [*writer]]]    [      Algorithm for retrieving buffers when serializing.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body.file_type [*file_type]]]    [      The type of File this body uses.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_file_body.size [*size]]]    [      Returns the size of the body.     ]  ]]
Messages with this type have bodies represented by a file on the file system. When parsing a message using this body type, the data is stored in the file pointed to by the path, which must be writable. When serializing, the implementation will read the file and present those octets as the body content. This may be used to serve content from a directory as part of a web service.
[heading Template Parameters][table [[Type][Description]]  [[`File`][    
The implementation to use for accessing files. This type must meet the requirements of ['File].   ]]]
[heading Description]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__header http::header]
A container for an HTTP request or response header. [heading Synopsis]Defined in header [include_file boost/beast/http/message.hpp]```template<    bool isRequest,    class __Fields__ = fields>class header :    public Fields```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__header.fields_type [*fields_type]]]    [      The type representing the fields.     ]  ]  [    [[link beast.ref.boost__beast__http__header.is_request [*is_request]]]    [      Indicates if the header is a request or response.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__header.header [*header]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__http__header.method [*method]]]    [      Return the request-method verb.       Set the request-method.     ]  ]  [    [[link beast.ref.boost__beast__http__header.method_string [*method_string]]]    [      Return the request-method as a string.     ]  ]  [    [[link beast.ref.boost__beast__http__header.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__http__header.reason [*reason]]]    [      Return the response reason-phrase.       Set the response reason-phrase (deprecated)     ]  ]  [    [[link beast.ref.boost__beast__http__header.result [*result]]]    [      The response status-code result.       Set the response status-code.       Set the response status-code as an integer.     ]  ]  [    [[link beast.ref.boost__beast__http__header.result_int [*result_int]]]    [      The response status-code expressed as an integer.     ]  ]  [    [[link beast.ref.boost__beast__http__header.target [*target]]]    [      Returns the request-target string.       Set the request-target string.     ]  ]  [    [[link beast.ref.boost__beast__http__header.version [*version]]]    [      Return the HTTP-version.       Set the HTTP-version.     ]  ]][heading Description]
This container is derived from the `Fields` template type. To understand all of the members of this class it is necessary to view the declaration for the `Fields` type. When using the default fields container, those declarations are in [link beast.ref.boost__beast__http__fields `http::fields`].
Newly constructed header objects have version set to HTTP/1.1. Newly constructed response objects also have result code set to [link beast.ref.boost__beast__http__status `http::ok`].
A `header` includes the start-line and header-fields. [section:fields_type http::header::fields_type][indexterm2 fields_type..http::header]
The type representing the fields. [heading Synopsis]```using fields_type = Fields;```[heading Description][endsect][section:header http::header::header][indexterm2 header..http::header]
Constructor. `````[link beast.ref.boost__beast__http__header.header.overload1 header]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.header.overload1 more...]]````[link beast.ref.boost__beast__http__header.header.overload2 header]``(    header&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.header.overload2 more...]]````[link beast.ref.boost__beast__http__header.header.overload3 header]``(    header const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.header.overload3 more...]]``template<    class... Args>explicit``[link beast.ref.boost__beast__http__header.header.overload4 header]``(    Args&&... args);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.header.overload4 more...]]`````[section:overload1 http::header::header (1 of 4 overloads)]
Constructor. [heading Synopsis]```header();```[heading Description][endsect][section:overload2 http::header::header (2 of 4 overloads)]
Constructor. [heading Synopsis]```header(    header&&);```[heading Description][endsect][section:overload3 http::header::header (3 of 4 overloads)]
Constructor. [heading Synopsis]```header(    header const&);```[heading Description][endsect][section:overload4 http::header::header (4 of 4 overloads)]
Constructor. [heading Synopsis]```template<    class... Args>header(    Args&&... args);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`args`][    
Arguments forwarded to the `Fields` base class constructor.  ]]]
[heading Remarks]
This constructor participates in overload resolution if and only if the first parameter is not convertible to [link beast.ref.boost__beast__http__header `http::header`], [link beast.ref.boost__beast__http__verb `http::verb`], or [link beast.ref.boost__beast__http__status `http::status`]. 
[endsect][endsect][section:is_request http::header::is_request][indexterm2 is_request..http::header]
Indicates if the header is a request or response. [heading Synopsis]```using is_request = std::integral_constant< bool, isRequest >;```[heading Description][endsect][section:method http::header::method][indexterm2 method..http::header]
Return the request-method verb. ```verb``[link beast.ref.boost__beast__http__header.method.overload1 method]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.method.overload1 more...]]`````
Set the request-method. ```void``[link beast.ref.boost__beast__http__header.method.overload2 method]``(    verb v);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.method.overload2 more...]]`````[section:overload1 http::header::method (1 of 2 overloads)]
Return the request-method verb. [heading Synopsis]```verbmethod() const;```[heading Description]
If the request-method is not one of the recognized verbs, [link beast.ref.boost__beast__http__field `http::unknown`] is returned. Callers may use [link beast.ref.boost__beast__http__header.method_string `http::header::method_string`] to retrieve the exact text.
[heading Remarks]
This function is only available when `isRequest == true`.
[heading See Also]
[link beast.ref.boost__beast__http__header.method_string `http::header::method_string`] 
[endsect][section:overload2 http::header::method (2 of 2 overloads)]
Set the request-method. [heading Synopsis]```voidmethod(    verb v);```[heading Description]
This function will set the method for requests to a known verb.
[heading Parameters][table [[Name][Description]]  [[`v`][    
The request method verb to set. This may not be [link beast.ref.boost__beast__http__field `http::unknown`].  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::invalid_argument`][    
when `v == verb::unknown`.  ]]]
[heading Remarks]
This function is only available when `isRequest == true`. 
[endsect][endsect][section:method_string http::header::method_string][indexterm2 method_string..http::header]
Return the request-method as a string. ```string_view``[link beast.ref.boost__beast__http__header.method_string.overload1 method_string]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.method_string.overload1 more...]]``void``[link beast.ref.boost__beast__http__header.method_string.overload2 method_string]``(    string_view s);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.method_string.overload2 more...]]`````[section:overload1 http::header::method_string (1 of 2 overloads)]
Return the request-method as a string. [heading Synopsis]```string_viewmethod_string() const;```[heading Description]
[heading Remarks]
This function is only available when `isRequest == true`.
[heading See Also]
[link beast.ref.boost__beast__http__header.method `http::header::method`] 
[endsect][section:overload2 http::header::method_string (2 of 2 overloads)]
Set the request-method. [heading Synopsis]```voidmethod_string(    string_view s);```[heading Description]
This function will set the request-method a known verb if the string matches, otherwise it will store a copy of the passed string.
[heading Parameters][table [[Name][Description]]  [[`s`][    
A string representing the request-method.  ]]]
[heading Remarks]
This function is only available when `isRequest == true`. 
[endsect][endsect][section:operator_eq_ http::header::operator=][indexterm2 operator=..http::header]
Assignment. ```header&``[link beast.ref.boost__beast__http__header.operator_eq_.overload1 operator=]``(    header&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.operator_eq_.overload1 more...]]``header&``[link beast.ref.boost__beast__http__header.operator_eq_.overload2 operator=]``(    header const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.operator_eq_.overload2 more...]]`````[section:overload1 http::header::operator= (1 of 2 overloads)]
Assignment. [heading Synopsis]```header&operator=(    header&&);```[heading Description][endsect][section:overload2 http::header::operator= (2 of 2 overloads)]
Assignment. [heading Synopsis]```header&operator=(    header const&);```[heading Description][endsect][endsect][section:reason http::header::reason][indexterm2 reason..http::header]
Return the response reason-phrase. ```string_view``[link beast.ref.boost__beast__http__header.reason.overload1 reason]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.reason.overload1 more...]]`````
Set the response reason-phrase (deprecated) ```void``[link beast.ref.boost__beast__http__header.reason.overload2 reason]``(    string_view s);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.reason.overload2 more...]]`````[section:overload1 http::header::reason (1 of 2 overloads)]
Return the response reason-phrase. [heading Synopsis]```string_viewreason() const;```[heading Description]
The reason-phrase is obsolete as of rfc7230.
[heading Remarks]
This function is only available when `isRequest == false`. 
[endsect][section:overload2 http::header::reason (2 of 2 overloads)]
Set the response reason-phrase (deprecated) [heading Synopsis]```voidreason(    string_view s);```[heading Description]
This function sets a custom reason-phrase to a copy of the string passed in. Normally it is not necessary to set the reason phrase on an outgoing response object; the implementation will automatically use the standard reason text for the corresponding status code.
To clear a previously set custom phrase, pass an empty string. This will restore the default standard reason text based on the status code used when serializing.
The reason-phrase is obsolete as of rfc7230.
[heading Parameters][table [[Name][Description]]  [[`s`][    
The string to use for the reason-phrase.  ]]]
[heading Remarks]
This function is only available when `isRequest == false`. 
[endsect][endsect][section:result http::header::result][indexterm2 result..http::header]
The response status-code result. ```status``[link beast.ref.boost__beast__http__header.result.overload1 result]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.result.overload1 more...]]`````
Set the response status-code. ```void``[link beast.ref.boost__beast__http__header.result.overload2 result]``(    status v);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.result.overload2 more...]]`````
Set the response status-code as an integer. ```void``[link beast.ref.boost__beast__http__header.result.overload3 result]``(    unsigned v);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.result.overload3 more...]]`````[section:overload1 http::header::result (1 of 3 overloads)]
The response status-code result. [heading Synopsis]```statusresult() const;```[heading Description]
If the actual status code is not a known code, this function returns [link beast.ref.boost__beast__http__field `http::unknown`]. Use [link beast.ref.boost__beast__http__header.result_int `http::header::result_int`] to return the raw status code as a number.
[heading Remarks]
This member is only available when `isRequest == false`. 
[endsect][section:overload2 http::header::result (2 of 3 overloads)]
Set the response status-code. [heading Synopsis]```voidresult(    status v);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`v`][    
The code to set.  ]]]
[heading Remarks]
This member is only available when `isRequest == false`. 
[endsect][section:overload3 http::header::result (3 of 3 overloads)]
Set the response status-code as an integer. [heading Synopsis]```voidresult(    unsigned v);```[heading Description]
This sets the status code to the exact number passed in. If the number does not correspond to one of the known status codes, the function [link beast.ref.boost__beast__http__header.result `http::header::result`] will return [link beast.ref.boost__beast__http__field `http::unknown`]. Use [link beast.ref.boost__beast__http__header.result_int `http::header::result_int`] to obtain the original raw status-code.
[heading Parameters][table [[Name][Description]]  [[`v`][    
The status-code integer to set.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::invalid_argument`][    
if `v > 999`.   ]]]
[endsect][endsect][section:result_int http::header::result_int][indexterm2 result_int..http::header]
The response status-code expressed as an integer. [heading Synopsis]```unsignedresult_int() const;```[heading Description]
This returns the raw status code as an integer, even when that code is not in the list of known status codes.
[heading Remarks]
This member is only available when `isRequest == false`. 
[endsect][section:target http::header::target][indexterm2 target..http::header]
Returns the request-target string. ```string_view``[link beast.ref.boost__beast__http__header.target.overload1 target]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.target.overload1 more...]]`````
Set the request-target string. ```void``[link beast.ref.boost__beast__http__header.target.overload2 target]``(    string_view s);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.target.overload2 more...]]`````[section:overload1 http::header::target (1 of 2 overloads)]
Returns the request-target string. [heading Synopsis]```string_viewtarget() const;```[heading Description]
The request target string returned is the same string which was received from the network or stored. In particular, it will contain url-encoded characters and should follow the syntax rules for URIs used with HTTP.
[heading Remarks]
This function is only available when `isRequest == true`. 
[endsect][section:overload2 http::header::target (2 of 2 overloads)]
Set the request-target string. [heading Synopsis]```voidtarget(    string_view s);```[heading Description]
It is the caller's responsibility to ensure that the request target string follows the syntax rules for URIs used with HTTP. In particular, reserved or special characters must be url-encoded. The implementation does not perform syntax checking on the passed string.
[heading Parameters][table [[Name][Description]]  [[`s`][    
A string representing the request-target.  ]]]
[heading Remarks]
This function is only available when `isRequest == true`. 
[endsect][endsect][section:version http::header::version][indexterm2 version..http::header]
Return the HTTP-version. ```unsigned``[link beast.ref.boost__beast__http__header.version.overload1 version]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.version.overload1 more...]]`````
Set the HTTP-version. ```void``[link beast.ref.boost__beast__http__header.version.overload2 version]``(    unsigned value);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.version.overload2 more...]]`````[section:overload1 http::header::version (1 of 2 overloads)]
Return the HTTP-version. [heading Synopsis]```unsignedversion() const;```[heading Description]
This holds both the major and minor version numbers, using these formulas: ```  unsigned major = version / 10;
  unsigned minor = version % 10;
```
Newly constructed headers will use HTTP/1.1 by default. [endsect][section:overload2 http::header::version (2 of 2 overloads)]
Set the HTTP-version. [heading Synopsis]```voidversion(    unsigned value);```[heading Description]
This holds both the major and minor version numbers, using these formulas: ```  unsigned major = version / 10;
  unsigned minor = version % 10;
```
Newly constructed headers will use HTTP/1.1 by default.
[heading Parameters][table [[Name][Description]]  [[`value`][    
The version number to use   ]]]
[endsect][endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__icy_stream http::icy_stream]
Stream wrapper to process Shoutcast HTTP responses. [heading Synopsis]Defined in header [include_file boost/beast/_experimental/http/icy_stream.hpp]```template<    class NextLayer>class icy_stream```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__icy_stream.executor_type [*executor_type]]]    [      The type of the executor associated with the object.     ]  ]  [    [[link beast.ref.boost__beast__http__icy_stream.next_layer_type [*next_layer_type]]]    [      The type of the next layer.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__icy_stream.async_read_some [*async_read_some]]]    [      Start an asynchronous read.     ]  ]  [    [[link beast.ref.boost__beast__http__icy_stream.async_write_some [*async_write_some]]]    [      Start an asynchronous write.     ]  ]  [    [[link beast.ref.boost__beast__http__icy_stream.get_executor [*get_executor]]]    [      Get the executor associated with the object.     ]  ]  [    [[link beast.ref.boost__beast__http__icy_stream.icy_stream [*icy_stream]]]    [            Constructor.     ]  ]  [    [[link beast.ref.boost__beast__http__icy_stream.next_layer [*next_layer]]]    [      Get a reference to the next layer.     ]  ]  [    [[link beast.ref.boost__beast__http__icy_stream.operator_eq_ [*operator=]]]    [          ]  ]  [    [[link beast.ref.boost__beast__http__icy_stream.read_some [*read_some]]]    [      Read some data from the stream.     ]  ]  [    [[link beast.ref.boost__beast__http__icy_stream.write_some [*write_some]]]    [      Write some data to the stream.     ]  ]  [    [[link beast.ref.boost__beast__http__icy_stream.icy_stream_dtor_ [*~icy_stream]]]    [      Destructor.     ]  ]][heading Description]
This wrapper replaces the word "ICY" in the first HTTP response received on the connection, with "HTTP/1.1". This allows the Beast parser to be used with Shoutcast servers, which send a non-standard HTTP message as the response.
For asynchronous operations, the application must ensure that they are are all performed within the same implicit or explicit strand.
[heading Thread Safety]
['Distinct] ['objects:] Safe.['Shared] ['objects:] Unsafe. The application must also ensure that all asynchronous operations are performed within the same implicit or explicit strand.
[heading Example]
To use the [link beast.ref.boost__beast__http__icy_stream `http::icy_stream`] template with an [link beast.ref.boost__beast__tcp_stream `tcp_stream`] you would write: ```  http::icy_stream<tcp_stream> is(ioc);
```
[heading Template Parameters][table [[Type][Description]]  [[`NextLayer`][    
The type representing the next layer, to which data will be read and written during operations. For synchronous operations, the type must support the ['SyncStream] concept. For asynchronous operations, the type must support the ['AsyncStream] concept.  ]]]
[heading Remarks]
A stream object must not be moved or destroyed while there are pending asynchronous operations associated with it.
[heading Concepts]
['AsyncStream], ['SyncStream] 
[section:async_read_some http::icy_stream::async_read_some][indexterm2 async_read_some..http::icy_stream]
Start an asynchronous read. [heading Synopsis]```template<    class __MutableBufferSequence__,    class __ReadHandler__>``__deduced__``async_read_some(    MutableBufferSequence const& buffers,    ReadHandler&& handler);```[heading Description]
This function is used to asynchronously read one or more bytes of data from the stream. The function call always returns immediately.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The buffers into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying buffers is retained by the caller, which must guarantee that they remain valid until the handler is called.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
    const boost::system::error_code& error, // Result of operation.
    std::size_t bytes_transferred           // Number of bytes read.
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.  ]]]
[heading Remarks]
The `async_read_some` operation may not read all of the requested number of bytes. Consider using the function `net::async_read` if you need to ensure that the requested amount of data is read before the asynchronous operation completes. 
[endsect][section:async_write_some http::icy_stream::async_write_some][indexterm2 async_write_some..http::icy_stream]
Start an asynchronous write. [heading Synopsis]```template<    class __ConstBufferSequence__,    class __WriteHandler__>``__deduced__``async_write_some(    ConstBufferSequence const& buffers,    WriteHandler&& handler);```[heading Description]
This function is used to asynchronously write one or more bytes of data to the stream. The function call always returns immediately.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The data to be written to the stream. Although the buffers object may be copied as necessary, ownership of the underlying buffers is retained by the caller, which must guarantee that they remain valid until the handler is called.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
    error_code const& error,          // Result of operation.
    std::size_t bytes_transferred     // Number of bytes written.
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.  ]]]
[heading Remarks]
The `async_write_some` operation may not transmit all of the data to the peer. Consider using the function `net::async_write` if you need to ensure that all data is written before the asynchronous operation completes. 
[endsect][section:executor_type http::icy_stream::executor_type][indexterm2 executor_type..http::icy_stream]
The type of the executor associated with the object. [heading Synopsis]```using executor_type = typename next_layer_type::executor_type;```[heading Description][endsect][section:get_executor http::icy_stream::get_executor][indexterm2 get_executor..http::icy_stream]
Get the executor associated with the object. [heading Synopsis]```executor_typeget_executor();```[heading Description]
This function may be used to obtain the executor object that the stream uses to dispatch handlers for asynchronous operations.
[heading Return Value]
A copy of the executor that stream will use to dispatch handlers. 
[endsect][section:icy_stream http::icy_stream::icy_stream][indexterm2 icy_stream..http::icy_stream]`````[link beast.ref.boost__beast__http__icy_stream.icy_stream.overload1 icy_stream]``(    icy_stream&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__icy_stream.icy_stream.overload1 more...]]````[link beast.ref.boost__beast__http__icy_stream.icy_stream.overload2 icy_stream]``(    icy_stream const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__icy_stream.icy_stream.overload2 more...]]`````
Constructor. ```template<    class... Args>explicit``[link beast.ref.boost__beast__http__icy_stream.icy_stream.overload3 icy_stream]``(    Args&&... args);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__icy_stream.icy_stream.overload3 more...]]`````[section:overload1 http::icy_stream::icy_stream (1 of 3 overloads)][heading Synopsis]```icy_stream(    icy_stream&&);```[heading Description][endsect][section:overload2 http::icy_stream::icy_stream (2 of 3 overloads)][heading Synopsis]```icy_stream(    icy_stream const&);```[heading Description][endsect][section:overload3 http::icy_stream::icy_stream (3 of 3 overloads)]
Constructor. [heading Synopsis]```template<    class... Args>icy_stream(    Args&&... args);```[heading Description]
Arguments, if any, are forwarded to the next layer's constructor. [endsect][endsect][section:next_layer http::icy_stream::next_layer][indexterm2 next_layer..http::icy_stream]
Get a reference to the next layer. ```next_layer_type&``[link beast.ref.boost__beast__http__icy_stream.next_layer.overload1 next_layer]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__icy_stream.next_layer.overload1 more...]]``next_layer_type const &``[link beast.ref.boost__beast__http__icy_stream.next_layer.overload2 next_layer]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__icy_stream.next_layer.overload2 more...]]`````[section:overload1 http::icy_stream::next_layer (1 of 2 overloads)]
Get a reference to the next layer. [heading Synopsis]```next_layer_type&next_layer();```[heading Description]
This function returns a reference to the next layer in a stack of stream layers.
[heading Return Value]
A reference to the next layer in the stack of stream layers. 
[endsect][section:overload2 http::icy_stream::next_layer (2 of 2 overloads)]
Get a reference to the next layer. [heading Synopsis]```next_layer_type const &next_layer() const;```[heading Description]
This function returns a reference to the next layer in a stack of stream layers.
[heading Return Value]
A reference to the next layer in the stack of stream layers. 
[endsect][endsect][section:next_layer_type http::icy_stream::next_layer_type][indexterm2 next_layer_type..http::icy_stream]
The type of the next layer. [heading Synopsis]```using next_layer_type = typename std::remove_reference< NextLayer >::type;```[heading Description][endsect][section:operator_eq_ http::icy_stream::operator=][indexterm2 operator=..http::icy_stream]```icy_stream&``[link beast.ref.boost__beast__http__icy_stream.operator_eq_.overload1 operator=]``(    icy_stream&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__icy_stream.operator_eq_.overload1 more...]]``icy_stream&``[link beast.ref.boost__beast__http__icy_stream.operator_eq_.overload2 operator=]``(    icy_stream const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__icy_stream.operator_eq_.overload2 more...]]`````[section:overload1 http::icy_stream::operator= (1 of 2 overloads)][heading Synopsis]```icy_stream&operator=(    icy_stream&&);```[heading Description][endsect][section:overload2 http::icy_stream::operator= (2 of 2 overloads)][heading Synopsis]```icy_stream&operator=(    icy_stream const&);```[heading Description][endsect][endsect][section:read_some http::icy_stream::read_some][indexterm2 read_some..http::icy_stream]
Read some data from the stream. ```template<    class __MutableBufferSequence__>std::size_t``[link beast.ref.boost__beast__http__icy_stream.read_some.overload1 read_some]``(    MutableBufferSequence const& buffers);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__icy_stream.read_some.overload1 more...]]``template<    class __MutableBufferSequence__>std::size_t``[link beast.ref.boost__beast__http__icy_stream.read_some.overload2 read_some]``(    MutableBufferSequence const& buffers,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__icy_stream.read_some.overload2 more...]]`````[section:overload1 http::icy_stream::read_some (1 of 2 overloads)]
Read some data from the stream. [heading Synopsis]```template<    class __MutableBufferSequence__>std::size_tread_some(    MutableBufferSequence const& buffers);```[heading Description]
This function is used to read data from the stream. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The buffers into which the data will be read.  ]]]
[heading Return Value]
The number of bytes read.
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    
Thrown on failure.  ]]]
[heading Remarks]
The `read_some` operation may not read all of the requested number of bytes. Consider using the function `net::read` if you need to ensure that the requested amount of data is read before the blocking operation completes. 
[endsect][section:overload2 http::icy_stream::read_some (2 of 2 overloads)]
Read some data from the stream. [heading Synopsis]```template<    class __MutableBufferSequence__>std::size_tread_some(    MutableBufferSequence const& buffers,    error_code& ec);```[heading Description]
This function is used to read data from the stream. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The buffers into which the data will be read.  ]]  [[`ec`][    
Set to indicate what error occurred, if any.  ]]]
[heading Return Value]
The number of bytes read.
[heading Remarks]
The `read_some` operation may not read all of the requested number of bytes. Consider using the function `net::read` if you need to ensure that the requested amount of data is read before the blocking operation completes. 
[endsect][endsect][section:write_some http::icy_stream::write_some][indexterm2 write_some..http::icy_stream]
Write some data to the stream. ```template<    class __ConstBufferSequence__>std::size_t``[link beast.ref.boost__beast__http__icy_stream.write_some.overload1 write_some]``(    ConstBufferSequence const& buffers);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__icy_stream.write_some.overload1 more...]]``template<    class __ConstBufferSequence__>std::size_t``[link beast.ref.boost__beast__http__icy_stream.write_some.overload2 write_some]``(    ConstBufferSequence const& buffers,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__icy_stream.write_some.overload2 more...]]`````[section:overload1 http::icy_stream::write_some (1 of 2 overloads)]
Write some data to the stream. [heading Synopsis]```template<    class __ConstBufferSequence__>std::size_twrite_some(    ConstBufferSequence const& buffers);```[heading Description]
This function is used to write data on the stream. The function call will block until one or more bytes of data has been written successfully, or until an error occurs.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The data to be written.  ]]]
[heading Return Value]
The number of bytes written.
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    
Thrown on failure.  ]]]
[heading Remarks]
The `write_some` operation may not transmit all of the data to the peer. Consider using the function `net::write` if you need to ensure that all data is written before the blocking operation completes. 
[endsect][section:overload2 http::icy_stream::write_some (2 of 2 overloads)]
Write some data to the stream. [heading Synopsis]```template<    class __ConstBufferSequence__>std::size_twrite_some(    ConstBufferSequence const& buffers,    error_code& ec);```[heading Description]
This function is used to write data on the stream. The function call will block until one or more bytes of data has been written successfully, or until an error occurs.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The data to be written.  ]]  [[`ec`][    
Set to indicate what error occurred, if any.  ]]]
[heading Return Value]
The number of bytes written.
[heading Remarks]
The `write_some` operation may not transmit all of the data to the peer. Consider using the function `net::write` if you need to ensure that all data is written before the blocking operation completes. 
[endsect][endsect][section:icy_stream_dtor_ http::icy_stream::~icy_stream][indexterm2 ~icy_stream..http::icy_stream]
Destructor. [heading Synopsis]```~icy_stream();```[heading Description]
The treatment of pending operations will be the same as that of the next layer. [endsect][endsect][section:boost__beast__http__int_to_status http::int_to_status][indexterm1 http::int_to_status]
Converts the integer to a known status-code. [heading Synopsis]Defined in header [include_file boost/beast/http/status.hpp]```statusint_to_status(    unsigned v);```[heading Description]
If the integer does not match a known status code, [link beast.ref.boost__beast__http__field `http::unknown`] is returned. Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__is_body http::is_body][indexterm1 http::is_body]
Determine if a type meets the ['Body] named requirements. [heading Synopsis]Defined in header [include_file boost/beast/http/type_traits.hpp]```template<    class T>using is_body = ``['see-below]``;```[heading Description]
This alias template is `std::true_type` if `T` meets the requirements, otherwise it is `std::false_type`.
[heading Template Parameters][table [[Type][Description]]  [[`T`][    
The type to test.  ]]]
[heading Example]
```  template<bool isRequest, class Body, class Fields>
  void check_body(message<isRequest, Body, Fields> const&)
  {
      static_assert(is_body<Body>::value,
          "Body type requirements not met");
  }
```
Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__is_body_reader http::is_body_reader][indexterm1 http::is_body_reader]
Determine if a type has a nested ['BodyReader]. [heading Synopsis]Defined in header [include_file boost/beast/http/type_traits.hpp]```template<    class T>using is_body_reader = ``['see-below]``;```[heading Description]
This alias template is `std::true_type` when:

* `T` has a nested type named `reader`


* `reader` meets the requirements of ['BodyReader].

[heading Template Parameters][table [[Type][Description]]  [[`T`][    
The body type to test.  ]]]
[heading Example]
```  template<bool isRequest, class Body, class Fields>
  void check_can_parse(message<isRequest, Body, Fields>&)
  {
      static_assert(is_body_reader<Body>::value,
          "Cannot parse Body, no reader");
  }
```
Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__is_body_writer http::is_body_writer][indexterm1 http::is_body_writer]
Determine if a type has a nested ['BodyWriter]. [heading Synopsis]Defined in header [include_file boost/beast/http/type_traits.hpp]```template<    class T>using is_body_writer = ``['see-below]``;```[heading Description]
This alias template is `std::true_type` when:

* `T` has a nested type named `writer`


* `writer` meets the requirements of ['BodyWriter].

[heading Template Parameters][table [[Type][Description]]  [[`T`][    
The body type to test.  ]]]
[heading Example]
```  template<bool isRequest, class Body, class Fields>
  void check_can_serialize(message<isRequest, Body, Fields> const&)
  {
      static_assert(is_body_writer<Body>::value,
          "Cannot serialize Body, no reader");
  }
```
Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__is_fields http::is_fields][indexterm1 http::is_fields]
Determine if a type meets the ['Fields] named requirements. [heading Synopsis]Defined in header [include_file boost/beast/http/type_traits.hpp]```template<    class T>using is_fields = ``['see-below]``;```[heading Description]
This alias template is `std::true_type` if `T` meets the requirements, otherwise it is `std::false_type`.
[heading Template Parameters][table [[Type][Description]]  [[`T`][    
The type to test.  ]]]
[heading Example]
Use with `static_assert`: ```  template<bool isRequest, class Body, class Fields>
  void f(message<isRequest, Body, Fields> const&)
  {
      static_assert(is_fields<Fields>::value,
          "Fields type requirements not met");
  ...
```
Use with `std::enable_if` (SFINAE): ```  template<bool isRequest, class Body, class Fields>
  typename std::enable_if<is_fields<Fields>::value>::type
  f(message<isRequest, Body, Fields> const&);
```Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__is_mutable_body_writer http::is_mutable_body_writer][indexterm1 http::is_mutable_body_writer]
Determine if a type has a nested ['BodyWriter]. [heading Synopsis]Defined in header [include_file boost/beast/http/type_traits.hpp]```template<    class T>using is_mutable_body_writer = ``['see-below]``;```[heading Description]
This alias template is `std::true_type` when:

* `T` has a nested type named `writer`


* `writer` meets the requirements of ['BodyWriter].

[heading Template Parameters][table [[Type][Description]]  [[`T`][    
The body type to test.   ]]]
Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__make_chunk http::make_chunk][indexterm1 http::make_chunk]
Returns a [link beast.ref.boost__beast__http__chunk_body `http::chunk_body`]. [heading Synopsis]Defined in header [include_file boost/beast/http/chunk_encode.hpp]```template<    class __ConstBufferSequence__,    class... Args>automake_chunk(    ConstBufferSequence const& buffers,    Args&&... args);```[heading Description]
This functions constructs and returns a complete [link beast.ref.boost__beast__http__chunk_body `http::chunk_body`] for a chunk body represented by the specified buffer sequence.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The buffers representing the chunk body.  ]]  [[`args`][    
Optional arguments passed to the [link beast.ref.boost__beast__http__chunk_body `http::chunk_body`] constructor.  ]]]
[heading Remarks]
This function is provided as a notational convenience to omit specification of the class template arguments. 
Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__make_chunk_last http::make_chunk_last][indexterm1 http::make_chunk_last]
Returns a [link beast.ref.boost__beast__http__chunk_last `http::chunk_last`]. ```chunk_last< chunk_crlf >``[link beast.ref.boost__beast__http__make_chunk_last.overload1 make_chunk_last]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__make_chunk_last.overload1 more...]]``template<    class Trailer,    class... Args>chunk_last< Trailer >``[link beast.ref.boost__beast__http__make_chunk_last.overload2 make_chunk_last]``(    Trailer const& trailer,    Args&&... args);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__make_chunk_last.overload2 more...]]`````[section:overload1 http::make_chunk_last (1 of 2 overloads)]
Returns a [link beast.ref.boost__beast__http__chunk_last `http::chunk_last`]. [heading Synopsis]Defined in header [include_file boost/beast/http/chunk_encode.hpp]```chunk_last< chunk_crlf >make_chunk_last();```[heading Description]
[heading Remarks]
This function is provided as a notational convenience to omit specification of the class template arguments. 
Convenience header [include_file boost/beast/http.hpp][endsect][section:overload2 http::make_chunk_last (2 of 2 overloads)]
Returns a [link beast.ref.boost__beast__http__chunk_last `http::chunk_last`]. [heading Synopsis]Defined in header [include_file boost/beast/http/chunk_encode.hpp]```template<    class Trailer,    class... Args>chunk_last< Trailer >make_chunk_last(    Trailer const& trailer,    Args&&... args);```[heading Description]
This function construct and returns a complete [link beast.ref.boost__beast__http__chunk_last `http::chunk_last`] for a last chunk containing the specified trailers.
[heading Parameters][table [[Name][Description]]  [[`trailer`][    
A ConstBufferSequence or   ]]]
[heading Remarks]
This function is provided as a notational convenience to omit specification of the class template arguments.
[heading Parameters][table [[Name][Description]]  [[`args`][    
Optional arguments passed to the [link beast.ref.boost__beast__http__chunk_last `http::chunk_last`] constructor.   ]]]
Convenience header [include_file boost/beast/http.hpp][endsect][endsect][section:boost__beast__http__message http::message]
A container for a complete HTTP message. [heading Synopsis]Defined in header [include_file boost/beast/http/message.hpp]```template<    bool isRequest,    class __Body__,    class __Fields__ = fields>class message :    public http::header< isRequest, Fields >```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__message.body_type [*body_type]]]    [      The type providing the body traits.     ]  ]  [    [[link beast.ref.boost__beast__http__message.fields_type [*fields_type]]]    [      The type representing the fields.     ]  ]  [    [[link beast.ref.boost__beast__http__message.header_type [*header_type]]]    [      The base class used to hold the header portion of the message.     ]  ]  [    [[link beast.ref.boost__beast__http__message.is_request [*is_request]]]    [      Indicates if the header is a request or response.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__message.base [*base]]]    [      Returns the header portion of the message.     ]  ]  [    [[link beast.ref.boost__beast__http__message.body [*body]]]    [      Returns the body.     ]  ]  [    [[link beast.ref.boost__beast__http__message.chunked [*chunked]]]    [      Returns true if the chunked Transfer-Encoding is specified.       Set or clear the chunked Transfer-Encoding.     ]  ]  [    [[link beast.ref.boost__beast__http__message.content_length [*content_length]]]    [      Set or clear the Content-Length field.     ]  ]  [    [[link beast.ref.boost__beast__http__message.has_content_length [*has_content_length]]]    [      Returns true if the Content-Length field is present.     ]  ]  [    [[link beast.ref.boost__beast__http__message.keep_alive [*keep_alive]]]    [      Returns true if the message semantics indicate keep-alive.       Set the keep-alive message semantic option.     ]  ]  [    [[link beast.ref.boost__beast__http__message.message [*message]]]    [      Constructor.       Construct a message.     ]  ]  [    [[link beast.ref.boost__beast__http__message.method [*method]]]    [      Return the request-method verb.       Set the request-method.     ]  ]  [    [[link beast.ref.boost__beast__http__message.method_string [*method_string]]]    [      Return the request-method as a string.     ]  ]  [    [[link beast.ref.boost__beast__http__message.need_eof [*need_eof]]]    [      Returns true if the message semantics require an end of file.     ]  ]  [    [[link beast.ref.boost__beast__http__message.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__http__message.payload_size [*payload_size]]]    [      Returns the payload size of the body in octets if possible.     ]  ]  [    [[link beast.ref.boost__beast__http__message.prepare_payload [*prepare_payload]]]    [      Prepare the message payload fields for the body.     ]  ]  [    [[link beast.ref.boost__beast__http__message.reason [*reason]]]    [      Return the response reason-phrase.       Set the response reason-phrase (deprecated)     ]  ]  [    [[link beast.ref.boost__beast__http__message.result [*result]]]    [      The response status-code result.       Set the response status-code.       Set the response status-code as an integer.     ]  ]  [    [[link beast.ref.boost__beast__http__message.result_int [*result_int]]]    [      The response status-code expressed as an integer.     ]  ]  [    [[link beast.ref.boost__beast__http__message.target [*target]]]    [      Returns the request-target string.       Set the request-target string.     ]  ]  [    [[link beast.ref.boost__beast__http__message.version [*version]]]    [      Return the HTTP-version.       Set the HTTP-version.     ]  ]][heading Description]
This container is derived from the `Fields` template type. To understand all of the members of this class it is necessary to view the declaration for the `Fields` type. When using the default fields container, those declarations are in [link beast.ref.boost__beast__http__fields `http::fields`].
A message can be a request or response, depending on the `isRequest` template argument value. Requests and responses have different types; functions may be overloaded based on the type if desired.
The `Body` template argument type determines the model used to read or write the content body of the message.
Newly constructed messages objects have version set to HTTP/1.1. Newly constructed response objects also have result code set to [link beast.ref.boost__beast__http__status `http::ok`].
[heading Template Parameters][table [[Type][Description]]  [[`isRequest`][    
`true` if this represents a request, or `false` if this represents a response. Some class data members are conditionally present depending on this value.  ]]  [[`Body`][    
A type meeting the requirements of Body.  ]]  [[`Fields`][    
The type of container used to hold the field value pairs.   ]]]
[section:base http::message::base][indexterm2 base..http::message]
Returns the header portion of the message. ```header_type const &``[link beast.ref.boost__beast__http__message.base.overload1 base]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.base.overload1 more...]]``header_type&``[link beast.ref.boost__beast__http__message.base.overload2 base]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.base.overload2 more...]]`````[section:overload1 http::message::base (1 of 2 overloads)]
Returns the header portion of the message. [heading Synopsis]```header_type const &base() const;```[heading Description][endsect][section:overload2 http::message::base (2 of 2 overloads)]
Returns the header portion of the message. [heading Synopsis]```header_type&base();```[heading Description][endsect][endsect][section:body http::message::body][indexterm2 body..http::message]
Returns the body. ```body_type::value_type&``[link beast.ref.boost__beast__http__message.body.overload1 body]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.body.overload1 more...]]``body_type::value_type&&``[link beast.ref.boost__beast__http__message.body.overload2 body]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.body.overload2 more...]]``body_type::value_type const &``[link beast.ref.boost__beast__http__message.body.overload3 body]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.body.overload3 more...]]`````[section:overload1 http::message::body (1 of 3 overloads)]
Returns the body. [heading Synopsis]```body_type::value_type&body();```[heading Description][endsect][section:overload2 http::message::body (2 of 3 overloads)]
Returns the body. [heading Synopsis]```body_type::value_type&&body();```[heading Description][endsect][section:overload3 http::message::body (3 of 3 overloads)]
Returns the body. [heading Synopsis]```body_type::value_type const &body() const;```[heading Description][endsect][endsect][section:body_type http::message::body_type][indexterm2 body_type..http::message]
The type providing the body traits. [heading Synopsis]```using body_type = Body;```[heading Description]
The [link beast.ref.boost__beast__http__message.body `http::message::body`] member will be of type `body_type::value_type`. [endsect][section:chunked http::message::chunked][indexterm2 chunked..http::message]
Returns `true` if the chunked Transfer-Encoding is specified. ```bool``[link beast.ref.boost__beast__http__message.chunked.overload1 chunked]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.chunked.overload1 more...]]`````
Set or clear the chunked Transfer-Encoding. ```void``[link beast.ref.boost__beast__http__message.chunked.overload2 chunked]``(    bool value);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.chunked.overload2 more...]]`````[section:overload1 http::message::chunked (1 of 2 overloads)]
Returns `true` if the chunked Transfer-Encoding is specified. [heading Synopsis]```boolchunked() const;```[heading Description][endsect][section:overload2 http::message::chunked (2 of 2 overloads)]
Set or clear the chunked Transfer-Encoding. [heading Synopsis]```voidchunked(    bool value);```[heading Description]
This function will set or remove the "chunked" transfer encoding as the last item in the list of encodings in the field.
If the result of removing the chunked token results in an empty string, the field is erased.
The Content-Length field is erased unconditionally. [endsect][endsect][section:content_length http::message::content_length][indexterm2 content_length..http::message]
Set or clear the Content-Length field. [heading Synopsis]```voidcontent_length(    boost::optional< std::uint64_t > const& value);```[heading Description]
This function adjusts the Content-Length field as follows:

* If `value` specifies a value, the Content-Length field is set to the value. Otherwise


* The Content-Length field is erased.

If "chunked" token appears as the last item in the Transfer-Encoding field it is unconditionally removed.
[heading Parameters][table [[Name][Description]]  [[`value`][    
The value to set for Content-Length.   ]]]
[endsect][section:fields_type http::message::fields_type](Inherited from `http::header`)[indexterm2 fields_type..http::message]
The type representing the fields. [heading Synopsis]```using fields_type = Fields;```[heading Description][endsect][section:has_content_length http::message::has_content_length][indexterm2 has_content_length..http::message]
Returns `true` if the Content-Length field is present. [heading Synopsis]```boolhas_content_length() const;```[heading Description]
This function inspects the fields and returns `true` if the Content-Length field is present. The properties of the body are not checked, this only looks for the field. [endsect][section:header_type http::message::header_type][indexterm2 header_type..http::message]
The base class used to hold the header portion of the message. [heading Synopsis]```using header_type = header< isRequest, Fields >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__header.fields_type [*fields_type]]]    [      The type representing the fields.     ]  ]  [    [[link beast.ref.boost__beast__http__header.is_request [*is_request]]]    [      Indicates if the header is a request or response.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__header.header [*header]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__http__header.method [*method]]]    [      Return the request-method verb.       Set the request-method.     ]  ]  [    [[link beast.ref.boost__beast__http__header.method_string [*method_string]]]    [      Return the request-method as a string.     ]  ]  [    [[link beast.ref.boost__beast__http__header.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__http__header.reason [*reason]]]    [      Return the response reason-phrase.       Set the response reason-phrase (deprecated)     ]  ]  [    [[link beast.ref.boost__beast__http__header.result [*result]]]    [      The response status-code result.       Set the response status-code.       Set the response status-code as an integer.     ]  ]  [    [[link beast.ref.boost__beast__http__header.result_int [*result_int]]]    [      The response status-code expressed as an integer.     ]  ]  [    [[link beast.ref.boost__beast__http__header.target [*target]]]    [      Returns the request-target string.       Set the request-target string.     ]  ]  [    [[link beast.ref.boost__beast__http__header.version [*version]]]    [      Return the HTTP-version.       Set the HTTP-version.     ]  ]]
This container is derived from the `Fields` template type. To understand all of the members of this class it is necessary to view the declaration for the `Fields` type. When using the default fields container, those declarations are in [link beast.ref.boost__beast__http__fields `http::fields`].
Newly constructed header objects have version set to HTTP/1.1. Newly constructed response objects also have result code set to [link beast.ref.boost__beast__http__status `http::ok`].
A `header` includes the start-line and header-fields. [heading Description][endsect][section:is_request http::message::is_request](Inherited from `http::header`)[indexterm2 is_request..http::message]
Indicates if the header is a request or response. [heading Synopsis]```using is_request = std::integral_constant< bool, isRequest >;```[heading Description][endsect][section:keep_alive http::message::keep_alive][indexterm2 keep_alive..http::message]
Returns `true` if the message semantics indicate keep-alive. ```bool``[link beast.ref.boost__beast__http__message.keep_alive.overload1 keep_alive]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.keep_alive.overload1 more...]]`````
Set the keep-alive message semantic option. ```void``[link beast.ref.boost__beast__http__message.keep_alive.overload2 keep_alive]``(    bool value);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.keep_alive.overload2 more...]]`````[section:overload1 http::message::keep_alive (1 of 2 overloads)]
Returns `true` if the message semantics indicate keep-alive. [heading Synopsis]```boolkeep_alive() const;```[heading Description]
The value depends on the version in the message, which must be set to the final value before this function is called or else the return value is unreliable. [endsect][section:overload2 http::message::keep_alive (2 of 2 overloads)]
Set the keep-alive message semantic option. [heading Synopsis]```voidkeep_alive(    bool value);```[heading Description]
This function adjusts the Connection field to indicate whether or not the connection should be kept open after the corresponding response. The result depends on the version set on the message, which must be set to the final value before making this call.
[heading Parameters][table [[Name][Description]]  [[`value`][    
`true` if the connection should persist.   ]]]
[endsect][endsect][section:message http::message::message][indexterm2 message..http::message]
Constructor. `````[link beast.ref.boost__beast__http__message.message.overload1 message]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.message.overload1 more...]]````[link beast.ref.boost__beast__http__message.message.overload2 message]``(    message&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.message.overload2 more...]]````[link beast.ref.boost__beast__http__message.message.overload3 message]``(    message const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.message.overload3 more...]]``template<    class... BodyArgs>explicit``[link beast.ref.boost__beast__http__message.message.overload4 message]``(    header_type&& h,    BodyArgs&&... body_args);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.message.overload4 more...]]``template<    class... BodyArgs>explicit``[link beast.ref.boost__beast__http__message.message.overload5 message]``(    header_type const& h,    BodyArgs&&... body_args);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.message.overload5 more...]]````[link beast.ref.boost__beast__http__message.message.overload6 message]``(    verb method,    string_view target,    unsigned version);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.message.overload6 more...]]``template<    class BodyArg>``[link beast.ref.boost__beast__http__message.message.overload7 message]``(    verb method,    string_view target,    unsigned version,    BodyArg&& body_arg);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.message.overload7 more...]]``template<    class BodyArg,    class FieldsArg>``[link beast.ref.boost__beast__http__message.message.overload8 message]``(    verb method,    string_view target,    unsigned version,    BodyArg&& body_arg,    FieldsArg&& fields_arg);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.message.overload8 more...]]````[link beast.ref.boost__beast__http__message.message.overload9 message]``(    status result,    unsigned version);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.message.overload9 more...]]``template<    class BodyArg>``[link beast.ref.boost__beast__http__message.message.overload10 message]``(    status result,    unsigned version,    BodyArg&& body_arg);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.message.overload10 more...]]``template<    class BodyArg,    class FieldsArg>``[link beast.ref.boost__beast__http__message.message.overload11 message]``(    status result,    unsigned version,    BodyArg&& body_arg,    FieldsArg&& fields_arg);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.message.overload11 more...]]``explicit``[link beast.ref.boost__beast__http__message.message.overload12 message]``(    std::piecewise_construct_t);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.message.overload12 more...]]`````
Construct a message. ```template<    class... BodyArgs>``[link beast.ref.boost__beast__http__message.message.overload13 message]``(    std::piecewise_construct_t,    std::tuple< BodyArgs... > body_args);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.message.overload13 more...]]``template<    class... BodyArgs,    class... FieldsArgs>``[link beast.ref.boost__beast__http__message.message.overload14 message]``(    std::piecewise_construct_t,    std::tuple< BodyArgs... > body_args,    std::tuple< FieldsArgs... > fields_args);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.message.overload14 more...]]`````[section:overload1 http::message::message (1 of 14 overloads)]
Constructor. [heading Synopsis]```message();```[heading Description][endsect][section:overload2 http::message::message (2 of 14 overloads)]
Constructor. [heading Synopsis]```message(    message&&);```[heading Description][endsect][section:overload3 http::message::message (3 of 14 overloads)]
Constructor. [heading Synopsis]```message(    message const&);```[heading Description][endsect][section:overload4 http::message::message (4 of 14 overloads)]
Constructor. [heading Synopsis]```template<    class... BodyArgs>message(    header_type&& h,    BodyArgs&&... body_args);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`h`][    
The header to move construct from.  ]]  [[`body_args`][    
Optional arguments forwarded to the `body` constructor.   ]]]
[endsect][section:overload5 http::message::message (5 of 14 overloads)]
Constructor. [heading Synopsis]```template<    class... BodyArgs>message(    header_type const& h,    BodyArgs&&... body_args);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`h`][    
The header to copy construct from.  ]]  [[`body_args`][    
Optional arguments forwarded to the `body` constructor.   ]]]
[endsect][section:overload6 http::message::message (6 of 14 overloads)]
Constructor. [heading Synopsis]```message(    verb method,    string_view target,    unsigned version);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`method`][    
The request-method to use.  ]]  [[`target`][    
The request-target.  ]]  [[`version`][    
The HTTP-version.  ]]]
[heading Remarks]
This function is only available when `isRequest == true`. 
[endsect][section:overload7 http::message::message (7 of 14 overloads)]
Constructor. [heading Synopsis]```template<    class BodyArg>message(    verb method,    string_view target,    unsigned version,    BodyArg&& body_arg);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`method`][    
The request-method to use.  ]]  [[`target`][    
The request-target.  ]]  [[`version`][    
The HTTP-version.  ]]  [[`body_arg`][    
An argument forwarded to the `body` constructor.  ]]]
[heading Remarks]
This function is only available when `isRequest == true`. 
[endsect][section:overload8 http::message::message (8 of 14 overloads)]
Constructor. [heading Synopsis]```template<    class BodyArg,    class FieldsArg>message(    verb method,    string_view target,    unsigned version,    BodyArg&& body_arg,    FieldsArg&& fields_arg);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`method`][    
The request-method to use.  ]]  [[`target`][    
The request-target.  ]]  [[`version`][    
The HTTP-version.  ]]  [[`body_arg`][    
An argument forwarded to the `body` constructor.  ]]  [[`fields_arg`][    
An argument forwarded to the `Fields` constructor.  ]]]
[heading Remarks]
This function is only available when `isRequest == true`. 
[endsect][section:overload9 http::message::message (9 of 14 overloads)]
Constructor. [heading Synopsis]```message(    status result,    unsigned version);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`result`][    
The status-code for the response.  ]]  [[`version`][    
The HTTP-version.  ]]]
[heading Remarks]
This member is only available when `isRequest == false`. 
[endsect][section:overload10 http::message::message (10 of 14 overloads)]
Constructor. [heading Synopsis]```template<    class BodyArg>message(    status result,    unsigned version,    BodyArg&& body_arg);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`result`][    
The status-code for the response.  ]]  [[`version`][    
The HTTP-version.  ]]  [[`body_arg`][    
An argument forwarded to the `body` constructor.  ]]]
[heading Remarks]
This member is only available when `isRequest == false`. 
[endsect][section:overload11 http::message::message (11 of 14 overloads)]
Constructor. [heading Synopsis]```template<    class BodyArg,    class FieldsArg>message(    status result,    unsigned version,    BodyArg&& body_arg,    FieldsArg&& fields_arg);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`result`][    
The status-code for the response.  ]]  [[`version`][    
The HTTP-version.  ]]  [[`body_arg`][    
An argument forwarded to the `body` constructor.  ]]  [[`fields_arg`][    
An argument forwarded to the `Fields` base class constructor.  ]]]
[heading Remarks]
This member is only available when `isRequest == false`. 
[endsect][section:overload12 http::message::message (12 of 14 overloads)]
Constructor. [heading Synopsis]```message(    std::piecewise_construct_t);```[heading Description]
The header and body are default-constructed. [endsect][section:overload13 http::message::message (13 of 14 overloads)]
Construct a message. [heading Synopsis]```template<    class... BodyArgs>message(    std::piecewise_construct_t,    std::tuple< BodyArgs... > body_args);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`body_args`][    
A tuple forwarded as a parameter pack to the body constructor.   ]]]
[endsect][section:overload14 http::message::message (14 of 14 overloads)]
Construct a message. [heading Synopsis]```template<    class... BodyArgs,    class... FieldsArgs>message(    std::piecewise_construct_t,    std::tuple< BodyArgs... > body_args,    std::tuple< FieldsArgs... > fields_args);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`body_args`][    
A tuple forwarded as a parameter pack to the body constructor.  ]]  [[`fields_args`][    
A tuple forwarded as a parameter pack to the `Fields` constructor.   ]]]
[endsect][endsect][section:method http::message::method][indexterm2 method..http::message]
Return the request-method verb. ```verb``[link beast.ref.boost__beast__http__message.method.overload1 method]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.method.overload1 more...]]`````
Set the request-method. ```void``[link beast.ref.boost__beast__http__message.method.overload2 method]``(    verb v);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.method.overload2 more...]]`````[section:overload1 http::message::method (1 of 2 overloads)](Inherited from `http::header`)
Return the request-method verb. [heading Synopsis]```verbmethod() const;```[heading Description]
If the request-method is not one of the recognized verbs, [link beast.ref.boost__beast__http__field `http::unknown`] is returned. Callers may use [link beast.ref.boost__beast__http__header.method_string `http::header::method_string`] to retrieve the exact text.
[heading Remarks]
This function is only available when `isRequest == true`.
[heading See Also]
[link beast.ref.boost__beast__http__header.method_string `http::header::method_string`] 
[endsect][section:overload2 http::message::method (2 of 2 overloads)](Inherited from `http::header`)
Set the request-method. [heading Synopsis]```voidmethod(    verb v);```[heading Description]
This function will set the method for requests to a known verb.
[heading Parameters][table [[Name][Description]]  [[`v`][    
The request method verb to set. This may not be [link beast.ref.boost__beast__http__field `http::unknown`].  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::invalid_argument`][    
when `v == verb::unknown`.  ]]]
[heading Remarks]
This function is only available when `isRequest == true`. 
[endsect][endsect][section:method_string http::message::method_string][indexterm2 method_string..http::message]
Return the request-method as a string. ```string_view``[link beast.ref.boost__beast__http__message.method_string.overload1 method_string]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.method_string.overload1 more...]]``void``[link beast.ref.boost__beast__http__message.method_string.overload2 method_string]``(    string_view s);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.method_string.overload2 more...]]`````[section:overload1 http::message::method_string (1 of 2 overloads)](Inherited from `http::header`)
Return the request-method as a string. [heading Synopsis]```string_viewmethod_string() const;```[heading Description]
[heading Remarks]
This function is only available when `isRequest == true`.
[heading See Also]
[link beast.ref.boost__beast__http__header.method `http::header::method`] 
[endsect][section:overload2 http::message::method_string (2 of 2 overloads)](Inherited from `http::header`)
Set the request-method. [heading Synopsis]```voidmethod_string(    string_view s);```[heading Description]
This function will set the request-method a known verb if the string matches, otherwise it will store a copy of the passed string.
[heading Parameters][table [[Name][Description]]  [[`s`][    
A string representing the request-method.  ]]]
[heading Remarks]
This function is only available when `isRequest == true`. 
[endsect][endsect][section:need_eof http::message::need_eof][indexterm2 need_eof..http::message]
Returns `true` if the message semantics require an end of file. [heading Synopsis]```boolneed_eof() const;```[heading Description]
For HTTP requests, this function returns the logical NOT of a call to [link beast.ref.boost__beast__http__message.keep_alive `http::message::keep_alive`].
For HTTP responses, this function returns the logical NOT of a call to [link beast.ref.boost__beast__http__message.keep_alive `http::message::keep_alive`] if any of the following are true:

* [link beast.ref.boost__beast__http__message.has_content_length `http::message::has_content_length`] would return `true`


* [link beast.ref.boost__beast__http__message.chunked `http::message::chunked`] would return `true`


* [link beast.ref.boost__beast__http__header.result `http::header::result`] returns [link beast.ref.boost__beast__http__status `http::no_content`]


* [link beast.ref.boost__beast__http__header.result `http::header::result`] returns [link beast.ref.boost__beast__http__status `http::not_modified`]


* [link beast.ref.boost__beast__http__header.result `http::header::result`] returns any informational status class (100 to 199)

Otherwise, the function returns `true`.
[heading See Also]
[@https://tools.ietf.org/html/rfc7230#section-3.3 https://tools.ietf.org/html/rfc7230#section-3.3] 
[endsect][section:operator_eq_ http::message::operator=][indexterm2 operator=..http::message]
Assignment. ```message&``[link beast.ref.boost__beast__http__message.operator_eq_.overload1 operator=]``(    message&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.operator_eq_.overload1 more...]]``message&``[link beast.ref.boost__beast__http__message.operator_eq_.overload2 operator=]``(    message const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.operator_eq_.overload2 more...]]`````[section:overload1 http::message::operator= (1 of 2 overloads)]
Assignment. [heading Synopsis]```message&operator=(    message&&);```[heading Description][endsect][section:overload2 http::message::operator= (2 of 2 overloads)]
Assignment. [heading Synopsis]```message&operator=(    message const&);```[heading Description][endsect][endsect][section:payload_size http::message::payload_size][indexterm2 payload_size..http::message]
Returns the payload size of the body in octets if possible. [heading Synopsis]```boost::optional< std::uint64_t >payload_size() const;```[heading Description]
This function invokes the ['Body] algorithm to measure the number of octets in the serialized body container. If there is no body, this will return zero. Otherwise, if the body exists but is not known ahead of time, `boost::none` is returned (usually indicating that a chunked Transfer-Encoding will be used).
[heading Remarks]
The value of the Content-Length field in the message is not inspected. 
[endsect][section:prepare_payload http::message::prepare_payload][indexterm2 prepare_payload..http::message]
Prepare the message payload fields for the body. [heading Synopsis]```voidprepare_payload();```[heading Description]
This function will adjust the Content-Length and Transfer-Encoding field values based on the properties of the body.
[heading Example]
```  request<string_body> req{verb::post, "/"};
  req.set(field::user_agent, "Beast");
  req.body() = "Hello, world!";
  req.prepare_payload();
```
[endsect][section:reason http::message::reason][indexterm2 reason..http::message]
Return the response reason-phrase. ```string_view``[link beast.ref.boost__beast__http__message.reason.overload1 reason]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.reason.overload1 more...]]`````
Set the response reason-phrase (deprecated) ```void``[link beast.ref.boost__beast__http__message.reason.overload2 reason]``(    string_view s);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.reason.overload2 more...]]`````[section:overload1 http::message::reason (1 of 2 overloads)](Inherited from `http::header`)
Return the response reason-phrase. [heading Synopsis]```string_viewreason() const;```[heading Description]
The reason-phrase is obsolete as of rfc7230.
[heading Remarks]
This function is only available when `isRequest == false`. 
[endsect][section:overload2 http::message::reason (2 of 2 overloads)](Inherited from `http::header`)
Set the response reason-phrase (deprecated) [heading Synopsis]```voidreason(    string_view s);```[heading Description]
This function sets a custom reason-phrase to a copy of the string passed in. Normally it is not necessary to set the reason phrase on an outgoing response object; the implementation will automatically use the standard reason text for the corresponding status code.
To clear a previously set custom phrase, pass an empty string. This will restore the default standard reason text based on the status code used when serializing.
The reason-phrase is obsolete as of rfc7230.
[heading Parameters][table [[Name][Description]]  [[`s`][    
The string to use for the reason-phrase.  ]]]
[heading Remarks]
This function is only available when `isRequest == false`. 
[endsect][endsect][section:result http::message::result][indexterm2 result..http::message]
The response status-code result. ```status``[link beast.ref.boost__beast__http__message.result.overload1 result]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.result.overload1 more...]]`````
Set the response status-code. ```void``[link beast.ref.boost__beast__http__message.result.overload2 result]``(    status v);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.result.overload2 more...]]`````
Set the response status-code as an integer. ```void``[link beast.ref.boost__beast__http__message.result.overload3 result]``(    unsigned v);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.result.overload3 more...]]`````[section:overload1 http::message::result (1 of 3 overloads)](Inherited from `http::header`)
The response status-code result. [heading Synopsis]```statusresult() const;```[heading Description]
If the actual status code is not a known code, this function returns [link beast.ref.boost__beast__http__field `http::unknown`]. Use [link beast.ref.boost__beast__http__header.result_int `http::header::result_int`] to return the raw status code as a number.
[heading Remarks]
This member is only available when `isRequest == false`. 
[endsect][section:overload2 http::message::result (2 of 3 overloads)](Inherited from `http::header`)
Set the response status-code. [heading Synopsis]```voidresult(    status v);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`v`][    
The code to set.  ]]]
[heading Remarks]
This member is only available when `isRequest == false`. 
[endsect][section:overload3 http::message::result (3 of 3 overloads)](Inherited from `http::header`)
Set the response status-code as an integer. [heading Synopsis]```voidresult(    unsigned v);```[heading Description]
This sets the status code to the exact number passed in. If the number does not correspond to one of the known status codes, the function [link beast.ref.boost__beast__http__header.result `http::header::result`] will return [link beast.ref.boost__beast__http__field `http::unknown`]. Use [link beast.ref.boost__beast__http__header.result_int `http::header::result_int`] to obtain the original raw status-code.
[heading Parameters][table [[Name][Description]]  [[`v`][    
The status-code integer to set.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::invalid_argument`][    
if `v > 999`.   ]]]
[endsect][endsect][section:result_int http::message::result_int](Inherited from `http::header`)[indexterm2 result_int..http::message]
The response status-code expressed as an integer. [heading Synopsis]```unsignedresult_int() const;```[heading Description]
This returns the raw status code as an integer, even when that code is not in the list of known status codes.
[heading Remarks]
This member is only available when `isRequest == false`. 
[endsect][section:target http::message::target][indexterm2 target..http::message]
Returns the request-target string. ```string_view``[link beast.ref.boost__beast__http__message.target.overload1 target]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.target.overload1 more...]]`````
Set the request-target string. ```void``[link beast.ref.boost__beast__http__message.target.overload2 target]``(    string_view s);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.target.overload2 more...]]`````[section:overload1 http::message::target (1 of 2 overloads)](Inherited from `http::header`)
Returns the request-target string. [heading Synopsis]```string_viewtarget() const;```[heading Description]
The request target string returned is the same string which was received from the network or stored. In particular, it will contain url-encoded characters and should follow the syntax rules for URIs used with HTTP.
[heading Remarks]
This function is only available when `isRequest == true`. 
[endsect][section:overload2 http::message::target (2 of 2 overloads)](Inherited from `http::header`)
Set the request-target string. [heading Synopsis]```voidtarget(    string_view s);```[heading Description]
It is the caller's responsibility to ensure that the request target string follows the syntax rules for URIs used with HTTP. In particular, reserved or special characters must be url-encoded. The implementation does not perform syntax checking on the passed string.
[heading Parameters][table [[Name][Description]]  [[`s`][    
A string representing the request-target.  ]]]
[heading Remarks]
This function is only available when `isRequest == true`. 
[endsect][endsect][section:version http::message::version][indexterm2 version..http::message]
Return the HTTP-version. ```unsigned``[link beast.ref.boost__beast__http__message.version.overload1 version]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.version.overload1 more...]]`````
Set the HTTP-version. ```void``[link beast.ref.boost__beast__http__message.version.overload2 version]``(    unsigned value);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.version.overload2 more...]]`````[section:overload1 http::message::version (1 of 2 overloads)](Inherited from `http::header`)
Return the HTTP-version. [heading Synopsis]```unsignedversion() const;```[heading Description]
This holds both the major and minor version numbers, using these formulas: ```  unsigned major = version / 10;
  unsigned minor = version % 10;
```
Newly constructed headers will use HTTP/1.1 by default. [endsect][section:overload2 http::message::version (2 of 2 overloads)](Inherited from `http::header`)
Set the HTTP-version. [heading Synopsis]```voidversion(    unsigned value);```[heading Description]
This holds both the major and minor version numbers, using these formulas: ```  unsigned major = version / 10;
  unsigned minor = version % 10;
```
Newly constructed headers will use HTTP/1.1 by default.
[heading Parameters][table [[Name][Description]]  [[`value`][    
The version number to use   ]]]
[endsect][endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__obsolete_reason http::obsolete_reason][indexterm1 http::obsolete_reason]
Returns the obsolete reason-phrase text for a status code. [heading Synopsis]Defined in header [include_file boost/beast/http/status.hpp]```string_viewobsolete_reason(    status v);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`v`][    
The status code to use.   ]]]
Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__operator_lt__lt_ http::operator<<][indexterm1 http::operator<<]
Write the text for a field name to an output stream. ```std::ostream&``[link beast.ref.boost__beast__http__operator_lt__lt_.overload1 operator<<]``(    std::ostream& os,    field f);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__operator_lt__lt_.overload1 more...]]`````
Outputs the standard reason phrase of a status code to a stream. ```std::ostream&``[link beast.ref.boost__beast__http__operator_lt__lt_.overload2 operator<<]``(    std::ostream&,    status);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__operator_lt__lt_.overload2 more...]]`````
Write the text for a request method verb to an output stream. ```std::ostream&``[link beast.ref.boost__beast__http__operator_lt__lt_.overload3 operator<<]``(    std::ostream& os,    verb v);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__operator_lt__lt_.overload3 more...]]`````
Serialize an HTTP/1 header to a `std::ostream`. ```template<    bool isRequest,    class __Fields__>std::ostream&``[link beast.ref.boost__beast__http__operator_lt__lt_.overload4 operator<<]``(    std::ostream& os,    header< isRequest, Fields > const& msg);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__operator_lt__lt_.overload4 more...]]`````
Serialize an HTTP/1 message to a `std::ostream`. ```template<    bool isRequest,    class __Body__,    class __Fields__>std::ostream&``[link beast.ref.boost__beast__http__operator_lt__lt_.overload5 operator<<]``(    std::ostream& os,    message< isRequest, Body, Fields > const& msg);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__operator_lt__lt_.overload5 more...]]`````[section:overload1 http::operator<< (1 of 5 overloads)]
Write the text for a field name to an output stream. [heading Synopsis]Defined in header [include_file boost/beast/http/field.hpp]```std::ostream&operator<<(    std::ostream& os,    field f);```[heading Description]Convenience header [include_file boost/beast/http.hpp][endsect][section:overload2 http::operator<< (2 of 5 overloads)]
Outputs the standard reason phrase of a status code to a stream. [heading Synopsis]Defined in header [include_file boost/beast/http/status.hpp]```std::ostream&operator<<(    std::ostream&,    status);```[heading Description]Convenience header [include_file boost/beast/http.hpp][endsect][section:overload3 http::operator<< (3 of 5 overloads)]
Write the text for a request method verb to an output stream. [heading Synopsis]Defined in header [include_file boost/beast/http/verb.hpp]```std::ostream&operator<<(    std::ostream& os,    verb v);```[heading Description]Convenience header [include_file boost/beast/http.hpp][endsect][section:overload4 http::operator<< (4 of 5 overloads)]
Serialize an HTTP/1 header to a `std::ostream`. [heading Synopsis]Defined in header [include_file boost/beast/http/write.hpp]```template<    bool isRequest,    class __Fields__>std::ostream&operator<<(    std::ostream& os,    header< isRequest, Fields > const& msg);```[heading Description]
The function converts the header to its HTTP/1 serialized representation and stores the result in the output stream.
[heading Parameters][table [[Name][Description]]  [[`os`][    
The output stream to write to.  ]]  [[`msg`][    
The message fields to write.   ]]]
Convenience header [include_file boost/beast/http.hpp][endsect][section:overload5 http::operator<< (5 of 5 overloads)]
Serialize an HTTP/1 message to a `std::ostream`. [heading Synopsis]Defined in header [include_file boost/beast/http/write.hpp]```template<    bool isRequest,    class __Body__,    class __Fields__>std::ostream&operator<<(    std::ostream& os,    message< isRequest, Body, Fields > const& msg);```[heading Description]
The function converts the message to its HTTP/1 serialized representation and stores the result in the output stream.
The implementation will automatically perform chunk encoding if the contents of the message indicate that chunk encoding is required.
[heading Parameters][table [[Name][Description]]  [[`os`][    
The output stream to write to.  ]]  [[`msg`][    
The message to write.   ]]]
Convenience header [include_file boost/beast/http.hpp][endsect][endsect][section:boost__beast__http__opt_token_list http::opt_token_list][indexterm1 http::opt_token_list]
A list of tokens in a comma separated HTTP field value. [heading Synopsis]Defined in header [include_file boost/beast/http/rfc7230.hpp]```using opt_token_list = detail::basic_parsed_list< detail::opt_token_list_policy >;```[heading Description]
This container allows iteration of a list of items in a header field value. The input is a comma separated list of tokens.
If a parsing error is encountered while iterating the string, the behavior of the container will be as if a string containing only characters up to but excluding the first invalid character was used to construct the list.
[heading BNF]
```  token-list  = *( "," OWS ) token *( OWS "," [ OWS token ] )
```
To use this class, construct with the string to be parsed and then use `begin` and `end`, or range-for to iterate each item:
[heading Example]
```  for(auto const& token : token_list{"apple, pear, banana"})
      std::cout << token << "\n";
```
Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__param_list http::param_list]
A list of parameters in an HTTP extension field value. [heading Synopsis]Defined in header [include_file boost/beast/http/rfc7230.hpp]```class param_list```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__param_list.const_iterator [*const_iterator]]]    [      A constant iterator to the list.     ]  ]  [    [[link beast.ref.boost__beast__http__param_list.value_type [*value_type]]]    [      The type of each element in the list.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__param_list.begin [*begin]]]    [      Return a const iterator to the beginning of the list.     ]  ]  [    [[link beast.ref.boost__beast__http__param_list.cbegin [*cbegin]]]    [      Return a const iterator to the beginning of the list.     ]  ]  [    [[link beast.ref.boost__beast__http__param_list.cend [*cend]]]    [      Return a const iterator to the end of the list.     ]  ]  [    [[link beast.ref.boost__beast__http__param_list.end [*end]]]    [      Return a const iterator to the end of the list.     ]  ]  [    [[link beast.ref.boost__beast__http__param_list.param_list [*param_list]]]    [      Default constructor.       Construct a list.     ]  ]][heading Description]
This container allows iteration of the parameter list in an HTTP extension. The parameter list is a series of name/value pairs with each pair starting with a semicolon. The value is optional.
If a parsing error is encountered while iterating the string, the behavior of the container will be as if a string containing only characters up to but excluding the first invalid character was used to construct the list.
[heading BNF]
```  param-list  = *( OWS ";" OWS param )
  param       = token OWS [ "=" OWS ( token / quoted-string ) ]
```
To use this class, construct with the string to be parsed and then use [link beast.ref.boost__beast__http__param_list.begin `http::param_list::begin`] and [link beast.ref.boost__beast__http__param_list.end `http::param_list::end`], or range-for to iterate each item:
[heading Example]
```  for(auto const& param : param_list{";level=9;no_context_takeover;bits=15"})
  {
      std::cout << ";" << param.first;
      if(! param.second.empty())
          std::cout << "=" << param.second;
      std::cout << "\n";
  }
```
[section:begin http::param_list::begin][indexterm2 begin..http::param_list]
Return a const iterator to the beginning of the list. [heading Synopsis]```const_iteratorbegin() const;```[heading Description][endsect][section:cbegin http::param_list::cbegin][indexterm2 cbegin..http::param_list]
Return a const iterator to the beginning of the list. [heading Synopsis]```const_iteratorcbegin() const;```[heading Description][endsect][section:cend http::param_list::cend][indexterm2 cend..http::param_list]
Return a const iterator to the end of the list. [heading Synopsis]```const_iteratorcend() const;```[heading Description][endsect][section:const_iterator http::param_list::const_iterator][indexterm2 const_iterator..http::param_list]
A constant iterator to the list. [heading Synopsis]```using const_iterator = ``['implementation-defined]``;```[heading Description][endsect][section:end http::param_list::end][indexterm2 end..http::param_list]
Return a const iterator to the end of the list. [heading Synopsis]```const_iteratorend() const;```[heading Description][endsect][section:param_list http::param_list::param_list][indexterm2 param_list..http::param_list]
Default constructor. `````[link beast.ref.boost__beast__http__param_list.param_list.overload1 param_list]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__param_list.param_list.overload1 more...]]`````
Construct a list. ```explicit``[link beast.ref.boost__beast__http__param_list.param_list.overload2 param_list]``(    string_view s);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__param_list.param_list.overload2 more...]]`````[section:overload1 http::param_list::param_list (1 of 2 overloads)]
Default constructor. [heading Synopsis]```param_list();```[heading Description][endsect][section:overload2 http::param_list::param_list (2 of 2 overloads)]
Construct a list. [heading Synopsis]```param_list(    string_view s);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`s`][    
A string containing the list contents. The string must remain valid for the lifetime of the container.   ]]]
[endsect][endsect][section:value_type http::param_list::value_type][indexterm2 value_type..http::param_list]
The type of each element in the list. [heading Synopsis]```using value_type = std::pair< string_view, string_view >;```[heading Description]
The first string in the pair is the name of the parameter, and the second string in the pair is its value (which may be empty). [endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__parser http::parser]
An HTTP/1 parser for producing a message. [heading Synopsis]Defined in header [include_file boost/beast/http/parser.hpp]```template<    bool isRequest,    class __Body__,    class __Allocator__ = std::allocator<char>>class parser :    public http::basic_parser< isRequest >```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__parser.is_request [*is_request]]]    [      true if this parser parses requests, false for responses.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.value_type [*value_type]]]    [      The type of message returned by the parser.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__parser.body_limit [*body_limit]]]    [      Set the limit on the payload body.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.chunked [*chunked]]]    [      Returns true if the last value for Transfer-Encoding is "chunked".     ]  ]  [    [[link beast.ref.boost__beast__http__parser.content_length [*content_length]]]    [      Returns the optional value of Content-Length if known.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.content_length_remaining [*content_length_remaining]]]    [      Returns the remaining content length if known.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.eager [*eager]]]    [      Returns true if the eager parse option is set.       Set the eager parse option.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.get [*get]]]    [      Returns the parsed message.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.got_some [*got_some]]]    [      Returns true if the parser has received at least one byte of input.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.header_limit [*header_limit]]]    [      Set a limit on the total size of the header.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.is_done [*is_done]]]    [      Returns true if the message is complete.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.is_header_done [*is_header_done]]]    [      Returns true if a the parser has produced the full header.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.keep_alive [*keep_alive]]]    [      Returns true if the message has keep-alive connection semantics.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.need_eof [*need_eof]]]    [      Returns true if the message semantics require an end of file.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.on_chunk_body [*on_chunk_body]]]    [      Set a callback to be invoked on chunk body data.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.on_chunk_header [*on_chunk_header]]]    [      Set a callback to be invoked on each chunk header.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.operator_eq_ [*operator=]]]    [      Assignment (disallowed)     ]  ]  [    [[link beast.ref.boost__beast__http__parser.parser [*parser]]]    [      Constructor (disallowed)       Constructor.       Construct a parser from another parser, changing the Body type.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.put [*put]]]    [      Write a buffer sequence to the parser.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.put_eof [*put_eof]]]    [      Inform the parser that the end of stream was reached.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.release [*release]]]    [      Returns ownership of the parsed message.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.skip [*skip]]]    [      Returns true if the skip parse option is set.       Set the skip parse option.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.upgrade [*upgrade]]]    [      Returns true if the message is an upgrade message.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.parser_dtor_ [*~parser]]]    [      Destructor.     ]  ]][heading Description]
This class uses the basic HTTP/1 wire format parser to convert a series of octets into a [link beast.ref.boost__beast__http__message `http::message`] using the [link beast.ref.boost__beast__http__basic_fields `http::basic_fields`] container to represent the fields.
[heading Template Parameters][table [[Type][Description]]  [[`isRequest`][    
Indicates whether a request or response will be parsed.  ]]  [[`Body`][    
The type used to represent the body. This must meet the requirements of ['Body].  ]]  [[`Allocator`][    
The type of allocator used with the [link beast.ref.boost__beast__http__basic_fields `http::basic_fields`] container.  ]]]
[heading Remarks]
A new instance of the parser is required for each message. 
[section:body_limit http::parser::body_limit](Inherited from `http::basic_parser`)[indexterm2 body_limit..http::parser]
Set the limit on the payload body. [heading Synopsis]```voidbody_limit(    std::uint64_t v);```[heading Description]
This function sets the maximum allowed size of the payload body, before any encodings except chunked have been removed. Depending on the message semantics, one of these cases will apply:

* The Content-Length is specified and exceeds the limit. In this case the result [link beast.ref.boost__beast__http__error `http::body_limit`] is returned immediately after the header is parsed.


* The Content-Length is unspecified and the chunked encoding is not specified as the last encoding. In this case the end of message is determined by the end of file indicator on the associated stream or input source. If a sufficient number of body payload octets are presented to the parser to exceed the configured limit, the parse fails with the result [link beast.ref.boost__beast__http__error `http::body_limit`]


* The Transfer-Encoding specifies the chunked encoding as the last encoding. In this case, when the number of payload body octets produced by removing the chunked encoding exceeds the configured limit, the parse fails with the result [link beast.ref.boost__beast__http__error `http::body_limit`].

Setting the limit after any body octets have been parsed results in undefined behavior.
The default limit is 1MB for requests and 8MB for responses.
[heading Parameters][table [[Name][Description]]  [[`v`][    
The payload body limit to set   ]]]
[endsect][section:chunked http::parser::chunked](Inherited from `http::basic_parser`)[indexterm2 chunked..http::parser]
Returns `true` if the last value for Transfer-Encoding is "chunked". [heading Synopsis]```boolchunked() const;```[heading Description]
[heading Remarks]
The return value is undefined unless [link beast.ref.boost__beast__http__basic_parser.is_header_done `http::basic_parser::is_header_done`] would return `true`. 
[endsect][section:content_length http::parser::content_length](Inherited from `http::basic_parser`)[indexterm2 content_length..http::parser]
Returns the optional value of Content-Length if known. [heading Synopsis]```boost::optional< std::uint64_t >content_length() const;```[heading Description]
[heading Remarks]
The return value is undefined unless [link beast.ref.boost__beast__http__basic_parser.is_header_done `http::basic_parser::is_header_done`] would return `true`. 
[endsect][section:content_length_remaining http::parser::content_length_remaining](Inherited from `http::basic_parser`)[indexterm2 content_length_remaining..http::parser]
Returns the remaining content length if known. [heading Synopsis]```boost::optional< std::uint64_t >content_length_remaining() const;```[heading Description]
If the message header specifies a Content-Length, the return value will be the number of bytes remaining in the payload body have not yet been parsed.
[heading Remarks]
The return value is undefined unless [link beast.ref.boost__beast__http__basic_parser.is_header_done `http::basic_parser::is_header_done`] would return `true`. 
[endsect][section:eager http::parser::eager][indexterm2 eager..http::parser]
Returns `true` if the eager parse option is set. ```bool``[link beast.ref.boost__beast__http__parser.eager.overload1 eager]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__parser.eager.overload1 more...]]`````
Set the eager parse option. ```void``[link beast.ref.boost__beast__http__parser.eager.overload2 eager]``(    bool v);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__parser.eager.overload2 more...]]`````[section:overload1 http::parser::eager (1 of 2 overloads)](Inherited from `http::basic_parser`)
Returns `true` if the eager parse option is set. [heading Synopsis]```booleager() const;```[heading Description][endsect][section:overload2 http::parser::eager (2 of 2 overloads)](Inherited from `http::basic_parser`)
Set the eager parse option. [heading Synopsis]```voideager(    bool v);```[heading Description]
Normally the parser returns after successfully parsing a structured element (header, chunk header, or chunk body) even if there are octets remaining in the input. This is necessary when attempting to parse the header first, or when the caller wants to inspect information which may be invalidated by subsequent parsing, such as a chunk extension. The `eager` option controls whether the parser keeps going after parsing structured element if there are octets remaining in the buffer and no error occurs. This option is automatically set or cleared during certain stream operations to improve performance with no change in functionality.
The default setting is `false`.
[heading Parameters][table [[Name][Description]]  [[`v`][    
`true` to set the eager parse option or `false` to disable it.   ]]]
[endsect][endsect][section:get http::parser::get][indexterm2 get..http::parser]
Returns the parsed message. ```value_type const &``[link beast.ref.boost__beast__http__parser.get.overload1 get]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__parser.get.overload1 more...]]``value_type&``[link beast.ref.boost__beast__http__parser.get.overload2 get]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__parser.get.overload2 more...]]`````[section:overload1 http::parser::get (1 of 2 overloads)]
Returns the parsed message. [heading Synopsis]```value_type const &get() const;```[heading Description]
Depending on the parser's progress, parts of this object may be incomplete. [endsect][section:overload2 http::parser::get (2 of 2 overloads)]
Returns the parsed message. [heading Synopsis]```value_type&get();```[heading Description]
Depending on the parser's progress, parts of this object may be incomplete. [endsect][endsect][section:got_some http::parser::got_some](Inherited from `http::basic_parser`)[indexterm2 got_some..http::parser]
Returns `true` if the parser has received at least one byte of input. [heading Synopsis]```boolgot_some() const;```[heading Description][endsect][section:header_limit http::parser::header_limit](Inherited from `http::basic_parser`)[indexterm2 header_limit..http::parser]
Set a limit on the total size of the header. [heading Synopsis]```voidheader_limit(    std::uint32_t v);```[heading Description]
This function sets the maximum allowed size of the header including all field name, value, and delimiter characters and also including the CRLF sequences in the serialized input. If the end of the header is not found within the limit of the header size, the error [link beast.ref.boost__beast__http__error `http::header_limit`] is returned by [link beast.ref.boost__beast__http__basic_parser.put `http::basic_parser::put`].
Setting the limit after any header octets have been parsed results in undefined behavior. [endsect][section:is_done http::parser::is_done](Inherited from `http::basic_parser`)[indexterm2 is_done..http::parser]
Returns `true` if the message is complete. [heading Synopsis]```boolis_done() const;```[heading Description]
The message is complete after the full header is prduced and one of the following is true:

* The skip body option was set.


* The semantics of the message indicate there is no body.


* The semantics of the message indicate a body is expected, and the entire body was parsed. 

[endsect][section:is_header_done http::parser::is_header_done](Inherited from `http::basic_parser`)[indexterm2 is_header_done..http::parser]
Returns `true` if a the parser has produced the full header. [heading Synopsis]```boolis_header_done() const;```[heading Description][endsect][section:is_request http::parser::is_request](Inherited from `http::basic_parser`)[indexterm2 is_request..http::parser]
`true` if this parser parses requests, `false` for responses. [heading Synopsis]```using is_request = std::integral_constant< bool, isRequest >;```[heading Description][endsect][section:keep_alive http::parser::keep_alive](Inherited from `http::basic_parser`)[indexterm2 keep_alive..http::parser]
Returns `true` if the message has keep-alive connection semantics. [heading Synopsis]```boolkeep_alive() const;```[heading Description]
This function always returns `false` if [link beast.ref.boost__beast__http__basic_parser.need_eof `http::basic_parser::need_eof`] would return `false`.
[heading Remarks]
The return value is undefined unless [link beast.ref.boost__beast__http__basic_parser.is_header_done `http::basic_parser::is_header_done`] would return `true`. 
[endsect][section:need_eof http::parser::need_eof](Inherited from `http::basic_parser`)[indexterm2 need_eof..http::parser]
Returns `true` if the message semantics require an end of file. [heading Synopsis]```boolneed_eof() const;```[heading Description]
Depending on the contents of the header, the parser may require and end of file notification to know where the end of the body lies. If this function returns `true` it will be necessary to call [link beast.ref.boost__beast__http__basic_parser.put_eof `http::basic_parser::put_eof`] when there will never be additional data from the input. [endsect][section:on_chunk_body http::parser::on_chunk_body][indexterm2 on_chunk_body..http::parser]
Set a callback to be invoked on chunk body data. [heading Synopsis]```template<    class Callback>voidon_chunk_body(    Callback& cb);```[heading Description]
The provided function object will be invoked one or more times to provide buffers corresponding to the chunk body for the current chunk. The callback receives the number of octets remaining in this chunk body including the octets in the buffer provided.
The callback must return the number of octets actually consumed. Any octets not consumed will be presented again in a subsequent invocation of the callback. The implementation type-erases the callback without requiring a dynamic allocation. For this reason, the callback object is passed by a non-constant reference.
[heading Example]
```  auto callback =
      [](std::uint64_t remain, string_view body, error_code& ec)
      {
          //...
      };
  parser.on_chunk_body(callback);
```
[heading Parameters][table [[Name][Description]]  [[`cb`][    
The function to set, which must be invocable with this equivalent signature: ```  std::size_t
  on_chunk_header(
      std::uint64_t remain,       // Octets remaining in this chunk, includes `body`
      string_view body,           // A buffer holding some or all of the remainder of the chunk body
      error_code& ec);            // May be set by the callback to indicate an error
```  ]]]
[endsect][section:on_chunk_header http::parser::on_chunk_header][indexterm2 on_chunk_header..http::parser]
Set a callback to be invoked on each chunk header. [heading Synopsis]```template<    class Callback>voidon_chunk_header(    Callback& cb);```[heading Description]
The callback will be invoked once for every chunk in the message payload, as well as once for the last chunk. The invocation happens after the chunk header is available but before any body octets have been parsed.
The extensions are provided in raw, validated form, use [link beast.ref.boost__beast__http__basic_chunk_extensions.parse `http::basic_chunk_extensions::parse`] to parse the extensions into a structured container for easier access. The implementation type-erases the callback without requiring a dynamic allocation. For this reason, the callback object is passed by a non-constant reference.
[heading Example]
```  auto callback =
      [](std::uint64_t size, string_view extensions, error_code& ec)
      {
          //...
      };
  parser.on_chunk_header(callback);
```
[heading Parameters][table [[Name][Description]]  [[`cb`][    
The function to set, which must be invocable with this equivalent signature: ```  void
  on_chunk_header(
      std::uint64_t size,         // Size of the chunk, zero for the last chunk
      string_view extensions,     // The chunk-extensions in raw form
      error_code& ec);            // May be set by the callback to indicate an error
```  ]]]
[endsect][section:operator_eq_ http::parser::operator=][indexterm2 operator=..http::parser]
Assignment (disallowed) [heading Synopsis]```parser&operator=(    parser const&);```[heading Description][endsect][section:parser http::parser::parser][indexterm2 parser..http::parser]
Constructor (disallowed) `````[link beast.ref.boost__beast__http__parser.parser.overload1 parser]``(    parser const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__parser.parser.overload1 more...]]````[link beast.ref.boost__beast__http__parser.parser.overload2 parser]``(    parser&& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__parser.parser.overload2 more...]]`````
Constructor. `````[link beast.ref.boost__beast__http__parser.parser.overload3 parser]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__parser.parser.overload3 more...]]``template<    class... Args>explicit``[link beast.ref.boost__beast__http__parser.parser.overload4 parser]``(    Args&&... args);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__parser.parser.overload4 more...]]`````
Construct a parser from another parser, changing the Body type. ```template<    class OtherBody,    class... Args>explicit``[link beast.ref.boost__beast__http__parser.parser.overload5 parser]``(    parser< isRequest, OtherBody, Allocator >&& parser,    Args&&... args);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__parser.parser.overload5 more...]]`````[section:overload1 http::parser::parser (1 of 5 overloads)]
Constructor (disallowed) [heading Synopsis]```parser(    parser const&);```[heading Description][endsect][section:overload2 http::parser::parser (2 of 5 overloads)]
Constructor (disallowed) [heading Synopsis]```parser(    parser&& other);```[heading Description][endsect][section:overload3 http::parser::parser (3 of 5 overloads)]
Constructor. [heading Synopsis]```parser();```[heading Description][endsect][section:overload4 http::parser::parser (4 of 5 overloads)]
Constructor. [heading Synopsis]```template<    class... Args>parser(    Args&&... args);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`args`][    
Optional arguments forwarded to the [link beast.ref.boost__beast__http__message `http::message`] constructor.  ]]]
[heading Remarks]
This function participates in overload resolution only if the first argument is not a [link beast.ref.boost__beast__http__parser `http::parser`]. 
[endsect][section:overload5 http::parser::parser (5 of 5 overloads)]
Construct a parser from another parser, changing the Body type. [heading Synopsis]```template<    class OtherBody,    class... Args>parser(    parser< isRequest, OtherBody, Allocator >&& parser,    Args&&... args);```[heading Description]
This constructs a new parser by move constructing the header from another parser with a different body type. The constructed-from parser must not have any parsed body octets or initialized ['BodyReader], otherwise an exception is generated.
[heading Example]
```  // Deferred body type commitment
  request_parser<empty_body> req0;
  ...
  request_parser<string_body> req{std::move(req0)};
```
If an exception is thrown, the state of the constructed-from parser is undefined.
[heading Parameters][table [[Name][Description]]  [[`parser`][    
The other parser to construct from. After this call returns, the constructed-from parser may only be destroyed.  ]]  [[`args`][    
Optional arguments forwarded to the message constructor.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::invalid_argument`][    
Thrown when the constructed-from parser has already initialized a body reader.  ]]]
[heading Remarks]
This function participates in overload resolution only if the other parser uses a different body type. 
[endsect][endsect][section:put http::parser::put](Inherited from `http::basic_parser`)[indexterm2 put..http::parser]
Write a buffer sequence to the parser. [heading Synopsis]```template<    class __ConstBufferSequence__>std::size_tput(    ConstBufferSequence const& buffers,    error_code& ec);```[heading Description]
This function attempts to incrementally parse the HTTP message data stored in the caller provided buffers. Upon success, a positive return value indicates that the parser made forward progress, consuming that number of bytes.
In some cases there may be an insufficient number of octets in the input buffer in order to make forward progress. This is indicated by the code [link beast.ref.boost__beast__http__error `http::need_more`]. When this happens, the caller should place additional bytes into the buffer sequence and call [link beast.ref.boost__beast__http__basic_parser.put `http::basic_parser::put`] again.
The error code [link beast.ref.boost__beast__http__error `http::need_more`] is special. When this error is returned, a subsequent call to [link beast.ref.boost__beast__http__basic_parser.put `http::basic_parser::put`] may succeed if the buffers have been updated. Otherwise, upon error the parser may not be restarted.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
An object meeting the requirements of ['ConstBufferSequence] that represents the next chunk of message data. If the length of this buffer sequence is one, the implementation will not allocate additional memory. The class [link beast.ref.boost__beast__basic_flat_buffer `basic_flat_buffer`] is provided as one way to meet this requirement  ]]  [[`ec`][    
Set to the error, if any occurred.  ]]]
[heading Return Value]
The number of octets consumed in the buffer sequence. The caller should remove these octets even if the error is set. 
[endsect][section:put_eof http::parser::put_eof](Inherited from `http::basic_parser`)[indexterm2 put_eof..http::parser]
Inform the parser that the end of stream was reached. [heading Synopsis]```voidput_eof(    error_code& ec);```[heading Description]
In certain cases, HTTP needs to know where the end of the stream is. For example, sometimes servers send responses without Content-Length and expect the client to consume input (for the body) until EOF. Callbacks and errors will still be processed as usual.
This is typically called when a read from the underlying stream object sets the error code to `net::error::eof`.
[heading Remarks]
Only valid after parsing a complete header.
[heading Parameters][table [[Name][Description]]  [[`ec`][    
Set to the error, if any occurred.   ]]]
[endsect][section:release http::parser::release][indexterm2 release..http::parser]
Returns ownership of the parsed message. [heading Synopsis]```value_typerelease();```[heading Description]
Ownership is transferred to the caller. Depending on the parser's progress, parts of this object may be incomplete.
[heading Requires]

[link beast.ref.boost__beast__http__parser.value_type `http::parser::value_type`] is [*MoveConstructible] [endsect][section:skip http::parser::skip][indexterm2 skip..http::parser]
Returns `true` if the skip parse option is set. ```bool``[link beast.ref.boost__beast__http__parser.skip.overload1 skip]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__parser.skip.overload1 more...]]`````
Set the skip parse option. ```void``[link beast.ref.boost__beast__http__parser.skip.overload2 skip]``(    bool v);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__parser.skip.overload2 more...]]`````[section:overload1 http::parser::skip (1 of 2 overloads)](Inherited from `http::basic_parser`)
Returns `true` if the skip parse option is set. [heading Synopsis]```boolskip() const;```[heading Description][endsect][section:overload2 http::parser::skip (2 of 2 overloads)](Inherited from `http::basic_parser`)
Set the skip parse option. [heading Synopsis]```voidskip(    bool v);```[heading Description]
This option controls whether or not the parser expects to see an HTTP body, regardless of the presence or absence of certain fields such as Content-Length or a chunked Transfer-Encoding. Depending on the request, some responses do not carry a body. For example, a 200 response to a CONNECT request from a tunneling proxy, or a response to a HEAD request. In these cases, callers may use this function inform the parser that no body is expected. The parser will consider the message complete after the header has been received.
[heading Parameters][table [[Name][Description]]  [[`v`][    
`true` to set the skip body option or `false` to disable it.  ]]]
[heading Remarks]
This function must called before any bytes are processed. 
[endsect][endsect][section:upgrade http::parser::upgrade](Inherited from `http::basic_parser`)[indexterm2 upgrade..http::parser]
Returns `true` if the message is an upgrade message. [heading Synopsis]```boolupgrade() const;```[heading Description]
[heading Remarks]
The return value is undefined unless [link beast.ref.boost__beast__http__basic_parser.is_header_done `http::basic_parser::is_header_done`] would return `true`. 
[endsect][section:value_type http::parser::value_type][indexterm2 value_type..http::parser]
The type of message returned by the parser. [heading Synopsis]```using value_type = message< isRequest, Body, basic_fields< Allocator > >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__message.body_type [*body_type]]]    [      The type providing the body traits.     ]  ]  [    [[link beast.ref.boost__beast__http__message.fields_type [*fields_type]]]    [      The type representing the fields.     ]  ]  [    [[link beast.ref.boost__beast__http__message.header_type [*header_type]]]    [      The base class used to hold the header portion of the message.     ]  ]  [    [[link beast.ref.boost__beast__http__message.is_request [*is_request]]]    [      Indicates if the header is a request or response.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__message.base [*base]]]    [      Returns the header portion of the message.     ]  ]  [    [[link beast.ref.boost__beast__http__message.body [*body]]]    [      Returns the body.     ]  ]  [    [[link beast.ref.boost__beast__http__message.chunked [*chunked]]]    [      Returns true if the chunked Transfer-Encoding is specified.       Set or clear the chunked Transfer-Encoding.     ]  ]  [    [[link beast.ref.boost__beast__http__message.content_length [*content_length]]]    [      Set or clear the Content-Length field.     ]  ]  [    [[link beast.ref.boost__beast__http__message.has_content_length [*has_content_length]]]    [      Returns true if the Content-Length field is present.     ]  ]  [    [[link beast.ref.boost__beast__http__message.keep_alive [*keep_alive]]]    [      Returns true if the message semantics indicate keep-alive.       Set the keep-alive message semantic option.     ]  ]  [    [[link beast.ref.boost__beast__http__message.message [*message]]]    [      Constructor.       Construct a message.     ]  ]  [    [[link beast.ref.boost__beast__http__message.method [*method]]]    [      Return the request-method verb.       Set the request-method.     ]  ]  [    [[link beast.ref.boost__beast__http__message.method_string [*method_string]]]    [      Return the request-method as a string.     ]  ]  [    [[link beast.ref.boost__beast__http__message.need_eof [*need_eof]]]    [      Returns true if the message semantics require an end of file.     ]  ]  [    [[link beast.ref.boost__beast__http__message.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__http__message.payload_size [*payload_size]]]    [      Returns the payload size of the body in octets if possible.     ]  ]  [    [[link beast.ref.boost__beast__http__message.prepare_payload [*prepare_payload]]]    [      Prepare the message payload fields for the body.     ]  ]  [    [[link beast.ref.boost__beast__http__message.reason [*reason]]]    [      Return the response reason-phrase.       Set the response reason-phrase (deprecated)     ]  ]  [    [[link beast.ref.boost__beast__http__message.result [*result]]]    [      The response status-code result.       Set the response status-code.       Set the response status-code as an integer.     ]  ]  [    [[link beast.ref.boost__beast__http__message.result_int [*result_int]]]    [      The response status-code expressed as an integer.     ]  ]  [    [[link beast.ref.boost__beast__http__message.target [*target]]]    [      Returns the request-target string.       Set the request-target string.     ]  ]  [    [[link beast.ref.boost__beast__http__message.version [*version]]]    [      Return the HTTP-version.       Set the HTTP-version.     ]  ]]
This container is derived from the `Fields` template type. To understand all of the members of this class it is necessary to view the declaration for the `Fields` type. When using the default fields container, those declarations are in [link beast.ref.boost__beast__http__fields `http::fields`].
A message can be a request or response, depending on the `isRequest` template argument value. Requests and responses have different types; functions may be overloaded based on the type if desired.
The `Body` template argument type determines the model used to read or write the content body of the message.
Newly constructed messages objects have version set to HTTP/1.1. Newly constructed response objects also have result code set to [link beast.ref.boost__beast__http__status `http::ok`].
[heading Template Parameters][table [[Type][Description]]  [[`isRequest`][    
`true` if this represents a request, or `false` if this represents a response. Some class data members are conditionally present depending on this value.  ]]  [[`Body`][    
A type meeting the requirements of Body.  ]]  [[`Fields`][    
The type of container used to hold the field value pairs.   ]]]
[heading Description][endsect][section:parser_dtor_ http::parser::~parser][indexterm2 ~parser..http::parser]
Destructor. [heading Synopsis]```~parser();```[heading Description][endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__read http::read][indexterm1 http::read]
Read a complete message from a stream using a parser. ```template<    class __SyncReadStream__,    class __DynamicBuffer__,    bool isRequest>std::size_t``[link beast.ref.boost__beast__http__read.overload1 read]``(    SyncReadStream& stream,    DynamicBuffer& buffer,    basic_parser< isRequest >& parser);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__read.overload1 more...]]``template<    class __SyncReadStream__,    class __DynamicBuffer__,    bool isRequest>std::size_t``[link beast.ref.boost__beast__http__read.overload2 read]``(    SyncReadStream& stream,    DynamicBuffer& buffer,    basic_parser< isRequest >& parser,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__read.overload2 more...]]`````
Read a complete message from a stream. ```template<    class __SyncReadStream__,    class __DynamicBuffer__,    bool isRequest,    class __Body__,    class __Allocator__>std::size_t``[link beast.ref.boost__beast__http__read.overload3 read]``(    SyncReadStream& stream,    DynamicBuffer& buffer,    message< isRequest, Body, basic_fields< Allocator >>& msg);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__read.overload3 more...]]``template<    class __SyncReadStream__,    class __DynamicBuffer__,    bool isRequest,    class __Body__,    class __Allocator__>std::size_t``[link beast.ref.boost__beast__http__read.overload4 read]``(    SyncReadStream& stream,    DynamicBuffer& buffer,    message< isRequest, Body, basic_fields< Allocator >>& msg,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__read.overload4 more...]]`````[section:overload1 http::read (1 of 4 overloads)]
Read a complete message from a stream using a parser. [heading Synopsis]Defined in header [include_file boost/beast/http/read.hpp]```template<    class __SyncReadStream__,    class __DynamicBuffer__,    bool isRequest>std::size_tread(    SyncReadStream& stream,    DynamicBuffer& buffer,    basic_parser< isRequest >& parser);```[heading Description]
This function is used to read a complete message from a stream into an instance of [link beast.ref.boost__beast__http__basic_parser `http::basic_parser`]. The call will block until one of the following conditions is true:

* [link beast.ref.boost__beast__http__basic_parser.is_done `http::basic_parser::is_done`] returns `true`


* An error occurs.

This operation is implemented in terms of one or more calls to the stream's `read_some` function. The implementation may read additional bytes from the stream that lie past the end of the message being read. These additional bytes are stored in the dynamic buffer, which must be preserved for subsequent reads.
If the end of file error is received while reading from the stream, then the error returned from this function will be:

* [link beast.ref.boost__beast__http__error `http::end_of_stream`] if no bytes were parsed, or


* [link beast.ref.boost__beast__http__error `http::partial_message`] if any bytes were parsed but the message was incomplete, otherwise:


* A successful result. The next attempt to read will return [link beast.ref.boost__beast__http__error `http::end_of_stream`]

[heading Parameters][table [[Name][Description]]  [[`stream`][    
The stream from which the data is to be read. The type must meet the ['SyncReadStream] requirements.  ]]  [[`buffer`][    
Storage for additional bytes read by the implementation from the stream. This is both an input and an output parameter; on entry, the parser will be presented with any remaining data in the dynamic buffer's readable bytes sequence first. The type must meet the ['DynamicBuffer] requirements.  ]]  [[`parser`][    
The parser to use.  ]]]
[heading Return Value]
The number of bytes transferred from the stream.
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    
Thrown on failure.  ]]]
[heading Remarks]
The function returns the total number of bytes transferred from the stream. This may be zero for the case where there is sufficient pre-existing message data in the dynamic buffer. The implementation will call [link beast.ref.boost__beast__http__basic_parser.eager `http::basic_parser::eager`] with the value `true` on the parser passed in. 
Convenience header [include_file boost/beast/http.hpp][endsect][section:overload2 http::read (2 of 4 overloads)]
Read a complete message from a stream using a parser. [heading Synopsis]Defined in header [include_file boost/beast/http/read.hpp]```template<    class __SyncReadStream__,    class __DynamicBuffer__,    bool isRequest>std::size_tread(    SyncReadStream& stream,    DynamicBuffer& buffer,    basic_parser< isRequest >& parser,    error_code& ec);```[heading Description]
This function is used to read a complete message from a stream into an instance of [link beast.ref.boost__beast__http__basic_parser `http::basic_parser`]. The call will block until one of the following conditions is true:

* [link beast.ref.boost__beast__http__basic_parser.is_done `http::basic_parser::is_done`] returns `true`


* An error occurs.

This operation is implemented in terms of one or more calls to the stream's `read_some` function. The implementation may read additional bytes from the stream that lie past the end of the message being read. These additional bytes are stored in the dynamic buffer, which must be preserved for subsequent reads.
If the end of file error is received while reading from the stream, then the error returned from this function will be:

* [link beast.ref.boost__beast__http__error `http::end_of_stream`] if no bytes were parsed, or


* [link beast.ref.boost__beast__http__error `http::partial_message`] if any bytes were parsed but the message was incomplete, otherwise:


* A successful result. The next attempt to read will return [link beast.ref.boost__beast__http__error `http::end_of_stream`]

[heading Parameters][table [[Name][Description]]  [[`stream`][    
The stream from which the data is to be read. The type must meet the ['SyncReadStream] requirements.  ]]  [[`buffer`][    
Storage for additional bytes read by the implementation from the stream. This is both an input and an output parameter; on entry, the parser will be presented with any remaining data in the dynamic buffer's readable bytes sequence first. The type must meet the ['DynamicBuffer] requirements.  ]]  [[`parser`][    
The parser to use.  ]]  [[`ec`][    
Set to the error, if any occurred.  ]]]
[heading Return Value]
The number of bytes transferred from the stream.
[heading Remarks]
The function returns the total number of bytes transferred from the stream. This may be zero for the case where there is sufficient pre-existing message data in the dynamic buffer. The implementation will call [link beast.ref.boost__beast__http__basic_parser.eager `http::basic_parser::eager`] with the value `true` on the parser passed in. 
Convenience header [include_file boost/beast/http.hpp][endsect][section:overload3 http::read (3 of 4 overloads)]
Read a complete message from a stream. [heading Synopsis]Defined in header [include_file boost/beast/http/read.hpp]```template<    class __SyncReadStream__,    class __DynamicBuffer__,    bool isRequest,    class __Body__,    class __Allocator__>std::size_tread(    SyncReadStream& stream,    DynamicBuffer& buffer,    message< isRequest, Body, basic_fields< Allocator >>& msg);```[heading Description]
This function is used to read a complete message from a stream into an instance of [link beast.ref.boost__beast__http__message `http::message`]. The call will block until one of the following conditions is true:

* The entire message is read in.


* An error occurs.

This operation is implemented in terms of one or more calls to the stream's `read_some` function. The implementation may read additional bytes from the stream that lie past the end of the message being read. These additional bytes are stored in the dynamic buffer, which must be preserved for subsequent reads.
If the end of file error is received while reading from the stream, then the error returned from this function will be:

* [link beast.ref.boost__beast__http__error `http::end_of_stream`] if no bytes were parsed, or


* [link beast.ref.boost__beast__http__error `http::partial_message`] if any bytes were parsed but the message was incomplete, otherwise:


* A successful result. The next attempt to read will return [link beast.ref.boost__beast__http__error `http::end_of_stream`]

[heading Parameters][table [[Name][Description]]  [[`stream`][    
The stream from which the data is to be read. The type must meet the ['SyncReadStream] requirements.  ]]  [[`buffer`][    
Storage for additional bytes read by the implementation from the stream. This is both an input and an output parameter; on entry, the parser will be presented with any remaining data in the dynamic buffer's readable bytes sequence first. The type must meet the ['DynamicBuffer] requirements.  ]]  [[`msg`][    
The container in which to store the message contents. This message container should not have previous contents, otherwise the behavior is undefined. The type must be meet the ['MoveAssignable] and ['MoveConstructible] requirements.  ]]]
[heading Return Value]
The number of bytes transferred from the stream.
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    
Thrown on failure.  ]]]
[heading Remarks]
The function returns the total number of bytes transferred from the stream. This may be zero for the case where there is sufficient pre-existing message data in the dynamic buffer. The implementation will call [link beast.ref.boost__beast__http__basic_parser.eager `http::basic_parser::eager`] with the value `true` on the parser passed in. 
Convenience header [include_file boost/beast/http.hpp][endsect][section:overload4 http::read (4 of 4 overloads)]
Read a complete message from a stream. [heading Synopsis]Defined in header [include_file boost/beast/http/read.hpp]```template<    class __SyncReadStream__,    class __DynamicBuffer__,    bool isRequest,    class __Body__,    class __Allocator__>std::size_tread(    SyncReadStream& stream,    DynamicBuffer& buffer,    message< isRequest, Body, basic_fields< Allocator >>& msg,    error_code& ec);```[heading Description]
This function is used to read a complete message from a stream into an instance of [link beast.ref.boost__beast__http__message `http::message`]. The call will block until one of the following conditions is true:

* The entire message is read in.


* An error occurs.

This operation is implemented in terms of one or more calls to the stream's `read_some` function. The implementation may read additional bytes from the stream that lie past the end of the message being read. These additional bytes are stored in the dynamic buffer, which must be preserved for subsequent reads.
If the end of file error is received while reading from the stream, then the error returned from this function will be:

* [link beast.ref.boost__beast__http__error `http::end_of_stream`] if no bytes were parsed, or


* [link beast.ref.boost__beast__http__error `http::partial_message`] if any bytes were parsed but the message was incomplete, otherwise:


* A successful result. The next attempt to read will return [link beast.ref.boost__beast__http__error `http::end_of_stream`]

[heading Parameters][table [[Name][Description]]  [[`stream`][    
The stream from which the data is to be read. The type must meet the ['SyncReadStream] requirements.  ]]  [[`buffer`][    
Storage for additional bytes read by the implementation from the stream. This is both an input and an output parameter; on entry, the parser will be presented with any remaining data in the dynamic buffer's readable bytes sequence first. The type must meet the ['DynamicBuffer] requirements.  ]]  [[`msg`][    
The container in which to store the message contents. This message container should not have previous contents, otherwise the behavior is undefined. The type must be meet the ['MoveAssignable] and ['MoveConstructible] requirements.  ]]  [[`ec`][    
Set to the error, if any occurred.  ]]]
[heading Return Value]
The number of bytes transferred from the stream.
[heading Remarks]
The function returns the total number of bytes transferred from the stream. This may be zero for the case where there is sufficient pre-existing message data in the dynamic buffer. The implementation will call [link beast.ref.boost__beast__http__basic_parser.eager `http::basic_parser::eager`] with the value `true` on the parser passed in. 
Convenience header [include_file boost/beast/http.hpp][endsect][endsect][section:boost__beast__http__read_header http::read_header][indexterm1 http::read_header]
Read a complete message header from a stream using a parser. ```template<    class __SyncReadStream__,    class __DynamicBuffer__,    bool isRequest>std::size_t``[link beast.ref.boost__beast__http__read_header.overload1 read_header]``(    SyncReadStream& stream,    DynamicBuffer& buffer,    basic_parser< isRequest >& parser);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__read_header.overload1 more...]]``template<    class __SyncReadStream__,    class __DynamicBuffer__,    bool isRequest>std::size_t``[link beast.ref.boost__beast__http__read_header.overload2 read_header]``(    SyncReadStream& stream,    DynamicBuffer& buffer,    basic_parser< isRequest >& parser,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__read_header.overload2 more...]]`````[section:overload1 http::read_header (1 of 2 overloads)]
Read a complete message header from a stream using a parser. [heading Synopsis]Defined in header [include_file boost/beast/http/read.hpp]```template<    class __SyncReadStream__,    class __DynamicBuffer__,    bool isRequest>std::size_tread_header(    SyncReadStream& stream,    DynamicBuffer& buffer,    basic_parser< isRequest >& parser);```[heading Description]
This function is used to read a complete message header from a stream into an instance of [link beast.ref.boost__beast__http__basic_parser `http::basic_parser`]. The call will block until one of the following conditions is true:

* [link beast.ref.boost__beast__http__basic_parser.is_header_done `http::basic_parser::is_header_done`] returns `true`


* An error occurs.

This operation is implemented in terms of one or more calls to the stream's `read_some` function. The implementation may read additional bytes from the stream that lie past the end of the message being read. These additional bytes are stored in the dynamic buffer, which must be preserved for subsequent reads.
If the end of file error is received while reading from the stream, then the error returned from this function will be:

* [link beast.ref.boost__beast__http__error `http::end_of_stream`] if no bytes were parsed, or


* [link beast.ref.boost__beast__http__error `http::partial_message`] if any bytes were parsed but the message was incomplete, otherwise:


* A successful result. The next attempt to read will return [link beast.ref.boost__beast__http__error `http::end_of_stream`]

[heading Parameters][table [[Name][Description]]  [[`stream`][    
The stream from which the data is to be read. The type must meet the ['SyncReadStream] requirements.  ]]  [[`buffer`][    
Storage for additional bytes read by the implementation from the stream. This is both an input and an output parameter; on entry, the parser will be presented with any remaining data in the dynamic buffer's readable bytes sequence first. The type must meet the ['DynamicBuffer] requirements.  ]]  [[`parser`][    
The parser to use.  ]]]
[heading Return Value]
The number of bytes transferred from the stream.
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    
Thrown on failure.  ]]]
[heading Remarks]
The function returns the total number of bytes transferred from the stream. This may be zero for the case where there is sufficient pre-existing message data in the dynamic buffer. The implementation will call [link beast.ref.boost__beast__http__basic_parser.eager `http::basic_parser::eager`] with the value `false` on the parser passed in. 
Convenience header [include_file boost/beast/http.hpp][endsect][section:overload2 http::read_header (2 of 2 overloads)]
Read a complete message header from a stream using a parser. [heading Synopsis]Defined in header [include_file boost/beast/http/read.hpp]```template<    class __SyncReadStream__,    class __DynamicBuffer__,    bool isRequest>std::size_tread_header(    SyncReadStream& stream,    DynamicBuffer& buffer,    basic_parser< isRequest >& parser,    error_code& ec);```[heading Description]
This function is used to read a complete message header from a stream into an instance of [link beast.ref.boost__beast__http__basic_parser `http::basic_parser`]. The call will block until one of the following conditions is true:

* [link beast.ref.boost__beast__http__basic_parser.is_header_done `http::basic_parser::is_header_done`] returns `true`


* An error occurs.

This operation is implemented in terms of one or more calls to the stream's `read_some` function. The implementation may read additional bytes from the stream that lie past the end of the message being read. These additional bytes are stored in the dynamic buffer, which must be preserved for subsequent reads.
If the end of file error is received while reading from the stream, then the error returned from this function will be:

* [link beast.ref.boost__beast__http__error `http::end_of_stream`] if no bytes were parsed, or


* [link beast.ref.boost__beast__http__error `http::partial_message`] if any bytes were parsed but the message was incomplete, otherwise:


* A successful result. The next attempt to read will return [link beast.ref.boost__beast__http__error `http::end_of_stream`]

[heading Parameters][table [[Name][Description]]  [[`stream`][    
The stream from which the data is to be read. The type must meet the ['SyncReadStream] requirements.  ]]  [[`buffer`][    
Storage for additional bytes read by the implementation from the stream. This is both an input and an output parameter; on entry, the parser will be presented with any remaining data in the dynamic buffer's readable bytes sequence first. The type must meet the ['DynamicBuffer] requirements.  ]]  [[`parser`][    
The parser to use.  ]]  [[`ec`][    
Set to the error, if any occurred.  ]]]
[heading Return Value]
The number of bytes transferred from the stream.
[heading Remarks]
The function returns the total number of bytes transferred from the stream. This may be zero for the case where there is sufficient pre-existing message data in the dynamic buffer. The implementation will call [link beast.ref.boost__beast__http__basic_parser.eager `http::basic_parser::eager`] with the value `false` on the parser passed in. 
Convenience header [include_file boost/beast/http.hpp][endsect][endsect][section:boost__beast__http__read_some http::read_some][indexterm1 http::read_some]
Read part of a message from a stream using a parser. ```template<    class __SyncReadStream__,    class __DynamicBuffer__,    bool isRequest>std::size_t``[link beast.ref.boost__beast__http__read_some.overload1 read_some]``(    SyncReadStream& stream,    DynamicBuffer& buffer,    basic_parser< isRequest >& parser);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__read_some.overload1 more...]]``template<    class __SyncReadStream__,    class __DynamicBuffer__,    bool isRequest>std::size_t``[link beast.ref.boost__beast__http__read_some.overload2 read_some]``(    SyncReadStream& stream,    DynamicBuffer& buffer,    basic_parser< isRequest >& parser,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__read_some.overload2 more...]]`````[section:overload1 http::read_some (1 of 2 overloads)]
Read part of a message from a stream using a parser. [heading Synopsis]Defined in header [include_file boost/beast/http/read.hpp]```template<    class __SyncReadStream__,    class __DynamicBuffer__,    bool isRequest>std::size_tread_some(    SyncReadStream& stream,    DynamicBuffer& buffer,    basic_parser< isRequest >& parser);```[heading Description]
This function is used to read part of a message from a stream into an instance of [link beast.ref.boost__beast__http__basic_parser `http::basic_parser`]. The call will block until one of the following conditions is true:

* A call to [link beast.ref.boost__beast__http__basic_parser.put `http::basic_parser::put`] with a non-empty buffer sequence is successful.


* An error occurs.

This operation is implemented in terms of one or more calls to the stream's `read_some` function. The implementation may read additional bytes from the stream that lie past the end of the message being read. These additional bytes are stored in the dynamic buffer, which must be preserved for subsequent reads.
If the end of file error is received while reading from the stream, then the error returned from this function will be:

* [link beast.ref.boost__beast__http__error `http::end_of_stream`] if no bytes were parsed, or


* [link beast.ref.boost__beast__http__error `http::partial_message`] if any bytes were parsed but the message was incomplete, otherwise:


* A successful result. The next attempt to read will return [link beast.ref.boost__beast__http__error `http::end_of_stream`]

[heading Parameters][table [[Name][Description]]  [[`stream`][    
The stream from which the data is to be read. The type must meet the ['SyncReadStream] requirements.  ]]  [[`buffer`][    
Storage for additional bytes read by the implementation from the stream. This is both an input and an output parameter; on entry, the parser will be presented with any remaining data in the dynamic buffer's readable bytes sequence first. The type must meet the ['DynamicBuffer] requirements.  ]]  [[`parser`][    
The parser to use.  ]]]
[heading Return Value]
The number of bytes transferred from the stream.
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    
Thrown on failure.  ]]]
[heading Remarks]
The function returns the total number of bytes transferred from the stream. This may be zero for the case where there is sufficient pre-existing message data in the dynamic buffer. 
Convenience header [include_file boost/beast/http.hpp][endsect][section:overload2 http::read_some (2 of 2 overloads)]
Read part of a message from a stream using a parser. [heading Synopsis]Defined in header [include_file boost/beast/http/read.hpp]```template<    class __SyncReadStream__,    class __DynamicBuffer__,    bool isRequest>std::size_tread_some(    SyncReadStream& stream,    DynamicBuffer& buffer,    basic_parser< isRequest >& parser,    error_code& ec);```[heading Description]
This function is used to read part of a message from a stream into an instance of [link beast.ref.boost__beast__http__basic_parser `http::basic_parser`]. The call will block until one of the following conditions is true:

* A call to [link beast.ref.boost__beast__http__basic_parser.put `http::basic_parser::put`] with a non-empty buffer sequence is successful.


* An error occurs.

This operation is implemented in terms of one or more calls to the stream's `read_some` function. The implementation may read additional bytes from the stream that lie past the end of the message being read. These additional bytes are stored in the dynamic buffer, which must be preserved for subsequent reads.
If the end of file error is received while reading from the stream, then the error returned from this function will be:

* [link beast.ref.boost__beast__http__error `http::end_of_stream`] if no bytes were parsed, or


* [link beast.ref.boost__beast__http__error `http::partial_message`] if any bytes were parsed but the message was incomplete, otherwise:


* A successful result. The next attempt to read will return [link beast.ref.boost__beast__http__error `http::end_of_stream`]

[heading Parameters][table [[Name][Description]]  [[`stream`][    
The stream from which the data is to be read. The type must support the ['SyncReadStream] requirements.  ]]  [[`buffer`][    
Storage for additional bytes read by the implementation from the stream. This is both an input and an output parameter; on entry, the parser will be presented with any remaining data in the dynamic buffer's readable bytes sequence first. The type must meet the ['DynamicBuffer] requirements.  ]]  [[`parser`][    
The parser to use.  ]]  [[`ec`][    
Set to the error, if any occurred.  ]]]
[heading Return Value]
The number of bytes transferred from the stream.
[heading Remarks]
The function returns the total number of bytes transferred from the stream. This may be zero for the case where there is sufficient pre-existing message data in the dynamic buffer. 
Convenience header [include_file boost/beast/http.hpp][endsect][endsect][section:boost__beast__http__request http::request][indexterm1 http::request]
A typical HTTP request. [heading Synopsis]Defined in header [include_file boost/beast/http/message.hpp]```template<    class __Body__,    class __Fields__ = fields>using request = message< true, Body, Fields >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__message.body_type [*body_type]]]    [      The type providing the body traits.     ]  ]  [    [[link beast.ref.boost__beast__http__message.fields_type [*fields_type]]]    [      The type representing the fields.     ]  ]  [    [[link beast.ref.boost__beast__http__message.header_type [*header_type]]]    [      The base class used to hold the header portion of the message.     ]  ]  [    [[link beast.ref.boost__beast__http__message.is_request [*is_request]]]    [      Indicates if the header is a request or response.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__message.base [*base]]]    [      Returns the header portion of the message.     ]  ]  [    [[link beast.ref.boost__beast__http__message.body [*body]]]    [      Returns the body.     ]  ]  [    [[link beast.ref.boost__beast__http__message.chunked [*chunked]]]    [      Returns true if the chunked Transfer-Encoding is specified.       Set or clear the chunked Transfer-Encoding.     ]  ]  [    [[link beast.ref.boost__beast__http__message.content_length [*content_length]]]    [      Set or clear the Content-Length field.     ]  ]  [    [[link beast.ref.boost__beast__http__message.has_content_length [*has_content_length]]]    [      Returns true if the Content-Length field is present.     ]  ]  [    [[link beast.ref.boost__beast__http__message.keep_alive [*keep_alive]]]    [      Returns true if the message semantics indicate keep-alive.       Set the keep-alive message semantic option.     ]  ]  [    [[link beast.ref.boost__beast__http__message.message [*message]]]    [      Constructor.       Construct a message.     ]  ]  [    [[link beast.ref.boost__beast__http__message.method [*method]]]    [      Return the request-method verb.       Set the request-method.     ]  ]  [    [[link beast.ref.boost__beast__http__message.method_string [*method_string]]]    [      Return the request-method as a string.     ]  ]  [    [[link beast.ref.boost__beast__http__message.need_eof [*need_eof]]]    [      Returns true if the message semantics require an end of file.     ]  ]  [    [[link beast.ref.boost__beast__http__message.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__http__message.payload_size [*payload_size]]]    [      Returns the payload size of the body in octets if possible.     ]  ]  [    [[link beast.ref.boost__beast__http__message.prepare_payload [*prepare_payload]]]    [      Prepare the message payload fields for the body.     ]  ]  [    [[link beast.ref.boost__beast__http__message.reason [*reason]]]    [      Return the response reason-phrase.       Set the response reason-phrase (deprecated)     ]  ]  [    [[link beast.ref.boost__beast__http__message.result [*result]]]    [      The response status-code result.       Set the response status-code.       Set the response status-code as an integer.     ]  ]  [    [[link beast.ref.boost__beast__http__message.result_int [*result_int]]]    [      The response status-code expressed as an integer.     ]  ]  [    [[link beast.ref.boost__beast__http__message.target [*target]]]    [      Returns the request-target string.       Set the request-target string.     ]  ]  [    [[link beast.ref.boost__beast__http__message.version [*version]]]    [      Return the HTTP-version.       Set the HTTP-version.     ]  ]]
This container is derived from the `Fields` template type. To understand all of the members of this class it is necessary to view the declaration for the `Fields` type. When using the default fields container, those declarations are in [link beast.ref.boost__beast__http__fields `http::fields`].
A message can be a request or response, depending on the `isRequest` template argument value. Requests and responses have different types; functions may be overloaded based on the type if desired.
The `Body` template argument type determines the model used to read or write the content body of the message.
Newly constructed messages objects have version set to HTTP/1.1. Newly constructed response objects also have result code set to [link beast.ref.boost__beast__http__status `http::ok`].
[heading Template Parameters][table [[Type][Description]]  [[`isRequest`][    
`true` if this represents a request, or `false` if this represents a response. Some class data members are conditionally present depending on this value.  ]]  [[`Body`][    
A type meeting the requirements of Body.  ]]  [[`Fields`][    
The type of container used to hold the field value pairs.   ]]]
[heading Description]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__request_header http::request_header][indexterm1 http::request_header]
A typical HTTP request header. [heading Synopsis]Defined in header [include_file boost/beast/http/message.hpp]```template<    class __Fields__ = fields>using request_header = header< true, Fields >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__header.fields_type [*fields_type]]]    [      The type representing the fields.     ]  ]  [    [[link beast.ref.boost__beast__http__header.is_request [*is_request]]]    [      Indicates if the header is a request or response.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__header.header [*header]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__http__header.method [*method]]]    [      Return the request-method verb.       Set the request-method.     ]  ]  [    [[link beast.ref.boost__beast__http__header.method_string [*method_string]]]    [      Return the request-method as a string.     ]  ]  [    [[link beast.ref.boost__beast__http__header.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__http__header.reason [*reason]]]    [      Return the response reason-phrase.       Set the response reason-phrase (deprecated)     ]  ]  [    [[link beast.ref.boost__beast__http__header.result [*result]]]    [      The response status-code result.       Set the response status-code.       Set the response status-code as an integer.     ]  ]  [    [[link beast.ref.boost__beast__http__header.result_int [*result_int]]]    [      The response status-code expressed as an integer.     ]  ]  [    [[link beast.ref.boost__beast__http__header.target [*target]]]    [      Returns the request-target string.       Set the request-target string.     ]  ]  [    [[link beast.ref.boost__beast__http__header.version [*version]]]    [      Return the HTTP-version.       Set the HTTP-version.     ]  ]]
This container is derived from the `Fields` template type. To understand all of the members of this class it is necessary to view the declaration for the `Fields` type. When using the default fields container, those declarations are in [link beast.ref.boost__beast__http__fields `http::fields`].
Newly constructed header objects have version set to HTTP/1.1. Newly constructed response objects also have result code set to [link beast.ref.boost__beast__http__status `http::ok`].
A `header` includes the start-line and header-fields. [heading Description]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__request_parser http::request_parser][indexterm1 http::request_parser]
An HTTP/1 parser for producing a request message. [heading Synopsis]Defined in header [include_file boost/beast/http/parser.hpp]```template<    class __Body__,    class __Allocator__ = std::allocator<char>>using request_parser = parser< true, Body, Allocator >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__parser.is_request [*is_request]]]    [      true if this parser parses requests, false for responses.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.value_type [*value_type]]]    [      The type of message returned by the parser.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__parser.body_limit [*body_limit]]]    [      Set the limit on the payload body.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.chunked [*chunked]]]    [      Returns true if the last value for Transfer-Encoding is "chunked".     ]  ]  [    [[link beast.ref.boost__beast__http__parser.content_length [*content_length]]]    [      Returns the optional value of Content-Length if known.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.content_length_remaining [*content_length_remaining]]]    [      Returns the remaining content length if known.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.eager [*eager]]]    [      Returns true if the eager parse option is set.       Set the eager parse option.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.get [*get]]]    [      Returns the parsed message.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.got_some [*got_some]]]    [      Returns true if the parser has received at least one byte of input.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.header_limit [*header_limit]]]    [      Set a limit on the total size of the header.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.is_done [*is_done]]]    [      Returns true if the message is complete.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.is_header_done [*is_header_done]]]    [      Returns true if a the parser has produced the full header.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.keep_alive [*keep_alive]]]    [      Returns true if the message has keep-alive connection semantics.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.need_eof [*need_eof]]]    [      Returns true if the message semantics require an end of file.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.on_chunk_body [*on_chunk_body]]]    [      Set a callback to be invoked on chunk body data.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.on_chunk_header [*on_chunk_header]]]    [      Set a callback to be invoked on each chunk header.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.operator_eq_ [*operator=]]]    [      Assignment (disallowed)     ]  ]  [    [[link beast.ref.boost__beast__http__parser.parser [*parser]]]    [      Constructor (disallowed)       Constructor.       Construct a parser from another parser, changing the Body type.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.put [*put]]]    [      Write a buffer sequence to the parser.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.put_eof [*put_eof]]]    [      Inform the parser that the end of stream was reached.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.release [*release]]]    [      Returns ownership of the parsed message.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.skip [*skip]]]    [      Returns true if the skip parse option is set.       Set the skip parse option.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.upgrade [*upgrade]]]    [      Returns true if the message is an upgrade message.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.parser_dtor_ [*~parser]]]    [      Destructor.     ]  ]]
This class uses the basic HTTP/1 wire format parser to convert a series of octets into a [link beast.ref.boost__beast__http__message `http::message`] using the [link beast.ref.boost__beast__http__basic_fields `http::basic_fields`] container to represent the fields.
[heading Template Parameters][table [[Type][Description]]  [[`isRequest`][    
Indicates whether a request or response will be parsed.  ]]  [[`Body`][    
The type used to represent the body. This must meet the requirements of ['Body].  ]]  [[`Allocator`][    
The type of allocator used with the [link beast.ref.boost__beast__http__basic_fields `http::basic_fields`] container.  ]]]
[heading Remarks]
A new instance of the parser is required for each message. 
[heading Description]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__request_serializer http::request_serializer][indexterm1 http::request_serializer]
A serializer for HTTP/1 requests. [heading Synopsis]Defined in header [include_file boost/beast/http/serializer.hpp]```template<    class __Body__,    class __Fields__ = fields>using request_serializer = serializer< true, Body, Fields >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__serializer.value_type [*value_type]]]    [      The type of message this serializer uses.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__serializer.consume [*consume]]]    [      Consume buffer octets in the serialization.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.get [*get]]]    [      Returns the message being serialized.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.is_done [*is_done]]]    [      Return true if serialization is complete.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.is_header_done [*is_header_done]]]    [      Return true if serialization of the header is complete.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.limit [*limit]]]    [      Returns the serialized buffer size limit.       Set the serialized buffer size limit.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.next [*next]]]    [      Returns the next set of buffers in the serialization.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.serializer [*serializer]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.split [*split]]]    [      Returns true if we will pause after writing the complete header.       Set whether the header and body are written separately.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.writer_impl [*writer_impl]]]    [      Provides low-level access to the associated BodyWriter     ]  ]]
An object of this type is used to serialize a complete HTTP message into a sequence of octets. To use this class, construct an instance with the message to be serialized. The implementation will automatically perform chunk encoding if the contents of the message indicate that chunk encoding is required.
Chunked output produced by the serializer never contains chunk extensions or trailers, and the location of chunk boundaries is not specified. If callers require chunk extensions, trailers, or control over the exact contents of each chunk they should use the serializer to write just the message header, and then assume control over serializing the chunked payload by using the chunk buffer sequence types [link beast.ref.boost__beast__http__chunk_body `http::chunk_body`], [link beast.ref.boost__beast__http__chunk_crlf `http::chunk_crlf`], [link beast.ref.boost__beast__http__chunk_header `http::chunk_header`], and [link beast.ref.boost__beast__http__chunk_last `http::chunk_last`].
[heading Template Parameters][table [[Type][Description]]  [[`isRequest`][    
`true` if the message is a request.  ]]  [[`Body`][    
The body type of the message.  ]]  [[`Fields`][    
The type of fields in the message.   ]]]
[heading Description]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__response http::response][indexterm1 http::response]
A typical HTTP response. [heading Synopsis]Defined in header [include_file boost/beast/http/message.hpp]```template<    class __Body__,    class __Fields__ = fields>using response = message< false, Body, Fields >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__message.body_type [*body_type]]]    [      The type providing the body traits.     ]  ]  [    [[link beast.ref.boost__beast__http__message.fields_type [*fields_type]]]    [      The type representing the fields.     ]  ]  [    [[link beast.ref.boost__beast__http__message.header_type [*header_type]]]    [      The base class used to hold the header portion of the message.     ]  ]  [    [[link beast.ref.boost__beast__http__message.is_request [*is_request]]]    [      Indicates if the header is a request or response.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__message.base [*base]]]    [      Returns the header portion of the message.     ]  ]  [    [[link beast.ref.boost__beast__http__message.body [*body]]]    [      Returns the body.     ]  ]  [    [[link beast.ref.boost__beast__http__message.chunked [*chunked]]]    [      Returns true if the chunked Transfer-Encoding is specified.       Set or clear the chunked Transfer-Encoding.     ]  ]  [    [[link beast.ref.boost__beast__http__message.content_length [*content_length]]]    [      Set or clear the Content-Length field.     ]  ]  [    [[link beast.ref.boost__beast__http__message.has_content_length [*has_content_length]]]    [      Returns true if the Content-Length field is present.     ]  ]  [    [[link beast.ref.boost__beast__http__message.keep_alive [*keep_alive]]]    [      Returns true if the message semantics indicate keep-alive.       Set the keep-alive message semantic option.     ]  ]  [    [[link beast.ref.boost__beast__http__message.message [*message]]]    [      Constructor.       Construct a message.     ]  ]  [    [[link beast.ref.boost__beast__http__message.method [*method]]]    [      Return the request-method verb.       Set the request-method.     ]  ]  [    [[link beast.ref.boost__beast__http__message.method_string [*method_string]]]    [      Return the request-method as a string.     ]  ]  [    [[link beast.ref.boost__beast__http__message.need_eof [*need_eof]]]    [      Returns true if the message semantics require an end of file.     ]  ]  [    [[link beast.ref.boost__beast__http__message.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__http__message.payload_size [*payload_size]]]    [      Returns the payload size of the body in octets if possible.     ]  ]  [    [[link beast.ref.boost__beast__http__message.prepare_payload [*prepare_payload]]]    [      Prepare the message payload fields for the body.     ]  ]  [    [[link beast.ref.boost__beast__http__message.reason [*reason]]]    [      Return the response reason-phrase.       Set the response reason-phrase (deprecated)     ]  ]  [    [[link beast.ref.boost__beast__http__message.result [*result]]]    [      The response status-code result.       Set the response status-code.       Set the response status-code as an integer.     ]  ]  [    [[link beast.ref.boost__beast__http__message.result_int [*result_int]]]    [      The response status-code expressed as an integer.     ]  ]  [    [[link beast.ref.boost__beast__http__message.target [*target]]]    [      Returns the request-target string.       Set the request-target string.     ]  ]  [    [[link beast.ref.boost__beast__http__message.version [*version]]]    [      Return the HTTP-version.       Set the HTTP-version.     ]  ]]
This container is derived from the `Fields` template type. To understand all of the members of this class it is necessary to view the declaration for the `Fields` type. When using the default fields container, those declarations are in [link beast.ref.boost__beast__http__fields `http::fields`].
A message can be a request or response, depending on the `isRequest` template argument value. Requests and responses have different types; functions may be overloaded based on the type if desired.
The `Body` template argument type determines the model used to read or write the content body of the message.
Newly constructed messages objects have version set to HTTP/1.1. Newly constructed response objects also have result code set to [link beast.ref.boost__beast__http__status `http::ok`].
[heading Template Parameters][table [[Type][Description]]  [[`isRequest`][    
`true` if this represents a request, or `false` if this represents a response. Some class data members are conditionally present depending on this value.  ]]  [[`Body`][    
A type meeting the requirements of Body.  ]]  [[`Fields`][    
The type of container used to hold the field value pairs.   ]]]
[heading Description]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__response_header http::response_header][indexterm1 http::response_header]
A typical HTTP response header. [heading Synopsis]Defined in header [include_file boost/beast/http/message.hpp]```template<    class __Fields__ = fields>using response_header = header< false, Fields >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__header.fields_type [*fields_type]]]    [      The type representing the fields.     ]  ]  [    [[link beast.ref.boost__beast__http__header.is_request [*is_request]]]    [      Indicates if the header is a request or response.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__header.header [*header]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__http__header.method [*method]]]    [      Return the request-method verb.       Set the request-method.     ]  ]  [    [[link beast.ref.boost__beast__http__header.method_string [*method_string]]]    [      Return the request-method as a string.     ]  ]  [    [[link beast.ref.boost__beast__http__header.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__http__header.reason [*reason]]]    [      Return the response reason-phrase.       Set the response reason-phrase (deprecated)     ]  ]  [    [[link beast.ref.boost__beast__http__header.result [*result]]]    [      The response status-code result.       Set the response status-code.       Set the response status-code as an integer.     ]  ]  [    [[link beast.ref.boost__beast__http__header.result_int [*result_int]]]    [      The response status-code expressed as an integer.     ]  ]  [    [[link beast.ref.boost__beast__http__header.target [*target]]]    [      Returns the request-target string.       Set the request-target string.     ]  ]  [    [[link beast.ref.boost__beast__http__header.version [*version]]]    [      Return the HTTP-version.       Set the HTTP-version.     ]  ]]
This container is derived from the `Fields` template type. To understand all of the members of this class it is necessary to view the declaration for the `Fields` type. When using the default fields container, those declarations are in [link beast.ref.boost__beast__http__fields `http::fields`].
Newly constructed header objects have version set to HTTP/1.1. Newly constructed response objects also have result code set to [link beast.ref.boost__beast__http__status `http::ok`].
A `header` includes the start-line and header-fields. [heading Description]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__response_parser http::response_parser][indexterm1 http::response_parser]
An HTTP/1 parser for producing a response message. [heading Synopsis]Defined in header [include_file boost/beast/http/parser.hpp]```template<    class __Body__,    class __Allocator__ = std::allocator<char>>using response_parser = parser< false, Body, Allocator >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__parser.is_request [*is_request]]]    [      true if this parser parses requests, false for responses.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.value_type [*value_type]]]    [      The type of message returned by the parser.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__parser.body_limit [*body_limit]]]    [      Set the limit on the payload body.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.chunked [*chunked]]]    [      Returns true if the last value for Transfer-Encoding is "chunked".     ]  ]  [    [[link beast.ref.boost__beast__http__parser.content_length [*content_length]]]    [      Returns the optional value of Content-Length if known.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.content_length_remaining [*content_length_remaining]]]    [      Returns the remaining content length if known.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.eager [*eager]]]    [      Returns true if the eager parse option is set.       Set the eager parse option.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.get [*get]]]    [      Returns the parsed message.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.got_some [*got_some]]]    [      Returns true if the parser has received at least one byte of input.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.header_limit [*header_limit]]]    [      Set a limit on the total size of the header.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.is_done [*is_done]]]    [      Returns true if the message is complete.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.is_header_done [*is_header_done]]]    [      Returns true if a the parser has produced the full header.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.keep_alive [*keep_alive]]]    [      Returns true if the message has keep-alive connection semantics.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.need_eof [*need_eof]]]    [      Returns true if the message semantics require an end of file.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.on_chunk_body [*on_chunk_body]]]    [      Set a callback to be invoked on chunk body data.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.on_chunk_header [*on_chunk_header]]]    [      Set a callback to be invoked on each chunk header.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.operator_eq_ [*operator=]]]    [      Assignment (disallowed)     ]  ]  [    [[link beast.ref.boost__beast__http__parser.parser [*parser]]]    [      Constructor (disallowed)       Constructor.       Construct a parser from another parser, changing the Body type.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.put [*put]]]    [      Write a buffer sequence to the parser.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.put_eof [*put_eof]]]    [      Inform the parser that the end of stream was reached.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.release [*release]]]    [      Returns ownership of the parsed message.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.skip [*skip]]]    [      Returns true if the skip parse option is set.       Set the skip parse option.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.upgrade [*upgrade]]]    [      Returns true if the message is an upgrade message.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.parser_dtor_ [*~parser]]]    [      Destructor.     ]  ]]
This class uses the basic HTTP/1 wire format parser to convert a series of octets into a [link beast.ref.boost__beast__http__message `http::message`] using the [link beast.ref.boost__beast__http__basic_fields `http::basic_fields`] container to represent the fields.
[heading Template Parameters][table [[Type][Description]]  [[`isRequest`][    
Indicates whether a request or response will be parsed.  ]]  [[`Body`][    
The type used to represent the body. This must meet the requirements of ['Body].  ]]  [[`Allocator`][    
The type of allocator used with the [link beast.ref.boost__beast__http__basic_fields `http::basic_fields`] container.  ]]]
[heading Remarks]
A new instance of the parser is required for each message. 
[heading Description]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__response_serializer http::response_serializer][indexterm1 http::response_serializer]
A serializer for HTTP/1 responses. [heading Synopsis]Defined in header [include_file boost/beast/http/serializer.hpp]```template<    class __Body__,    class __Fields__ = fields>using response_serializer = serializer< false, Body, Fields >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__serializer.value_type [*value_type]]]    [      The type of message this serializer uses.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__serializer.consume [*consume]]]    [      Consume buffer octets in the serialization.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.get [*get]]]    [      Returns the message being serialized.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.is_done [*is_done]]]    [      Return true if serialization is complete.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.is_header_done [*is_header_done]]]    [      Return true if serialization of the header is complete.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.limit [*limit]]]    [      Returns the serialized buffer size limit.       Set the serialized buffer size limit.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.next [*next]]]    [      Returns the next set of buffers in the serialization.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.serializer [*serializer]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.split [*split]]]    [      Returns true if we will pause after writing the complete header.       Set whether the header and body are written separately.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.writer_impl [*writer_impl]]]    [      Provides low-level access to the associated BodyWriter     ]  ]]
An object of this type is used to serialize a complete HTTP message into a sequence of octets. To use this class, construct an instance with the message to be serialized. The implementation will automatically perform chunk encoding if the contents of the message indicate that chunk encoding is required.
Chunked output produced by the serializer never contains chunk extensions or trailers, and the location of chunk boundaries is not specified. If callers require chunk extensions, trailers, or control over the exact contents of each chunk they should use the serializer to write just the message header, and then assume control over serializing the chunked payload by using the chunk buffer sequence types [link beast.ref.boost__beast__http__chunk_body `http::chunk_body`], [link beast.ref.boost__beast__http__chunk_crlf `http::chunk_crlf`], [link beast.ref.boost__beast__http__chunk_header `http::chunk_header`], and [link beast.ref.boost__beast__http__chunk_last `http::chunk_last`].
[heading Template Parameters][table [[Type][Description]]  [[`isRequest`][    
`true` if the message is a request.  ]]  [[`Body`][    
The body type of the message.  ]]  [[`Fields`][    
The type of fields in the message.   ]]]
[heading Description]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__serializer http::serializer]
Provides buffer oriented HTTP message serialization functionality. [heading Synopsis]Defined in header [include_file boost/beast/http/serializer.hpp]```template<    bool isRequest,    class __Body__,    class __Fields__ = fields>class serializer```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__serializer.value_type [*value_type]]]    [      The type of message this serializer uses.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__serializer.consume [*consume]]]    [      Consume buffer octets in the serialization.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.get [*get]]]    [      Returns the message being serialized.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.is_done [*is_done]]]    [      Return true if serialization is complete.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.is_header_done [*is_header_done]]]    [      Return true if serialization of the header is complete.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.limit [*limit]]]    [      Returns the serialized buffer size limit.       Set the serialized buffer size limit.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.next [*next]]]    [      Returns the next set of buffers in the serialization.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.serializer [*serializer]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.split [*split]]]    [      Returns true if we will pause after writing the complete header.       Set whether the header and body are written separately.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.writer_impl [*writer_impl]]]    [      Provides low-level access to the associated BodyWriter     ]  ]][heading Description]
An object of this type is used to serialize a complete HTTP message into a sequence of octets. To use this class, construct an instance with the message to be serialized. The implementation will automatically perform chunk encoding if the contents of the message indicate that chunk encoding is required.
Chunked output produced by the serializer never contains chunk extensions or trailers, and the location of chunk boundaries is not specified. If callers require chunk extensions, trailers, or control over the exact contents of each chunk they should use the serializer to write just the message header, and then assume control over serializing the chunked payload by using the chunk buffer sequence types [link beast.ref.boost__beast__http__chunk_body `http::chunk_body`], [link beast.ref.boost__beast__http__chunk_crlf `http::chunk_crlf`], [link beast.ref.boost__beast__http__chunk_header `http::chunk_header`], and [link beast.ref.boost__beast__http__chunk_last `http::chunk_last`].
[heading Template Parameters][table [[Type][Description]]  [[`isRequest`][    
`true` if the message is a request.  ]]  [[`Body`][    
The body type of the message.  ]]  [[`Fields`][    
The type of fields in the message.   ]]]
[section:consume http::serializer::consume][indexterm2 consume..http::serializer]
Consume buffer octets in the serialization. [heading Synopsis]```voidconsume(    std::size_t n);```[heading Description]
This function should be called after one or more octets contained in the buffers provided in the prior call to [link beast.ref.boost__beast__http__serializer.next `http::serializer::next`] have been used.
After a call to [link beast.ref.boost__beast__http__serializer.consume `http::serializer::consume`], callers should check the return value of [link beast.ref.boost__beast__http__serializer.is_done `http::serializer::is_done`] to determine if the entire message has been serialized.
[heading Parameters][table [[Name][Description]]  [[`n`][    
The number of octets to consume. This number must be greater than zero and no greater than the number of octets in the buffers provided in the prior call to [link beast.ref.boost__beast__http__serializer.next `http::serializer::next`].   ]]]
[endsect][section:get http::serializer::get][indexterm2 get..http::serializer]
Returns the message being serialized. [heading Synopsis]```value_type&get();```[heading Description][endsect][section:is_done http::serializer::is_done][indexterm2 is_done..http::serializer]
Return `true` if serialization is complete. [heading Synopsis]```boolis_done();```[heading Description]
The operation is complete when all octets corresponding to the serialized representation of the message have been successfully retrieved. [endsect][section:is_header_done http::serializer::is_header_done][indexterm2 is_header_done..http::serializer]
Return `true` if serialization of the header is complete. [heading Synopsis]```boolis_header_done();```[heading Description]
This function indicates whether or not all buffers containing serialized header octets have been retrieved. [endsect][section:limit http::serializer::limit][indexterm2 limit..http::serializer]
Returns the serialized buffer size limit. ```std::size_t``[link beast.ref.boost__beast__http__serializer.limit.overload1 limit]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__serializer.limit.overload1 more...]]`````
Set the serialized buffer size limit. ```void``[link beast.ref.boost__beast__http__serializer.limit.overload2 limit]``(    std::size_t limit);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__serializer.limit.overload2 more...]]`````[section:overload1 http::serializer::limit (1 of 2 overloads)]
Returns the serialized buffer size limit. [heading Synopsis]```std::size_tlimit();```[heading Description][endsect][section:overload2 http::serializer::limit (2 of 2 overloads)]
Set the serialized buffer size limit. [heading Synopsis]```voidlimit(    std::size_t limit);```[heading Description]
This function adjusts the limit on the maximum size of the buffers passed to the visitor. The new size limit takes effect in the following call to [link beast.ref.boost__beast__http__serializer.next `http::serializer::next`].
The default is no buffer size limit.
[heading Parameters][table [[Name][Description]]  [[`limit`][    
The new buffer size limit. If this number is zero, the size limit is removed.   ]]]
[endsect][endsect][section:next http::serializer::next][indexterm2 next..http::serializer]
Returns the next set of buffers in the serialization. [heading Synopsis]```template<    class Visit>voidnext(    error_code& ec,    Visit&& visit);```[heading Description]
This function will attempt to call the `visit` function object with a ['ConstBufferSequence] of unspecified type representing the next set of buffers in the serialization of the message represented by this object.
If there are no more buffers in the serialization, the visit function will not be called. In this case, no error will be indicated, and the function [link beast.ref.boost__beast__http__serializer.is_done `http::serializer::is_done`] will return `true`.
[heading Parameters][table [[Name][Description]]  [[`ec`][    
Set to the error, if any occurred.  ]]  [[`visit`][    
The function to call. The equivalent function signature of this object must be: ```  template<class ConstBufferSequence>
  void visit(error_code&, ConstBufferSequence const&);
```The function is not copied, if no error occurs it will be invoked before the call to [link beast.ref.boost__beast__http__serializer.next `http::serializer::next`] returns.   ]]]
[endsect][section:operator_eq_ http::serializer::operator=][indexterm2 operator=..http::serializer]
Assignment. [heading Synopsis]```serializer&operator=(    serializer const&);```[heading Description][endsect][section:serializer http::serializer::serializer][indexterm2 serializer..http::serializer]
Constructor. `````[link beast.ref.boost__beast__http__serializer.serializer.overload1 serializer]``(    serializer&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__serializer.serializer.overload1 more...]]````[link beast.ref.boost__beast__http__serializer.serializer.overload2 serializer]``(    serializer const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__serializer.serializer.overload2 more...]]``explicit``[link beast.ref.boost__beast__http__serializer.serializer.overload3 serializer]``(    value_type& msg);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__serializer.serializer.overload3 more...]]`````[section:overload1 http::serializer::serializer (1 of 3 overloads)]
Constructor. [heading Synopsis]```serializer(    serializer&&);```[heading Description][endsect][section:overload2 http::serializer::serializer (2 of 3 overloads)]
Constructor. [heading Synopsis]```serializer(    serializer const&);```[heading Description][endsect][section:overload3 http::serializer::serializer (3 of 3 overloads)]
Constructor. [heading Synopsis]```serializer(    value_type& msg);```[heading Description]
The implementation guarantees that the message passed on construction will not be accessed until the first call to [link beast.ref.boost__beast__http__serializer.next `http::serializer::next`]. This allows the message to be lazily created. For example, if the header is filled in before serialization.
[heading Parameters][table [[Name][Description]]  [[`msg`][    
A reference to the message to serialize, which must remain valid for the lifetime of the serializer. Depending on the type of Body used, this may or may not be a `const` reference.  ]]]
[heading Remarks]
This function participates in overload resolution only if Body::writer is constructible from a `const` message reference. 
[endsect][endsect][section:split http::serializer::split][indexterm2 split..http::serializer]
Returns `true` if we will pause after writing the complete header. ```bool``[link beast.ref.boost__beast__http__serializer.split.overload1 split]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__serializer.split.overload1 more...]]`````
Set whether the header and body are written separately. ```void``[link beast.ref.boost__beast__http__serializer.split.overload2 split]``(    bool v);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__serializer.split.overload2 more...]]`````[section:overload1 http::serializer::split (1 of 2 overloads)]
Returns `true` if we will pause after writing the complete header. [heading Synopsis]```boolsplit();```[heading Description][endsect][section:overload2 http::serializer::split (2 of 2 overloads)]
Set whether the header and body are written separately. [heading Synopsis]```voidsplit(    bool v);```[heading Description]
When the split feature is enabled, the implementation will write only the octets corresponding to the serialized header first. If the header has already been written, this function will have no effect on output. [endsect][endsect][section:value_type http::serializer::value_type][indexterm2 value_type..http::serializer]
The type of message this serializer uses. [heading Synopsis]```using value_type = ``['implementation-defined]``;```[heading Description]
This may be const or non-const depending on the implementation of the corresponding ['BodyWriter]. [endsect][section:writer_impl http::serializer::writer_impl][indexterm2 writer_impl..http::serializer]
Provides low-level access to the associated ['BodyWriter] [heading Synopsis]```writer&writer_impl();```[heading Description]
This function provides access to the instance of the writer associated with the body and created by the serializer upon construction. The behavior of accessing this object is defined by the specification of the particular writer and its associated body.
[heading Return Value]
A reference to the writer. 
[endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__span_body http::span_body]
A ['Body] using [link beast.ref.boost__beast__span `span`]. [heading Synopsis]Defined in header [include_file boost/beast/http/span_body.hpp]```template<    class T>struct span_body```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__span_body.reader [*reader]]]    [      The algorithm for parsing the body.     ]  ]  [    [[link beast.ref.boost__beast__http__span_body.value_type [*value_type]]]    [      The type of container used for the body.     ]  ]  [    [[link beast.ref.boost__beast__http__span_body.writer [*writer]]]    [      The algorithm for serializing the body.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__span_body.size [*size]]]    [      Returns the payload size of the body.     ]  ]][heading Description]
This body uses [link beast.ref.boost__beast__span `span`] as a memory-based container for holding message payloads. The container represents a non-owning reference to a contiguous area of memory. Messages using this body type may be serialized and parsed.
Unlike [link beast.ref.boost__beast__http__buffer_body `http::buffer_body`], only one buffer may be provided during a parse or serialize operation. [section:reader http::span_body::reader][indexterm2 reader..http::span_body]
The algorithm for parsing the body. [heading Synopsis]```using reader = ``['implementation-defined]``;```[heading Description]
Meets the requirements of ['BodyReader]. [endsect][section:size http::span_body::size][indexterm2 size..http::span_body]
Returns the payload size of the body. [heading Synopsis]```staticstd::uint64_tsize(    value_type const& body);```[heading Description]
When this body is used with [link beast.ref.boost__beast__http__message.prepare_payload `http::message::prepare_payload`], the Content-Length will be set to the payload size, and any chunked Transfer-Encoding will be removed. [endsect][section:value_type http::span_body::value_type][indexterm2 value_type..http::span_body]
The type of container used for the body. [heading Synopsis]```using value_type = span< T >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__span.const_iterator [*const_iterator]]]    [      The const iterator used by the container.     ]  ]  [    [[link beast.ref.boost__beast__span.const_pointer [*const_pointer]]]    [      The const pointer used by the container.     ]  ]  [    [[link beast.ref.boost__beast__span.const_reference [*const_reference]]]    [      The const reference used by the container.     ]  ]  [    [[link beast.ref.boost__beast__span.element_type [*element_type]]]    [      The type of value, including cv qualifiers.     ]  ]  [    [[link beast.ref.boost__beast__span.index_type [*index_type]]]    [      The type of integer used to index the span.     ]  ]  [    [[link beast.ref.boost__beast__span.iterator [*iterator]]]    [      The iterator used by the container.     ]  ]  [    [[link beast.ref.boost__beast__span.pointer [*pointer]]]    [      A pointer to a span element.     ]  ]  [    [[link beast.ref.boost__beast__span.reference [*reference]]]    [      A reference to a span element.     ]  ]  [    [[link beast.ref.boost__beast__span.value_type [*value_type]]]    [      The type of value of each span element.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__span.begin [*begin]]]    [      Returns an iterator to the beginning of the span.     ]  ]  [    [[link beast.ref.boost__beast__span.cbegin [*cbegin]]]    [      Returns an iterator to the beginning of the span.     ]  ]  [    [[link beast.ref.boost__beast__span.cend [*cend]]]    [      Returns an iterator to one past the end of the span.     ]  ]  [    [[link beast.ref.boost__beast__span.data [*data]]]    [      Returns a pointer to the beginning of the span.     ]  ]  [    [[link beast.ref.boost__beast__span.empty [*empty]]]    [      Returns true if the span is empty.     ]  ]  [    [[link beast.ref.boost__beast__span.end [*end]]]    [      Returns an iterator to one past the end of the span.     ]  ]  [    [[link beast.ref.boost__beast__span.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__span.size [*size]]]    [      Returns the number of elements in the span.     ]  ]  [    [[link beast.ref.boost__beast__span.span [*span]]]    [      Constructor.     ]  ]]
This class implements a non-owning reference to a storage area of a certain size and having an underlying integral type with size of 1.
[heading Template Parameters][table [[Type][Description]]  [[`T`][    
The type pointed to by span iterators   ]]]
[heading Description]
This determines the type of [link beast.ref.boost__beast__http__message.body `http::message::body`] when this body type is used with a message container. [endsect][section:writer http::span_body::writer][indexterm2 writer..http::span_body]
The algorithm for serializing the body. [heading Synopsis]```using writer = ``['implementation-defined]``;```[heading Description]
Meets the requirements of ['BodyWriter]. [endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__status http::status][indexterm1 http::status][heading Synopsis]Defined in header [include_file boost/beast/http/status.hpp]```enum status```[indexterm2 unknown..http::status][indexterm2 continue_..http::status][indexterm2 switching_protocols..http::status][indexterm2 processing..http::status][indexterm2 ok..http::status][indexterm2 created..http::status][indexterm2 accepted..http::status][indexterm2 non_authoritative_information..http::status][indexterm2 no_content..http::status][indexterm2 reset_content..http::status][indexterm2 partial_content..http::status][indexterm2 multi_status..http::status][indexterm2 already_reported..http::status][indexterm2 im_used..http::status][indexterm2 multiple_choices..http::status][indexterm2 moved_permanently..http::status][indexterm2 found..http::status][indexterm2 see_other..http::status][indexterm2 not_modified..http::status][indexterm2 use_proxy..http::status][indexterm2 temporary_redirect..http::status][indexterm2 permanent_redirect..http::status][indexterm2 bad_request..http::status][indexterm2 unauthorized..http::status][indexterm2 payment_required..http::status][indexterm2 forbidden..http::status][indexterm2 not_found..http::status][indexterm2 method_not_allowed..http::status][indexterm2 not_acceptable..http::status][indexterm2 proxy_authentication_required..http::status][indexterm2 request_timeout..http::status][indexterm2 conflict..http::status][indexterm2 gone..http::status][indexterm2 length_required..http::status][indexterm2 precondition_failed..http::status][indexterm2 payload_too_large..http::status][indexterm2 uri_too_long..http::status][indexterm2 unsupported_media_type..http::status][indexterm2 range_not_satisfiable..http::status][indexterm2 expectation_failed..http::status][indexterm2 misdirected_request..http::status][indexterm2 unprocessable_entity..http::status][indexterm2 locked..http::status][indexterm2 failed_dependency..http::status][indexterm2 upgrade_required..http::status][indexterm2 precondition_required..http::status][indexterm2 too_many_requests..http::status][indexterm2 request_header_fields_too_large..http::status][indexterm2 connection_closed_without_response..http::status][indexterm2 unavailable_for_legal_reasons..http::status][indexterm2 client_closed_request..http::status][indexterm2 internal_server_error..http::status][indexterm2 not_implemented..http::status][indexterm2 bad_gateway..http::status][indexterm2 service_unavailable..http::status][indexterm2 gateway_timeout..http::status][indexterm2 http_version_not_supported..http::status][indexterm2 variant_also_negotiates..http::status][indexterm2 insufficient_storage..http::status][indexterm2 loop_detected..http::status][indexterm2 not_extended..http::status][indexterm2 network_authentication_required..http::status][indexterm2 network_connect_timeout_error..http::status][heading Values][table [[Name][Description]]  [[[^unknown]][An unknown status-code. This value indicates that the value for the status code
is not in the list of commonly recognized status codes.
Callers interested in the exactly value should use the
interface which provides the raw integer.
 ]]  [[[^continue_]][]]  [[[^switching_protocols]][Switching Protocols. This status indicates that a request to switch to a new
protocol was accepted and applied by the server. A successful
response to a WebSocket Upgrade HTTP request will have this
code.
 ]]  [[[^processing]][]]  [[[^ok]][]]  [[[^created]][]]  [[[^accepted]][]]  [[[^non_authoritative_information]][]]  [[[^no_content]][]]  [[[^reset_content]][]]  [[[^partial_content]][]]  [[[^multi_status]][]]  [[[^already_reported]][]]  [[[^im_used]][]]  [[[^multiple_choices]][]]  [[[^moved_permanently]][]]  [[[^found]][]]  [[[^see_other]][]]  [[[^not_modified]][]]  [[[^use_proxy]][]]  [[[^temporary_redirect]][]]  [[[^permanent_redirect]][]]  [[[^bad_request]][]]  [[[^unauthorized]][]]  [[[^payment_required]][]]  [[[^forbidden]][]]  [[[^not_found]][]]  [[[^method_not_allowed]][]]  [[[^not_acceptable]][]]  [[[^proxy_authentication_required]][]]  [[[^request_timeout]][]]  [[[^conflict]][]]  [[[^gone]][]]  [[[^length_required]][]]  [[[^precondition_failed]][]]  [[[^payload_too_large]][]]  [[[^uri_too_long]][]]  [[[^unsupported_media_type]][]]  [[[^range_not_satisfiable]][]]  [[[^expectation_failed]][]]  [[[^misdirected_request]][]]  [[[^unprocessable_entity]][]]  [[[^locked]][]]  [[[^failed_dependency]][]]  [[[^upgrade_required]][]]  [[[^precondition_required]][]]  [[[^too_many_requests]][]]  [[[^request_header_fields_too_large]][]]  [[[^connection_closed_without_response]][]]  [[[^unavailable_for_legal_reasons]][]]  [[[^client_closed_request]][]]  [[[^internal_server_error]][]]  [[[^not_implemented]][]]  [[[^bad_gateway]][]]  [[[^service_unavailable]][]]  [[[^gateway_timeout]][]]  [[[^http_version_not_supported]][]]  [[[^variant_also_negotiates]][]]  [[[^insufficient_storage]][]]  [[[^loop_detected]][]]  [[[^not_extended]][]]  [[[^network_authentication_required]][]]  [[[^network_connect_timeout_error]][]]][heading Description]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__status_class http::status_class][indexterm1 http::status_class]
Represents the class of a status-code. [heading Synopsis]Defined in header [include_file boost/beast/http/status.hpp]```enum status_class```[indexterm2 unknown..http::status_class][indexterm2 informational..http::status_class][indexterm2 successful..http::status_class][indexterm2 redirection..http::status_class][indexterm2 client_error..http::status_class][indexterm2 server_error..http::status_class][heading Values][table [[Name][Description]]  [[[^unknown]][Unknown status-class. ]]  [[[^informational]][The request was received, continuing processing. ]]  [[[^successful]][The request was successfully received, understood, and accepted. ]]  [[[^redirection]][Further action needs to be taken in order to complete the request. ]]  [[[^client_error]][The request contains bad syntax or cannot be fulfilled. ]]  [[[^server_error]][The server failed to fulfill an apparently valid request. ]]][heading Description]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__string_body http::string_body][indexterm1 http::string_body]
A ['Body] using `std::string` [heading Synopsis]Defined in header [include_file boost/beast/http/string_body.hpp]```using string_body = basic_string_body< char >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_string_body.reader [*reader]]]    [      The algorithm for parsing the body.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_string_body.value_type [*value_type]]]    [      The type of container used for the body.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_string_body.writer [*writer]]]    [      The algorithm for serializing the body.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_string_body.size [*size]]]    [      Returns the payload size of the body.     ]  ]]
This body uses `std::basic_string` as a memory-based container for holding message payloads. Messages using this body type may be serialized and parsed. [heading Description]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__string_to_field http::string_to_field][indexterm1 http::string_to_field]
Attempt to convert a string to a field enum. [heading Synopsis]Defined in header [include_file boost/beast/http/field.hpp]```fieldstring_to_field(    string_view s);```[heading Description]
The string comparison is case-insensitive.
[heading Return Value]
The corresponding field, or [link beast.ref.boost__beast__http__field `http::unknown`] if no known field matches. 
Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__string_to_verb http::string_to_verb][indexterm1 http::string_to_verb]
Converts a string to the request method verb. [heading Synopsis]Defined in header [include_file boost/beast/http/verb.hpp]```verbstring_to_verb(    string_view s);```[heading Description]
If the string does not match a known request method, [link beast.ref.boost__beast__http__field `http::unknown`] is returned. Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__swap http::swap][indexterm1 http::swap]
Swap two header objects. ```template<    bool isRequest,    class __Fields__>void``[link beast.ref.boost__beast__http__swap.overload1 swap]``(    header< isRequest, Fields >& m1,    header< isRequest, Fields >& m2);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__swap.overload1 more...]]`````
Swap two message objects. ```template<    bool isRequest,    class __Body__,    class __Fields__>void``[link beast.ref.boost__beast__http__swap.overload2 swap]``(    message< isRequest, Body, Fields >& m1,    message< isRequest, Body, Fields >& m2);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__swap.overload2 more...]]`````[section:overload1 http::swap (1 of 2 overloads)]
Swap two header objects. [heading Synopsis]Defined in header [include_file boost/beast/http/message.hpp]```template<    bool isRequest,    class __Fields__>voidswap(    header< isRequest, Fields >& m1,    header< isRequest, Fields >& m2);```[heading Description]
[heading Requirements]
`Fields` is [*Swappable]. 
Convenience header [include_file boost/beast/http.hpp][endsect][section:overload2 http::swap (2 of 2 overloads)]
Swap two message objects. [heading Synopsis]Defined in header [include_file boost/beast/http/message.hpp]```template<    bool isRequest,    class __Body__,    class __Fields__>voidswap(    message< isRequest, Body, Fields >& m1,    message< isRequest, Body, Fields >& m2);```[heading Description]
[heading Requirements:]
`Body::value_type` and `Fields` are [*Swappable]. 
Convenience header [include_file boost/beast/http.hpp][endsect][endsect][section:boost__beast__http__to_status_class http::to_status_class][indexterm1 http::to_status_class]
Convert an integer to a status\_class. ```status_class``[link beast.ref.boost__beast__http__to_status_class.overload1 to_status_class]``(    unsigned v);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__to_status_class.overload1 more...]]`````
Convert a status\_code to a status\_class. ```status_class``[link beast.ref.boost__beast__http__to_status_class.overload2 to_status_class]``(    status v);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__to_status_class.overload2 more...]]`````[section:overload1 http::to_status_class (1 of 2 overloads)]
Convert an integer to a status\_class. [heading Synopsis]Defined in header [include_file boost/beast/http/status.hpp]```status_classto_status_class(    unsigned v);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`v`][    
The integer representing a status code.  ]]]
[heading Return Value]
The status class. If the integer does not match a known status class, [link beast.ref.boost__beast__http__field `http::unknown`] is returned. 
Convenience header [include_file boost/beast/http.hpp][endsect][section:overload2 http::to_status_class (2 of 2 overloads)]
Convert a status\_code to a status\_class. [heading Synopsis]Defined in header [include_file boost/beast/http/status.hpp]```status_classto_status_class(    status v);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`v`][    
The status code to convert.  ]]]
[heading Return Value]
The status class. 
Convenience header [include_file boost/beast/http.hpp][endsect][endsect][section:boost__beast__http__to_string http::to_string][indexterm1 http::to_string]
Convert a field enum to a string. ```string_view``[link beast.ref.boost__beast__http__to_string.overload1 to_string]``(    field f);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__to_string.overload1 more...]]`````
Returns the text representation of a request method verb. ```string_view``[link beast.ref.boost__beast__http__to_string.overload2 to_string]``(    verb v);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__to_string.overload2 more...]]`````[section:overload1 http::to_string (1 of 2 overloads)]
Convert a field enum to a string. [heading Synopsis]Defined in header [include_file boost/beast/http/field.hpp]```string_viewto_string(    field f);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`f`][    
The field to convert   ]]]
Convenience header [include_file boost/beast/http.hpp][endsect][section:overload2 http::to_string (2 of 2 overloads)]
Returns the text representation of a request method verb. [heading Synopsis]Defined in header [include_file boost/beast/http/verb.hpp]```string_viewto_string(    verb v);```[heading Description]Convenience header [include_file boost/beast/http.hpp][endsect][endsect][section:boost__beast__http__token_list http::token_list]
A list of tokens in a comma separated HTTP field value. [heading Synopsis]Defined in header [include_file boost/beast/http/rfc7230.hpp]```class token_list```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__token_list.const_iterator [*const_iterator]]]    [      A constant iterator to the list.     ]  ]  [    [[link beast.ref.boost__beast__http__token_list.value_type [*value_type]]]    [      The type of each element in the token list.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__token_list.begin [*begin]]]    [      Return a const iterator to the beginning of the list.     ]  ]  [    [[link beast.ref.boost__beast__http__token_list.cbegin [*cbegin]]]    [      Return a const iterator to the beginning of the list.     ]  ]  [    [[link beast.ref.boost__beast__http__token_list.cend [*cend]]]    [      Return a const iterator to the end of the list.     ]  ]  [    [[link beast.ref.boost__beast__http__token_list.end [*end]]]    [      Return a const iterator to the end of the list.     ]  ]  [    [[link beast.ref.boost__beast__http__token_list.exists [*exists]]]    [      Return true if a token is present in the list.     ]  ]  [    [[link beast.ref.boost__beast__http__token_list.token_list [*token_list]]]    [      Construct a list.     ]  ]][heading Description]
This container allows iteration of a list of items in a header field value. The input is a comma separated list of tokens.
If a parsing error is encountered while iterating the string, the behavior of the container will be as if a string containing only characters up to but excluding the first invalid character was used to construct the list.
[heading BNF]
```  token-list  = *( "," OWS ) token *( OWS "," [ OWS token ] )
```
To use this class, construct with the string to be parsed and then use [link beast.ref.boost__beast__http__token_list.begin `http::token_list::begin`] and [link beast.ref.boost__beast__http__token_list.end `http::token_list::end`], or range-for to iterate each item:
[heading Example]
```  for(auto const& token : token_list{"apple, pear, banana"})
      std::cout << token << "\n";
```
[section:begin http::token_list::begin][indexterm2 begin..http::token_list]
Return a const iterator to the beginning of the list. [heading Synopsis]```const_iteratorbegin() const;```[heading Description][endsect][section:cbegin http::token_list::cbegin][indexterm2 cbegin..http::token_list]
Return a const iterator to the beginning of the list. [heading Synopsis]```const_iteratorcbegin() const;```[heading Description][endsect][section:cend http::token_list::cend][indexterm2 cend..http::token_list]
Return a const iterator to the end of the list. [heading Synopsis]```const_iteratorcend() const;```[heading Description][endsect][section:const_iterator http::token_list::const_iterator][indexterm2 const_iterator..http::token_list]
A constant iterator to the list. [heading Synopsis]```using const_iterator = ``['implementation-defined]``;```[heading Description][endsect][section:end http::token_list::end][indexterm2 end..http::token_list]
Return a const iterator to the end of the list. [heading Synopsis]```const_iteratorend() const;```[heading Description][endsect][section:exists http::token_list::exists][indexterm2 exists..http::token_list]
Return `true` if a token is present in the list. [heading Synopsis]```boolexists(    string_view const& s);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`s`][    
The token to find. A case-insensitive comparison is used.   ]]]
[endsect][section:token_list http::token_list::token_list][indexterm2 token_list..http::token_list]
Construct a list. [heading Synopsis]```token_list(    string_view s);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`s`][    
A string containing the list contents. The string must remain valid for the lifetime of the container.   ]]]
[endsect][section:value_type http::token_list::value_type][indexterm2 value_type..http::token_list]
The type of each element in the token list. [heading Synopsis]```using value_type = string_view;```[heading Description][endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__validate_list http::validate_list][indexterm1 http::validate_list]
Returns `true` if a parsed list is parsed without errors. [heading Synopsis]Defined in header [include_file boost/beast/http/rfc7230.hpp]```template<    class Policy>boolvalidate_list(    detail::basic_parsed_list< Policy > const& list);```[heading Description]
This function iterates a single pass through a parsed list and returns `true` if there were no parsing errors, else returns `false`. Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__vector_body http::vector_body]
A ['Body] using `std::vector` [heading Synopsis]Defined in header [include_file boost/beast/http/vector_body.hpp]```template<    class T,    class __Allocator__ = std::allocator<T>>struct vector_body```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__vector_body.reader [*reader]]]    [      The algorithm for parsing the body.     ]  ]  [    [[link beast.ref.boost__beast__http__vector_body.value_type [*value_type]]]    [      The type of container used for the body.     ]  ]  [    [[link beast.ref.boost__beast__http__vector_body.writer [*writer]]]    [      The algorithm for serializing the body.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__vector_body.size [*size]]]    [      Returns the payload size of the body.     ]  ]][heading Description]
This body uses `std::vector` as a memory-based container for holding message payloads. Messages using this body type may be serialized and parsed. [section:reader http::vector_body::reader][indexterm2 reader..http::vector_body]
The algorithm for parsing the body. [heading Synopsis]```using reader = ``['implementation-defined]``;```[heading Description]
Meets the requirements of ['BodyReader]. [endsect][section:size http::vector_body::size][indexterm2 size..http::vector_body]
Returns the payload size of the body. [heading Synopsis]```staticstd::uint64_tsize(    value_type const& body);```[heading Description]
When this body is used with [link beast.ref.boost__beast__http__message.prepare_payload `http::message::prepare_payload`], the Content-Length will be set to the payload size, and any chunked Transfer-Encoding will be removed. [endsect][section:value_type http::vector_body::value_type][indexterm2 value_type..http::vector_body]
The type of container used for the body. [heading Synopsis]```using value_type = std::vector< T, Allocator >;```[heading Description]
This determines the type of [link beast.ref.boost__beast__http__message.body `http::message::body`] when this body type is used with a message container. [endsect][section:writer http::vector_body::writer][indexterm2 writer..http::vector_body]
The algorithm for serializing the body. [heading Synopsis]```using writer = ``['implementation-defined]``;```[heading Description]
Meets the requirements of ['BodyWriter]. [endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__verb http::verb][indexterm1 http::verb]
HTTP request method verbs. [heading Synopsis]Defined in header [include_file boost/beast/http/verb.hpp]```enum verb```[indexterm2 unknown..http::verb][indexterm2 delete_..http::verb][indexterm2 get..http::verb][indexterm2 head..http::verb][indexterm2 post..http::verb][indexterm2 put..http::verb][indexterm2 connect..http::verb][indexterm2 options..http::verb][indexterm2 trace..http::verb][indexterm2 copy..http::verb][indexterm2 lock..http::verb][indexterm2 mkcol..http::verb][indexterm2 move..http::verb][indexterm2 propfind..http::verb][indexterm2 proppatch..http::verb][indexterm2 search..http::verb][indexterm2 unlock..http::verb][indexterm2 bind..http::verb][indexterm2 rebind..http::verb][indexterm2 unbind..http::verb][indexterm2 acl..http::verb][indexterm2 report..http::verb][indexterm2 mkactivity..http::verb][indexterm2 checkout..http::verb][indexterm2 merge..http::verb][indexterm2 msearch..http::verb][indexterm2 notify..http::verb][indexterm2 subscribe..http::verb][indexterm2 unsubscribe..http::verb][indexterm2 patch..http::verb][indexterm2 purge..http::verb][indexterm2 mkcalendar..http::verb][indexterm2 link..http::verb][indexterm2 unlink..http::verb][heading Values][table [[Name][Description]]  [[[^unknown]][An unknown method. This value indicates that the request method string is not
one of the recognized verbs. Callers interested in the method
should use an interface which returns the original string.
 ]]  [[[^delete_]][The DELETE method deletes the specified resource. ]]  [[[^get]][The GET method requests a representation of the specified resource. Requests using GET should only retrieve data and should have no other effect.
 ]]  [[[^head]][The HEAD method asks for a response identical to that of a GET request, but without the response body. This is useful for retrieving meta-information written in response
headers, without having to transport the entire content.
 ]]  [[[^post]][The POST method requests that the server accept the entity enclosed in the request as a new subordinate of the web resource identified by the URI. The data POSTed might be, for example, an annotation for existing
resources; a message for a bulletin board, newsgroup, mailing list,
or comment thread; a block of data that is the result of submitting
a web form to a data-handling process; or an item to add to a database
 ]]  [[[^put]][The PUT method requests that the enclosed entity be stored under the supplied URI. If the URI refers to an already existing resource, it is modified;
if the URI does not point to an existing resource, then the server
can create the resource with that URI.
 ]]  [[[^connect]][The CONNECT method converts the request connection to a transparent TCP/IP tunnel. This is usually to facilitate SSL-encrypted communication (HTTPS)
through an unencrypted HTTP proxy.
 ]]  [[[^options]][The OPTIONS method returns the HTTP methods that the server supports for the specified URL. This can be used to check the functionality of a web server by requesting
'*' instead of a specific resource.
 ]]  [[[^trace]][The TRACE method echoes the received request so that a client can see what (if any) changes or additions have been made by intermediate servers. ]]  [[[^copy]][]]  [[[^lock]][]]  [[[^mkcol]][]]  [[[^move]][]]  [[[^propfind]][]]  [[[^proppatch]][]]  [[[^search]][]]  [[[^unlock]][]]  [[[^bind]][]]  [[[^rebind]][]]  [[[^unbind]][]]  [[[^acl]][]]  [[[^report]][]]  [[[^mkactivity]][]]  [[[^checkout]][]]  [[[^merge]][]]  [[[^msearch]][]]  [[[^notify]][]]  [[[^subscribe]][]]  [[[^unsubscribe]][]]  [[[^patch]][]]  [[[^purge]][]]  [[[^mkcalendar]][]]  [[[^link]][]]  [[[^unlink]][]]][heading Description]
Each verb corresponds to a particular method string used in HTTP request messages. Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__write http::write][indexterm1 http::write]
Write a complete message to a stream using a serializer. ```template<    class __SyncWriteStream__,    bool isRequest,    class __Body__,    class __Fields__>std::size_t``[link beast.ref.boost__beast__http__write.overload1 write]``(    SyncWriteStream& stream,    serializer< isRequest, Body, Fields >& sr);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__write.overload1 more...]]``template<    class __SyncWriteStream__,    bool isRequest,    class __Body__,    class __Fields__>std::size_t``[link beast.ref.boost__beast__http__write.overload2 write]``(    SyncWriteStream& stream,    serializer< isRequest, Body, Fields >& sr,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__write.overload2 more...]]`````
Write a complete message to a stream. ```template<    class __SyncWriteStream__,    bool isRequest,    class __Body__,    class __Fields__>std::size_t``[link beast.ref.boost__beast__http__write.overload3 write]``(    SyncWriteStream& stream,    message< isRequest, Body, Fields >& msg);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__write.overload3 more...]]``template<    class __SyncWriteStream__,    bool isRequest,    class __Body__,    class __Fields__>std::size_t``[link beast.ref.boost__beast__http__write.overload4 write]``(    SyncWriteStream& stream,    message< isRequest, Body, Fields > const& msg);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__write.overload4 more...]]``template<    class __SyncWriteStream__,    bool isRequest,    class __Body__,    class __Fields__>std::size_t``[link beast.ref.boost__beast__http__write.overload5 write]``(    SyncWriteStream& stream,    message< isRequest, Body, Fields >& msg,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__write.overload5 more...]]``template<    class __SyncWriteStream__,    bool isRequest,    class __Body__,    class __Fields__>std::size_t``[link beast.ref.boost__beast__http__write.overload6 write]``(    SyncWriteStream& stream,    message< isRequest, Body, Fields > const& msg,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__write.overload6 more...]]`````[section:overload1 http::write (1 of 6 overloads)]
Write a complete message to a stream using a serializer. [heading Synopsis]Defined in header [include_file boost/beast/http/write.hpp]```template<    class __SyncWriteStream__,    bool isRequest,    class __Body__,    class __Fields__>std::size_twrite(    SyncWriteStream& stream,    serializer< isRequest, Body, Fields >& sr);```[heading Description]
This function is used to write a complete message to a stream using a caller-provided HTTP/1 serializer. The call will block until one of the following conditions is true:

* The function [link beast.ref.boost__beast__http__serializer.is_done `http::serializer::is_done`] returns `true`


* An error occurs.

This operation is implemented in terms of one or more calls to the stream's `write_some` function.
[heading Parameters][table [[Name][Description]]  [[`stream`][    
The stream to which the data is to be written. The type must support the ['SyncWriteStream] concept.  ]]  [[`sr`][    
The serializer to use.  ]]]
[heading Return Value]
The number of bytes written to the stream.
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    
Thrown on failure.  ]]]
[heading See Also]
[link beast.ref.boost__beast__http__serializer `http::serializer`] 
Convenience header [include_file boost/beast/http.hpp][endsect][section:overload2 http::write (2 of 6 overloads)]
Write a complete message to a stream using a serializer. [heading Synopsis]Defined in header [include_file boost/beast/http/write.hpp]```template<    class __SyncWriteStream__,    bool isRequest,    class __Body__,    class __Fields__>std::size_twrite(    SyncWriteStream& stream,    serializer< isRequest, Body, Fields >& sr,    error_code& ec);```[heading Description]
This function is used to write a complete message to a stream using a caller-provided HTTP/1 serializer. The call will block until one of the following conditions is true:

* The function [link beast.ref.boost__beast__http__serializer.is_done `http::serializer::is_done`] returns `true`


* An error occurs.

This operation is implemented in terms of one or more calls to the stream's `write_some` function.
[heading Parameters][table [[Name][Description]]  [[`stream`][    
The stream to which the data is to be written. The type must support the ['SyncWriteStream] concept.  ]]  [[`sr`][    
The serializer to use.  ]]  [[`ec`][    
Set to the error, if any occurred.  ]]]
[heading Return Value]
The number of bytes written to the stream.
[heading See Also]
[link beast.ref.boost__beast__http__serializer `http::serializer`] 
Convenience header [include_file boost/beast/http.hpp][endsect][section:overload3 http::write (3 of 6 overloads)]
Write a complete message to a stream. [heading Synopsis]Defined in header [include_file boost/beast/http/write.hpp]```template<    class __SyncWriteStream__,    bool isRequest,    class __Body__,    class __Fields__>std::size_twrite(    SyncWriteStream& stream,    message< isRequest, Body, Fields >& msg);```[heading Description]
This function is used to write a complete message to a stream using HTTP/1. The call will block until one of the following conditions is true:

* The entire message is written.


* An error occurs.

This operation is implemented in terms of one or more calls to the stream's `write_some` function. The algorithm will use a temporary [link beast.ref.boost__beast__http__serializer `http::serializer`] with an empty chunk decorator to produce buffers.
[heading Remarks]
This function only participates in overload resolution if [link beast.ref.boost__beast__http__is_mutable_body_writer `http::is_mutable_body_writer`] for ['Body] returns `true`.
[heading Parameters][table [[Name][Description]]  [[`stream`][    
The stream to which the data is to be written. The type must support the ['SyncWriteStream] concept.  ]]  [[`msg`][    
The message to write.  ]]]
[heading Return Value]
The number of bytes written to the stream.
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    
Thrown on failure.  ]]]
[heading See Also]
[link beast.ref.boost__beast__http__message `http::message`] 
Convenience header [include_file boost/beast/http.hpp][endsect][section:overload4 http::write (4 of 6 overloads)]
Write a complete message to a stream. [heading Synopsis]Defined in header [include_file boost/beast/http/write.hpp]```template<    class __SyncWriteStream__,    bool isRequest,    class __Body__,    class __Fields__>std::size_twrite(    SyncWriteStream& stream,    message< isRequest, Body, Fields > const& msg);```[heading Description]
This function is used to write a complete message to a stream using HTTP/1. The call will block until one of the following conditions is true:

* The entire message is written.


* An error occurs.

This operation is implemented in terms of one or more calls to the stream's `write_some` function. The algorithm will use a temporary [link beast.ref.boost__beast__http__serializer `http::serializer`] with an empty chunk decorator to produce buffers.
[heading Remarks]
This function only participates in overload resolution if [link beast.ref.boost__beast__http__is_mutable_body_writer `http::is_mutable_body_writer`] for ['Body] returns `false`.
[heading Parameters][table [[Name][Description]]  [[`stream`][    
The stream to which the data is to be written. The type must support the ['SyncWriteStream] concept.  ]]  [[`msg`][    
The message to write.  ]]]
[heading Return Value]
The number of bytes written to the stream.
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    
Thrown on failure.  ]]]
[heading See Also]
[link beast.ref.boost__beast__http__message `http::message`] 
Convenience header [include_file boost/beast/http.hpp][endsect][section:overload5 http::write (5 of 6 overloads)]
Write a complete message to a stream. [heading Synopsis]Defined in header [include_file boost/beast/http/write.hpp]```template<    class __SyncWriteStream__,    bool isRequest,    class __Body__,    class __Fields__>std::size_twrite(    SyncWriteStream& stream,    message< isRequest, Body, Fields >& msg,    error_code& ec);```[heading Description]
This function is used to write a complete message to a stream using HTTP/1. The call will block until one of the following conditions is true:

* The entire message is written.


* An error occurs.

This operation is implemented in terms of one or more calls to the stream's `write_some` function. The algorithm will use a temporary [link beast.ref.boost__beast__http__serializer `http::serializer`] with an empty chunk decorator to produce buffers.
[heading Remarks]
This function only participates in overload resolution if [link beast.ref.boost__beast__http__is_mutable_body_writer `http::is_mutable_body_writer`] for ['Body] returns `true`.
[heading Parameters][table [[Name][Description]]  [[`stream`][    
The stream to which the data is to be written. The type must support the ['SyncWriteStream] concept.  ]]  [[`msg`][    
The message to write.  ]]  [[`ec`][    
Set to the error, if any occurred.  ]]]
[heading Return Value]
The number of bytes written to the stream.
[heading See Also]
[link beast.ref.boost__beast__http__message `http::message`] 
Convenience header [include_file boost/beast/http.hpp][endsect][section:overload6 http::write (6 of 6 overloads)]
Write a complete message to a stream. [heading Synopsis]Defined in header [include_file boost/beast/http/write.hpp]```template<    class __SyncWriteStream__,    bool isRequest,    class __Body__,    class __Fields__>std::size_twrite(    SyncWriteStream& stream,    message< isRequest, Body, Fields > const& msg,    error_code& ec);```[heading Description]
This function is used to write a complete message to a stream using HTTP/1. The call will block until one of the following conditions is true:

* The entire message is written.


* An error occurs.

This operation is implemented in terms of one or more calls to the stream's `write_some` function. The algorithm will use a temporary [link beast.ref.boost__beast__http__serializer `http::serializer`] with an empty chunk decorator to produce buffers.
[heading Remarks]
This function only participates in overload resolution if [link beast.ref.boost__beast__http__is_mutable_body_writer `http::is_mutable_body_writer`] for ['Body] returns `false`.
[heading Parameters][table [[Name][Description]]  [[`stream`][    
The stream to which the data is to be written. The type must support the ['SyncWriteStream] concept.  ]]  [[`msg`][    
The message to write.  ]]  [[`ec`][    
Set to the error, if any occurred.  ]]]
[heading Return Value]
The number of bytes written to the stream.
[heading See Also]
[link beast.ref.boost__beast__http__message `http::message`] 
Convenience header [include_file boost/beast/http.hpp][endsect][endsect][section:boost__beast__http__write_header http::write_header][indexterm1 http::write_header]
Write a header to a stream using a serializer. ```template<    class __SyncWriteStream__,    bool isRequest,    class __Body__,    class __Fields__>std::size_t``[link beast.ref.boost__beast__http__write_header.overload1 write_header]``(    SyncWriteStream& stream,    serializer< isRequest, Body, Fields >& sr);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__write_header.overload1 more...]]``template<    class __SyncWriteStream__,    bool isRequest,    class __Body__,    class __Fields__>std::size_t``[link beast.ref.boost__beast__http__write_header.overload2 write_header]``(    SyncWriteStream& stream,    serializer< isRequest, Body, Fields >& sr,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__write_header.overload2 more...]]`````[section:overload1 http::write_header (1 of 2 overloads)]
Write a header to a stream using a serializer. [heading Synopsis]Defined in header [include_file boost/beast/http/write.hpp]```template<    class __SyncWriteStream__,    bool isRequest,    class __Body__,    class __Fields__>std::size_twrite_header(    SyncWriteStream& stream,    serializer< isRequest, Body, Fields >& sr);```[heading Description]
This function is used to write a header to a stream using a caller-provided HTTP/1 serializer. The call will block until one of the following conditions is true:

* The function [link beast.ref.boost__beast__http__serializer.is_header_done `http::serializer::is_header_done`] returns `true`


* An error occurs.

This operation is implemented in terms of one or more calls to the stream's `write_some` function.
[heading Parameters][table [[Name][Description]]  [[`stream`][    
The stream to which the data is to be written. The type must support the ['SyncWriteStream] concept.  ]]  [[`sr`][    
The serializer to use.  ]]]
[heading Return Value]
The number of bytes written to the stream.
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    
Thrown on failure.  ]]]
[heading Remarks]
The implementation will call [link beast.ref.boost__beast__http__serializer.split `http::serializer::split`] with the value `true` on the serializer passed in.
[heading See Also]
[link beast.ref.boost__beast__http__serializer `http::serializer`] 
Convenience header [include_file boost/beast/http.hpp][endsect][section:overload2 http::write_header (2 of 2 overloads)]
Write a header to a stream using a serializer. [heading Synopsis]Defined in header [include_file boost/beast/http/write.hpp]```template<    class __SyncWriteStream__,    bool isRequest,    class __Body__,    class __Fields__>std::size_twrite_header(    SyncWriteStream& stream,    serializer< isRequest, Body, Fields >& sr,    error_code& ec);```[heading Description]
This function is used to write a header to a stream using a caller-provided HTTP/1 serializer. The call will block until one of the following conditions is true:

* The function [link beast.ref.boost__beast__http__serializer.is_header_done `http::serializer::is_header_done`] returns `true`


* An error occurs.

This operation is implemented in terms of one or more calls to the stream's `write_some` function.
[heading Parameters][table [[Name][Description]]  [[`stream`][    
The stream to which the data is to be written. The type must support the ['SyncWriteStream] concept.  ]]  [[`sr`][    
The serializer to use.  ]]  [[`ec`][    
Set to indicate what error occurred, if any.  ]]]
[heading Return Value]
The number of bytes written to the stream.
[heading Remarks]
The implementation will call [link beast.ref.boost__beast__http__serializer.split `http::serializer::split`] with the value `true` on the serializer passed in.
[heading See Also]
[link beast.ref.boost__beast__http__serializer `http::serializer`] 
Convenience header [include_file boost/beast/http.hpp][endsect][endsect][section:boost__beast__http__write_some http::write_some][indexterm1 http::write_some]
Write part of a message to a stream using a serializer. ```template<    class __SyncWriteStream__,    bool isRequest,    class __Body__,    class __Fields__>std::size_t``[link beast.ref.boost__beast__http__write_some.overload1 write_some]``(    SyncWriteStream& stream,    serializer< isRequest, Body, Fields >& sr);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__write_some.overload1 more...]]``template<    class __SyncWriteStream__,    bool isRequest,    class __Body__,    class __Fields__>std::size_t``[link beast.ref.boost__beast__http__write_some.overload2 write_some]``(    SyncWriteStream& stream,    serializer< isRequest, Body, Fields >& sr,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__write_some.overload2 more...]]`````[section:overload1 http::write_some (1 of 2 overloads)]
Write part of a message to a stream using a serializer. [heading Synopsis]Defined in header [include_file boost/beast/http/write.hpp]```template<    class __SyncWriteStream__,    bool isRequest,    class __Body__,    class __Fields__>std::size_twrite_some(    SyncWriteStream& stream,    serializer< isRequest, Body, Fields >& sr);```[heading Description]
This function is used to write part of a message to a stream using a caller-provided HTTP/1 serializer. The call will block until one of the following conditions is true:

* One or more bytes have been transferred.


* The function [link beast.ref.boost__beast__http__serializer.is_done `http::serializer::is_done`] returns `true`


* An error occurs on the stream.

This operation is implemented in terms of one or more calls to the stream's `write_some` function.
The amount of data actually transferred is controlled by the behavior of the underlying stream, subject to the buffer size limit of the serializer obtained or set through a call to [link beast.ref.boost__beast__http__serializer.limit `http::serializer::limit`]. Setting a limit and performing bounded work helps applications set reasonable timeouts. It also allows application-level flow control to function correctly. For example when using a TCP/IP based stream.
[heading Parameters][table [[Name][Description]]  [[`stream`][    
The stream to which the data is to be written. The type must support the ['SyncWriteStream] concept.  ]]  [[`sr`][    
The serializer to use.  ]]]
[heading Return Value]
The number of bytes written to the stream.
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    
Thrown on failure.  ]]]
[heading See Also]
[link beast.ref.boost__beast__http__serializer `http::serializer`] 
Convenience header [include_file boost/beast/http.hpp][endsect][section:overload2 http::write_some (2 of 2 overloads)]
Write part of a message to a stream using a serializer. [heading Synopsis]Defined in header [include_file boost/beast/http/write.hpp]```template<    class __SyncWriteStream__,    bool isRequest,    class __Body__,    class __Fields__>std::size_twrite_some(    SyncWriteStream& stream,    serializer< isRequest, Body, Fields >& sr,    error_code& ec);```[heading Description]
This function is used to write part of a message to a stream using a caller-provided HTTP/1 serializer. The call will block until one of the following conditions is true:

* One or more bytes have been transferred.


* The function [link beast.ref.boost__beast__http__serializer.is_done `http::serializer::is_done`] returns `true`


* An error occurs on the stream.

This operation is implemented in terms of one or more calls to the stream's `write_some` function.
The amount of data actually transferred is controlled by the behavior of the underlying stream, subject to the buffer size limit of the serializer obtained or set through a call to [link beast.ref.boost__beast__http__serializer.limit `http::serializer::limit`]. Setting a limit and performing bounded work helps applications set reasonable timeouts. It also allows application-level flow control to function correctly. For example when using a TCP/IP based stream.
[heading Parameters][table [[Name][Description]]  [[`stream`][    
The stream to which the data is to be written. The type must support the ['SyncWriteStream] concept.  ]]  [[`sr`][    
The serializer to use.  ]]  [[`ec`][    
Set to indicate what error occurred, if any.  ]]]
[heading Return Value]
The number of bytes written to the stream.
[heading See Also]
[link beast.ref.boost__beast__http__async_write_some `http::async_write_some`], [link beast.ref.boost__beast__http__serializer `http::serializer`] 
Convenience header [include_file boost/beast/http.hpp][endsect][endsect][section:boost__beast__iequal iequal]
A case-insensitive equality predicate for strings. [heading Synopsis]Defined in header [include_file boost/beast/core/string.hpp]```struct iequal```[heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__iequal.operator_lp__rp_ [*operator()]]]    [          ]  ]][heading Description]
The case-comparison operation is defined only for low-ASCII characters. [section:operator_lp__rp_ iequal::operator()][indexterm2 operator()..iequal][heading Synopsis]```booloperator()(    string_view lhs,    string_view rhs) const;```[heading Description][endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__iequals iequals][indexterm1 iequals]
Returns `true` if two strings are equal, using a case-insensitive comparison. [heading Synopsis]Defined in header [include_file boost/beast/core/string.hpp]```booliequals(    beast::string_view lhs,    beast::string_view rhs);```[heading Description]
The case-comparison operation is defined only for low-ASCII characters.
[heading Parameters][table [[Name][Description]]  [[`lhs`][    
The string on the left side of the equality  ]]  [[`rhs`][    
The string on the right side of the equality   ]]]
Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__iless iless]
A case-insensitive less predicate for strings. [heading Synopsis]Defined in header [include_file boost/beast/core/string.hpp]```struct iless```[heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__iless.operator_lp__rp_ [*operator()]]]    [          ]  ]][heading Description]
The case-comparison operation is defined only for low-ASCII characters. [section:operator_lp__rp_ iless::operator()][indexterm2 operator()..iless][heading Synopsis]```booloperator()(    string_view lhs,    string_view rhs) const;```[heading Description][endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__is_async_read_stream is_async_read_stream][indexterm1 is_async_read_stream]
Determine if `T` meets the requirements of ['AsyncReadStream]. [heading Synopsis]Defined in header [include_file boost/beast/core/stream_traits.hpp]```template<    class T>using is_async_read_stream = ``['see-below]``;```[heading Description]
Metafunctions are used to perform compile time checking of template types. This type will be `std::true_type` if `T` meets the requirements, else the type will be `std::false_type`.
[heading Example]

Use with `static_assert`:
```  template<class AsyncReadStream>
  void f(AsyncReadStream& stream)
  {
      static_assert(is_async_read_stream<AsyncReadStream>::value,
          "AsyncReadStream type requirements not met");
  ...
```
Use with `std::enable_if` (SFINAE):
```  template<class AsyncReadStream>
  typename std::enable_if<is_async_read_stream<AsyncReadStream>::value>::type
  f(AsyncReadStream& stream);
```Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__is_async_stream is_async_stream][indexterm1 is_async_stream]
Determine if `T` meets the requirements of [*AsyncStream]. [heading Synopsis]Defined in header [include_file boost/beast/core/stream_traits.hpp]```template<    class T>using is_async_stream = ``['see-below]``;```[heading Description]
Metafunctions are used to perform compile time checking of template types. This type will be `std::true_type` if `T` meets the requirements, else the type will be `std::false_type`.
[heading Example]

Use with `static_assert`:
```  template<class AsyncStream>
  void f(AsyncStream& stream)
  {
      static_assert(is_async_stream<AsyncStream>::value,
          "AsyncStream type requirements not met");
  ...
```
Use with `std::enable_if` (SFINAE):
```  template<class AsyncStream>
  typename std::enable_if<is_async_stream<AsyncStream>::value>::type
  f(AsyncStream& stream);
```Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__is_async_write_stream is_async_write_stream][indexterm1 is_async_write_stream]
Determine if `T` meets the requirements of ['AsyncWriteStream]. [heading Synopsis]Defined in header [include_file boost/beast/core/stream_traits.hpp]```template<    class T>using is_async_write_stream = ``['see-below]``;```[heading Description]
Metafunctions are used to perform compile time checking of template types. This type will be `std::true_type` if `T` meets the requirements, else the type will be `std::false_type`.
[heading Example]

Use with `static_assert`:
```  template<class AsyncWriteStream>
  void f(AsyncWriteStream& stream)
  {
      static_assert(is_async_write_stream<AsyncWriteStream>::value,
          "AsyncWriteStream type requirements not met");
  ...
```
Use with `std::enable_if` (SFINAE):
```  template<class AsyncWriteStream>
  typename std::enable_if<is_async_write_stream<AsyncWriteStream>::value>::type
  f(AsyncWriteStream& stream);
```Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__is_const_buffer_sequence is_const_buffer_sequence][indexterm1 is_const_buffer_sequence]
Determine if a list of types satisfy the ['ConstBufferSequence] requirements. [heading Synopsis]Defined in header [include_file boost/beast/core/buffer_traits.hpp]```template<    class... __BufferSequence__>using is_const_buffer_sequence = ``['see-below]``;```[heading Description]
This metafunction is used to determine if all of the specified types meet the requirements for constant buffer sequences. This type alias will be `std::true_type` if each specified type meets the requirements, otherwise, this type alias will be `std::false_type`.
[heading Template Parameters][table [[Type][Description]]  [[`BufferSequence`][    
A list of zero or more types to check. If this list is empty, the resulting type alias will be `std::true_type`.   ]]]
Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__is_file is_file]
Determine if `T` meets the requirements of ['File]. [heading Synopsis]Defined in header [include_file boost/beast/core/file_base.hpp]```template<    class T>struct is_file :    public std::integral_constant< bool,... >```[heading Description]
Metafunctions are used to perform compile time checking of template types. This type will be `std::true_type` if `T` meets the requirements, else the type will be `std::false_type`.
[heading Example]

Use with `static_assert`:
```  template<class File>
  void f(File& file)
  {
      static_assert(is_file<File>::value,
          "File type requirements not met");
  ...
```
Use with `std::enable_if` (SFINAE):
```  template<class File>
  typename std::enable_if<is_file<File>::value>::type
  f(File& file);
```Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__is_mutable_buffer_sequence is_mutable_buffer_sequence][indexterm1 is_mutable_buffer_sequence]
Determine if a list of types satisfy the ['MutableBufferSequence] requirements. [heading Synopsis]Defined in header [include_file boost/beast/core/buffer_traits.hpp]```template<    class... __BufferSequence__>using is_mutable_buffer_sequence = ``['see-below]``;```[heading Description]
This metafunction is used to determine if all of the specified types meet the requirements for mutable buffer sequences. This type alias will be `std::true_type` if each specified type meets the requirements, otherwise, this type alias will be `std::false_type`.
[heading Template Parameters][table [[Type][Description]]  [[`BufferSequence`][    
A list of zero or more types to check. If this list is empty, the resulting type alias will be `std::true_type`.   ]]]
Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__is_sync_read_stream is_sync_read_stream][indexterm1 is_sync_read_stream]
Determine if at type meets the requirements of ['SyncReadStream]. [heading Synopsis]Defined in header [include_file boost/beast/core/stream_traits.hpp]```template<    class T>using is_sync_read_stream = ``['see-below]``;```[heading Description]
Metafunctions are used to perform compile time checking of template types. This type will be `std::true_type` if `T` meets the requirements, else the type will be `std::false_type`.
[heading Example]
Use with `static_assert`: ```  template<class SyncReadStream>
  void f(SyncReadStream& stream)
  {
      static_assert(is_sync_read_stream<SyncReadStream>::value,
          "SyncReadStream type requirements not met");
  ...
```
Use with `std::enable_if` (SFINAE): ```  template<class SyncReadStream>
  typename std::enable_if<is_sync_read_stream<SyncReadStream>::value>::type
  f(SyncReadStream& stream);
```Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__is_sync_stream is_sync_stream][indexterm1 is_sync_stream]
Determine if `T` meets the requirements of [*SyncStream]. [heading Synopsis]Defined in header [include_file boost/beast/core/stream_traits.hpp]```template<    class T>using is_sync_stream = ``['see-below]``;```[heading Description]
Metafunctions are used to perform compile time checking of template types. This type will be `std::true_type` if `T` meets the requirements, else the type will be `std::false_type`.
[heading Example]

Use with `static_assert`:
```  template<class SyncStream>
  void f(SyncStream& stream)
  {
      static_assert(is_sync_stream<SyncStream>::value,
          "SyncStream type requirements not met");
  ...
```
Use with `std::enable_if` (SFINAE):
```  template<class SyncStream>
  typename std::enable_if<is_sync_stream<SyncStream>::value>::type
  f(SyncStream& stream);
```Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__is_sync_write_stream is_sync_write_stream][indexterm1 is_sync_write_stream]
Determine if `T` meets the requirements of ['SyncWriteStream]. [heading Synopsis]Defined in header [include_file boost/beast/core/stream_traits.hpp]```template<    class T>using is_sync_write_stream = ``['see-below]``;```[heading Description]
Metafunctions are used to perform compile time checking of template types. This type will be `std::true_type` if `T` meets the requirements, else the type will be `std::false_type`.
[heading Example]

Use with `static_assert`:
```  template<class SyncReadStream>
  void f(SyncReadStream& stream)
  {
      static_assert(is_sync_read_stream<SyncReadStream>::value,
          "SyncReadStream type requirements not met");
  ...
```
Use with `std::enable_if` (SFINAE):
```  template<class SyncReadStream>
  typename std::enable_if<is_sync_read_stream<SyncReadStream>::value>::type
  f(SyncReadStream& stream);
```Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__lowest_layer_type lowest_layer_type][indexterm1 lowest_layer_type]
A trait to determine the lowest layer type of a stack of stream layers. [heading Synopsis]Defined in header [include_file boost/beast/core/stream_traits.hpp]```template<    class T>using lowest_layer_type = ``['see-below]``;```[heading Description]
If `t.next_layer()` is well-defined for an object `t` of type `T`, then `lowest_layer_type<T>` will be an alias for `lowest_layer_type<decltype(t.next_layer())>`, otherwise it will be the type `std::remove_reference<T>`.
[heading Parameters][table [[Name][Description]]  [[`T`][    
The type to determine the lowest layer type of.  ]]]
[heading Return Value]
The type of the lowest layer. 
Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__make_printable make_printable][indexterm1 make_printable]
Helper to permit a buffer sequence to be printed to a std::ostream. [heading Synopsis]Defined in header [include_file boost/beast/core/make_printable.hpp]```template<    class __ConstBufferSequence__>``['implementation-defined]``make_printable(    ConstBufferSequence const& buffers);```[heading Description]
This function is used to wrap a buffer sequence to allow it to be interpreted as characters and written to a `std::ostream` such as `std::cout`. No character translation is performed; unprintable and null characters will be transferred as-is to the output stream.
[heading Example]
This function prints the size and contents of a buffer sequence to standard output: ```  template <class ConstBufferSequence>
  void
  print (ConstBufferSequence const& buffers)
  {
      std::cout <<
          "Buffer size: " << buffer_bytes(buffers) << " bytes\n"
          "Buffer data: '" << make_printable(buffers) << "'\n";
  }
```
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
An object meeting the requirements of ['ConstBufferSequence] to be streamed. The implementation will make a copy of this object. Ownership of the underlying memory is not transferred, the application is still responsible for managing its lifetime.   ]]]
Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__multi_buffer multi_buffer][indexterm1 multi_buffer]
A typical multi buffer. [heading Synopsis]Defined in header [include_file boost/beast/core/multi_buffer.hpp]```using multi_buffer = basic_multi_buffer< std::allocator< char > >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__basic_multi_buffer.allocator_type [*allocator_type]]]    [      The type of allocator used.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.const_buffers_type [*const_buffers_type]]]    [      The ConstBufferSequence used to represent the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.mutable_buffers_type [*mutable_buffers_type]]]    [      The MutableBufferSequence used to represent the writable bytes.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.mutable_data_type [*mutable_data_type]]]    [      The MutableBufferSequence used to represent the readable bytes.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer [*basic_multi_buffer]]]    [      Constructor.       Move Constructor.       Copy Constructor.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.capacity [*capacity]]]    [      Return the maximum number of bytes, both readable and writable, that can be held without requiring an allocation.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.cdata [*cdata]]]    [      Returns a constant buffer sequence representing the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.clear [*clear]]]    [      Set the size of the readable and writable bytes to zero.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.commit [*commit]]]    [      Append writable bytes to the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.consume [*consume]]]    [      Remove bytes from beginning of the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.data [*data]]]    [      Returns a constant buffer sequence representing the readable bytes.       Returns a mutable buffer sequence representing the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.get_allocator [*get_allocator]]]    [      Returns a copy of the allocator used.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.max_size [*max_size]]]    [      Set the maximum allowed capacity.       Return the maximum number of bytes, both readable and writable, that can ever be held.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.operator_eq_ [*operator=]]]    [      Move Assignment.       Copy Assignment.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.prepare [*prepare]]]    [      Returns a mutable buffer sequence representing writable bytes.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.reserve [*reserve]]]    [      Guarantee a minimum capacity.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.shrink_to_fit [*shrink_to_fit]]]    [      Reallocate the buffer to fit the readable bytes exactly.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.size [*size]]]    [      Returns the number of readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer_dtor_ [*~basic_multi_buffer]]]    [      Destructor.     ]  ]][heading Friends][table [[Name][Description]]  [    [[link beast.ref.boost__beast__basic_multi_buffer.swap [*swap]]]    [      Exchange two dynamic buffers.     ]  ]]
A dynamic buffer encapsulates memory storage that may be automatically resized as required, where the memory is divided into two regions: readable bytes followed by writable bytes. These memory regions are internal to the dynamic buffer, but direct access to the elements is provided to permit them to be efficiently used with I/O operations.
The implementation uses a sequence of one or more byte arrays of varying sizes to represent the readable and writable bytes. Additional byte array objects are appended to the sequence to accommodate changes in the desired size. The behavior and implementation of this container is most similar to `std::deque`.
Objects of this type meet the requirements of ['DynamicBuffer] and have the following additional properties:

* A mutable buffer sequence representing the readable bytes is returned by [link beast.ref.boost__beast__basic_multi_buffer.data `basic_multi_buffer::data`] when `this` is non-const.


* Buffer sequences representing the readable and writable bytes, returned by [link beast.ref.boost__beast__basic_multi_buffer.data `basic_multi_buffer::data`] and [link beast.ref.boost__beast__basic_multi_buffer.prepare `basic_multi_buffer::prepare`], may have length greater than one.


* A configurable maximum size may be set upon construction and adjusted afterwards. Calls to [link beast.ref.boost__beast__basic_multi_buffer.prepare `basic_multi_buffer::prepare`] that would exceed this size will throw `std::length_error`.


* Sequences previously obtained using [link beast.ref.boost__beast__basic_multi_buffer.data `basic_multi_buffer::data`] remain valid after calls to [link beast.ref.boost__beast__basic_multi_buffer.prepare `basic_multi_buffer::prepare`] or [link beast.ref.boost__beast__basic_multi_buffer.commit `basic_multi_buffer::commit`].

[heading Template Parameters][table [[Type][Description]]  [[`Allocator`][    
The allocator to use for managing memory.   ]]]
[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__operator_not__eq_ operator!=][indexterm1 operator!=]```template<    std::size_t N,    std::size_t M,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_not__eq_.overload1 operator!=]``(    static_string< N, CharT, Traits > const& lhs,    static_string< M, CharT, Traits > const& rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_not__eq_.overload1 more...]]``template<    std::size_t N,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_not__eq_.overload2 operator!=]``(    CharT const* lhs,    static_string< N, CharT, Traits > const& rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_not__eq_.overload2 more...]]``template<    std::size_t N,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_not__eq_.overload3 operator!=]``(    static_string< N, CharT, Traits > const& lhs,    CharT const* rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_not__eq_.overload3 more...]]`````[section:overload1 operator!= (1 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    std::size_t M,    class CharT,    class Traits>booloperator!=(    static_string< N, CharT, Traits > const& lhs,    static_string< M, CharT, Traits > const& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:overload2 operator!= (2 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>booloperator!=(    CharT const* lhs,    static_string< N, CharT, Traits > const& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:overload3 operator!= (3 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>booloperator!=(    static_string< N, CharT, Traits > const& lhs,    CharT const* rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][endsect][section:boost__beast__operator_plus_ operator+][indexterm1 operator+]```template<    std::size_t N,    std::size_t M,    class CharT,    class Traits>void``[link beast.ref.boost__beast__operator_plus_.overload1 operator+]``(    static_string< N, CharT, Traits >const& lhs,    static_string< M, CharT, Traits >const& rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_plus_.overload1 more...]]``template<    std::size_t N,    class CharT,    class Traits>void``[link beast.ref.boost__beast__operator_plus_.overload2 operator+]``(    CharT const* lhs,    static_string< N, CharT, Traits >const& rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_plus_.overload2 more...]]``template<    std::size_t N,    class CharT,    class Traits>void``[link beast.ref.boost__beast__operator_plus_.overload3 operator+]``(    CharT lhs,    static_string< N, CharT, Traits > const& rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_plus_.overload3 more...]]``template<    std::size_t N,    class CharT,    class Traits>void``[link beast.ref.boost__beast__operator_plus_.overload4 operator+]``(    static_string< N, CharT, Traits > const& lhs,    CharT const* rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_plus_.overload4 more...]]``template<    std::size_t N,    class CharT,    class Traits>void``[link beast.ref.boost__beast__operator_plus_.overload5 operator+]``(    static_string< N, CharT, Traits > const& lhs,    CharT rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_plus_.overload5 more...]]`````[section:overload1 operator+ (1 of 5 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    std::size_t M,    class CharT,    class Traits>voidoperator+(    static_string< N, CharT, Traits >const& lhs,    static_string< M, CharT, Traits >const& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:overload2 operator+ (2 of 5 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>voidoperator+(    CharT const* lhs,    static_string< N, CharT, Traits >const& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:overload3 operator+ (3 of 5 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>voidoperator+(    CharT lhs,    static_string< N, CharT, Traits > const& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:overload4 operator+ (4 of 5 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>voidoperator+(    static_string< N, CharT, Traits > const& lhs,    CharT const* rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:overload5 operator+ (5 of 5 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>voidoperator+(    static_string< N, CharT, Traits > const& lhs,    CharT rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][endsect][section:boost__beast__operator_lt_ operator<][indexterm1 operator<]```template<    std::size_t N,    std::size_t M,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_lt_.overload1 operator<]``(    static_string< N, CharT, Traits > const& lhs,    static_string< M, CharT, Traits > const& rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_lt_.overload1 more...]]``template<    std::size_t N,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_lt_.overload2 operator<]``(    CharT const* lhs,    static_string< N, CharT, Traits > const& rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_lt_.overload2 more...]]``template<    std::size_t N,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_lt_.overload3 operator<]``(    static_string< N, CharT, Traits > const& lhs,    CharT const* rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_lt_.overload3 more...]]`````[section:overload1 operator< (1 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    std::size_t M,    class CharT,    class Traits>booloperator<(    static_string< N, CharT, Traits > const& lhs,    static_string< M, CharT, Traits > const& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:overload2 operator< (2 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>booloperator<(    CharT const* lhs,    static_string< N, CharT, Traits > const& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:overload3 operator< (3 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>booloperator<(    static_string< N, CharT, Traits > const& lhs,    CharT const* rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][endsect][section:boost__beast__operator_lt__lt_ operator<<][indexterm1 operator<<][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>std::basic_ostream< CharT, Traits >&operator<<(    std::basic_ostream< CharT, Traits >& os,    static_string< N, CharT, Traits > const& str);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__operator_lt__eq_ operator<=][indexterm1 operator<=]```template<    std::size_t N,    std::size_t M,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_lt__eq_.overload1 operator<=]``(    static_string< N, CharT, Traits > const& lhs,    static_string< M, CharT, Traits > const& rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_lt__eq_.overload1 more...]]``template<    std::size_t N,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_lt__eq_.overload2 operator<=]``(    CharT const* lhs,    static_string< N, CharT, Traits > const& rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_lt__eq_.overload2 more...]]``template<    std::size_t N,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_lt__eq_.overload3 operator<=]``(    static_string< N, CharT, Traits > const& lhs,    CharT const* rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_lt__eq_.overload3 more...]]`````[section:overload1 operator<= (1 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    std::size_t M,    class CharT,    class Traits>booloperator<=(    static_string< N, CharT, Traits > const& lhs,    static_string< M, CharT, Traits > const& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:overload2 operator<= (2 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>booloperator<=(    CharT const* lhs,    static_string< N, CharT, Traits > const& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:overload3 operator<= (3 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>booloperator<=(    static_string< N, CharT, Traits > const& lhs,    CharT const* rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][endsect][section:boost__beast__operator_eq__eq_ operator==][indexterm1 operator==]```template<    std::size_t N,    std::size_t M,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_eq__eq_.overload1 operator==]``(    static_string< N, CharT, Traits > const& lhs,    static_string< M, CharT, Traits > const& rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_eq__eq_.overload1 more...]]``template<    std::size_t N,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_eq__eq_.overload2 operator==]``(    CharT const* lhs,    static_string< N, CharT, Traits > const& rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_eq__eq_.overload2 more...]]``template<    std::size_t N,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_eq__eq_.overload3 operator==]``(    static_string< N, CharT, Traits > const& lhs,    CharT const* rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_eq__eq_.overload3 more...]]`````[section:overload1 operator== (1 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    std::size_t M,    class CharT,    class Traits>booloperator==(    static_string< N, CharT, Traits > const& lhs,    static_string< M, CharT, Traits > const& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:overload2 operator== (2 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>booloperator==(    CharT const* lhs,    static_string< N, CharT, Traits > const& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:overload3 operator== (3 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>booloperator==(    static_string< N, CharT, Traits > const& lhs,    CharT const* rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][endsect][section:boost__beast__operator_gt_ operator>][indexterm1 operator>]```template<    std::size_t N,    std::size_t M,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_gt_.overload1 operator>]``(    static_string< N, CharT, Traits > const& lhs,    static_string< M, CharT, Traits > const& rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_gt_.overload1 more...]]``template<    std::size_t N,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_gt_.overload2 operator>]``(    CharT const* lhs,    static_string< N, CharT, Traits > const& rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_gt_.overload2 more...]]``template<    std::size_t N,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_gt_.overload3 operator>]``(    static_string< N, CharT, Traits > const& lhs,    CharT const* rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_gt_.overload3 more...]]`````[section:overload1 operator> (1 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    std::size_t M,    class CharT,    class Traits>booloperator>(    static_string< N, CharT, Traits > const& lhs,    static_string< M, CharT, Traits > const& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:overload2 operator> (2 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>booloperator>(    CharT const* lhs,    static_string< N, CharT, Traits > const& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:overload3 operator> (3 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>booloperator>(    static_string< N, CharT, Traits > const& lhs,    CharT const* rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][endsect][section:boost__beast__operator_gt__eq_ operator>=][indexterm1 operator>=]```template<    std::size_t N,    std::size_t M,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_gt__eq_.overload1 operator>=]``(    static_string< N, CharT, Traits > const& lhs,    static_string< M, CharT, Traits > const& rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_gt__eq_.overload1 more...]]``template<    std::size_t N,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_gt__eq_.overload2 operator>=]``(    CharT const* lhs,    static_string< N, CharT, Traits > const& rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_gt__eq_.overload2 more...]]``template<    std::size_t N,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_gt__eq_.overload3 operator>=]``(    static_string< N, CharT, Traits > const& lhs,    CharT const* rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_gt__eq_.overload3 more...]]`````[section:overload1 operator>= (1 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    std::size_t M,    class CharT,    class Traits>booloperator>=(    static_string< N, CharT, Traits > const& lhs,    static_string< M, CharT, Traits > const& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:overload2 operator>= (2 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>booloperator>=(    CharT const* lhs,    static_string< N, CharT, Traits > const& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:overload3 operator>= (3 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>booloperator>=(    static_string< N, CharT, Traits > const& lhs,    CharT const* rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][endsect][section:boost__beast__ostream ostream][indexterm1 ostream]
Return an output stream that formats values into a ['DynamicBuffer]. [heading Synopsis]Defined in header [include_file boost/beast/core/ostream.hpp]```template<    class __DynamicBuffer__>``['implementation-defined]``ostream(    DynamicBuffer& buffer);```[heading Description]
This function wraps the caller provided ['DynamicBuffer] into a `std::ostream` derived class, to allow `operator<<` stream style formatting operations.
[heading Example]
```  ostream(buffer) << "Hello, world!" << std::endl;
```
[heading Remarks]
Calling members of the underlying buffer before the output stream is destroyed results in undefined behavior.
[heading Parameters][table [[Name][Description]]  [[`buffer`][    
An object meeting the requirements of ['DynamicBuffer] into which the formatted output will be placed.  ]]]
[heading Return Value]
An object derived from `std::ostream` which redirects output The wrapped dynamic buffer is not modified, a copy is made instead. Ownership of the underlying memory is not transferred, the application is still responsible for managing its lifetime. The caller is responsible for ensuring the dynamic buffer is not destroyed for the lifetime of the output stream. 
Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__rate_policy_access rate_policy_access]
Helper class to assist implementing a ['RatePolicy]. [heading Synopsis]Defined in header [include_file boost/beast/core/rate_policy.hpp]```class rate_policy_access```[heading Description]
This class is used by the implementation to gain access to the private members of a user-defined object meeting the requirements of ['RatePolicy]. To use it, simply declare it as a friend in your class:
[heading Example]
```  class custom_rate_policy
  {
      friend class beast::rate_policy_access;
      ...
```
[heading Concepts]


* ['RatePolicy]

[heading See Also]
[link beast.ref.boost__beast__basic_stream `basic_stream`] 
Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__read_size read_size][indexterm1 read_size]
Returns a natural read size. [heading Synopsis]Defined in header [include_file boost/beast/core/read_size.hpp]```template<    class __DynamicBuffer__>std::size_tread_size(    DynamicBuffer& buffer,    std::size_t max_size);```[heading Description]
This function inspects the capacity, size, and maximum size of the dynamic buffer. Then it computes a natural read size given the passed-in upper limit. It favors a read size that does not require a reallocation, subject to a reasonable minimum to avoid tiny reads.
[heading Parameters][table [[Name][Description]]  [[`buffer`][    
The dynamic buffer to inspect.  ]]  [[`max_size`][    
An upper limit on the returned value.  ]]]
[heading Remarks]
If the buffer is already at its maximum size, zero is returned. 
Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__read_size_or_throw read_size_or_throw][indexterm1 read_size_or_throw]
Returns a natural read size or throw if the buffer is full. [heading Synopsis]Defined in header [include_file boost/beast/core/read_size.hpp]```template<    class __DynamicBuffer__>std::size_tread_size_or_throw(    DynamicBuffer& buffer,    std::size_t max_size);```[heading Description]
This function inspects the capacity, size, and maximum size of the dynamic buffer. Then it computes a natural read size given the passed-in upper limit. It favors a read size that does not require a reallocation, subject to a reasonable minimum to avoid tiny reads.
[heading Parameters][table [[Name][Description]]  [[`buffer`][    
The dynamic buffer to inspect.  ]]  [[`max_size`][    
An upper limit on the returned value.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::length_error`][    
if `max_size > 0` and the buffer is full.   ]]]
Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__role_type role_type][indexterm1 role_type]
The role of local or remote peer. [heading Synopsis]Defined in header [include_file boost/beast/core/role.hpp]```enum role_type```[indexterm2 client..role_type][indexterm2 server..role_type][heading Values][table [[Name][Description]]  [[[^client]][The stream is operating as a client. ]]  [[[^server]][The stream is operating as a server. ]]][heading Description]
Whether the endpoint is a client or server affects the behavior of teardown. The teardown behavior also depends on the type of the stream being torn down.
The default implementation of teardown for regular TCP/IP sockets is as follows:

* In the client role, a TCP/IP shutdown is sent after reading all remaining data on the connection.


* In the server role, a TCP/IP shutdown is sent before reading all remaining data on the connection.

When the next layer type is a `net::ssl::stream`, the connection is closed by performing the SSL closing handshake corresponding to the role type, client or server. Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__saved_handler saved_handler]
An invocable, nullary function object which holds a completion handler. [heading Synopsis]Defined in header [include_file boost/beast/core/saved_handler.hpp]```class saved_handler```[heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__saved_handler.emplace [*emplace]]]    [      Store a completion handler in the container.     ]  ]  [    [[link beast.ref.boost__beast__saved_handler.has_value [*has_value]]]    [      Returns true if *this contains a completion handler.     ]  ]  [    [[link beast.ref.boost__beast__saved_handler.invoke [*invoke]]]    [      Unconditionally invoke the stored completion handler.     ]  ]  [    [[link beast.ref.boost__beast__saved_handler.maybe_invoke [*maybe_invoke]]]    [      Conditionally invoke the stored completion handler.     ]  ]  [    [[link beast.ref.boost__beast__saved_handler.operator_eq_ [*operator=]]]    [      Copy Assignment (deleted)       Move Assignment.     ]  ]  [    [[link beast.ref.boost__beast__saved_handler.reset [*reset]]]    [      Discard the saved handler, if one exists.     ]  ]  [    [[link beast.ref.boost__beast__saved_handler.saved_handler [*saved_handler]]]    [      Default Constructor.       Copy Constructor (deleted)       Move Constructor.     ]  ]  [    [[link beast.ref.boost__beast__saved_handler.saved_handler_dtor_ [*~saved_handler]]]    [      Destructor.     ]  ]][heading Description]
This container can hold a type-erased instance of any completion handler, or it can be empty. When the container holds a value, the implementation maintains an instance of `net::executor_work_guard` for the handler's associated executor. Memory is dynamically allocated to store the completion handler, and the allocator may optionally be specified. Otherwise, the implementation uses the handler's associated allocator. [section:emplace saved_handler::emplace][indexterm2 emplace..saved_handler]
Store a completion handler in the container. ```template<    class __Handler__,    class __Allocator__>void``[link beast.ref.boost__beast__saved_handler.emplace.overload1 emplace]``(    Handler&& handler,    Allocator const& alloc);  ``[''''&raquo;''' [link beast.ref.boost__beast__saved_handler.emplace.overload1 more...]]``template<    class __Handler__>void``[link beast.ref.boost__beast__saved_handler.emplace.overload2 emplace]``(    Handler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__saved_handler.emplace.overload2 more...]]`````[section:overload1 saved_handler::emplace (1 of 2 overloads)]
Store a completion handler in the container. [heading Synopsis]```template<    class __Handler__,    class __Allocator__>voidemplace(    Handler&& handler,    Allocator const& alloc);```[heading Description]
Requires `this->has_value() == false`.
[heading Parameters][table [[Name][Description]]  [[`handler`][    
The completion handler to store. The implementation takes ownership of the handler by performing a decay-copy.  ]]  [[`alloc`][    
The allocator to use.   ]]]
[endsect][section:overload2 saved_handler::emplace (2 of 2 overloads)]
Store a completion handler in the container. [heading Synopsis]```template<    class __Handler__>voidemplace(    Handler&& handler);```[heading Description]
Requires `this->has_value() == false`. The implementation will use the handler's associated allocator to obtian storage.
[heading Parameters][table [[Name][Description]]  [[`handler`][    
The completion handler to store. The implementation takes ownership of the handler by performing a decay-copy.   ]]]
[endsect][endsect][section:has_value saved_handler::has_value][indexterm2 has_value..saved_handler]
Returns `true` if `*this` contains a completion handler. [heading Synopsis]```boolhas_value() const;```[heading Description][endsect][section:invoke saved_handler::invoke][indexterm2 invoke..saved_handler]
Unconditionally invoke the stored completion handler. [heading Synopsis]```voidinvoke();```[heading Description]
Requires `this->has_value() == true`. Any dynamic memory used is deallocated before the stored completion handler is invoked. The executor work guard is also reset before the invocation. [endsect][section:maybe_invoke saved_handler::maybe_invoke][indexterm2 maybe_invoke..saved_handler]
Conditionally invoke the stored completion handler. [heading Synopsis]```boolmaybe_invoke();```[heading Description]
Invokes the stored completion handler if `this->has_value() == true`, otherwise does nothing. Any dynamic memory used is deallocated before the stored completion handler is invoked. The executor work guard is also reset before the invocation.
[heading Return Value]
`true` if the invocation took place. 
[endsect][section:operator_eq_ saved_handler::operator=][indexterm2 operator=..saved_handler]
Copy Assignment (deleted) ```saved_handler&``[link beast.ref.boost__beast__saved_handler.operator_eq_.overload1 operator=]``(    saved_handler const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__saved_handler.operator_eq_.overload1 more...]]`````
Move Assignment. ```saved_handler&``[link beast.ref.boost__beast__saved_handler.operator_eq_.overload2 operator=]``(    saved_handler&& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__saved_handler.operator_eq_.overload2 more...]]`````[section:overload1 saved_handler::operator= (1 of 2 overloads)]
Copy Assignment (deleted) [heading Synopsis]```saved_handler&operator=(    saved_handler const&);```[heading Description][endsect][section:overload2 saved_handler::operator= (2 of 2 overloads)]
Move Assignment. [heading Synopsis]```saved_handler&operator=(    saved_handler&& other);```[heading Description][endsect][endsect][section:reset saved_handler::reset][indexterm2 reset..saved_handler]
Discard the saved handler, if one exists. [heading Synopsis]```boolreset();```[heading Description]
If `*this` contains an object, it is destroyed.
[heading Return Value]
`true` if an object was destroyed. 
[endsect][section:saved_handler saved_handler::saved_handler][indexterm2 saved_handler..saved_handler]
Default Constructor. `````[link beast.ref.boost__beast__saved_handler.saved_handler.overload1 saved_handler]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__saved_handler.saved_handler.overload1 more...]]`````
Copy Constructor (deleted) `````[link beast.ref.boost__beast__saved_handler.saved_handler.overload2 saved_handler]``(    saved_handler const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__saved_handler.saved_handler.overload2 more...]]`````
Move Constructor. `````[link beast.ref.boost__beast__saved_handler.saved_handler.overload3 saved_handler]``(    saved_handler&& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__saved_handler.saved_handler.overload3 more...]]`````[section:overload1 saved_handler::saved_handler (1 of 3 overloads)]
Default Constructor. [heading Synopsis]```saved_handler();```[heading Description][endsect][section:overload2 saved_handler::saved_handler (2 of 3 overloads)]
Copy Constructor (deleted) [heading Synopsis]```saved_handler(    saved_handler const&);```[heading Description][endsect][section:overload3 saved_handler::saved_handler (3 of 3 overloads)]
Move Constructor. [heading Synopsis]```saved_handler(    saved_handler&& other);```[heading Description][endsect][endsect][section:saved_handler_dtor_ saved_handler::~saved_handler][indexterm2 ~saved_handler..saved_handler]
Destructor. [heading Synopsis]```~saved_handler();```[heading Description][endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__saved_handler__impl saved_handler::impl][heading Synopsis]Defined in header [include_file boost/beast/core/saved_handler.hpp]```template<    [role red error.class-detail-template.1][role red error.class-detail-template.2],    [role red error.class-detail-template.1][role red error.class-detail-template.2]>class impl```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__simple_rate_policy simple_rate_policy]
A rate policy with simple, configurable limits on reads and writes. [heading Synopsis]Defined in header [include_file boost/beast/core/rate_policy.hpp]```class simple_rate_policy```[heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__simple_rate_policy.read_limit [*read_limit]]]    [      Set the limit of bytes per second to read.     ]  ]  [    [[link beast.ref.boost__beast__simple_rate_policy.write_limit [*write_limit]]]    [      Set the limit of bytes per second to write.     ]  ]][heading Description]
This rate policy allows for simple individual limits on the amount of bytes per second allowed for reads and writes.
[heading Concepts]


* ['RatePolicy]

[heading See Also]
[link beast.ref.boost__beast__basic_stream `basic_stream`] 
[section:read_limit simple_rate_policy::read_limit][indexterm2 read_limit..simple_rate_policy]
Set the limit of bytes per second to read. [heading Synopsis]```voidread_limit(    std::size_t bytes_per_second);```[heading Description][endsect][section:write_limit simple_rate_policy::write_limit][indexterm2 write_limit..simple_rate_policy]
Set the limit of bytes per second to write. [heading Synopsis]```voidwrite_limit(    std::size_t bytes_per_second);```[heading Description][endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__span span]
A range of bytes expressed as a ContiguousContainer. [heading Synopsis]Defined in header [include_file boost/beast/core/span.hpp]```template<    class T>class span```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__span.const_iterator [*const_iterator]]]    [      The const iterator used by the container.     ]  ]  [    [[link beast.ref.boost__beast__span.const_pointer [*const_pointer]]]    [      The const pointer used by the container.     ]  ]  [    [[link beast.ref.boost__beast__span.const_reference [*const_reference]]]    [      The const reference used by the container.     ]  ]  [    [[link beast.ref.boost__beast__span.element_type [*element_type]]]    [      The type of value, including cv qualifiers.     ]  ]  [    [[link beast.ref.boost__beast__span.index_type [*index_type]]]    [      The type of integer used to index the span.     ]  ]  [    [[link beast.ref.boost__beast__span.iterator [*iterator]]]    [      The iterator used by the container.     ]  ]  [    [[link beast.ref.boost__beast__span.pointer [*pointer]]]    [      A pointer to a span element.     ]  ]  [    [[link beast.ref.boost__beast__span.reference [*reference]]]    [      A reference to a span element.     ]  ]  [    [[link beast.ref.boost__beast__span.value_type [*value_type]]]    [      The type of value of each span element.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__span.begin [*begin]]]    [      Returns an iterator to the beginning of the span.     ]  ]  [    [[link beast.ref.boost__beast__span.cbegin [*cbegin]]]    [      Returns an iterator to the beginning of the span.     ]  ]  [    [[link beast.ref.boost__beast__span.cend [*cend]]]    [      Returns an iterator to one past the end of the span.     ]  ]  [    [[link beast.ref.boost__beast__span.data [*data]]]    [      Returns a pointer to the beginning of the span.     ]  ]  [    [[link beast.ref.boost__beast__span.empty [*empty]]]    [      Returns true if the span is empty.     ]  ]  [    [[link beast.ref.boost__beast__span.end [*end]]]    [      Returns an iterator to one past the end of the span.     ]  ]  [    [[link beast.ref.boost__beast__span.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__span.size [*size]]]    [      Returns the number of elements in the span.     ]  ]  [    [[link beast.ref.boost__beast__span.span [*span]]]    [      Constructor.     ]  ]][heading Description]
This class implements a non-owning reference to a storage area of a certain size and having an underlying integral type with size of 1.
[heading Template Parameters][table [[Type][Description]]  [[`T`][    
The type pointed to by span iterators   ]]]
[section:begin span::begin][indexterm2 begin..span]
Returns an iterator to the beginning of the span. [heading Synopsis]```const_iteratorbegin() const;```[heading Description][endsect][section:cbegin span::cbegin][indexterm2 cbegin..span]
Returns an iterator to the beginning of the span. [heading Synopsis]```const_iteratorcbegin() const;```[heading Description][endsect][section:cend span::cend][indexterm2 cend..span]
Returns an iterator to one past the end of the span. [heading Synopsis]```const_iteratorcend() const;```[heading Description][endsect][section:const_iterator span::const_iterator][indexterm2 const_iterator..span]
The const iterator used by the container. [heading Synopsis]```using const_iterator = const_pointer;```[heading Description][endsect][section:const_pointer span::const_pointer][indexterm2 const_pointer..span]
The const pointer used by the container. [heading Synopsis]```using const_pointer = T const *;```[heading Description][endsect][section:const_reference span::const_reference][indexterm2 const_reference..span]
The const reference used by the container. [heading Synopsis]```using const_reference = T const &;```[heading Description][endsect][section:data span::data][indexterm2 data..span]
Returns a pointer to the beginning of the span. [heading Synopsis]```T*data() const;```[heading Description][endsect][section:element_type span::element_type][indexterm2 element_type..span]
The type of value, including cv qualifiers. [heading Synopsis]```using element_type = T;```[heading Description][endsect][section:empty span::empty][indexterm2 empty..span]
Returns `true` if the span is empty. [heading Synopsis]```boolempty() const;```[heading Description][endsect][section:end span::end][indexterm2 end..span]
Returns an iterator to one past the end of the span. [heading Synopsis]```const_iteratorend() const;```[heading Description][endsect][section:index_type span::index_type][indexterm2 index_type..span]
The type of integer used to index the span. [heading Synopsis]```using index_type = std::ptrdiff_t;```[heading Description][endsect][section:iterator span::iterator][indexterm2 iterator..span]
The iterator used by the container. [heading Synopsis]```using iterator = pointer;```[heading Description][endsect][section:operator_eq_ span::operator=][indexterm2 operator=..span]
Assignment. ```span&``[link beast.ref.boost__beast__span.operator_eq_.overload1 operator=]``(    span const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__span.operator_eq_.overload1 more...]]``template<    class ContiguousContainer>span&``[link beast.ref.boost__beast__span.operator_eq_.overload2 operator=]``(    ContiguousContainer&& container);  ``[''''&raquo;''' [link beast.ref.boost__beast__span.operator_eq_.overload2 more...]]`````[section:overload1 span::operator= (1 of 2 overloads)]
Assignment. [heading Synopsis]```span&operator=(    span const&);```[heading Description][endsect][section:overload2 span::operator= (2 of 2 overloads)]
Assignment. [heading Synopsis]```template<    class ContiguousContainer>span&operator=(    ContiguousContainer&& container);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`container`][    
The container to assign from   ]]]
[endsect][endsect][section:pointer span::pointer][indexterm2 pointer..span]
A pointer to a span element. [heading Synopsis]```using pointer = T*;```[heading Description][endsect][section:reference span::reference][indexterm2 reference..span]
A reference to a span element. [heading Synopsis]```using reference = T&;```[heading Description][endsect][section:size span::size][indexterm2 size..span]
Returns the number of elements in the span. [heading Synopsis]```std::size_tsize() const;```[heading Description][endsect][section:span span::span][indexterm2 span..span]
Constructor. `````[link beast.ref.boost__beast__span.span.overload1 span]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__span.span.overload1 more...]]````[link beast.ref.boost__beast__span.span.overload2 span]``(    span const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__span.span.overload2 more...]]````[link beast.ref.boost__beast__span.span.overload3 span]``(    T* data,    std::size_t size);  ``[''''&raquo;''' [link beast.ref.boost__beast__span.span.overload3 more...]]``template<    class ContiguousContainer>explicit``[link beast.ref.boost__beast__span.span.overload4 span]``(    ContiguousContainer&& container);  ``[''''&raquo;''' [link beast.ref.boost__beast__span.span.overload4 more...]]`````[section:overload1 span::span (1 of 4 overloads)]
Constructor. [heading Synopsis]```span();```[heading Description][endsect][section:overload2 span::span (2 of 4 overloads)]
Constructor. [heading Synopsis]```span(    span const&);```[heading Description][endsect][section:overload3 span::span (3 of 4 overloads)]
Constructor. [heading Synopsis]```span(    T* data,    std::size_t size);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`data`][    
A pointer to the beginning of the range of elements  ]]  [[`size`][    
The number of elements pointed to by `data`   ]]]
[endsect][section:overload4 span::span (4 of 4 overloads)]
Constructor. [heading Synopsis]```template<    class ContiguousContainer>span(    ContiguousContainer&& container);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`container`][    
The container to construct from   ]]]
[endsect][endsect][section:value_type span::value_type][indexterm2 value_type..span]
The type of value of each span element. [heading Synopsis]```using value_type = typename std::remove_const< T >::type;```[heading Description][endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__ssl_stream ssl_stream]
Provides stream-oriented functionality using OpenSSL. [heading Synopsis]Defined in header [include_file boost/beast/ssl/ssl_stream.hpp]```template<    class NextLayer>class ssl_stream :    public stream_base```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__ssl_stream.executor_type [*executor_type]]]    [      The type of the executor associated with the object.     ]  ]  [    [[link beast.ref.boost__beast__ssl_stream.impl_struct [*impl_struct]]]    [      Structure for use with deprecated impl_type.     ]  ]  [    [[link beast.ref.boost__beast__ssl_stream.native_handle_type [*native_handle_type]]]    [      The native handle type of the SSL stream.     ]  ]  [    [[link beast.ref.boost__beast__ssl_stream.next_layer_type [*next_layer_type]]]    [      The type of the next layer.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__ssl_stream.async_handshake [*async_handshake]]]    [      Start an asynchronous SSL handshake.     ]  ]  [    [[link beast.ref.boost__beast__ssl_stream.async_read_some [*async_read_some]]]    [      Start an asynchronous read.     ]  ]  [    [[link beast.ref.boost__beast__ssl_stream.async_shutdown [*async_shutdown]]]    [      Asynchronously shut down SSL on the stream.     ]  ]  [    [[link beast.ref.boost__beast__ssl_stream.async_write_some [*async_write_some]]]    [      Start an asynchronous write.     ]  ]  [    [[link beast.ref.boost__beast__ssl_stream.get_executor [*get_executor]]]    [      Get the executor associated with the object.     ]  ]  [    [[link beast.ref.boost__beast__ssl_stream.handshake [*handshake]]]    [      Perform SSL handshaking.     ]  ]  [    [[link beast.ref.boost__beast__ssl_stream.native_handle [*native_handle]]]    [      Get the underlying implementation in the native type.     ]  ]  [    [[link beast.ref.boost__beast__ssl_stream.next_layer [*next_layer]]]    [      Get a reference to the next layer.     ]  ]  [    [[link beast.ref.boost__beast__ssl_stream.read_some [*read_some]]]    [      Read some data from the stream.     ]  ]  [    [[link beast.ref.boost__beast__ssl_stream.set_verify_callback [*set_verify_callback]]]    [      Set the callback used to verify peer certificates.     ]  ]  [    [[link beast.ref.boost__beast__ssl_stream.set_verify_depth [*set_verify_depth]]]    [      Set the peer verification depth.     ]  ]  [    [[link beast.ref.boost__beast__ssl_stream.set_verify_mode [*set_verify_mode]]]    [      Set the peer verification mode.     ]  ]  [    [[link beast.ref.boost__beast__ssl_stream.shutdown [*shutdown]]]    [      Shut down SSL on the stream.     ]  ]  [    [[link beast.ref.boost__beast__ssl_stream.ssl_stream [*ssl_stream]]]    [      Construct a stream.     ]  ]  [    [[link beast.ref.boost__beast__ssl_stream.write_some [*write_some]]]    [      Write some data to the stream.     ]  ]][heading Description]
The stream class template provides asynchronous and blocking stream-oriented functionality using SSL.
[heading Thread Safety]
['Distinct] ['objects:] Safe.['Shared] ['objects:] Unsafe. The application must also ensure that all asynchronous operations are performed within the same implicit or explicit strand.
[heading Example]
To use this template with a [link beast.ref.boost__beast__tcp_stream `tcp_stream`], you would write: ```  net::io_context ioc;
  net::ssl::context ctx{net::ssl::context::tlsv12};
  beast::ssl_stream<beast::tcp_stream> sock{ioc, ctx};
```
In addition to providing an interface identical to `net::ssl::stream`, the wrapper has the following additional properties:

* Satisfies [*MoveConstructible] 


* Satisfies [*MoveAssignable] 


* Constructible from a moved socket.


* Uses [link beast.ref.boost__beast__flat_stream `flat_stream`] internally, as a performance work-around for a limitation of `net::ssl::stream` when writing buffer sequences having length greater than one.


[section:async_handshake ssl_stream::async_handshake][indexterm2 async_handshake..ssl_stream]
Start an asynchronous SSL handshake. ```template<    class HandshakeHandler>``__deduced__````[link beast.ref.boost__beast__ssl_stream.async_handshake.overload1 async_handshake]``(    handshake_type type,    BOOST_ASIO_MOVE_ARG(HandshakeHandler) handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__ssl_stream.async_handshake.overload1 more...]]``template<    class __ConstBufferSequence__,    class BufferedHandshakeHandler>``__deduced__````[link beast.ref.boost__beast__ssl_stream.async_handshake.overload2 async_handshake]``(    handshake_type type,    ConstBufferSequence const& buffers,    BOOST_ASIO_MOVE_ARG(BufferedHandshakeHandler) handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__ssl_stream.async_handshake.overload2 more...]]`````[section:overload1 ssl_stream::async_handshake (1 of 2 overloads)]
Start an asynchronous SSL handshake. [heading Synopsis]```template<    class HandshakeHandler>``__deduced__``async_handshake(    handshake_type type,    BOOST_ASIO_MOVE_ARG(HandshakeHandler) handler);```[heading Description]
This function is used to asynchronously perform an SSL handshake on the stream. This function call always returns immediately.
[heading Parameters][table [[Name][Description]]  [[`type`][    
The type of handshaking to be performed, i.e. as a client or as a server.  ]]  [[`handler`][    
The handler to be called when the handshake operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: ```   void handler(
    const boost::system::error_code& error // Result of operation.
  ); 
```  ]]]
[endsect][section:overload2 ssl_stream::async_handshake (2 of 2 overloads)]
Start an asynchronous SSL handshake. [heading Synopsis]```template<    class __ConstBufferSequence__,    class BufferedHandshakeHandler>``__deduced__``async_handshake(    handshake_type type,    ConstBufferSequence const& buffers,    BOOST_ASIO_MOVE_ARG(BufferedHandshakeHandler) handler);```[heading Description]
This function is used to asynchronously perform an SSL handshake on the stream. This function call always returns immediately.
[heading Parameters][table [[Name][Description]]  [[`type`][    
The type of handshaking to be performed, i.e. as a client or as a server.  ]]  [[`buffers`][    
The buffered data to be reused for the handshake. Although the buffers object may be copied as necessary, ownership of the underlying buffers is retained by the caller, which must guarantee that they remain valid until the handler is called.  ]]  [[`handler`][    
The handler to be called when the handshake operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: ```   void handler(
    const boost::system::error_code& error, // Result of operation.
    std::size_t bytes_transferred // Amount of buffers used in handshake.
  ); 
```  ]]]
[endsect][endsect][section:async_read_some ssl_stream::async_read_some][indexterm2 async_read_some..ssl_stream]
Start an asynchronous read. [heading Synopsis]```template<    class __MutableBufferSequence__,    class __ReadHandler__>``__deduced__``async_read_some(    MutableBufferSequence const& buffers,    BOOST_ASIO_MOVE_ARG(ReadHandler) handler);```[heading Description]
This function is used to asynchronously read one or more bytes of data from the stream. The function call always returns immediately.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The buffers into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying buffers is retained by the caller, which must guarantee that they remain valid until the handler is called.  ]]  [[`handler`][    
The handler to be called when the read operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: ```   void handler(
    const boost::system::error_code& error, // Result of operation.
    std::size_t bytes_transferred           // Number of bytes read.
  ); 
```  ]]]
[heading Remarks]
The `async_read_some` operation may not read all of the requested number of bytes. Consider using the `net::async_read` function if you need to ensure that the requested amount of data is read before the asynchronous operation completes. 
[endsect][section:async_shutdown ssl_stream::async_shutdown][indexterm2 async_shutdown..ssl_stream]
Asynchronously shut down SSL on the stream. [heading Synopsis]```template<    class ShutdownHandler>``__deduced__``async_shutdown(    BOOST_ASIO_MOVE_ARG(ShutdownHandler) handler);```[heading Description]
This function is used to asynchronously shut down SSL on the stream. This function call always returns immediately.
[heading Parameters][table [[Name][Description]]  [[`handler`][    
The handler to be called when the handshake operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: ```   void handler(
    const boost::system::error_code& error // Result of operation.
  ); 
```  ]]]
[endsect][section:async_write_some ssl_stream::async_write_some][indexterm2 async_write_some..ssl_stream]
Start an asynchronous write. [heading Synopsis]```template<    class __ConstBufferSequence__,    class __WriteHandler__>``__deduced__``async_write_some(    ConstBufferSequence const& buffers,    BOOST_ASIO_MOVE_ARG(WriteHandler) handler);```[heading Description]
This function is used to asynchronously write one or more bytes of data to the stream. The function call always returns immediately.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The data to be written to the stream. Although the buffers object may be copied as necessary, ownership of the underlying buffers is retained by the caller, which must guarantee that they remain valid until the handler is called.  ]]  [[`handler`][    
The handler to be called when the write operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: ```   void handler(
    const boost::system::error_code& error, // Result of operation.
    std::size_t bytes_transferred           // Number of bytes written.
  ); 
```  ]]]
[heading Remarks]
The `async_write_some` operation may not transmit all of the data to the peer. Consider using the `net::async_write` function if you need to ensure that all data is written before the asynchronous operation completes. 
[endsect][section:executor_type ssl_stream::executor_type][indexterm2 executor_type..ssl_stream]
The type of the executor associated with the object. [heading Synopsis]```using executor_type = typename stream_type::executor_type;```[heading Description][endsect][section:get_executor ssl_stream::get_executor][indexterm2 get_executor..ssl_stream]
Get the executor associated with the object. [heading Synopsis]```executor_typeget_executor();```[heading Description]
This function may be used to obtain the executor object that the stream uses to dispatch handlers for asynchronous operations.
[heading Return Value]
A copy of the executor that stream will use to dispatch handlers. 
[endsect][section:handshake ssl_stream::handshake][indexterm2 handshake..ssl_stream]
Perform SSL handshaking. ```void``[link beast.ref.boost__beast__ssl_stream.handshake.overload1 handshake]``(    handshake_type type);  ``[''''&raquo;''' [link beast.ref.boost__beast__ssl_stream.handshake.overload1 more...]]``void``[link beast.ref.boost__beast__ssl_stream.handshake.overload2 handshake]``(    handshake_type type,    boost::system::error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__ssl_stream.handshake.overload2 more...]]``template<    class __ConstBufferSequence__>void``[link beast.ref.boost__beast__ssl_stream.handshake.overload3 handshake]``(    handshake_type type,    ConstBufferSequence const& buffers);  ``[''''&raquo;''' [link beast.ref.boost__beast__ssl_stream.handshake.overload3 more...]]``template<    class __ConstBufferSequence__>void``[link beast.ref.boost__beast__ssl_stream.handshake.overload4 handshake]``(    handshake_type type,    ConstBufferSequence const& buffers,    boost::system::error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__ssl_stream.handshake.overload4 more...]]`````[section:overload1 ssl_stream::handshake (1 of 4 overloads)]
Perform SSL handshaking. [heading Synopsis]```voidhandshake(    handshake_type type);```[heading Description]
This function is used to perform SSL handshaking on the stream. The function call will block until handshaking is complete or an error occurs.
[heading Parameters][table [[Name][Description]]  [[`type`][    
The type of handshaking to be performed, i.e. as a client or as a server.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`boost::system::system_error`][    
Thrown on failure.   ]]]
[endsect][section:overload2 ssl_stream::handshake (2 of 4 overloads)]
Perform SSL handshaking. [heading Synopsis]```voidhandshake(    handshake_type type,    boost::system::error_code& ec);```[heading Description]
This function is used to perform SSL handshaking on the stream. The function call will block until handshaking is complete or an error occurs.
[heading Parameters][table [[Name][Description]]  [[`type`][    
The type of handshaking to be performed, i.e. as a client or as a server.  ]]  [[`ec`][    
Set to indicate what error occurred, if any.   ]]]
[endsect][section:overload3 ssl_stream::handshake (3 of 4 overloads)]
Perform SSL handshaking. [heading Synopsis]```template<    class __ConstBufferSequence__>voidhandshake(    handshake_type type,    ConstBufferSequence const& buffers);```[heading Description]
This function is used to perform SSL handshaking on the stream. The function call will block until handshaking is complete or an error occurs.
[heading Parameters][table [[Name][Description]]  [[`type`][    
The type of handshaking to be performed, i.e. as a client or as a server.  ]]  [[`buffers`][    
The buffered data to be reused for the handshake.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`boost::system::system_error`][    
Thrown on failure.   ]]]
[endsect][section:overload4 ssl_stream::handshake (4 of 4 overloads)]
Perform SSL handshaking. [heading Synopsis]```template<    class __ConstBufferSequence__>voidhandshake(    handshake_type type,    ConstBufferSequence const& buffers,    boost::system::error_code& ec);```[heading Description]
This function is used to perform SSL handshaking on the stream. The function call will block until handshaking is complete or an error occurs.
[heading Parameters][table [[Name][Description]]  [[`type`][    
The type of handshaking to be performed, i.e. as a client or as a server.  ]]  [[`buffers`][    
The buffered data to be reused for the handshake.  ]]  [[`ec`][    
Set to indicate what error occurred, if any.   ]]]
[endsect][endsect][section:impl_struct ssl_stream::impl_struct][indexterm2 impl_struct..ssl_stream]
Structure for use with deprecated impl\_type. [heading Synopsis]```using impl_struct = typename ssl_stream_type::impl_struct;```[heading Description][endsect][section:native_handle ssl_stream::native_handle][indexterm2 native_handle..ssl_stream]
Get the underlying implementation in the native type. [heading Synopsis]```native_handle_typenative_handle();```[heading Description]
This function may be used to obtain the underlying implementation of the context. This is intended to allow access to context functionality that is not otherwise provided.
[heading Example]
The [link beast.ref.boost__beast__ssl_stream.native_handle `ssl_stream::native_handle()`] function returns a pointer of type `SSL*` that is suitable for passing to functions such as `SSL_get_verify_result` and `SSL_get_peer_certificate:` ```  boost::beast::ssl_stream<net::ip::tcp::socket> ss{ioc, ctx};

  // ... establish connection and perform handshake ...

  if (X509* cert = SSL_get_peer_certificate(ss.native_handle()))
  {
    if (SSL_get_verify_result(ss.native_handle()) == X509_V_OK)
    {
      // ...
    }
  }
```
[endsect][section:native_handle_type ssl_stream::native_handle_type][indexterm2 native_handle_type..ssl_stream]
The native handle type of the SSL stream. [heading Synopsis]```using native_handle_type = typename ssl_stream_type::native_handle_type;```[heading Description][endsect][section:next_layer ssl_stream::next_layer][indexterm2 next_layer..ssl_stream]
Get a reference to the next layer. ```next_layer_type const &``[link beast.ref.boost__beast__ssl_stream.next_layer.overload1 next_layer]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__ssl_stream.next_layer.overload1 more...]]``next_layer_type&``[link beast.ref.boost__beast__ssl_stream.next_layer.overload2 next_layer]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__ssl_stream.next_layer.overload2 more...]]`````[section:overload1 ssl_stream::next_layer (1 of 2 overloads)]
Get a reference to the next layer. [heading Synopsis]```next_layer_type const &next_layer() const;```[heading Description]
This function returns a reference to the next layer in a stack of stream layers.
[heading Remarks]
The next layer is the wrapped stream and not the [link beast.ref.boost__beast__flat_stream `flat_stream`] used in the implementation.
[heading Return Value]
A reference to the next layer in the stack of stream layers. Ownership is not transferred to the caller. 
[endsect][section:overload2 ssl_stream::next_layer (2 of 2 overloads)]
Get a reference to the next layer. [heading Synopsis]```next_layer_type&next_layer();```[heading Description]
This function returns a reference to the next layer in a stack of stream layers.
[heading Remarks]
The next layer is the wrapped stream and not the [link beast.ref.boost__beast__flat_stream `flat_stream`] used in the implementation.
[heading Return Value]
A reference to the next layer in the stack of stream layers. Ownership is not transferred to the caller. 
[endsect][endsect][section:next_layer_type ssl_stream::next_layer_type][indexterm2 next_layer_type..ssl_stream]
The type of the next layer. [heading Synopsis]```using next_layer_type = typename ssl_stream_type::next_layer_type;```[heading Description][endsect][section:read_some ssl_stream::read_some][indexterm2 read_some..ssl_stream]
Read some data from the stream. ```template<    class __MutableBufferSequence__>std::size_t``[link beast.ref.boost__beast__ssl_stream.read_some.overload1 read_some]``(    MutableBufferSequence const& buffers);  ``[''''&raquo;''' [link beast.ref.boost__beast__ssl_stream.read_some.overload1 more...]]``template<    class __MutableBufferSequence__>std::size_t``[link beast.ref.boost__beast__ssl_stream.read_some.overload2 read_some]``(    MutableBufferSequence const& buffers,    boost::system::error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__ssl_stream.read_some.overload2 more...]]`````[section:overload1 ssl_stream::read_some (1 of 2 overloads)]
Read some data from the stream. [heading Synopsis]```template<    class __MutableBufferSequence__>std::size_tread_some(    MutableBufferSequence const& buffers);```[heading Description]
This function is used to read data from the stream. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The buffers into which the data will be read.  ]]]
[heading Return Value]
The number of bytes read.
[heading Exceptions][table [[Type][Thrown On]]  [[`boost::system::system_error`][    
Thrown on failure.  ]]]
[heading Remarks]
The `read_some` operation may not read all of the requested number of bytes. Consider using the `net::read` function if you need to ensure that the requested amount of data is read before the blocking operation completes. 
[endsect][section:overload2 ssl_stream::read_some (2 of 2 overloads)]
Read some data from the stream. [heading Synopsis]```template<    class __MutableBufferSequence__>std::size_tread_some(    MutableBufferSequence const& buffers,    boost::system::error_code& ec);```[heading Description]
This function is used to read data from the stream. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The buffers into which the data will be read.  ]]  [[`ec`][    
Set to indicate what error occurred, if any.  ]]]
[heading Return Value]
The number of bytes read. Returns 0 if an error occurred.
[heading Remarks]
The `read_some` operation may not read all of the requested number of bytes. Consider using the `net::read` function if you need to ensure that the requested amount of data is read before the blocking operation completes. 
[endsect][endsect][section:set_verify_callback ssl_stream::set_verify_callback][indexterm2 set_verify_callback..ssl_stream]
Set the callback used to verify peer certificates. ```template<    class VerifyCallback>void``[link beast.ref.boost__beast__ssl_stream.set_verify_callback.overload1 set_verify_callback]``(    VerifyCallback callback);  ``[''''&raquo;''' [link beast.ref.boost__beast__ssl_stream.set_verify_callback.overload1 more...]]``template<    class VerifyCallback>void``[link beast.ref.boost__beast__ssl_stream.set_verify_callback.overload2 set_verify_callback]``(    VerifyCallback callback,    boost::system::error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__ssl_stream.set_verify_callback.overload2 more...]]`````[section:overload1 ssl_stream::set_verify_callback (1 of 2 overloads)]
Set the callback used to verify peer certificates. [heading Synopsis]```template<    class VerifyCallback>voidset_verify_callback(    VerifyCallback callback);```[heading Description]
This function is used to specify a callback function that will be called by the implementation when it needs to verify a peer certificate.
[heading Parameters][table [[Name][Description]]  [[`callback`][    
The function object to be used for verifying a certificate. The function signature of the handler must be: ```   bool verify_callback(
    bool preverified, // True if the certificate passed pre-verification.
    verify_context& ctx // The peer certificate and other context.
  ); 
```The return value of the callback is true if the certificate has passed verification, false otherwise.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`boost::system::system_error`][    
Thrown on failure.  ]]]
[heading Remarks]
Calls `SSL_set_verify`. 
[endsect][section:overload2 ssl_stream::set_verify_callback (2 of 2 overloads)]
Set the callback used to verify peer certificates. [heading Synopsis]```template<    class VerifyCallback>voidset_verify_callback(    VerifyCallback callback,    boost::system::error_code& ec);```[heading Description]
This function is used to specify a callback function that will be called by the implementation when it needs to verify a peer certificate.
[heading Parameters][table [[Name][Description]]  [[`callback`][    
The function object to be used for verifying a certificate. The function signature of the handler must be: ```   bool verify_callback(
    bool preverified, // True if the certificate passed pre-verification.
    net::verify_context& ctx // The peer certificate and other context.
  ); 
```The return value of the callback is true if the certificate has passed verification, false otherwise.  ]]  [[`ec`][    
Set to indicate what error occurred, if any.  ]]]
[heading Remarks]
Calls `SSL_set_verify`. 
[endsect][endsect][section:set_verify_depth ssl_stream::set_verify_depth][indexterm2 set_verify_depth..ssl_stream]
Set the peer verification depth. ```void``[link beast.ref.boost__beast__ssl_stream.set_verify_depth.overload1 set_verify_depth]``(    int depth);  ``[''''&raquo;''' [link beast.ref.boost__beast__ssl_stream.set_verify_depth.overload1 more...]]``void``[link beast.ref.boost__beast__ssl_stream.set_verify_depth.overload2 set_verify_depth]``(    int depth,    boost::system::error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__ssl_stream.set_verify_depth.overload2 more...]]`````[section:overload1 ssl_stream::set_verify_depth (1 of 2 overloads)]
Set the peer verification depth. [heading Synopsis]```voidset_verify_depth(    int depth);```[heading Description]
This function may be used to configure the maximum verification depth allowed by the stream.
[heading Parameters][table [[Name][Description]]  [[`depth`][    
Maximum depth for the certificate chain verification that shall be allowed.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`boost::system::system_error`][    
Thrown on failure.  ]]]
[heading Remarks]
Calls `SSL_set_verify_depth`. 
[endsect][section:overload2 ssl_stream::set_verify_depth (2 of 2 overloads)]
Set the peer verification depth. [heading Synopsis]```voidset_verify_depth(    int depth,    boost::system::error_code& ec);```[heading Description]
This function may be used to configure the maximum verification depth allowed by the stream.
[heading Parameters][table [[Name][Description]]  [[`depth`][    
Maximum depth for the certificate chain verification that shall be allowed.  ]]  [[`ec`][    
Set to indicate what error occurred, if any.  ]]]
[heading Remarks]
Calls `SSL_set_verify_depth`. 
[endsect][endsect][section:set_verify_mode ssl_stream::set_verify_mode][indexterm2 set_verify_mode..ssl_stream]
Set the peer verification mode. ```void``[link beast.ref.boost__beast__ssl_stream.set_verify_mode.overload1 set_verify_mode]``(    net::ssl::verify_mode v);  ``[''''&raquo;''' [link beast.ref.boost__beast__ssl_stream.set_verify_mode.overload1 more...]]``void``[link beast.ref.boost__beast__ssl_stream.set_verify_mode.overload2 set_verify_mode]``(    net::ssl::verify_mode v,    boost::system::error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__ssl_stream.set_verify_mode.overload2 more...]]`````[section:overload1 ssl_stream::set_verify_mode (1 of 2 overloads)]
Set the peer verification mode. [heading Synopsis]```voidset_verify_mode(    net::ssl::verify_mode v);```[heading Description]
This function may be used to configure the peer verification mode used by the stream. The new mode will override the mode inherited from the context.
[heading Parameters][table [[Name][Description]]  [[`v`][    
A bitmask of peer verification modes.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`boost::system::system_error`][    
Thrown on failure.  ]]]
[heading Remarks]
Calls `SSL_set_verify`. 
[endsect][section:overload2 ssl_stream::set_verify_mode (2 of 2 overloads)]
Set the peer verification mode. [heading Synopsis]```voidset_verify_mode(    net::ssl::verify_mode v,    boost::system::error_code& ec);```[heading Description]
This function may be used to configure the peer verification mode used by the stream. The new mode will override the mode inherited from the context.
[heading Parameters][table [[Name][Description]]  [[`v`][    
A bitmask of peer verification modes. See `verify_mode` for available values.  ]]  [[`ec`][    
Set to indicate what error occurred, if any.  ]]]
[heading Remarks]
Calls `SSL_set_verify`. 
[endsect][endsect][section:shutdown ssl_stream::shutdown][indexterm2 shutdown..ssl_stream]
Shut down SSL on the stream. ```void``[link beast.ref.boost__beast__ssl_stream.shutdown.overload1 shutdown]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__ssl_stream.shutdown.overload1 more...]]``void``[link beast.ref.boost__beast__ssl_stream.shutdown.overload2 shutdown]``(    boost::system::error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__ssl_stream.shutdown.overload2 more...]]`````[section:overload1 ssl_stream::shutdown (1 of 2 overloads)]
Shut down SSL on the stream. [heading Synopsis]```voidshutdown();```[heading Description]
This function is used to shut down SSL on the stream. The function call will block until SSL has been shut down or an error occurs.
[heading Exceptions][table [[Type][Thrown On]]  [[`boost::system::system_error`][    
Thrown on failure.   ]]]
[endsect][section:overload2 ssl_stream::shutdown (2 of 2 overloads)]
Shut down SSL on the stream. [heading Synopsis]```voidshutdown(    boost::system::error_code& ec);```[heading Description]
This function is used to shut down SSL on the stream. The function call will block until SSL has been shut down or an error occurs.
[heading Parameters][table [[Name][Description]]  [[`ec`][    
Set to indicate what error occurred, if any.   ]]]
[endsect][endsect][section:ssl_stream ssl_stream::ssl_stream][indexterm2 ssl_stream..ssl_stream]
Construct a stream. [heading Synopsis]```template<    class Arg>ssl_stream(    Arg&& arg,    net::ssl::context& ctx);```[heading Description]
This constructor creates a stream and initialises the underlying stream object.
[heading Parameters][table [[Name][Description]]  [[`arg`][    
The argument to be passed to initialise the underlying stream.  ]]  [[`ctx`][    
The SSL context to be used for the stream.   ]]]
[endsect][section:write_some ssl_stream::write_some][indexterm2 write_some..ssl_stream]
Write some data to the stream. ```template<    class __ConstBufferSequence__>std::size_t``[link beast.ref.boost__beast__ssl_stream.write_some.overload1 write_some]``(    ConstBufferSequence const& buffers);  ``[''''&raquo;''' [link beast.ref.boost__beast__ssl_stream.write_some.overload1 more...]]``template<    class __ConstBufferSequence__>std::size_t``[link beast.ref.boost__beast__ssl_stream.write_some.overload2 write_some]``(    ConstBufferSequence const& buffers,    boost::system::error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__ssl_stream.write_some.overload2 more...]]`````[section:overload1 ssl_stream::write_some (1 of 2 overloads)]
Write some data to the stream. [heading Synopsis]```template<    class __ConstBufferSequence__>std::size_twrite_some(    ConstBufferSequence const& buffers);```[heading Description]
This function is used to write data on the stream. The function call will block until one or more bytes of data has been written successfully, or until an error occurs.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The data to be written.  ]]]
[heading Return Value]
The number of bytes written.
[heading Exceptions][table [[Type][Thrown On]]  [[`boost::system::system_error`][    
Thrown on failure.  ]]]
[heading Remarks]
The `write_some` operation may not transmit all of the data to the peer. Consider using the `net::write` function if you need to ensure that all data is written before the blocking operation completes. 
[endsect][section:overload2 ssl_stream::write_some (2 of 2 overloads)]
Write some data to the stream. [heading Synopsis]```template<    class __ConstBufferSequence__>std::size_twrite_some(    ConstBufferSequence const& buffers,    boost::system::error_code& ec);```[heading Description]
This function is used to write data on the stream. The function call will block until one or more bytes of data has been written successfully, or until an error occurs.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The data to be written to the stream.  ]]  [[`ec`][    
Set to indicate what error occurred, if any.  ]]]
[heading Return Value]
The number of bytes written. Returns 0 if an error occurred.
[heading Remarks]
The `write_some` operation may not transmit all of the data to the peer. Consider using the `net::write` function if you need to ensure that all data is written before the blocking operation completes. 
[endsect][endsect]Convenience header [include_file boost/beast/ssl.hpp][endsect][section:boost__beast__stable_async_base stable_async_base]
Base class to provide completion handler boilerplate for composed operations. [heading Synopsis]Defined in header [include_file boost/beast/core/async_base.hpp]```template<    class __Handler__,    class __Executor1__,    class __Allocator__ = std::allocator<void>>class stable_async_base :    public async_base< Handler, Executor1, Allocator >```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__stable_async_base.allocator_type [*allocator_type]]]    [      The type of allocator associated with this object.     ]  ]  [    [[link beast.ref.boost__beast__stable_async_base.executor_type [*executor_type]]]    [      The type of executor associated with this object.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__stable_async_base.complete [*complete]]]    [      Invoke the final completion handler, maybe using post.     ]  ]  [    [[link beast.ref.boost__beast__stable_async_base.complete_now [*complete_now]]]    [      Invoke the final completion handler.     ]  ]  [    [[link beast.ref.boost__beast__stable_async_base.get_allocator [*get_allocator]]]    [      Returns the allocator associated with this object.     ]  ]  [    [[link beast.ref.boost__beast__stable_async_base.get_executor [*get_executor]]]    [      Returns the executor associated with this object.     ]  ]  [    [[link beast.ref.boost__beast__stable_async_base.handler [*handler]]]    [      Returns the handler associated with this object.     ]  ]  [    [[link beast.ref.boost__beast__stable_async_base.release_handler [*release_handler]]]    [      Returns ownership of the handler associated with this object.     ]  ]  [    [[link beast.ref.boost__beast__stable_async_base.stable_async_base [*stable_async_base]]]    [      Constructor.       Move Constructor.     ]  ]  [    [[link beast.ref.boost__beast__stable_async_base.stable_async_base_dtor_ [*~stable_async_base]]]    [      Destructor.     ]  ]][heading Friends][table [[Name][Description]]  [    [[link beast.ref.boost__beast__stable_async_base.allocate_stable [*allocate_stable]]]    [      Allocate a temporary object to hold operation state.     ]  ]][heading Description]
A function object submitted to intermediate initiating functions during a composed operation may derive from this type to inherit all of the boilerplate to forward the executor, allocator, and legacy customization points associated with the completion handler invoked at the end of the composed operation.
The composed operation must be typical; that is, associated with one executor of an I/O object, and invoking a caller-provided completion handler when the operation is finished. Classes derived from [link beast.ref.boost__beast__async_base `async_base`] will acquire these properties:

* Ownership of the final completion handler provided upon construction.


* If the final handler has an associated allocator, this allocator will be propagated to the composed operation subclass. Otherwise, the associated allocator will be the type specified in the allocator template parameter, or the default of `std::allocator<void>` if the parameter is omitted.


* If the final handler has an associated executor, then it will be used as the executor associated with the composed operation. Otherwise, the specified `Executor1` will be the type of executor associated with the composed operation.


* An instance of `net::executor_work_guard` for the instance of `Executor1` shall be maintained until either the final handler is invoked, or the operation base is destroyed, whichever comes first.


* Calls to the legacy customization points `asio_handler_invoke`, `asio_handler_allocate`, `asio_handler_deallocate`, and `asio_handler_is_continuation`, which use argument-dependent lookup, will be forwarded to the legacy customization points associated with the handler.

Data members of composed operations implemented as completion handlers do not have stable addresses, as the composed operation object is move constructed upon each call to an initiating function. For most operations this is not a problem. For complex operations requiring stable temporary storage, the class [link beast.ref.boost__beast__stable_async_base `stable_async_base`] is provided which offers additional functionality:

* The free function [link beast.ref.boost__beast__allocate_stable `allocate_stable`] may be used to allocate one or more temporary objects associated with the composed operation.


* Memory for stable temporary objects is allocated using the allocator associated with the composed operation.


* Stable temporary objects are automatically destroyed, and the memory freed using the associated allocator, either before the final completion handler is invoked (a Networking requirement) or when the composed operation is destroyed, whichever occurs first.

[heading Example]

The following code demonstrates how [link beast.ref.boost__beast__stable_async_base `stable_async_base`] may be be used to assist authoring an asynchronous initiating function, by providing all of the boilerplate to manage the final completion handler in a way that maintains the allocator and executor associations. Furthermore, the operation shown allocates temporary memory using [link beast.ref.boost__beast__allocate_stable `allocate_stable`] for the timer and message, whose addresses must not change between intermediate operations:
```  // Asynchronously send a message multiple times, once per second
  template <class AsyncWriteStream, class T, class WriteHandler>
  auto async_write_messages(
      AsyncWriteStream& stream,
      T const& message,
      std::size_t repeat_count,
      WriteHandler&& handler) ->
          typename net::async_result<
              typename std::decay<WriteHandler>::type,
              void(error_code)>::return_type
  {
      using handler_type = typename net::async_completion<WriteHandler, void(error_code)>::completion_handler_type;
      using base_type = stable_async_base<handler_type, typename AsyncWriteStream::executor_type>;

      struct op : base_type, boost::asio::coroutine
      {
          // This object must have a stable address
          struct temporary_data
          {
              // Although std::string is in theory movable, most implementations
              // use a "small buffer optimization" which means that we might
              // be submitting a buffer to the write operation and then
              // moving the string, invalidating the buffer. To prevent
              // undefined behavior we store the string object itself at
              // a stable location.
              std::string const message;

              net::steady_timer timer;

              temporary_data(std::string message_, net::io_context& ctx)
                  : message(std::move(message_))
                  , timer(ctx)
              {
              }
          };

          AsyncWriteStream& stream_;
          std::size_t repeats_;
          temporary_data& data_;

          op(AsyncWriteStream& stream, std::size_t repeats, std::string message, handler_type& handler)
              : base_type(std::move(handler), stream.get_executor())
              , stream_(stream)
              , repeats_(repeats)
              , data_(allocate_stable<temporary_data>(*this, std::move(message), stream.get_executor().context()))
          {
              (*this)(); // start the operation
          }

          // Including this file provides the keywords for macro-based coroutines
          #include <boost/asio/yield.hpp>

          void operator()(error_code ec = {}, std::size_t = 0)
          {
              reenter(*this)
              {
                  // If repeats starts at 0 then we must complete immediately. But
                  // we can't call the final handler from inside the initiating
                  // function, so we post our intermediate handler first. We use
                  // net::async_write with an empty buffer instead of calling
                  // net::post to avoid an extra function template instantiation, to
                  // keep compile times lower and make the resulting executable smaller.
                  yield net::async_write(stream_, net::const_buffer{}, std::move(*this));
                  while(! ec && repeats_-- > 0)
                  {
                      // Send the string. We construct a `const_buffer` here to guarantee
                      // that we do not create an additional function template instantation
                      // of net::async_write, since we already instantiated it above for
                      // net::const_buffer.

                      yield net::async_write(stream_,
                          net::const_buffer(net::buffer(data_.message)), std::move(*this));
                      if(ec)
                          break;

                      // Set the timer and wait
                      data_.timer.expires_after(std::chrono::seconds(1));
                      yield data_.timer.async_wait(std::move(*this));
                  }
              }

              // The base class destroys the temporary data automatically,
              // before invoking the final completion handler
              this->complete_now(ec);
          }

          // Including this file undefines the macros for the coroutines
          #include <boost/asio/unyield.hpp>
      };

      net::async_completion<WriteHandler, void(error_code)> completion(handler);
      std::ostringstream os;
      os << message;
      op(stream, repeat_count, os.str(), completion.completion_handler);
      return completion.result.get();
  }
```
[heading Template Parameters][table [[Type][Description]]  [[`Handler`][    
The type of the completion handler to store. This type must meet the requirements of ['CompletionHandler].  ]]  [[`Executor1`][    
The type of the executor used when the handler has no associated executor. An instance of this type must be provided upon construction. The implementation will maintain an executor work guard and a copy of this instance.  ]]  [[`Allocator`][    
The allocator type to use if the handler does not have an associated allocator. If this parameter is omitted, then `std::allocator<void>` will be used. If the specified allocator is not default constructible, an instance of the type must be provided upon construction.  ]]]
[heading See Also]
[link beast.ref.boost__beast__stable_async_base.allocate_stable `stable_async_base::allocate_stable`], [link beast.ref.boost__beast__async_base `async_base`] 
[section:allocate_stable stable_async_base::allocate_stable][indexterm2 allocate_stable..stable_async_base]
Allocate a temporary object to hold operation state. [heading Synopsis]Defined in header [include_file boost/beast/core/async_base.hpp]```template<    class State,    class __Handler__,    class Executor1_,    class Allocator_,    class... Args>friend State&allocate_stable(    stable_async_base< Handler_, Executor1_, Allocator_ >& base,    Args&&... args);```[heading Description]
The object will be destroyed just before the completion handler is invoked, or when the operation base is destroyed. Convenience header [include_file boost/beast/core.hpp][endsect][section:allocator_type stable_async_base::allocator_type](Inherited from `async_base`)[indexterm2 allocator_type..stable_async_base]
The type of allocator associated with this object. [heading Synopsis]```using allocator_type = net::associated_allocator_t< Handler, Allocator >;```[heading Description]
If a class derived from [link beast.ref.boost__beast__async_base `async_base`] is a completion handler, then the associated allocator of the derived class will be this type. [endsect][section:complete stable_async_base::complete](Inherited from `async_base`)[indexterm2 complete..stable_async_base]
Invoke the final completion handler, maybe using post. [heading Synopsis]```template<    class... Args>voidcomplete(    bool is_continuation,    Args&&... args);```[heading Description]
This invokes the final completion handler with the specified arguments forwarded. It is undefined to call either of [link beast.ref.boost__beast__async_base.complete `async_base::complete`] or [link beast.ref.boost__beast__async_base.complete_now `async_base::complete_now`] more than once.
Any temporary objects allocated with [link beast.ref.boost__beast__allocate_stable `allocate_stable`] will be automatically destroyed before the final completion handler is invoked.
[heading Parameters][table [[Name][Description]]  [[`is_continuation`][    
If this value is `false`, then the handler will be submitted to the executor using `net::post`. Otherwise the handler will be invoked as if by calling [link beast.ref.boost__beast__async_base.complete_now `async_base::complete_now`].  ]]  [[`args`][    
A list of optional parameters to invoke the handler with. The completion handler must be invocable with the parameter list, or else a compilation error will result.   ]]]
[endsect][section:complete_now stable_async_base::complete_now](Inherited from `async_base`)[indexterm2 complete_now..stable_async_base]
Invoke the final completion handler. [heading Synopsis]```template<    class... Args>voidcomplete_now(    Args&&... args);```[heading Description]
This invokes the final completion handler with the specified arguments forwarded. It is undefined to call either of [link beast.ref.boost__beast__async_base.complete `async_base::complete`] or [link beast.ref.boost__beast__async_base.complete_now `async_base::complete_now`] more than once.
Any temporary objects allocated with [link beast.ref.boost__beast__allocate_stable `allocate_stable`] will be automatically destroyed before the final completion handler is invoked.
[heading Parameters][table [[Name][Description]]  [[`args`][    
A list of optional parameters to invoke the handler with. The completion handler must be invocable with the parameter list, or else a compilation error will result.   ]]]
[endsect][section:executor_type stable_async_base::executor_type](Inherited from `async_base`)[indexterm2 executor_type..stable_async_base]
The type of executor associated with this object. [heading Synopsis]```using executor_type = net::associated_executor_t< Handler, Executor1 >;```[heading Description]
If a class derived from [link beast.ref.boost__beast__async_base `async_base`] is a completion handler, then the associated executor of the derived class will be this type. [endsect][section:get_allocator stable_async_base::get_allocator](Inherited from `async_base`)[indexterm2 get_allocator..stable_async_base]
Returns the allocator associated with this object. [heading Synopsis]```allocator_typeget_allocator() const;```[heading Description]
If a class derived from [link beast.ref.boost__beast__async_base `async_base`] is a completion handler, then the object returned from this function will be used as the associated allocator of the derived class. [endsect][section:get_executor stable_async_base::get_executor](Inherited from `async_base`)[indexterm2 get_executor..stable_async_base]
Returns the executor associated with this object. [heading Synopsis]```executor_typeget_executor() const;```[heading Description]
If a class derived from [link beast.ref.boost__beast__async_base `async_base`] is a completion handler, then the object returned from this function will be used as the associated executor of the derived class. [endsect][section:handler stable_async_base::handler](Inherited from `async_base`)[indexterm2 handler..stable_async_base]
Returns the handler associated with this object. [heading Synopsis]```Handler const &handler() const;```[heading Description][endsect][section:release_handler stable_async_base::release_handler](Inherited from `async_base`)[indexterm2 release_handler..stable_async_base]
Returns ownership of the handler associated with this object. [heading Synopsis]```Handlerrelease_handler();```[heading Description]
This function is used to transfer ownership of the handler to the caller, by move-construction. After the move, the only valid operations on the base object are move construction and destruction. [endsect][section:stable_async_base stable_async_base::stable_async_base][indexterm2 stable_async_base..stable_async_base]
Constructor. ```template<    class __Handler__>``[link beast.ref.boost__beast__stable_async_base.stable_async_base.overload1 stable_async_base]``(    Handler&& handler,    Executor1 const& ex1,    Allocator const& alloc = Allocator());  ``[''''&raquo;''' [link beast.ref.boost__beast__stable_async_base.stable_async_base.overload1 more...]]`````
Move Constructor. `````[link beast.ref.boost__beast__stable_async_base.stable_async_base.overload2 stable_async_base]``(    stable_async_base&& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__stable_async_base.stable_async_base.overload2 more...]]`````[section:overload1 stable_async_base::stable_async_base (1 of 2 overloads)]
Constructor. [heading Synopsis]```template<    class __Handler__>stable_async_base(    Handler&& handler,    Executor1 const& ex1,    Allocator const& alloc = Allocator());```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`handler`][    
The final completion handler. The type of this object must meet the requirements of ['CompletionHandler]. The implementation takes ownership of the handler by performing a decay-copy.  ]]  [[`ex1`][    
The executor associated with the implied I/O object target of the operation. The implementation shall maintain an executor work guard for the lifetime of the operation, or until the final completion handler is invoked, whichever is shorter.  ]]  [[`alloc`][    
The allocator to be associated with objects derived from this class. If `Allocator` is default-constructible, this parameter is optional and may be omitted.   ]]]
[endsect][section:overload2 stable_async_base::stable_async_base (2 of 2 overloads)]
Move Constructor. [heading Synopsis]```stable_async_base(    stable_async_base&& other);```[heading Description][endsect][endsect][section:stable_async_base_dtor_ stable_async_base::~stable_async_base][indexterm2 ~stable_async_base..stable_async_base]
Destructor. [heading Synopsis]```~stable_async_base();```[heading Description]
If the completion handler was not invoked, then any state objects allocated with [link beast.ref.boost__beast__stable_async_base.allocate_stable `stable_async_base::allocate_stable`] will be destroyed here. [endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__static_buffer static_buffer]
A dynamic buffer providing a fixed size, circular buffer. [heading Synopsis]Defined in header [include_file boost/beast/core/static_buffer.hpp]```template<    std::size_t N>class static_buffer :    public static_buffer_base```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__static_buffer.const_buffers_type [*const_buffers_type]]]    [      The ConstBufferSequence used to represent the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer.mutable_buffers_type [*mutable_buffers_type]]]    [      The MutableBufferSequence used to represent the writable bytes.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer.mutable_data_type [*mutable_data_type]]]    [      The MutableBufferSequence used to represent the readable bytes.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__static_buffer.base [*base]]]    [      Returns the static_buffer_base portion of this object.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer.capacity [*capacity]]]    [      Return the maximum sum of input and output sizes that can be held without an allocation.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer.cdata [*cdata]]]    [      Returns a constant buffer sequence representing the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer.clear [*clear]]]    [      Clear the readable and writable bytes to zero.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer.commit [*commit]]]    [      Append writable bytes to the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer.consume [*consume]]]    [      Remove bytes from beginning of the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer.data [*data]]]    [      Returns a constant buffer sequence representing the readable bytes.       Returns a mutable buffer sequence representing the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer.max_size [*max_size]]]    [      Return the maximum sum of the input and output sequence sizes.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer.prepare [*prepare]]]    [      Returns a mutable buffer sequence representing writable bytes.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer.size [*size]]]    [      Returns the number of readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer.static_buffer [*static_buffer]]]    [      Constructor.     ]  ]][heading Description]
A dynamic buffer encapsulates memory storage that may be automatically resized as required, where the memory is divided into two regions: readable bytes followed by writable bytes. These memory regions are internal to the dynamic buffer, but direct access to the elements is provided to permit them to be efficiently used with I/O operations.
Objects of this type meet the requirements of ['DynamicBuffer] and have the following additional properties:

* A mutable buffer sequence representing the readable bytes is returned by [link beast.ref.boost__beast__static_buffer.data `static_buffer::data`] when `this` is non-const.


* Buffer sequences representing the readable and writable bytes, returned by [link beast.ref.boost__beast__static_buffer.data `static_buffer::data`] and [link beast.ref.boost__beast__static_buffer.prepare `static_buffer::prepare`], may have length up to two.


* All operations execute in constant time.

[heading Template Parameters][table [[Type][Description]]  [[`N`][    
The number of bytes in the internal buffer.  ]]]
[heading Remarks]
To reduce the number of template instantiations when passing objects of this type in a deduced context, the signature of the receiving function should use [link beast.ref.boost__beast__static_buffer_base `static_buffer_base`] instead.
[heading See Also]
[link beast.ref.boost__beast__static_buffer_base `static_buffer_base`] 
[section:base static_buffer::base][indexterm2 base..static_buffer]
Returns the [link beast.ref.boost__beast__static_buffer_base `static_buffer_base`] portion of this object. ```static_buffer_base&``[link beast.ref.boost__beast__static_buffer.base.overload1 base]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__static_buffer.base.overload1 more...]]``static_buffer_base const &``[link beast.ref.boost__beast__static_buffer.base.overload2 base]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_buffer.base.overload2 more...]]`````[section:overload1 static_buffer::base (1 of 2 overloads)]
Returns the [link beast.ref.boost__beast__static_buffer_base `static_buffer_base`] portion of this object. [heading Synopsis]```static_buffer_base&base();```[heading Description][endsect][section:overload2 static_buffer::base (2 of 2 overloads)]
Returns the [link beast.ref.boost__beast__static_buffer_base `static_buffer_base`] portion of this object. [heading Synopsis]```static_buffer_base const &base() const;```[heading Description][endsect][endsect][section:capacity static_buffer::capacity][indexterm2 capacity..static_buffer]
Return the maximum sum of input and output sizes that can be held without an allocation. [heading Synopsis]```std::size_t constexprcapacity() const;```[heading Description][endsect][section:cdata static_buffer::cdata][indexterm2 cdata..static_buffer]
Returns a constant buffer sequence representing the readable bytes. [heading Synopsis]```const_buffers_typecdata() const;```[heading Description][endsect][section:clear static_buffer::clear][indexterm2 clear..static_buffer]
Clear the readable and writable bytes to zero. [heading Synopsis]```voidclear();```[heading Description]
This function causes the readable and writable bytes to become empty. The capacity is not changed.
Buffer sequences previously obtained using [link beast.ref.boost__beast__static_buffer.data `static_buffer::data`] or [link beast.ref.boost__beast__static_buffer.prepare `static_buffer::prepare`] become invalid.
[heading Exception Safety]

No-throw guarantee. [endsect][section:commit static_buffer::commit][indexterm2 commit..static_buffer]
Append writable bytes to the readable bytes. [heading Synopsis]```voidcommit(    std::size_t n);```[heading Description]
Appends n bytes from the start of the writable bytes to the end of the readable bytes. The remainder of the writable bytes are discarded. If n is greater than the number of writable bytes, all writable bytes are appended to the readable bytes.
All buffers sequences previously obtained using [link beast.ref.boost__beast__static_buffer.data `static_buffer::data`] or [link beast.ref.boost__beast__static_buffer.prepare `static_buffer::prepare`] are invalidated.
[heading Parameters][table [[Name][Description]]  [[`n`][    
The number of bytes to append. If this number is greater than the number of writable bytes, all writable bytes are appended.  ]]]
[heading Exception Safety]

No-throw guarantee. [endsect][section:const_buffers_type static_buffer::const_buffers_type][indexterm2 const_buffers_type..static_buffer]
The ConstBufferSequence used to represent the readable bytes. [heading Synopsis]```using const_buffers_type = ``['implementation-defined]``;```[heading Description][endsect][section:consume static_buffer::consume][indexterm2 consume..static_buffer]
Remove bytes from beginning of the readable bytes. [heading Synopsis]```voidconsume(    std::size_t n);```[heading Description]
Removes n bytes from the beginning of the readable bytes.
All buffers sequences previously obtained using [link beast.ref.boost__beast__static_buffer.data `static_buffer::data`] or [link beast.ref.boost__beast__static_buffer.prepare `static_buffer::prepare`] are invalidated.
[heading Parameters][table [[Name][Description]]  [[`n`][    
The number of bytes to remove. If this number is greater than the number of readable bytes, all readable bytes are removed.  ]]]
[heading Exception Safety]

No-throw guarantee. [endsect][section:data static_buffer::data][indexterm2 data..static_buffer]
Returns a constant buffer sequence representing the readable bytes. ```const_buffers_type``[link beast.ref.boost__beast__static_buffer.data.overload1 data]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_buffer.data.overload1 more...]]`````
Returns a mutable buffer sequence representing the readable bytes. ```mutable_data_type``[link beast.ref.boost__beast__static_buffer.data.overload2 data]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__static_buffer.data.overload2 more...]]`````[section:overload1 static_buffer::data (1 of 2 overloads)]
Returns a constant buffer sequence representing the readable bytes. [heading Synopsis]```const_buffers_typedata() const;```[heading Description][endsect][section:overload2 static_buffer::data (2 of 2 overloads)]
Returns a mutable buffer sequence representing the readable bytes. [heading Synopsis]```mutable_data_typedata();```[heading Description][endsect][endsect][section:max_size static_buffer::max_size][indexterm2 max_size..static_buffer]
Return the maximum sum of the input and output sequence sizes. [heading Synopsis]```std::size_t constexprmax_size() const;```[heading Description][endsect][section:mutable_buffers_type static_buffer::mutable_buffers_type][indexterm2 mutable_buffers_type..static_buffer]
The MutableBufferSequence used to represent the writable bytes. [heading Synopsis]```using mutable_buffers_type = ``['implementation-defined]``;```[heading Description][endsect][section:mutable_data_type static_buffer::mutable_data_type][indexterm2 mutable_data_type..static_buffer]
The MutableBufferSequence used to represent the readable bytes. [heading Synopsis]```using mutable_data_type = ``['implementation-defined]``;```[heading Description][endsect][section:operator_eq_ static_buffer::operator=][indexterm2 operator=..static_buffer]
Assignment. [heading Synopsis]```static_buffer&operator=(    static_buffer const&);```[heading Description][endsect][section:prepare static_buffer::prepare][indexterm2 prepare..static_buffer]
Returns a mutable buffer sequence representing writable bytes. [heading Synopsis]```mutable_buffers_typeprepare(    std::size_t n);```[heading Description]
Returns a mutable buffer sequence representing the writable bytes containing exactly `n` bytes of storage. Memory may be reallocated as needed.
All buffers sequences previously obtained using [link beast.ref.boost__beast__static_buffer.data `static_buffer::data`] or [link beast.ref.boost__beast__static_buffer.prepare `static_buffer::prepare`] are invalidated.
[heading Parameters][table [[Name][Description]]  [[`n`][    
The desired number of bytes in the returned buffer sequence.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::length_error`][    
if `size() + n` exceeds `max_size()`.  ]]]
[heading Exception Safety]

Strong guarantee. [endsect][section:size static_buffer::size][indexterm2 size..static_buffer]
Returns the number of readable bytes. [heading Synopsis]```std::size_tsize() const;```[heading Description][endsect][section:static_buffer static_buffer::static_buffer][indexterm2 static_buffer..static_buffer]
Constructor. `````[link beast.ref.boost__beast__static_buffer.static_buffer.overload1 static_buffer]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__static_buffer.static_buffer.overload1 more...]]````[link beast.ref.boost__beast__static_buffer.static_buffer.overload2 static_buffer]``(    static_buffer const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_buffer.static_buffer.overload2 more...]]`````[section:overload1 static_buffer::static_buffer (1 of 2 overloads)]
Constructor. [heading Synopsis]```static_buffer();```[heading Description][endsect][section:overload2 static_buffer::static_buffer (2 of 2 overloads)]
Constructor. [heading Synopsis]```static_buffer(    static_buffer const&);```[heading Description][endsect][endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__static_buffer_base static_buffer_base]
A dynamic buffer providing a fixed size, circular buffer. [heading Synopsis]Defined in header [include_file boost/beast/core/static_buffer.hpp]```class static_buffer_base```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__static_buffer_base.const_buffers_type [*const_buffers_type]]]    [      The ConstBufferSequence used to represent the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer_base.mutable_buffers_type [*mutable_buffers_type]]]    [      The MutableBufferSequence used to represent the writable bytes.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer_base.mutable_data_type [*mutable_data_type]]]    [      The MutableBufferSequence used to represent the readable bytes.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__static_buffer_base.capacity [*capacity]]]    [      Return the maximum number of bytes, both readable and writable, that can be held without requiring an allocation.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer_base.cdata [*cdata]]]    [      Returns a constant buffer sequence representing the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer_base.clear [*clear]]]    [      Clear the readable and writable bytes to zero.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer_base.commit [*commit]]]    [      Append writable bytes to the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer_base.consume [*consume]]]    [      Remove bytes from beginning of the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer_base.data [*data]]]    [      Returns a constant buffer sequence representing the readable bytes.       Returns a mutable buffer sequence representing the readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer_base.max_size [*max_size]]]    [      Return the maximum number of bytes, both readable and writable, that can ever be held.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer_base.prepare [*prepare]]]    [      Returns a mutable buffer sequence representing writable bytes.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer_base.size [*size]]]    [      Returns the number of readable bytes.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer_base.static_buffer_base [*static_buffer_base]]]    [      Constructor.     ]  ]][heading Description]
A dynamic buffer encapsulates memory storage that may be automatically resized as required, where the memory is divided into two regions: readable bytes followed by writable bytes. These memory regions are internal to the dynamic buffer, but direct access to the elements is provided to permit them to be efficiently used with I/O operations.
Objects of this type meet the requirements of ['DynamicBuffer] and have the following additional properties:

* A mutable buffer sequence representing the readable bytes is returned by [link beast.ref.boost__beast__static_buffer.data `static_buffer::data`] when `this` is non-const.


* Buffer sequences representing the readable and writable bytes, returned by [link beast.ref.boost__beast__static_buffer.data `static_buffer::data`] and [link beast.ref.boost__beast__static_buffer.prepare `static_buffer::prepare`], may have length up to two.


* All operations execute in constant time.


* Ownership of the underlying storage belongs to the derived class.

[heading Remarks]
Variables are usually declared using the template class [link beast.ref.boost__beast__static_buffer `static_buffer`]; however, to reduce the number of template instantiations, objects should be passed `static_buffer_base&`.
[heading See Also]
[link beast.ref.boost__beast__static_buffer `static_buffer`] 
[section:capacity static_buffer_base::capacity][indexterm2 capacity..static_buffer_base]
Return the maximum number of bytes, both readable and writable, that can be held without requiring an allocation. [heading Synopsis]```std::size_tcapacity() const;```[heading Description][endsect][section:cdata static_buffer_base::cdata][indexterm2 cdata..static_buffer_base]
Returns a constant buffer sequence representing the readable bytes. [heading Synopsis]```const_buffers_typecdata() const;```[heading Description][endsect][section:clear static_buffer_base::clear][indexterm2 clear..static_buffer_base]
Clear the readable and writable bytes to zero. [heading Synopsis]```voidclear();```[heading Description]
This function causes the readable and writable bytes to become empty. The capacity is not changed.
Buffer sequences previously obtained using [link beast.ref.boost__beast__static_buffer.data `static_buffer::data`] or [link beast.ref.boost__beast__static_buffer.prepare `static_buffer::prepare`] become invalid.
[heading Exception Safety]

No-throw guarantee. [endsect][section:commit static_buffer_base::commit][indexterm2 commit..static_buffer_base]
Append writable bytes to the readable bytes. [heading Synopsis]```voidcommit(    std::size_t n);```[heading Description]
Appends n bytes from the start of the writable bytes to the end of the readable bytes. The remainder of the writable bytes are discarded. If n is greater than the number of writable bytes, all writable bytes are appended to the readable bytes.
All buffers sequences previously obtained using [link beast.ref.boost__beast__static_buffer.data `static_buffer::data`] or [link beast.ref.boost__beast__static_buffer.prepare `static_buffer::prepare`] are invalidated.
[heading Parameters][table [[Name][Description]]  [[`n`][    
The number of bytes to append. If this number is greater than the number of writable bytes, all writable bytes are appended.  ]]]
[heading Exception Safety]

No-throw guarantee. [endsect][section:const_buffers_type static_buffer_base::const_buffers_type][indexterm2 const_buffers_type..static_buffer_base]
The ConstBufferSequence used to represent the readable bytes. [heading Synopsis]```using const_buffers_type = ``['implementation-defined]``;```[heading Description][endsect][section:consume static_buffer_base::consume][indexterm2 consume..static_buffer_base]
Remove bytes from beginning of the readable bytes. [heading Synopsis]```voidconsume(    std::size_t n);```[heading Description]
Removes n bytes from the beginning of the readable bytes.
All buffers sequences previously obtained using [link beast.ref.boost__beast__static_buffer.data `static_buffer::data`] or [link beast.ref.boost__beast__static_buffer.prepare `static_buffer::prepare`] are invalidated.
[heading Parameters][table [[Name][Description]]  [[`n`][    
The number of bytes to remove. If this number is greater than the number of readable bytes, all readable bytes are removed.  ]]]
[heading Exception Safety]

No-throw guarantee. [endsect][section:data static_buffer_base::data][indexterm2 data..static_buffer_base]
Returns a constant buffer sequence representing the readable bytes. ```const_buffers_type``[link beast.ref.boost__beast__static_buffer_base.data.overload1 data]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_buffer_base.data.overload1 more...]]`````
Returns a mutable buffer sequence representing the readable bytes. ```mutable_data_type``[link beast.ref.boost__beast__static_buffer_base.data.overload2 data]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__static_buffer_base.data.overload2 more...]]`````[section:overload1 static_buffer_base::data (1 of 2 overloads)]
Returns a constant buffer sequence representing the readable bytes. [heading Synopsis]```const_buffers_typedata() const;```[heading Description][endsect][section:overload2 static_buffer_base::data (2 of 2 overloads)]
Returns a mutable buffer sequence representing the readable bytes. [heading Synopsis]```mutable_data_typedata();```[heading Description][endsect][endsect][section:max_size static_buffer_base::max_size][indexterm2 max_size..static_buffer_base]
Return the maximum number of bytes, both readable and writable, that can ever be held. [heading Synopsis]```std::size_tmax_size() const;```[heading Description][endsect][section:mutable_buffers_type static_buffer_base::mutable_buffers_type][indexterm2 mutable_buffers_type..static_buffer_base]
The MutableBufferSequence used to represent the writable bytes. [heading Synopsis]```using mutable_buffers_type = ``['implementation-defined]``;```[heading Description][endsect][section:mutable_data_type static_buffer_base::mutable_data_type][indexterm2 mutable_data_type..static_buffer_base]
The MutableBufferSequence used to represent the readable bytes. [heading Synopsis]```using mutable_data_type = ``['implementation-defined]``;```[heading Description][endsect][section:prepare static_buffer_base::prepare][indexterm2 prepare..static_buffer_base]
Returns a mutable buffer sequence representing writable bytes. [heading Synopsis]```mutable_buffers_typeprepare(    std::size_t n);```[heading Description]
Returns a mutable buffer sequence representing the writable bytes containing exactly `n` bytes of storage. Memory may be reallocated as needed.
All buffers sequences previously obtained using [link beast.ref.boost__beast__static_buffer.data `static_buffer::data`] or [link beast.ref.boost__beast__static_buffer.prepare `static_buffer::prepare`] are invalidated.
[heading Parameters][table [[Name][Description]]  [[`n`][    
The desired number of bytes in the returned buffer sequence.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::length_error`][    
if `size() + n` exceeds `max_size()`.  ]]]
[heading Exception Safety]

Strong guarantee. [endsect][section:size static_buffer_base::size][indexterm2 size..static_buffer_base]
Returns the number of readable bytes. [heading Synopsis]```std::size_tsize() const;```[heading Description][endsect][section:static_buffer_base static_buffer_base::static_buffer_base][indexterm2 static_buffer_base..static_buffer_base]
Constructor. [heading Synopsis]```static_buffer_base(    void* p,    std::size_t size);```[heading Description]
This creates a dynamic buffer using the provided storage area.
[heading Parameters][table [[Name][Description]]  [[`p`][    
A pointer to valid storage of at least `n` bytes.  ]]  [[`size`][    
The number of valid bytes pointed to by `p`.   ]]]
[endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__static_string static_string]
A modifiable string with a fixed-size storage area. [heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT = char,    class Traits = std::char_traits<CharT>>class static_string```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__static_string.const_iterator [*const_iterator]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.const_pointer [*const_pointer]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.const_reference [*const_reference]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.const_reverse_iterator [*const_reverse_iterator]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.difference_type [*difference_type]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.iterator [*iterator]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.pointer [*pointer]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.reference [*reference]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.reverse_iterator [*reverse_iterator]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.size_type [*size_type]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.string_view_type [*string_view_type]]]    [      The type of string_view returned by the interface.     ]  ]  [    [[link beast.ref.boost__beast__static_string.traits_type [*traits_type]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.value_type [*value_type]]]    [          ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__static_string.append [*append]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.assign [*assign]]]    [      Assign count copies of ch.       Assign from another static_string       Assign count characterss starting at npos from other.       Assign the first count characters of s, including nulls.       Assign a null terminated string.       Assign from an iterator range of characters.       Assign from any object convertible to string_view_type.     ]  ]  [    [[link beast.ref.boost__beast__static_string.at [*at]]]    [      Access specified character with bounds checking.     ]  ]  [    [[link beast.ref.boost__beast__static_string.back [*back]]]    [      Accesses the last character.     ]  ]  [    [[link beast.ref.boost__beast__static_string.begin [*begin]]]    [      Returns an iterator to the beginning.     ]  ]  [    [[link beast.ref.boost__beast__static_string.c_str [*c_str]]]    [      Returns a non-modifiable standard C character array version of the string.     ]  ]  [    [[link beast.ref.boost__beast__static_string.capacity [*capacity]]]    [      Returns the number of characters that can be held in currently allocated storage.     ]  ]  [    [[link beast.ref.boost__beast__static_string.cbegin [*cbegin]]]    [      Returns an iterator to the beginning.     ]  ]  [    [[link beast.ref.boost__beast__static_string.cend [*cend]]]    [      Returns an iterator to the end.     ]  ]  [    [[link beast.ref.boost__beast__static_string.clear [*clear]]]    [      Clears the contents.     ]  ]  [    [[link beast.ref.boost__beast__static_string.compare [*compare]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.copy [*copy]]]    [      Copy a substring (pos, pos+count) to character string pointed to by dest.     ]  ]  [    [[link beast.ref.boost__beast__static_string.crbegin [*crbegin]]]    [      Returns a reverse iterator to the beginning.     ]  ]  [    [[link beast.ref.boost__beast__static_string.crend [*crend]]]    [      Returns a reverse iterator to the end.     ]  ]  [    [[link beast.ref.boost__beast__static_string.data [*data]]]    [      Returns a pointer to the first character of a string.     ]  ]  [    [[link beast.ref.boost__beast__static_string.empty [*empty]]]    [      Returns true if the string is empty.     ]  ]  [    [[link beast.ref.boost__beast__static_string.end [*end]]]    [      Returns an iterator to the end.     ]  ]  [    [[link beast.ref.boost__beast__static_string.erase [*erase]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.front [*front]]]    [      Accesses the first character.     ]  ]  [    [[link beast.ref.boost__beast__static_string.insert [*insert]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.length [*length]]]    [      Returns the number of characters, excluding the null terminator.     ]  ]  [    [[link beast.ref.boost__beast__static_string.max_size [*max_size]]]    [      Returns the maximum number of characters that can be stored, excluding the null terminator.     ]  ]  [    [[link beast.ref.boost__beast__static_string.operator_string_view_type [*operator string_view_type]]]    [      Convert a static string to a string_view_type     ]  ]  [    [[link beast.ref.boost__beast__static_string.operator_plus__eq_ [*operator+=]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.operator_eq_ [*operator=]]]    [      Copy assignment.       Assign from null-terminated string.       Assign from single character.       Assign from initializer list.       Assign from string_view_type.     ]  ]  [    [[link beast.ref.boost__beast__static_string.operator_lb__rb_ [*operator\[\]]]]    [      Access specified character.     ]  ]  [    [[link beast.ref.boost__beast__static_string.pop_back [*pop_back]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.push_back [*push_back]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.rbegin [*rbegin]]]    [      Returns a reverse iterator to the beginning.     ]  ]  [    [[link beast.ref.boost__beast__static_string.rend [*rend]]]    [      Returns a reverse iterator to the end.     ]  ]  [    [[link beast.ref.boost__beast__static_string.reserve [*reserve]]]    [      Reserves storage.     ]  ]  [    [[link beast.ref.boost__beast__static_string.resize [*resize]]]    [      Changes the number of characters stored.     ]  ]  [    [[link beast.ref.boost__beast__static_string.shrink_to_fit [*shrink_to_fit]]]    [      Reduces memory usage by freeing unused memory.     ]  ]  [    [[link beast.ref.boost__beast__static_string.size [*size]]]    [      Returns the number of characters, excluding the null terminator.     ]  ]  [    [[link beast.ref.boost__beast__static_string.static_string [*static_string]]]    [      Default constructor (empty string).       Construct with count copies of character ch.       Construct with a substring (pos, other.size()) of other.       Construct with a substring (pos, count) of other.       Construct with the first count characters of s, including nulls.       Construct from a null terminated string.       Construct from a range of characters.       Copy constructor.       Construct from an initializer list.       Construct from a string_view       Construct from any object convertible to string_view_type.     ]  ]  [    [[link beast.ref.boost__beast__static_string.substr [*substr]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.swap [*swap]]]    [      Exchange the contents of this string with another.     ]  ]][heading Data Members][table [[Name][Description]]  [    [[link beast.ref.boost__beast__static_string.max_size_n [*max_size_n]]]    [      Maximum size of the string excluding the null terminator.     ]  ]  [    [[link beast.ref.boost__beast__static_string.npos [*npos]]]    [      A special index.     ]  ]][heading Description]
These objects behave like `std::string` except that the storage is not dynamically allocated but rather fixed in size.
These strings offer performance advantages when a protocol imposes a natural small upper limit on the size of a value.
[heading Remarks]
The stored string is always null-terminated.
[heading See Also]
[link beast.ref.boost__beast__to_static_string `to_static_string`] 
[section:append static_string::append][indexterm2 append..static_string]```static_string&``[link beast.ref.boost__beast__static_string.append.overload1 append]``(    size_type count,    CharT ch);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.append.overload1 more...]]``template<    std::size_t M>static_string&``[link beast.ref.boost__beast__static_string.append.overload2 append]``(    static_string< M, CharT, Traits > const& str);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.append.overload2 more...]]``template<    std::size_t M>static_string&``[link beast.ref.boost__beast__static_string.append.overload3 append]``(    static_string< M, CharT, Traits > const& str,    size_type pos,    size_type count = npos);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.append.overload3 more...]]``static_string&``[link beast.ref.boost__beast__static_string.append.overload4 append]``(    CharT const* s,    size_type count);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.append.overload4 more...]]``static_string&``[link beast.ref.boost__beast__static_string.append.overload5 append]``(    CharT const* s);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.append.overload5 more...]]``template<    class InputIt>static_string&``[link beast.ref.boost__beast__static_string.append.overload6 append]``(    InputIt first,    InputIt last);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.append.overload6 more...]]``static_string&``[link beast.ref.boost__beast__static_string.append.overload7 append]``(    std::initializer_list< CharT > init);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.append.overload7 more...]]``static_string&``[link beast.ref.boost__beast__static_string.append.overload8 append]``(    string_view_type sv);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.append.overload8 more...]]``template<    class T>std::enable_if< std::is_convertible< T const  &, string_view_type >::value &&! std::is_convertible< T const  &, CharT const  * >::value, static_string & >::type``[link beast.ref.boost__beast__static_string.append.overload9 append]``(    T const& t,    size_type pos,    size_type count = npos);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.append.overload9 more...]]`````[section:overload1 static_string::append (1 of 9 overloads)][heading Synopsis]```static_string&append(    size_type count,    CharT ch);```[heading Description][endsect][section:overload2 static_string::append (2 of 9 overloads)][heading Synopsis]```template<    std::size_t M>static_string&append(    static_string< M, CharT, Traits > const& str);```[heading Description][endsect][section:overload3 static_string::append (3 of 9 overloads)][heading Synopsis]```template<    std::size_t M>static_string&append(    static_string< M, CharT, Traits > const& str,    size_type pos,    size_type count = npos);```[heading Description][endsect][section:overload4 static_string::append (4 of 9 overloads)][heading Synopsis]```static_string&append(    CharT const* s,    size_type count);```[heading Description][endsect][section:overload5 static_string::append (5 of 9 overloads)][heading Synopsis]```static_string&append(    CharT const* s);```[heading Description][endsect][section:overload6 static_string::append (6 of 9 overloads)][heading Synopsis]```template<    class InputIt>static_string&append(    InputIt first,    InputIt last);```[heading Description][endsect][section:overload7 static_string::append (7 of 9 overloads)][heading Synopsis]```static_string&append(    std::initializer_list< CharT > init);```[heading Description][endsect][section:overload8 static_string::append (8 of 9 overloads)][heading Synopsis]```static_string&append(    string_view_type sv);```[heading Description][endsect][section:overload9 static_string::append (9 of 9 overloads)][heading Synopsis]```template<    class T>std::enable_if< std::is_convertible< T const  &, string_view_type >::value &&! std::is_convertible< T const  &, CharT const  * >::value, static_string & >::typeappend(    T const& t,    size_type pos,    size_type count = npos);```[heading Description][endsect][endsect][section:assign static_string::assign][indexterm2 assign..static_string]
Assign `count` copies of `ch`. ```static_string&``[link beast.ref.boost__beast__static_string.assign.overload1 assign]``(    size_type count,    CharT ch);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.assign.overload1 more...]]`````
Assign from another `static_string` ```static_string&``[link beast.ref.boost__beast__static_string.assign.overload2 assign]``(    static_string const& str);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.assign.overload2 more...]]``template<    std::size_t M>static_string&``[link beast.ref.boost__beast__static_string.assign.overload3 assign]``(    static_string< M, CharT, Traits > const& str);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.assign.overload3 more...]]`````
Assign `count` characterss starting at `npos` from `other`. ```template<    std::size_t M>static_string&``[link beast.ref.boost__beast__static_string.assign.overload4 assign]``(    static_string< M, CharT, Traits > const& str,    size_type pos,    size_type count = npos);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.assign.overload4 more...]]`````
Assign the first `count` characters of `s`, including nulls. ```static_string&``[link beast.ref.boost__beast__static_string.assign.overload5 assign]``(    CharT const* s,    size_type count);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.assign.overload5 more...]]`````
Assign a null terminated string. ```static_string&``[link beast.ref.boost__beast__static_string.assign.overload6 assign]``(    CharT const* s);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.assign.overload6 more...]]`````
Assign from an iterator range of characters. ```template<    class InputIt>static_string&``[link beast.ref.boost__beast__static_string.assign.overload7 assign]``(    InputIt first,    InputIt last);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.assign.overload7 more...]]``static_string&``[link beast.ref.boost__beast__static_string.assign.overload8 assign]``(    std::initializer_list< CharT > init);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.assign.overload8 more...]]``static_string&``[link beast.ref.boost__beast__static_string.assign.overload9 assign]``(    string_view_type str);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.assign.overload9 more...]]`````
Assign from any object convertible to `string_view_type`. ```template<    class T>static_string&``[link beast.ref.boost__beast__static_string.assign.overload10 assign]``(    T const& t,    size_type pos,    size_type count = npos);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.assign.overload10 more...]]`````[section:overload1 static_string::assign (1 of 10 overloads)]
Assign `count` copies of `ch`. [heading Synopsis]```static_string&assign(    size_type count,    CharT ch);```[heading Description][endsect][section:overload2 static_string::assign (2 of 10 overloads)]
Assign from another `static_string` [heading Synopsis]```static_string&assign(    static_string const& str);```[heading Description][endsect][section:overload3 static_string::assign (3 of 10 overloads)]
Assign from another `static_string` [heading Synopsis]```template<    std::size_t M>static_string&assign(    static_string< M, CharT, Traits > const& str);```[heading Description][endsect][section:overload4 static_string::assign (4 of 10 overloads)]
Assign `count` characterss starting at `npos` from `other`. [heading Synopsis]```template<    std::size_t M>static_string&assign(    static_string< M, CharT, Traits > const& str,    size_type pos,    size_type count = npos);```[heading Description][endsect][section:overload5 static_string::assign (5 of 10 overloads)]
Assign the first `count` characters of `s`, including nulls. [heading Synopsis]```static_string&assign(    CharT const* s,    size_type count);```[heading Description][endsect][section:overload6 static_string::assign (6 of 10 overloads)]
Assign a null terminated string. [heading Synopsis]```static_string&assign(    CharT const* s);```[heading Description][endsect][section:overload7 static_string::assign (7 of 10 overloads)]
Assign from an iterator range of characters. [heading Synopsis]```template<    class InputIt>static_string&assign(    InputIt first,    InputIt last);```[heading Description][endsect][section:overload8 static_string::assign (8 of 10 overloads)]
Assign from initializer list. [heading Synopsis]```static_string&assign(    std::initializer_list< CharT > init);```[heading Description][endsect][section:overload9 static_string::assign (9 of 10 overloads)]
Assign from `string_view_type`. [heading Synopsis]```static_string&assign(    string_view_type str);```[heading Description][endsect][section:overload10 static_string::assign (10 of 10 overloads)]
Assign from any object convertible to `string_view_type`. [heading Synopsis]```template<    class T>static_string&assign(    T const& t,    size_type pos,    size_type count = npos);```[heading Description]
The range (pos, n) is extracted from the value obtained by converting `t` to `string_view_type`, and used to assign the string. [endsect][endsect][section:at static_string::at][indexterm2 at..static_string]
Access specified character with bounds checking. ```reference``[link beast.ref.boost__beast__static_string.at.overload1 at]``(    size_type pos);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.at.overload1 more...]]``const_reference``[link beast.ref.boost__beast__static_string.at.overload2 at]``(    size_type pos) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.at.overload2 more...]]`````[section:overload1 static_string::at (1 of 2 overloads)]
Access specified character with bounds checking. [heading Synopsis]```referenceat(    size_type pos);```[heading Description][endsect][section:overload2 static_string::at (2 of 2 overloads)]
Access specified character with bounds checking. [heading Synopsis]```const_referenceat(    size_type pos) const;```[heading Description][endsect][endsect][section:back static_string::back][indexterm2 back..static_string]
Accesses the last character. ```CharT&``[link beast.ref.boost__beast__static_string.back.overload1 back]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.back.overload1 more...]]``CharT const &``[link beast.ref.boost__beast__static_string.back.overload2 back]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.back.overload2 more...]]`````[section:overload1 static_string::back (1 of 2 overloads)]
Accesses the last character. [heading Synopsis]```CharT&back();```[heading Description][endsect][section:overload2 static_string::back (2 of 2 overloads)]
Accesses the last character. [heading Synopsis]```CharT const &back() const;```[heading Description][endsect][endsect][section:begin static_string::begin][indexterm2 begin..static_string]
Returns an iterator to the beginning. ```iterator``[link beast.ref.boost__beast__static_string.begin.overload1 begin]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.begin.overload1 more...]]``const_iterator``[link beast.ref.boost__beast__static_string.begin.overload2 begin]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.begin.overload2 more...]]`````[section:overload1 static_string::begin (1 of 2 overloads)]
Returns an iterator to the beginning. [heading Synopsis]```iteratorbegin();```[heading Description][endsect][section:overload2 static_string::begin (2 of 2 overloads)]
Returns an iterator to the beginning. [heading Synopsis]```const_iteratorbegin() const;```[heading Description][endsect][endsect][section:c_str static_string::c_str][indexterm2 c_str..static_string]
Returns a non-modifiable standard C character array version of the string. [heading Synopsis]```CharT const *c_str() const;```[heading Description][endsect][section:capacity static_string::capacity][indexterm2 capacity..static_string]
Returns the number of characters that can be held in currently allocated storage. [heading Synopsis]```size_type constexprcapacity() const;```[heading Description][endsect][section:cbegin static_string::cbegin][indexterm2 cbegin..static_string]
Returns an iterator to the beginning. [heading Synopsis]```const_iteratorcbegin() const;```[heading Description][endsect][section:cend static_string::cend][indexterm2 cend..static_string]
Returns an iterator to the end. [heading Synopsis]```const_iteratorcend() const;```[heading Description][endsect][section:clear static_string::clear][indexterm2 clear..static_string]
Clears the contents. [heading Synopsis]```voidclear();```[heading Description][endsect][section:compare static_string::compare][indexterm2 compare..static_string]```template<    std::size_t M>int``[link beast.ref.boost__beast__static_string.compare.overload1 compare]``(    static_string< M, CharT, Traits > const& str) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.compare.overload1 more...]]``template<    std::size_t M>int``[link beast.ref.boost__beast__static_string.compare.overload2 compare]``(    size_type pos1,    size_type count1,    static_string< M, CharT, Traits > const& str) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.compare.overload2 more...]]``template<    std::size_t M>int``[link beast.ref.boost__beast__static_string.compare.overload3 compare]``(    size_type pos1,    size_type count1,    static_string< M, CharT, Traits > const& str,    size_type pos2,    size_type count2 = npos) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.compare.overload3 more...]]``int``[link beast.ref.boost__beast__static_string.compare.overload4 compare]``(    CharT const* s) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.compare.overload4 more...]]``int``[link beast.ref.boost__beast__static_string.compare.overload5 compare]``(    size_type pos1,    size_type count1,    CharT const* s) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.compare.overload5 more...]]``int``[link beast.ref.boost__beast__static_string.compare.overload6 compare]``(    size_type pos1,    size_type count1,    CharT const* s,    size_type count2) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.compare.overload6 more...]]``int``[link beast.ref.boost__beast__static_string.compare.overload7 compare]``(    string_view_type str) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.compare.overload7 more...]]``int``[link beast.ref.boost__beast__static_string.compare.overload8 compare]``(    size_type pos1,    size_type count1,    string_view_type str) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.compare.overload8 more...]]``template<    class T>int``[link beast.ref.boost__beast__static_string.compare.overload9 compare]``(    size_type pos1,    size_type count1,    T const& t,    size_type pos2,    size_type count2 = npos) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.compare.overload9 more...]]`````[section:overload1 static_string::compare (1 of 9 overloads)][heading Synopsis]```template<    std::size_t M>intcompare(    static_string< M, CharT, Traits > const& str) const;```[heading Description][endsect][section:overload2 static_string::compare (2 of 9 overloads)][heading Synopsis]```template<    std::size_t M>intcompare(    size_type pos1,    size_type count1,    static_string< M, CharT, Traits > const& str) const;```[heading Description][endsect][section:overload3 static_string::compare (3 of 9 overloads)][heading Synopsis]```template<    std::size_t M>intcompare(    size_type pos1,    size_type count1,    static_string< M, CharT, Traits > const& str,    size_type pos2,    size_type count2 = npos) const;```[heading Description][endsect][section:overload4 static_string::compare (4 of 9 overloads)][heading Synopsis]```intcompare(    CharT const* s) const;```[heading Description][endsect][section:overload5 static_string::compare (5 of 9 overloads)][heading Synopsis]```intcompare(    size_type pos1,    size_type count1,    CharT const* s) const;```[heading Description][endsect][section:overload6 static_string::compare (6 of 9 overloads)][heading Synopsis]```intcompare(    size_type pos1,    size_type count1,    CharT const* s,    size_type count2) const;```[heading Description][endsect][section:overload7 static_string::compare (7 of 9 overloads)][heading Synopsis]```intcompare(    string_view_type str) const;```[heading Description][endsect][section:overload8 static_string::compare (8 of 9 overloads)][heading Synopsis]```intcompare(    size_type pos1,    size_type count1,    string_view_type str) const;```[heading Description][endsect][section:overload9 static_string::compare (9 of 9 overloads)][heading Synopsis]```template<    class T>intcompare(    size_type pos1,    size_type count1,    T const& t,    size_type pos2,    size_type count2 = npos) const;```[heading Description][endsect][endsect][section:const_iterator static_string::const_iterator][indexterm2 const_iterator..static_string][heading Synopsis]```using const_iterator = value_type const *;```[heading Description][endsect][section:const_pointer static_string::const_pointer][indexterm2 const_pointer..static_string][heading Synopsis]```using const_pointer = value_type const *;```[heading Description][endsect][section:const_reference static_string::const_reference][indexterm2 const_reference..static_string][heading Synopsis]```using const_reference = value_type const &;```[heading Description][endsect][section:const_reverse_iterator static_string::const_reverse_iterator][indexterm2 const_reverse_iterator..static_string][heading Synopsis]```using const_reverse_iterator = std::reverse_iterator< const_iterator >;```[heading Description][endsect][section:copy static_string::copy][indexterm2 copy..static_string]
Copy a substring (pos, pos+count) to character string pointed to by `dest`. [heading Synopsis]```size_typecopy(    CharT* dest,    size_type count,    size_type pos = 0) const;```[heading Description][endsect][section:crbegin static_string::crbegin][indexterm2 crbegin..static_string]
Returns a reverse iterator to the beginning. [heading Synopsis]```const_reverse_iteratorcrbegin() const;```[heading Description][endsect][section:crend static_string::crend][indexterm2 crend..static_string]
Returns a reverse iterator to the end. [heading Synopsis]```const_reverse_iteratorcrend() const;```[heading Description][endsect][section:data static_string::data][indexterm2 data..static_string]
Returns a pointer to the first character of a string. ```CharT*``[link beast.ref.boost__beast__static_string.data.overload1 data]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.data.overload1 more...]]``CharT const *``[link beast.ref.boost__beast__static_string.data.overload2 data]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.data.overload2 more...]]`````[section:overload1 static_string::data (1 of 2 overloads)]
Returns a pointer to the first character of a string. [heading Synopsis]```CharT*data();```[heading Description][endsect][section:overload2 static_string::data (2 of 2 overloads)]
Returns a pointer to the first character of a string. [heading Synopsis]```CharT const *data() const;```[heading Description][endsect][endsect][section:difference_type static_string::difference_type][indexterm2 difference_type..static_string][heading Synopsis]```using difference_type = std::ptrdiff_t;```[heading Description][endsect][section:empty static_string::empty][indexterm2 empty..static_string]
Returns `true` if the string is empty. [heading Synopsis]```boolempty() const;```[heading Description][endsect][section:end static_string::end][indexterm2 end..static_string]
Returns an iterator to the end. ```iterator``[link beast.ref.boost__beast__static_string.end.overload1 end]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.end.overload1 more...]]``const_iterator``[link beast.ref.boost__beast__static_string.end.overload2 end]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.end.overload2 more...]]`````[section:overload1 static_string::end (1 of 2 overloads)]
Returns an iterator to the end. [heading Synopsis]```iteratorend();```[heading Description][endsect][section:overload2 static_string::end (2 of 2 overloads)]
Returns an iterator to the end. [heading Synopsis]```const_iteratorend() const;```[heading Description][endsect][endsect][section:erase static_string::erase][indexterm2 erase..static_string]```static_string&``[link beast.ref.boost__beast__static_string.erase.overload1 erase]``(    size_type index = 0,    size_type count = npos);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.erase.overload1 more...]]``iterator``[link beast.ref.boost__beast__static_string.erase.overload2 erase]``(    const_iterator pos);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.erase.overload2 more...]]``iterator``[link beast.ref.boost__beast__static_string.erase.overload3 erase]``(    const_iterator first,    const_iterator last);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.erase.overload3 more...]]`````[section:overload1 static_string::erase (1 of 3 overloads)][heading Synopsis]```static_string&erase(    size_type index = 0,    size_type count = npos);```[heading Description][endsect][section:overload2 static_string::erase (2 of 3 overloads)][heading Synopsis]```iteratorerase(    const_iterator pos);```[heading Description][endsect][section:overload3 static_string::erase (3 of 3 overloads)][heading Synopsis]```iteratorerase(    const_iterator first,    const_iterator last);```[heading Description][endsect][endsect][section:front static_string::front][indexterm2 front..static_string]
Accesses the first character. ```CharT&``[link beast.ref.boost__beast__static_string.front.overload1 front]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.front.overload1 more...]]``CharT const &``[link beast.ref.boost__beast__static_string.front.overload2 front]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.front.overload2 more...]]`````[section:overload1 static_string::front (1 of 2 overloads)]
Accesses the first character. [heading Synopsis]```CharT&front();```[heading Description][endsect][section:overload2 static_string::front (2 of 2 overloads)]
Accesses the first character. [heading Synopsis]```CharT const &front() const;```[heading Description][endsect][endsect][section:insert static_string::insert][indexterm2 insert..static_string]```static_string&``[link beast.ref.boost__beast__static_string.insert.overload1 insert]``(    size_type index,    size_type count,    CharT ch);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.insert.overload1 more...]]``static_string&``[link beast.ref.boost__beast__static_string.insert.overload2 insert]``(    size_type index,    CharT const* s);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.insert.overload2 more...]]``static_string&``[link beast.ref.boost__beast__static_string.insert.overload3 insert]``(    size_type index,    CharT const* s,    size_type count);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.insert.overload3 more...]]``template<    std::size_t M>static_string&``[link beast.ref.boost__beast__static_string.insert.overload4 insert]``(    size_type index,    static_string< M, CharT, Traits > const& str);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.insert.overload4 more...]]``template<    std::size_t M>static_string&``[link beast.ref.boost__beast__static_string.insert.overload5 insert]``(    size_type index,    static_string< M, CharT, Traits > const& str,    size_type index_str,    size_type count = npos);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.insert.overload5 more...]]``iterator``[link beast.ref.boost__beast__static_string.insert.overload6 insert]``(    const_iterator pos,    CharT ch);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.insert.overload6 more...]]``iterator``[link beast.ref.boost__beast__static_string.insert.overload7 insert]``(    const_iterator pos,    size_type count,    CharT ch);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.insert.overload7 more...]]``template<    class InputIt>iterator``[link beast.ref.boost__beast__static_string.insert.overload8 insert]``(    const_iterator pos,    InputIt first,    InputIt last);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.insert.overload8 more...]]``iterator``[link beast.ref.boost__beast__static_string.insert.overload9 insert]``(    const_iterator pos,    std::initializer_list< CharT > init);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.insert.overload9 more...]]``static_string&``[link beast.ref.boost__beast__static_string.insert.overload10 insert]``(    size_type index,    string_view_type str);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.insert.overload10 more...]]``template<    class T>static_string&``[link beast.ref.boost__beast__static_string.insert.overload11 insert]``(    size_type index,    T const& t,    size_type index_str,    size_type count = npos);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.insert.overload11 more...]]`````[section:overload1 static_string::insert (1 of 11 overloads)][heading Synopsis]```static_string&insert(    size_type index,    size_type count,    CharT ch);```[heading Description][endsect][section:overload2 static_string::insert (2 of 11 overloads)][heading Synopsis]```static_string&insert(    size_type index,    CharT const* s);```[heading Description][endsect][section:overload3 static_string::insert (3 of 11 overloads)][heading Synopsis]```static_string&insert(    size_type index,    CharT const* s,    size_type count);```[heading Description][endsect][section:overload4 static_string::insert (4 of 11 overloads)][heading Synopsis]```template<    std::size_t M>static_string&insert(    size_type index,    static_string< M, CharT, Traits > const& str);```[heading Description][endsect][section:overload5 static_string::insert (5 of 11 overloads)][heading Synopsis]```template<    std::size_t M>static_string&insert(    size_type index,    static_string< M, CharT, Traits > const& str,    size_type index_str,    size_type count = npos);```[heading Description][endsect][section:overload6 static_string::insert (6 of 11 overloads)][heading Synopsis]```iteratorinsert(    const_iterator pos,    CharT ch);```[heading Description][endsect][section:overload7 static_string::insert (7 of 11 overloads)][heading Synopsis]```iteratorinsert(    const_iterator pos,    size_type count,    CharT ch);```[heading Description][endsect][section:overload8 static_string::insert (8 of 11 overloads)][heading Synopsis]```template<    class InputIt>iteratorinsert(    const_iterator pos,    InputIt first,    InputIt last);```[heading Description][endsect][section:overload9 static_string::insert (9 of 11 overloads)][heading Synopsis]```iteratorinsert(    const_iterator pos,    std::initializer_list< CharT > init);```[heading Description][endsect][section:overload10 static_string::insert (10 of 11 overloads)][heading Synopsis]```static_string&insert(    size_type index,    string_view_type str);```[heading Description][endsect][section:overload11 static_string::insert (11 of 11 overloads)][heading Synopsis]```template<    class T>static_string&insert(    size_type index,    T const& t,    size_type index_str,    size_type count = npos);```[heading Description][endsect][endsect][section:iterator static_string::iterator][indexterm2 iterator..static_string][heading Synopsis]```using iterator = value_type*;```[heading Description][endsect][section:length static_string::length][indexterm2 length..static_string]
Returns the number of characters, excluding the null terminator. [heading Synopsis]```size_typelength() const;```[heading Description][endsect][section:max_size static_string::max_size][indexterm2 max_size..static_string]
Returns the maximum number of characters that can be stored, excluding the null terminator. [heading Synopsis]```size_type constexprmax_size() const;```[heading Description][endsect][section:max_size_n static_string::max_size_n][indexterm2 max_size_n..static_string]
Maximum size of the string excluding the null terminator. [heading Synopsis]```staticstd::size_t constexpr max_size_n = N;```[heading Description][endsect][section:npos static_string::npos][indexterm2 npos..static_string]
A special index. [heading Synopsis]```staticconstexpr size_type npos = size_type(-1);```[heading Description][endsect][section:operator_string_view_type static_string::operator string_view_type][indexterm2 operator string_view_type..static_string]
Convert a static string to a `string_view_type` [heading Synopsis]```operator string_view_type() const;```[heading Description][endsect][section:operator_plus__eq_ static_string::operator+=][indexterm2 operator+=..static_string]```template<    std::size_t M>static_string&``[link beast.ref.boost__beast__static_string.operator_plus__eq_.overload1 operator+=]``(    static_string< M, CharT, Traits > const& str);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.operator_plus__eq_.overload1 more...]]``static_string&``[link beast.ref.boost__beast__static_string.operator_plus__eq_.overload2 operator+=]``(    CharT ch);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.operator_plus__eq_.overload2 more...]]``static_string&``[link beast.ref.boost__beast__static_string.operator_plus__eq_.overload3 operator+=]``(    CharT const* s);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.operator_plus__eq_.overload3 more...]]``static_string&``[link beast.ref.boost__beast__static_string.operator_plus__eq_.overload4 operator+=]``(    std::initializer_list< CharT > init);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.operator_plus__eq_.overload4 more...]]``static_string&``[link beast.ref.boost__beast__static_string.operator_plus__eq_.overload5 operator+=]``(    string_view_type const& str);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.operator_plus__eq_.overload5 more...]]`````[section:overload1 static_string::operator+= (1 of 5 overloads)][heading Synopsis]```template<    std::size_t M>static_string&operator+=(    static_string< M, CharT, Traits > const& str);```[heading Description][endsect][section:overload2 static_string::operator+= (2 of 5 overloads)][heading Synopsis]```static_string&operator+=(    CharT ch);```[heading Description][endsect][section:overload3 static_string::operator+= (3 of 5 overloads)][heading Synopsis]```static_string&operator+=(    CharT const* s);```[heading Description][endsect][section:overload4 static_string::operator+= (4 of 5 overloads)][heading Synopsis]```static_string&operator+=(    std::initializer_list< CharT > init);```[heading Description][endsect][section:overload5 static_string::operator+= (5 of 5 overloads)][heading Synopsis]```static_string&operator+=(    string_view_type const& str);```[heading Description][endsect][endsect][section:operator_eq_ static_string::operator=][indexterm2 operator=..static_string]
Copy assignment. ```static_string&``[link beast.ref.boost__beast__static_string.operator_eq_.overload1 operator=]``(    static_string const& str);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.operator_eq_.overload1 more...]]``template<    std::size_t M>static_string&``[link beast.ref.boost__beast__static_string.operator_eq_.overload2 operator=]``(    static_string< M, CharT, Traits > const& str);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.operator_eq_.overload2 more...]]`````
Assign from null-terminated string. ```static_string&``[link beast.ref.boost__beast__static_string.operator_eq_.overload3 operator=]``(    CharT const* s);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.operator_eq_.overload3 more...]]`````
Assign from single character. ```static_string&``[link beast.ref.boost__beast__static_string.operator_eq_.overload4 operator=]``(    CharT ch);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.operator_eq_.overload4 more...]]`````
Assign from initializer list. ```static_string&``[link beast.ref.boost__beast__static_string.operator_eq_.overload5 operator=]``(    std::initializer_list< CharT > init);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.operator_eq_.overload5 more...]]`````
Assign from `string_view_type`. ```static_string&``[link beast.ref.boost__beast__static_string.operator_eq_.overload6 operator=]``(    string_view_type sv);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.operator_eq_.overload6 more...]]`````[section:overload1 static_string::operator= (1 of 6 overloads)]
Copy assignment. [heading Synopsis]```static_string&operator=(    static_string const& str);```[heading Description][endsect][section:overload2 static_string::operator= (2 of 6 overloads)]
Copy assignment. [heading Synopsis]```template<    std::size_t M>static_string&operator=(    static_string< M, CharT, Traits > const& str);```[heading Description][endsect][section:overload3 static_string::operator= (3 of 6 overloads)]
Assign from null-terminated string. [heading Synopsis]```static_string&operator=(    CharT const* s);```[heading Description][endsect][section:overload4 static_string::operator= (4 of 6 overloads)]
Assign from single character. [heading Synopsis]```static_string&operator=(    CharT ch);```[heading Description][endsect][section:overload5 static_string::operator= (5 of 6 overloads)]
Assign from initializer list. [heading Synopsis]```static_string&operator=(    std::initializer_list< CharT > init);```[heading Description][endsect][section:overload6 static_string::operator= (6 of 6 overloads)]
Assign from `string_view_type`. [heading Synopsis]```static_string&operator=(    string_view_type sv);```[heading Description][endsect][endsect][section:operator_lb__rb_ static_string::operator\[\]][indexterm2 operator\[\]..static_string]
Access specified character. ```reference``[link beast.ref.boost__beast__static_string.operator_lb__rb_.overload1 operator[]]``(    size_type pos);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.operator_lb__rb_.overload1 more...]]``const_reference``[link beast.ref.boost__beast__static_string.operator_lb__rb_.overload2 operator[]]``(    size_type pos) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.operator_lb__rb_.overload2 more...]]`````[section:overload1 static_string::operator\[\] (1 of 2 overloads)]
Access specified character. [heading Synopsis]```referenceoperator[](    size_type pos);```[heading Description][endsect][section:overload2 static_string::operator\[\] (2 of 2 overloads)]
Access specified character. [heading Synopsis]```const_referenceoperator[](    size_type pos) const;```[heading Description][endsect][endsect][section:pointer static_string::pointer][indexterm2 pointer..static_string][heading Synopsis]```using pointer = value_type*;```[heading Description][endsect][section:pop_back static_string::pop_back][indexterm2 pop_back..static_string][heading Synopsis]```voidpop_back();```[heading Description][endsect][section:push_back static_string::push_back][indexterm2 push_back..static_string][heading Synopsis]```voidpush_back(    CharT ch);```[heading Description][endsect][section:rbegin static_string::rbegin][indexterm2 rbegin..static_string]
Returns a reverse iterator to the beginning. ```reverse_iterator``[link beast.ref.boost__beast__static_string.rbegin.overload1 rbegin]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.rbegin.overload1 more...]]``const_reverse_iterator``[link beast.ref.boost__beast__static_string.rbegin.overload2 rbegin]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.rbegin.overload2 more...]]`````[section:overload1 static_string::rbegin (1 of 2 overloads)]
Returns a reverse iterator to the beginning. [heading Synopsis]```reverse_iteratorrbegin();```[heading Description][endsect][section:overload2 static_string::rbegin (2 of 2 overloads)]
Returns a reverse iterator to the beginning. [heading Synopsis]```const_reverse_iteratorrbegin() const;```[heading Description][endsect][endsect][section:reference static_string::reference][indexterm2 reference..static_string][heading Synopsis]```using reference = value_type&;```[heading Description][endsect][section:rend static_string::rend][indexterm2 rend..static_string]
Returns a reverse iterator to the end. ```reverse_iterator``[link beast.ref.boost__beast__static_string.rend.overload1 rend]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.rend.overload1 more...]]``const_reverse_iterator``[link beast.ref.boost__beast__static_string.rend.overload2 rend]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.rend.overload2 more...]]`````[section:overload1 static_string::rend (1 of 2 overloads)]
Returns a reverse iterator to the end. [heading Synopsis]```reverse_iteratorrend();```[heading Description][endsect][section:overload2 static_string::rend (2 of 2 overloads)]
Returns a reverse iterator to the end. [heading Synopsis]```const_reverse_iteratorrend() const;```[heading Description][endsect][endsect][section:reserve static_string::reserve][indexterm2 reserve..static_string]
Reserves storage. [heading Synopsis]```voidreserve(    std::size_t n);```[heading Description]
This actually just throws an exception if `n > N`, otherwise does nothing since the storage is fixed. [endsect][section:resize static_string::resize][indexterm2 resize..static_string]
Changes the number of characters stored. ```void``[link beast.ref.boost__beast__static_string.resize.overload1 resize]``(    std::size_t n);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.resize.overload1 more...]]``void``[link beast.ref.boost__beast__static_string.resize.overload2 resize]``(    std::size_t n,    CharT c);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.resize.overload2 more...]]`````[section:overload1 static_string::resize (1 of 2 overloads)]
Changes the number of characters stored. [heading Synopsis]```voidresize(    std::size_t n);```[heading Description]
If the resulting string is larger, the new characters are uninitialized. [endsect][section:overload2 static_string::resize (2 of 2 overloads)]
Changes the number of characters stored. [heading Synopsis]```voidresize(    std::size_t n,    CharT c);```[heading Description]
If the resulting string is larger, the new characters are initialized to the value of `c`. [endsect][endsect][section:reverse_iterator static_string::reverse_iterator][indexterm2 reverse_iterator..static_string][heading Synopsis]```using reverse_iterator = std::reverse_iterator< iterator >;```[heading Description][endsect][section:shrink_to_fit static_string::shrink_to_fit][indexterm2 shrink_to_fit..static_string]
Reduces memory usage by freeing unused memory. [heading Synopsis]```voidshrink_to_fit();```[heading Description]
This actually does nothing, since the storage is fixed. [endsect][section:size static_string::size][indexterm2 size..static_string]
Returns the number of characters, excluding the null terminator. [heading Synopsis]```size_typesize() const;```[heading Description][endsect][section:size_type static_string::size_type][indexterm2 size_type..static_string][heading Synopsis]```using size_type = std::size_t;```[heading Description][endsect][section:static_string static_string::static_string][indexterm2 static_string..static_string]
Default constructor (empty string). `````[link beast.ref.boost__beast__static_string.static_string.overload1 static_string]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.static_string.overload1 more...]]`````
Construct with count copies of character `ch`. `````[link beast.ref.boost__beast__static_string.static_string.overload2 static_string]``(    size_type count,    CharT ch);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.static_string.overload2 more...]]`````
Construct with a substring (pos, other.size()) of `other`. ```template<    std::size_t M>``[link beast.ref.boost__beast__static_string.static_string.overload3 static_string]``(    static_string< M, CharT, Traits > const& other,    size_type pos);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.static_string.overload3 more...]]`````
Construct with a substring (pos, count) of `other`. ```template<    std::size_t M>``[link beast.ref.boost__beast__static_string.static_string.overload4 static_string]``(    static_string< M, CharT, Traits > const& other,    size_type pos,    size_type count);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.static_string.overload4 more...]]`````
Construct with the first `count` characters of `s`, including nulls. `````[link beast.ref.boost__beast__static_string.static_string.overload5 static_string]``(    CharT const* s,    size_type count);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.static_string.overload5 more...]]`````
Construct from a null terminated string. `````[link beast.ref.boost__beast__static_string.static_string.overload6 static_string]``(    CharT const* s);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.static_string.overload6 more...]]`````
Construct from a range of characters. ```template<    class InputIt>``[link beast.ref.boost__beast__static_string.static_string.overload7 static_string]``(    InputIt first,    InputIt last);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.static_string.overload7 more...]]`````
Copy constructor. `````[link beast.ref.boost__beast__static_string.static_string.overload8 static_string]``(    static_string const& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.static_string.overload8 more...]]``template<    std::size_t M>``[link beast.ref.boost__beast__static_string.static_string.overload9 static_string]``(    static_string< M, CharT, Traits > const& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.static_string.overload9 more...]]`````
Construct from an initializer list. `````[link beast.ref.boost__beast__static_string.static_string.overload10 static_string]``(    std::initializer_list< CharT > init);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.static_string.overload10 more...]]`````
Construct from a `string_view` ```explicit``[link beast.ref.boost__beast__static_string.static_string.overload11 static_string]``(    string_view_type sv);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.static_string.overload11 more...]]`````
Construct from any object convertible to `string_view_type`. ```template<    class T>``[link beast.ref.boost__beast__static_string.static_string.overload12 static_string]``(    T const& t,    size_type pos,    size_type n);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.static_string.overload12 more...]]`````[section:overload1 static_string::static_string (1 of 12 overloads)]
Default constructor (empty string). [heading Synopsis]```static_string();```[heading Description][endsect][section:overload2 static_string::static_string (2 of 12 overloads)]
Construct with count copies of character `ch`. [heading Synopsis]```static_string(    size_type count,    CharT ch);```[heading Description]
The behavior is undefined if `count >= npos` [endsect][section:overload3 static_string::static_string (3 of 12 overloads)]
Construct with a substring (pos, other.size()) of `other`. [heading Synopsis]```template<    std::size_t M>static_string(    static_string< M, CharT, Traits > const& other,    size_type pos);```[heading Description][endsect][section:overload4 static_string::static_string (4 of 12 overloads)]
Construct with a substring (pos, count) of `other`. [heading Synopsis]```template<    std::size_t M>static_string(    static_string< M, CharT, Traits > const& other,    size_type pos,    size_type count);```[heading Description][endsect][section:overload5 static_string::static_string (5 of 12 overloads)]
Construct with the first `count` characters of `s`, including nulls. [heading Synopsis]```static_string(    CharT const* s,    size_type count);```[heading Description][endsect][section:overload6 static_string::static_string (6 of 12 overloads)]
Construct from a null terminated string. [heading Synopsis]```static_string(    CharT const* s);```[heading Description][endsect][section:overload7 static_string::static_string (7 of 12 overloads)]
Construct from a range of characters. [heading Synopsis]```template<    class InputIt>static_string(    InputIt first,    InputIt last);```[heading Description][endsect][section:overload8 static_string::static_string (8 of 12 overloads)]
Copy constructor. [heading Synopsis]```static_string(    static_string const& other);```[heading Description][endsect][section:overload9 static_string::static_string (9 of 12 overloads)]
Copy constructor. [heading Synopsis]```template<    std::size_t M>static_string(    static_string< M, CharT, Traits > const& other);```[heading Description][endsect][section:overload10 static_string::static_string (10 of 12 overloads)]
Construct from an initializer list. [heading Synopsis]```static_string(    std::initializer_list< CharT > init);```[heading Description][endsect][section:overload11 static_string::static_string (11 of 12 overloads)]
Construct from a `string_view` [heading Synopsis]```static_string(    string_view_type sv);```[heading Description][endsect][section:overload12 static_string::static_string (12 of 12 overloads)]
Construct from any object convertible to `string_view_type`. [heading Synopsis]```template<    class T>static_string(    T const& t,    size_type pos,    size_type n);```[heading Description]
The range (pos, n) is extracted from the value obtained by converting `t` to `string_view_type`, and used to construct the string. [endsect][endsect][section:string_view_type static_string::string_view_type][indexterm2 string_view_type..static_string]
The type of `string_view` returned by the interface. [heading Synopsis]```using string_view_type = basic_string_view< CharT, Traits >;```[heading Description][endsect][section:substr static_string::substr][indexterm2 substr..static_string][heading Synopsis]```string_view_typesubstr(    size_type pos = 0,    size_type count = npos) const;```[heading Description][endsect][section:swap static_string::swap][indexterm2 swap..static_string]
Exchange the contents of this string with another. ```void``[link beast.ref.boost__beast__static_string.swap.overload1 swap]``(    static_string& str);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.swap.overload1 more...]]``template<    std::size_t M>void``[link beast.ref.boost__beast__static_string.swap.overload2 swap]``(    static_string< M, CharT, Traits >& str);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.swap.overload2 more...]]`````[section:overload1 static_string::swap (1 of 2 overloads)]
Exchange the contents of this string with another. [heading Synopsis]```voidswap(    static_string& str);```[heading Description][endsect][section:overload2 static_string::swap (2 of 2 overloads)]
Exchange the contents of this string with another. [heading Synopsis]```template<    std::size_t M>voidswap(    static_string< M, CharT, Traits >& str);```[heading Description][endsect][endsect][section:traits_type static_string::traits_type][indexterm2 traits_type..static_string][heading Synopsis]```using traits_type = Traits;```[heading Description][endsect][section:value_type static_string::value_type][indexterm2 value_type..static_string][heading Synopsis]```using value_type = typename Traits::char_type;```[heading Description][endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__string_param string_param]
A function parameter which efficiently converts to string. [heading Synopsis]Defined in header [include_file boost/beast/core/string_param.hpp]```class string_param```[heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__string_param.operator_string_view_const [*operator string_view const]]]    [      Implicit conversion to string_view.     ]  ]  [    [[link beast.ref.boost__beast__string_param.operator_eq_ [*operator=]]]    [      Copy assignment (disallowed)     ]  ]  [    [[link beast.ref.boost__beast__string_param.str [*str]]]    [      Returns the contained string.     ]  ]  [    [[link beast.ref.boost__beast__string_param.string_param [*string_param]]]    [      Copy constructor (disallowed)       Constructor.     ]  ]][heading Description]
This is used as a function parameter type to allow callers notational convenience: objects other than strings may be passed in contexts where a string is expected. The conversion to string is made using `operator<<` to a non-dynamically allocated static buffer if possible, else to a `std::string` on overflow.
To use it, modify your function signature to accept `string_param` and then extract the string inside the function: ```  void print(string_param s)
  {
      std::cout << s.str();
  }
```[section:operator_string_view_const string_param::operator string_view const][indexterm2 operator string_view const..string_param]
Implicit conversion to [link beast.ref.boost__beast__string_view `string_view`]. [heading Synopsis]```operator string_view const() const;```[heading Description][endsect][section:operator_eq_ string_param::operator=][indexterm2 operator=..string_param]
Copy assignment (disallowed) [heading Synopsis]```string_param&operator=(    string_param const&);```[heading Description][endsect][section:str string_param::str][indexterm2 str..string_param]
Returns the contained string. [heading Synopsis]```string_viewstr() const;```[heading Description][endsect][section:string_param string_param::string_param][indexterm2 string_param..string_param]
Copy constructor (disallowed) `````[link beast.ref.boost__beast__string_param.string_param.overload1 string_param]``(    string_param const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__string_param.string_param.overload1 more...]]`````
Constructor. ```template<    class... Args>``[link beast.ref.boost__beast__string_param.string_param.overload2 string_param]``(    Args const&... args);  ``[''''&raquo;''' [link beast.ref.boost__beast__string_param.string_param.overload2 more...]]`````[section:overload1 string_param::string_param (1 of 2 overloads)]
Copy constructor (disallowed) [heading Synopsis]```string_param(    string_param const&);```[heading Description][endsect][section:overload2 string_param::string_param (2 of 2 overloads)]
Constructor. [heading Synopsis]```template<    class... Args>string_param(    Args const&... args);```[heading Description]
This function constructs a string as if by concatenating the result of streaming each argument in order into an output stream. It is used as a notational convenience at call sites which expect a parameter with the semantics of a [link beast.ref.boost__beast__string_view `string_view`].
The implementation uses a small, internal static buffer to avoid memory allocations especially for the case where the list of arguments to be converted consists of a single integral type.
[heading Parameters][table [[Name][Description]]  [[`args`][    
One or more arguments to convert   ]]]
[endsect][endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__string_view string_view][indexterm1 string_view]
The type of string view used by the library. [heading Synopsis]Defined in header [include_file boost/beast/core/string_type.hpp]```using string_view = boost::string_view;```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__swap swap][indexterm1 swap]```template<    std::size_t N,    class CharT,    class Traits>void``[link beast.ref.boost__beast__swap.overload1 swap]``(    static_string< N, CharT, Traits >& lhs,    static_string< N, CharT, Traits >& rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__swap.overload1 more...]]``template<    std::size_t N,    std::size_t M,    class CharT,    class Traits>void``[link beast.ref.boost__beast__swap.overload2 swap]``(    static_string< N, CharT, Traits >& lhs,    static_string< M, CharT, Traits >& rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__swap.overload2 more...]]`````[section:overload1 swap (1 of 2 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>voidswap(    static_string< N, CharT, Traits >& lhs,    static_string< N, CharT, Traits >& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:overload2 swap (2 of 2 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    std::size_t M,    class CharT,    class Traits>voidswap(    static_string< N, CharT, Traits >& lhs,    static_string< M, CharT, Traits >& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][endsect][section:boost__beast__system_category system_category][indexterm1 system_category]
A function to return the system error category used by the library. [heading Synopsis]Defined in header [include_file boost/beast/core/error.hpp]```error_category const &system_category();```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__system_error system_error][indexterm1 system_error]
The type of system error thrown by the library. [heading Synopsis]Defined in header [include_file boost/beast/core/error.hpp]```using system_error = boost::system::system_error;```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__tcp_stream tcp_stream][indexterm1 tcp_stream]
A TCP/IP stream socket with timeouts and a polymorphic executor. [heading Synopsis]Defined in header [include_file boost/beast/core/tcp_stream.hpp]```using tcp_stream = basic_stream< net::ip::tcp, net::executor, unlimited_rate_policy >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__basic_stream.endpoint_type [*endpoint_type]]]    [      The endpoint type.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.executor_type [*executor_type]]]    [      The type of the executor associated with the stream.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.protocol_type [*protocol_type]]]    [      The protocol type.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.socket_type [*socket_type]]]    [      The type of the underlying socket.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__basic_stream.async_connect [*async_connect]]]    [      Connect the stream to the specified endpoint asynchronously.       Establishes a connection by trying each endpoint in a sequence asynchronously.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.async_read_some [*async_read_some]]]    [      Read some data asynchronously.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.async_write_some [*async_write_some]]]    [      Write some data asynchronously.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.basic_stream [*basic_stream]]]    [      Constructor.       Move constructor.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.cancel [*cancel]]]    [      Cancel all asynchronous operations associated with the socket.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.close [*close]]]    [      Close the timed stream.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.connect [*connect]]]    [      Connect the stream to the specified endpoint.       Establishes a connection by trying each endpoint in a sequence.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.expires_after [*expires_after]]]    [      Set the timeout for the next logical operation.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.expires_at [*expires_at]]]    [      Set the timeout for the next logical operation.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.expires_never [*expires_never]]]    [      Disable the timeout for the next logical operation.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.get_executor [*get_executor]]]    [      Get the executor associated with the object.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.operator_eq_ [*operator=]]]    [      Move assignment (deleted).     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.rate_policy [*rate_policy]]]    [      Returns the rate policy associated with the object.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.read_some [*read_some]]]    [      Read some data.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.release_socket [*release_socket]]]    [      Release ownership of the underlying socket.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.socket [*socket]]]    [      Return a reference to the underlying socket.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.write_some [*write_some]]]    [      Write some data.     ]  ]  [    [[link beast.ref.boost__beast__basic_stream.basic_stream_dtor_ [*~basic_stream]]]    [      Destructor.     ]  ]]
This stream wraps a `net::basic_stream_socket` to provide the following features:

* An ['Executor] may be associated with the stream, which will be used to invoke any completion handlers which do not already have an associated executor. This achieves support for [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1322r0.html [P1322R0] Networking TS enhancement to enable custom I/O executors].


* Timeouts may be specified for each logical asynchronous operation performing any reading, writing, or connecting.


* A ['RatePolicy] may be associated with the stream, to implement rate limiting through the policy's interface.

Although the stream supports multiple concurrent outstanding asynchronous operations, the stream object is not thread-safe. The caller is responsible for ensuring that the stream is accessed from only one thread at a time. This includes the times when the stream, and its underlying socket, are accessed by the networking implementation. To meet this thread safety requirement, all asynchronous operations must be performed by the stream within the same implicit strand (only one thread `net::io_context::run`) or within the same explicit strand, such as an instance of `net::strand`.
Completion handlers with explicit associated executors (such as those arising from use of `net::bind_executor`) will be invoked by the stream using the associated executor. Otherwise, the completion handler will be invoked by the executor associated with the stream upon construction. The type of executor used with this stream must meet the following requirements:

* Function objects submitted to the executor shall never run concurrently with each other.

The executor type `net::strand` meets these requirements. Use of a strand as the executor in the stream class template offers an additional notational convenience: the strand does not need to be specified in each individual initiating function call.
Unlike other stream wrappers, the underlying socket is accessed through the [link beast.ref.boost__beast__basic_stream.socket `basic_stream::socket`] member function instead of `next_layer`. This causes the [link beast.ref.boost__beast__basic_stream `basic_stream`] to be returned in calls to [link beast.ref.boost__beast__get_lowest_layer `get_lowest_layer`].
[heading Usage]

To use this stream declare an instance of the class. Then, before each logical operation for which a timeout is desired, call [link beast.ref.boost__beast__basic_stream.expires_after `basic_stream::expires_after`] with a duration, or call [link beast.ref.boost__beast__basic_stream.expires_at `basic_stream::expires_at`] with a time point. Alternatively, call [link beast.ref.boost__beast__basic_stream.expires_never `basic_stream::expires_never`] to disable the timeout for subsequent logical operations. A logical operation is any series of one or more direct or indirect calls to the timeout stream's asynchronous read, asynchronous write, or asynchronous connect functions.
When a timeout is set and a mixed operation is performed (one that includes both reads and writes, for example) the timeout applies to all of the intermediate asynchronous operations used in the enclosing operation. This allows timeouts to be applied to stream algorithms which were not written specifically to allow for timeouts, when those algorithms are passed a timeout stream with a timeout set.
When a timeout occurs the socket will be closed, canceling any pending I/O operations. The completion handlers for these canceled operations will be invoked with the error [link beast.ref.boost__beast__error `timeout`].
[heading Examples]

This function reads an HTTP request with a timeout, then sends the HTTP response with a different timeout.
```  void process_http_1 (tcp_stream& stream, net::yield_context yield)
  {
      flat_buffer buffer;
      http::request<http::empty_body> req;

      // Read the request, with a 15 second timeout
      stream.expires_after(std::chrono::seconds(15));
      http::async_read(stream, buffer, req, yield);

      // Calculate the response
      http::response<http::string_body> res = make_response(req);

      // Send the response, with a 30 second timeout.
      stream.expires_after (std::chrono::seconds(30));
      http::async_write (stream, res, yield);
  }
```
The example above could be expressed using a single timeout with a simple modification. The function that follows first reads an HTTP request then sends the HTTP response, with a single timeout that applies to the entire combined operation of reading and writing:
```  void process_http_2 (tcp_stream& stream, net::yield_context yield)
  {
      flat_buffer buffer;
      http::request<http::empty_body> req;

      // Require that the read and write combined take no longer than 30 seconds
      stream.expires_after(std::chrono::seconds(30));

      http::async_read(stream, buffer, req, yield);

      http::response<http::string_body> res = make_response(req);
      http::async_write (stream, res, yield);
  }
```
Some stream algorithms, such as `ssl::stream::async_handshake` perform both reads and writes. A timeout set before calling the initiating function of such composite stream algorithms will apply to the entire composite operation. For example, a timeout may be set on performing the SSL handshake thusly:
```  void do_ssl_handshake (net::ssl::stream<tcp_stream>& stream, net::yield_context yield)
  {
      // Require that the SSL handshake take no longer than 10 seconds
      stream.expires_after(std::chrono::seconds(10));

      stream.async_handshake(net::ssl::stream_base::client, yield);
  }
```
[heading Blocking I/O]

Synchronous functions behave identically as that of the wrapped `net::basic_stream_socket`. Timeouts are not available when performing blocking calls.
[heading Template Parameters][table [[Type][Description]]  [[`Protocol`][    
A type meeting the requirements of ['Protocol] representing the protocol the protocol to use for the basic stream socket. A common choice is `net::ip::tcp`.  ]]  [[`Executor`][    
A type meeting the requirements of ['Executor] to be used for submitting all completion handlers which do not already have an associated executor. If this type is omitted, the default of `net::executor` will be used.  ]]]
[heading Thread Safety]
['Distinct objects]: Safe.['Shared objects]: Unsafe. The application must also ensure that all asynchronous operations are performed within the same implicit or explicit strand.
[heading See Also]


* [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1322r0.html [P1322R0] Networking TS enhancement to enable custom I/O executors]. 

[heading Description]
[heading See Also]
[link beast.ref.boost__beast__basic_stream `basic_stream`] 
Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__teardown teardown][indexterm1 teardown]
Tear down a `net::ssl::stream`. [heading Synopsis]Defined in header [include_file boost/beast/websocket/ssl.hpp]```template<    class __SyncStream__>voidteardown(    role_type role,    net::ssl::stream< SyncStream >& stream,    error_code& ec);```[heading Description]
This tears down a connection. The implementation will call the overload of this function based on the `Stream` parameter used to consruct the socket. When `Stream` is a user defined type, and not a `net::ip::tcp::socket` or any `net::ssl::stream`, callers are responsible for providing a suitable overload of this function.
[heading Parameters][table [[Name][Description]]  [[`role`][    
The role of the local endpoint  ]]  [[`stream`][    
The stream to tear down.  ]]  [[`ec`][    
Set to the error if any occurred.   ]]]
Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__test__any_handler test::any_handler][indexterm1 test::any_handler]
Return a test CompletionHandler which requires invocation. [heading Synopsis]Defined in header [include_file boost/beast/_experimental/test/handler.hpp]```handlerany_handler();```[heading Description]
The returned handler can be invoked with any signature. The handler fails the test if:

* The handler is destroyed without being invoked. 

[endsect][section:boost__beast__test__connect test::connect][indexterm1 test::connect]
Return a new stream connected to the given stream. ```template<    class... Args>stream``[link beast.ref.boost__beast__test__connect.overload1 connect]``(    stream& to,    Args&&... args);  ``[''''&raquo;''' [link beast.ref.boost__beast__test__connect.overload1 more...]]`````
Connect two TCP sockets together. ```template<    class __Executor__>bool``[link beast.ref.boost__beast__test__connect.overload2 connect]``(    net::basic_stream_socket< net::ip::tcp, Executor >& s1,    net::basic_stream_socket< net::ip::tcp, Executor >& s2);  ``[''''&raquo;''' [link beast.ref.boost__beast__test__connect.overload2 more...]]`````[section:overload1 test::connect (1 of 2 overloads)]
Return a new stream connected to the given stream. [heading Synopsis]Defined in header [include_file boost/beast/_experimental/test/stream.hpp]```template<    class... Args>streamconnect(    stream& to,    Args&&... args);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`to`][    
The stream to connect to.  ]]  [[`args`][    
Optional arguments forwarded to the new stream's constructor.  ]]]
[heading Return Value]
The new, connected stream. 
[endsect][section:overload2 test::connect (2 of 2 overloads)]
Connect two TCP sockets together. [heading Synopsis]Defined in header [include_file boost/beast/_experimental/test/tcp.hpp]```template<    class __Executor__>boolconnect(    net::basic_stream_socket< net::ip::tcp, Executor >& s1,    net::basic_stream_socket< net::ip::tcp, Executor >& s2);```[heading Description][endsect][endsect][section:boost__beast__test__error test::error][indexterm1 test::error]
Error codes returned from unit testing algorithms. [heading Synopsis]Defined in header [include_file boost/beast/_experimental/test/error.hpp]```enum error```[indexterm2 test_failure..test::error][heading Values][table [[Name][Description]]  [[[^test_failure]][The test stream generated a simulated testing error. This error is returned by a @ref fail_count object
when it generates a simulated error.
 ]]][heading Description][endsect][section:boost__beast__test__fail_count test::fail_count]
A countdown to simulated failure. [heading Synopsis]Defined in header [include_file boost/beast/_experimental/test/fail_count.hpp]```class fail_count```[heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__test__fail_count.fail [*fail]]]    [      Throw an exception on the Nth failure.       Set an error code on the Nth failure.     ]  ]  [    [[link beast.ref.boost__beast__test__fail_count.fail_count [*fail_count]]]    [            Construct a counter.     ]  ]][heading Description]
On the Nth operation, the class will fail with the specified error code, or the default error code of [link beast.ref.boost__beast__test__error `test::test_failure`].
Instances of this class may be used to build objects which are specifically designed to aid in writing unit tests, for interfaces which can throw exceptions or return `error_code` values representing failure. [section:fail test::fail_count::fail][indexterm2 fail..test::fail_count]
Throw an exception on the Nth failure. ```void``[link beast.ref.boost__beast__test__fail_count.fail.overload1 fail]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__test__fail_count.fail.overload1 more...]]`````
Set an error code on the Nth failure. ```bool``[link beast.ref.boost__beast__test__fail_count.fail.overload2 fail]``(    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__test__fail_count.fail.overload2 more...]]`````[section:overload1 test::fail_count::fail (1 of 2 overloads)]
Throw an exception on the Nth failure. [heading Synopsis]```voidfail();```[heading Description][endsect][section:overload2 test::fail_count::fail (2 of 2 overloads)]
Set an error code on the Nth failure. [heading Synopsis]```boolfail(    error_code& ec);```[heading Description][endsect][endsect][section:fail_count test::fail_count::fail_count][indexterm2 fail_count..test::fail_count]`````[link beast.ref.boost__beast__test__fail_count.fail_count.overload1 fail_count]``(    fail_count&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__test__fail_count.fail_count.overload1 more...]]`````
Construct a counter. ```explicit``[link beast.ref.boost__beast__test__fail_count.fail_count.overload2 fail_count]``(    std::size_t n,    error_code ev = error::test_failure);  ``[''''&raquo;''' [link beast.ref.boost__beast__test__fail_count.fail_count.overload2 more...]]`````[section:overload1 test::fail_count::fail_count (1 of 2 overloads)][heading Synopsis]```fail_count(    fail_count&&);```[heading Description][endsect][section:overload2 test::fail_count::fail_count (2 of 2 overloads)]
Construct a counter. [heading Synopsis]```fail_count(    std::size_t n,    error_code ev = error::test_failure);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`n`][    
The 0-based index of the operation to fail on or after   ]]  [[`ev`][    
An optional error code to use when generating a simulated failure   ]]]
[endsect][endsect][endsect][section:boost__beast__test__fail_handler test::fail_handler][indexterm1 test::fail_handler]
Return a test CompletionHandler which requires a specific error code. [heading Synopsis]Defined in header [include_file boost/beast/_experimental/test/handler.hpp]```handlerfail_handler(    error_code ec);```[heading Description]
This handler can be invoked with any signature whose first parameter is an `error_code`. The handler fails the test if:

* The handler is destroyed without being invoked.


* The handler is invoked with an error code different from what is specified.

[heading Parameters][table [[Name][Description]]  [[`ec`][    
The error code to specify.   ]]]
[endsect][section:boost__beast__test__handler test::handler]
A CompletionHandler used for testing. [heading Synopsis]Defined in header [include_file boost/beast/_experimental/test/handler.hpp]```class handler```[heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__test__handler.handler [*handler]]]    [          ]  ]  [    [[link beast.ref.boost__beast__test__handler.operator_lp__rp_ [*operator()]]]    [          ]  ]  [    [[link beast.ref.boost__beast__test__handler.handler_dtor_ [*~handler]]]    [          ]  ]][heading Description]
This completion handler is used by tests to ensure correctness of behavior. It is designed as a single type to reduce template instantiations, with configurable settings through constructor arguments. Typically this type will be used in type lists and not instantiated directly; instances of this class are returned by the helper functions listed below.
[heading See Also]
[link beast.ref.boost__beast__test__success_handler `test::success_handler`], [link beast.ref.boost__beast__test__fail_handler `test::fail_handler`], [link beast.ref.boost__beast__test__any_handler `test::any_handler`] 
[section:handler test::handler::handler][indexterm2 handler..test::handler]`````[link beast.ref.boost__beast__test__handler.handler.overload1 handler]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__test__handler.handler.overload1 more...]]``explicit``[link beast.ref.boost__beast__test__handler.handler.overload2 handler]``(    error_code ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__test__handler.handler.overload2 more...]]``explicit``[link beast.ref.boost__beast__test__handler.handler.overload3 handler]``(    boost::none_t);  ``[''''&raquo;''' [link beast.ref.boost__beast__test__handler.handler.overload3 more...]]````[link beast.ref.boost__beast__test__handler.handler.overload4 handler]``(    handler&& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__test__handler.handler.overload4 more...]]`````[section:overload1 test::handler::handler (1 of 4 overloads)][heading Synopsis]```handler();```[heading Description][endsect][section:overload2 test::handler::handler (2 of 4 overloads)][heading Synopsis]```handler(    error_code ec);```[heading Description][endsect][section:overload3 test::handler::handler (3 of 4 overloads)][heading Synopsis]```handler(    boost::none_t);```[heading Description][endsect][section:overload4 test::handler::handler (4 of 4 overloads)][heading Synopsis]```handler(    handler&& other);```[heading Description][endsect][endsect][section:operator_lp__rp_ test::handler::operator()][indexterm2 operator()..test::handler]```template<    class... Args>void``[link beast.ref.boost__beast__test__handler.operator_lp__rp_.overload1 operator()]``(    error_code ec,    Args&& ...);  ``[''''&raquo;''' [link beast.ref.boost__beast__test__handler.operator_lp__rp_.overload1 more...]]``void``[link beast.ref.boost__beast__test__handler.operator_lp__rp_.overload2 operator()]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__test__handler.operator_lp__rp_.overload2 more...]]``template<    class Arg0,    class... Args,    [role red error.class-detail-template.1][role red error.class-detail-template.2] = typename std::enable_if<            ! std::is_convertible<Arg0, error_code>::value>::type>void``[link beast.ref.boost__beast__test__handler.operator_lp__rp_.overload3 operator()]``(    Arg0&&,    Args&& ...);  ``[''''&raquo;''' [link beast.ref.boost__beast__test__handler.operator_lp__rp_.overload3 more...]]`````[section:overload1 test::handler::operator() (1 of 3 overloads)][heading Synopsis]```template<    class... Args>voidoperator()(    error_code ec,    Args&& ...);```[heading Description][endsect][section:overload2 test::handler::operator() (2 of 3 overloads)][heading Synopsis]```voidoperator()();```[heading Description][endsect][section:overload3 test::handler::operator() (3 of 3 overloads)][heading Synopsis]```template<    class Arg0,    class... Args,    [role red error.class-detail-template.1][role red error.class-detail-template.2] = typename std::enable_if<            ! std::is_convertible<Arg0, error_code>::value>::type>voidoperator()(    Arg0&&,    Args&& ...);```[heading Description][endsect][endsect][section:handler_dtor_ test::handler::~handler][indexterm2 ~handler..test::handler][heading Synopsis]```~handler();```[heading Description][endsect][endsect][section:boost__beast__test__run test::run][indexterm1 test::run]
Run an I/O context. [heading Synopsis]Defined in header [include_file boost/beast/_experimental/test/handler.hpp]```voidrun(    net::io_context& ioc);```[heading Description]
This function runs and dispatches handlers on the specified I/O context, until one of the following conditions is true:

* The I/O context runs out of work.

[heading Parameters][table [[Name][Description]]  [[`ioc`][    
The I/O context to run   ]]]
[endsect][section:boost__beast__test__run_for test::run_for][indexterm1 test::run_for]
Run an I/O context for a certain amount of time. [heading Synopsis]Defined in header [include_file boost/beast/_experimental/test/handler.hpp]```template<    class Rep,    class Period>voidrun_for(    net::io_context& ioc,    std::chrono::duration< Rep, Period > elapsed);```[heading Description]
This function runs and dispatches handlers on the specified I/O context, until one of the following conditions is true:

* The I/O context runs out of work.


* No completions occur and the specified amount of time has elapsed.

[heading Parameters][table [[Name][Description]]  [[`ioc`][    
The I/O context to run  ]]  [[`elapsed`][    
The maximum amount of time to run for.   ]]]
[endsect][section:boost__beast__test__stream test::stream]
A two-way socket useful for unit testing. [heading Synopsis]Defined in header [include_file boost/beast/_experimental/test/stream.hpp]```class stream```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__test__stream.buffer_type [*buffer_type]]]    [          ]  ]  [    [[link beast.ref.boost__beast__test__stream.executor_type [*executor_type]]]    [      The type of the executor associated with the object.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__test__stream.append [*append]]]    [      Appends a string to the pending input data.     ]  ]  [    [[link beast.ref.boost__beast__test__stream.async_read_some [*async_read_some]]]    [      Start an asynchronous read.     ]  ]  [    [[link beast.ref.boost__beast__test__stream.async_write_some [*async_write_some]]]    [      Start an asynchronous write.     ]  ]  [    [[link beast.ref.boost__beast__test__stream.buffer [*buffer]]]    [      Direct input buffer access.     ]  ]  [    [[link beast.ref.boost__beast__test__stream.clear [*clear]]]    [      Clear the pending input area.     ]  ]  [    [[link beast.ref.boost__beast__test__stream.close [*close]]]    [      Close the stream.     ]  ]  [    [[link beast.ref.boost__beast__test__stream.close_remote [*close_remote]]]    [      Close the other end of the stream.     ]  ]  [    [[link beast.ref.boost__beast__test__stream.connect [*connect]]]    [      Establish a connection.     ]  ]  [    [[link beast.ref.boost__beast__test__stream.get_executor [*get_executor]]]    [      Return the executor associated with the object.     ]  ]  [    [[link beast.ref.boost__beast__test__stream.nread [*nread]]]    [      Return the number of reads.     ]  ]  [    [[link beast.ref.boost__beast__test__stream.nread_bytes [*nread_bytes]]]    [      Return the number of bytes read.     ]  ]  [    [[link beast.ref.boost__beast__test__stream.nwrite [*nwrite]]]    [      Return the number of writes.     ]  ]  [    [[link beast.ref.boost__beast__test__stream.nwrite_bytes [*nwrite_bytes]]]    [      Return the number of bytes written.     ]  ]  [    [[link beast.ref.boost__beast__test__stream.operator_eq_ [*operator=]]]    [      Move Assignment.     ]  ]  [    [[link beast.ref.boost__beast__test__stream.read_size [*read_size]]]    [      Set the maximum number of bytes returned by read_some.     ]  ]  [    [[link beast.ref.boost__beast__test__stream.read_some [*read_some]]]    [      Read some data from the stream.     ]  ]  [    [[link beast.ref.boost__beast__test__stream.str [*str]]]    [      Returns a string view representing the pending input data.     ]  ]  [    [[link beast.ref.boost__beast__test__stream.stream [*stream]]]    [      Move Constructor.       Construct a stream.     ]  ]  [    [[link beast.ref.boost__beast__test__stream.write_size [*write_size]]]    [      Set the maximum number of bytes returned by write_some.     ]  ]  [    [[link beast.ref.boost__beast__test__stream.write_some [*write_some]]]    [      Write some data to the stream.     ]  ]  [    [[link beast.ref.boost__beast__test__stream.stream_dtor_ [*~stream]]]    [      Destructor.     ]  ]][heading Description]
An instance of this class simulates a traditional socket, while also providing features useful for unit testing. Each endpoint maintains an independent buffer called the input area. Writes from one endpoint append data to the peer's pending input area. When an endpoint performs a read and data is present in the input area, the data is delivered to the blocking or asynchronous operation. Otherwise the operation is blocked or deferred until data is made available, or until the endpoints become disconnected.
These streams may be used anywhere an algorithm accepts a reference to a synchronous or asynchronous read or write stream. It is possible to use a test stream in a call to `net::read_until`, or in a call to [link beast.ref.boost__beast__http__async_write `http::async_write`] for example.
As with Boost.Asio I/O objects, a [link beast.ref.boost__beast__test__stream `test::stream`] constructs with a reference to the `net::io_context` to use for handling asynchronous I/O. For asynchronous operations, the stream follows the same rules as a traditional asio socket with respect to how completion handlers for asynchronous operations are performed.
To facilitate testing, these streams support some additional features:

* The input area, represented by a [link beast.ref.boost__beast__basic_flat_buffer `basic_flat_buffer`], may be directly accessed by the caller to inspect the contents before or after the remote endpoint writes data. This allows a unit test to verify that the received data matches.


* Data may be manually appended to the input area. This data will delivered in the next call to [link beast.ref.boost__beast__test__stream.read_some `test::stream::read_some`] or [link beast.ref.boost__beast__test__stream.async_read_some `test::stream::async_read_some`]. This allows predefined test vectors to be set up for testing read algorithms.


* The stream may be constructed with a fail count. The stream will eventually fail with a predefined error after a certain number of operations, where the number of operations is controlled by the test. When a test loops over a range of operation counts, it is possible to exercise every possible point of failure in the algorithm being tested. When used correctly the technique allows the tests to reach a high percentage of code coverage.

[heading Thread Safety]
['Distinct] ['objects:] Safe.['Shared] ['objects:] Unsafe. The application must also ensure that all asynchronous operations are performed within the same implicit or explicit strand.
[heading Concepts]

* ['SyncReadStream] 
* ['SyncWriteStream] 
* ['AsyncReadStream] 
* ['AsyncWriteStream] 


[section:append test::stream::append][indexterm2 append..test::stream]
Appends a string to the pending input data. [heading Synopsis]```voidappend(    string_view s);```[heading Description][endsect][section:async_read_some test::stream::async_read_some][indexterm2 async_read_some..test::stream]
Start an asynchronous read. [heading Synopsis]```template<    class __MutableBufferSequence__,    class __ReadHandler__>``__deduced__``async_read_some(    MutableBufferSequence const& buffers,    ReadHandler&& handler);```[heading Description]
This function is used to asynchronously read one or more bytes of data from the stream. The function call always returns immediately.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The buffers into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying buffers is retained by the caller, which must guarantee that they remain valid until the handler is called.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      error_code const& ec,           // Result of operation.
      std::size_t bytes_transferred   // Number of bytes read.
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.  ]]]
[heading Remarks]
The `async_read_some` operation may not read all of the requested number of bytes. Consider using the function `net::async_read` if you need to ensure that the requested amount of data is read before the asynchronous operation completes. 
[endsect][section:async_write_some test::stream::async_write_some][indexterm2 async_write_some..test::stream]
Start an asynchronous write. [heading Synopsis]```template<    class __ConstBufferSequence__,    class __WriteHandler__>``__deduced__``async_write_some(    ConstBufferSequence const& buffers,    WriteHandler&& handler);```[heading Description]
This function is used to asynchronously write one or more bytes of data to the stream. The function call always returns immediately.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The data to be written to the stream. Although the buffers object may be copied as necessary, ownership of the underlying buffers is retained by the caller, which must guarantee that they remain valid until the handler is called.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      error_code const& ec,           // Result of operation.
      std::size_t bytes_transferred   // Number of bytes written.
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.  ]]]
[heading Remarks]
The `async_write_some` operation may not transmit all of the data to the peer. Consider using the function `net::async_write` if you need to ensure that all data is written before the asynchronous operation completes. 
[endsect][section:buffer test::stream::buffer][indexterm2 buffer..test::stream]
Direct input buffer access. [heading Synopsis]```buffer_type&buffer();```[heading Description][endsect][section:buffer_type test::stream::buffer_type][indexterm2 buffer_type..test::stream][heading Synopsis]```using buffer_type = flat_buffer;```[heading Description][endsect][section:clear test::stream::clear][indexterm2 clear..test::stream]
Clear the pending input area. [heading Synopsis]```voidclear();```[heading Description][endsect][section:close test::stream::close][indexterm2 close..test::stream]
Close the stream. [heading Synopsis]```voidclose();```[heading Description]
The other end of the connection will see `error::eof` after reading all the remaining data. [endsect][section:close_remote test::stream::close_remote][indexterm2 close_remote..test::stream]
Close the other end of the stream. [heading Synopsis]```voidclose_remote();```[heading Description]
This end of the connection will see `error::eof` after reading all the remaining data. [endsect][section:connect test::stream::connect][indexterm2 connect..test::stream]
Establish a connection. [heading Synopsis]```voidconnect(    stream& remote);```[heading Description][endsect][section:executor_type test::stream::executor_type][indexterm2 executor_type..test::stream]
The type of the executor associated with the object. [heading Synopsis]```using executor_type = net::io_context::executor_type;```[heading Description][endsect][section:get_executor test::stream::get_executor][indexterm2 get_executor..test::stream]
Return the executor associated with the object. [heading Synopsis]```executor_typeget_executor();```[heading Description][endsect][section:nread test::stream::nread][indexterm2 nread..test::stream]
Return the number of reads. [heading Synopsis]```std::size_tnread() const;```[heading Description][endsect][section:nread_bytes test::stream::nread_bytes][indexterm2 nread_bytes..test::stream]
Return the number of bytes read. [heading Synopsis]```std::size_tnread_bytes() const;```[heading Description][endsect][section:nwrite test::stream::nwrite][indexterm2 nwrite..test::stream]
Return the number of writes. [heading Synopsis]```std::size_tnwrite() const;```[heading Description][endsect][section:nwrite_bytes test::stream::nwrite_bytes][indexterm2 nwrite_bytes..test::stream]
Return the number of bytes written. [heading Synopsis]```std::size_tnwrite_bytes() const;```[heading Description][endsect][section:operator_eq_ test::stream::operator=][indexterm2 operator=..test::stream]
Move Assignment. [heading Synopsis]```stream&operator=(    stream&& other);```[heading Description]
Moving the stream while asynchronous operations are pending results in undefined behavior. [endsect][section:read_size test::stream::read_size][indexterm2 read_size..test::stream]
Set the maximum number of bytes returned by read\_some. [heading Synopsis]```voidread_size(    std::size_t n);```[heading Description][endsect][section:read_some test::stream::read_some][indexterm2 read_some..test::stream]
Read some data from the stream. ```template<    class __MutableBufferSequence__>std::size_t``[link beast.ref.boost__beast__test__stream.read_some.overload1 read_some]``(    MutableBufferSequence const& buffers);  ``[''''&raquo;''' [link beast.ref.boost__beast__test__stream.read_some.overload1 more...]]``template<    class __MutableBufferSequence__>std::size_t``[link beast.ref.boost__beast__test__stream.read_some.overload2 read_some]``(    MutableBufferSequence const& buffers,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__test__stream.read_some.overload2 more...]]`````[section:overload1 test::stream::read_some (1 of 2 overloads)]
Read some data from the stream. [heading Synopsis]```template<    class __MutableBufferSequence__>std::size_tread_some(    MutableBufferSequence const& buffers);```[heading Description]
This function is used to read data from the stream. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The buffers into which the data will be read.  ]]]
[heading Return Value]
The number of bytes read.
[heading Exceptions][table [[Type][Thrown On]]  [[`boost::system::system_error`][    
Thrown on failure.  ]]]
[heading Remarks]
The `read_some` operation may not read all of the requested number of bytes. Consider using the function `net::read` if you need to ensure that the requested amount of data is read before the blocking operation completes. 
[endsect][section:overload2 test::stream::read_some (2 of 2 overloads)]
Read some data from the stream. [heading Synopsis]```template<    class __MutableBufferSequence__>std::size_tread_some(    MutableBufferSequence const& buffers,    error_code& ec);```[heading Description]
This function is used to read data from the stream. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The buffers into which the data will be read.  ]]  [[`ec`][    
Set to indicate what error occurred, if any.  ]]]
[heading Return Value]
The number of bytes read.
[heading Remarks]
The `read_some` operation may not read all of the requested number of bytes. Consider using the function `net::read` if you need to ensure that the requested amount of data is read before the blocking operation completes. 
[endsect][endsect][section:str test::stream::str][indexterm2 str..test::stream]
Returns a string view representing the pending input data. [heading Synopsis]```string_viewstr() const;```[heading Description][endsect][section:stream test::stream::stream][indexterm2 stream..test::stream]
Move Constructor. `````[link beast.ref.boost__beast__test__stream.stream.overload1 stream]``(    stream&& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__test__stream.stream.overload1 more...]]`````
Construct a stream. ```explicit``[link beast.ref.boost__beast__test__stream.stream.overload2 stream]``(    net::io_context& ioc);  ``[''''&raquo;''' [link beast.ref.boost__beast__test__stream.stream.overload2 more...]]````[link beast.ref.boost__beast__test__stream.stream.overload3 stream]``(    net::io_context& ioc,    fail_count& fc);  ``[''''&raquo;''' [link beast.ref.boost__beast__test__stream.stream.overload3 more...]]````[link beast.ref.boost__beast__test__stream.stream.overload4 stream]``(    net::io_context& ioc,    string_view s);  ``[''''&raquo;''' [link beast.ref.boost__beast__test__stream.stream.overload4 more...]]````[link beast.ref.boost__beast__test__stream.stream.overload5 stream]``(    net::io_context& ioc,    fail_count& fc,    string_view s);  ``[''''&raquo;''' [link beast.ref.boost__beast__test__stream.stream.overload5 more...]]`````[section:overload1 test::stream::stream (1 of 5 overloads)]
Move Constructor. [heading Synopsis]```stream(    stream&& other);```[heading Description]
Moving the stream while asynchronous operations are pending results in undefined behavior. [endsect][section:overload2 test::stream::stream (2 of 5 overloads)]
Construct a stream. [heading Synopsis]```stream(    net::io_context& ioc);```[heading Description]
The stream will be created in a disconnected state.
[heading Parameters][table [[Name][Description]]  [[`ioc`][    
The `io_context` object that the stream will use to dispatch handlers for any asynchronous operations.   ]]]
[endsect][section:overload3 test::stream::stream (3 of 5 overloads)]
Construct a stream. [heading Synopsis]```stream(    net::io_context& ioc,    fail_count& fc);```[heading Description]
The stream will be created in a disconnected state.
[heading Parameters][table [[Name][Description]]  [[`ioc`][    
The `io_context` object that the stream will use to dispatch handlers for any asynchronous operations.  ]]  [[`fc`][    
The [link beast.ref.boost__beast__test__fail_count `test::fail_count`] to associate with the stream. Each I/O operation performed on the stream will increment the fail count. When the fail count reaches its internal limit, a simulated failure error will be raised.   ]]]
[endsect][section:overload4 test::stream::stream (4 of 5 overloads)]
Construct a stream. [heading Synopsis]```stream(    net::io_context& ioc,    string_view s);```[heading Description]
The stream will be created in a disconnected state.
[heading Parameters][table [[Name][Description]]  [[`ioc`][    
The `io_context` object that the stream will use to dispatch handlers for any asynchronous operations.  ]]  [[`s`][    
A string which will be appended to the input area, not including the null terminator.   ]]]
[endsect][section:overload5 test::stream::stream (5 of 5 overloads)]
Construct a stream. [heading Synopsis]```stream(    net::io_context& ioc,    fail_count& fc,    string_view s);```[heading Description]
The stream will be created in a disconnected state.
[heading Parameters][table [[Name][Description]]  [[`ioc`][    
The `io_context` object that the stream will use to dispatch handlers for any asynchronous operations.  ]]  [[`fc`][    
The [link beast.ref.boost__beast__test__fail_count `test::fail_count`] to associate with the stream. Each I/O operation performed on the stream will increment the fail count. When the fail count reaches its internal limit, a simulated failure error will be raised.  ]]  [[`s`][    
A string which will be appended to the input area, not including the null terminator.   ]]]
[endsect][endsect][section:write_size test::stream::write_size][indexterm2 write_size..test::stream]
Set the maximum number of bytes returned by write\_some. [heading Synopsis]```voidwrite_size(    std::size_t n);```[heading Description][endsect][section:write_some test::stream::write_some][indexterm2 write_some..test::stream]
Write some data to the stream. ```template<    class __ConstBufferSequence__>std::size_t``[link beast.ref.boost__beast__test__stream.write_some.overload1 write_some]``(    ConstBufferSequence const& buffers);  ``[''''&raquo;''' [link beast.ref.boost__beast__test__stream.write_some.overload1 more...]]``template<    class __ConstBufferSequence__>std::size_t``[link beast.ref.boost__beast__test__stream.write_some.overload2 write_some]``(    ConstBufferSequence const& buffers,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__test__stream.write_some.overload2 more...]]`````[section:overload1 test::stream::write_some (1 of 2 overloads)]
Write some data to the stream. [heading Synopsis]```template<    class __ConstBufferSequence__>std::size_twrite_some(    ConstBufferSequence const& buffers);```[heading Description]
This function is used to write data on the stream. The function call will block until one or more bytes of data has been written successfully, or until an error occurs.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The data to be written.  ]]]
[heading Return Value]
The number of bytes written.
[heading Exceptions][table [[Type][Thrown On]]  [[`boost::system::system_error`][    
Thrown on failure.  ]]]
[heading Remarks]
The `write_some` operation may not transmit all of the data to the peer. Consider using the function `net::write` if you need to ensure that all data is written before the blocking operation completes. 
[endsect][section:overload2 test::stream::write_some (2 of 2 overloads)]
Write some data to the stream. [heading Synopsis]```template<    class __ConstBufferSequence__>std::size_twrite_some(    ConstBufferSequence const& buffers,    error_code& ec);```[heading Description]
This function is used to write data on the stream. The function call will block until one or more bytes of data has been written successfully, or until an error occurs.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The data to be written.  ]]  [[`ec`][    
Set to indicate what error occurred, if any.  ]]]
[heading Return Value]
The number of bytes written.
[heading Remarks]
The `write_some` operation may not transmit all of the data to the peer. Consider using the function `net::write` if you need to ensure that all data is written before the blocking operation completes. 
[endsect][endsect][section:stream_dtor_ test::stream::~stream][indexterm2 ~stream..test::stream]
Destructor. [heading Synopsis]```~stream();```[heading Description]
If an asynchronous read operation is pending, it will simply be discarded with no notification to the completion handler.
If a connection is established while the stream is destroyed, the peer will see the error `net::error::connection_reset` when performing any reads or writes. [endsect][endsect][section:boost__beast__test__stream__read_op test::stream::read_op][heading Synopsis]Defined in header [include_file boost/beast/_experimental/test/stream.hpp]```template<    class __Handler__,    class Buffers>class read_op```[heading Description][endsect][section:boost__beast__test__stream__read_op_base test::stream::read_op_base][heading Synopsis]Defined in header [include_file boost/beast/_experimental/test/stream.hpp]```struct read_op_base```[heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__test__stream__read_op_base.operator_lp__rp_ [*operator()]]]    [          ]  ]  [    [[link beast.ref.boost__beast__test__stream__read_op_base.read_op_base_dtor_ [*~read_op_base]]]    [          ]  ]][heading Description][section:operator_lp__rp_ test::stream::read_op_base::operator()][indexterm2 operator()..test::stream::read_op_base][heading Synopsis]```voidoperator()(    error_code ec);```[heading Description][endsect][section:read_op_base_dtor_ test::stream::read_op_base::~read_op_base][indexterm2 ~read_op_base..test::stream::read_op_base][heading Synopsis]```virtual~read_op_base();```[heading Description][endsect][endsect][section:boost__beast__test__stream__state test::stream::state][heading Synopsis]Defined in header [include_file boost/beast/_experimental/test/stream.hpp]```struct state```[heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__test__stream__state.cancel_read [*cancel_read]]]    [          ]  ]  [    [[link beast.ref.boost__beast__test__stream__state.notify_read [*notify_read]]]    [          ]  ]  [    [[link beast.ref.boost__beast__test__stream__state.remove [*remove]]]    [          ]  ]  [    [[link beast.ref.boost__beast__test__stream__state.state [*state]]]    [          ]  ]  [    [[link beast.ref.boost__beast__test__stream__state.state_dtor_ [*~state]]]    [          ]  ]][heading Data Members][table [[Name][Description]]  [    [[link beast.ref.boost__beast__test__stream__state.b [*b]]]    [          ]  ]  [    [[link beast.ref.boost__beast__test__stream__state.code [*code]]]    [          ]  ]  [    [[link beast.ref.boost__beast__test__stream__state.cv [*cv]]]    [          ]  ]  [    [[link beast.ref.boost__beast__test__stream__state.fc [*fc]]]    [          ]  ]  [    [[link beast.ref.boost__beast__test__stream__state.ioc [*ioc]]]    [          ]  ]  [    [[link beast.ref.boost__beast__test__stream__state.m [*m]]]    [          ]  ]  [    [[link beast.ref.boost__beast__test__stream__state.nread [*nread]]]    [          ]  ]  [    [[link beast.ref.boost__beast__test__stream__state.nread_bytes [*nread_bytes]]]    [          ]  ]  [    [[link beast.ref.boost__beast__test__stream__state.nwrite [*nwrite]]]    [          ]  ]  [    [[link beast.ref.boost__beast__test__stream__state.nwrite_bytes [*nwrite_bytes]]]    [          ]  ]  [    [[link beast.ref.boost__beast__test__stream__state.op [*op]]]    [          ]  ]  [    [[link beast.ref.boost__beast__test__stream__state.read_max [*read_max]]]    [          ]  ]  [    [[link beast.ref.boost__beast__test__stream__state.wp [*wp]]]    [          ]  ]  [    [[link beast.ref.boost__beast__test__stream__state.write_max [*write_max]]]    [          ]  ]][heading Description][section:b test::stream::state::b][indexterm2 b..test::stream::state][heading Synopsis]```flat_buffer b;```[heading Description][endsect][section:cancel_read test::stream::state::cancel_read][indexterm2 cancel_read..test::stream::state][heading Synopsis]```voidcancel_read();```[heading Description][endsect][section:code test::stream::state::code][indexterm2 code..test::stream::state][heading Synopsis]```status code = status::ok;```[heading Description][endsect][section:cv test::stream::state::cv][indexterm2 cv..test::stream::state][heading Synopsis]```std::condition_variable cv;```[heading Description][endsect][section:fc test::stream::state::fc][indexterm2 fc..test::stream::state][heading Synopsis]```fail_count * fc = nullptr;```[heading Description][endsect][section:ioc test::stream::state::ioc][indexterm2 ioc..test::stream::state][heading Synopsis]```net::io_context & ioc;```[heading Description][endsect][section:m test::stream::state::m][indexterm2 m..test::stream::state][heading Synopsis]```std::mutex m;```[heading Description][endsect][section:notify_read test::stream::state::notify_read][indexterm2 notify_read..test::stream::state][heading Synopsis]```voidnotify_read();```[heading Description][endsect][section:nread test::stream::state::nread][indexterm2 nread..test::stream::state][heading Synopsis]```std::size_t nread = 0;```[heading Description][endsect][section:nread_bytes test::stream::state::nread_bytes][indexterm2 nread_bytes..test::stream::state][heading Synopsis]```std::size_t nread_bytes = 0;```[heading Description][endsect][section:nwrite test::stream::state::nwrite][indexterm2 nwrite..test::stream::state][heading Synopsis]```std::size_t nwrite = 0;```[heading Description][endsect][section:nwrite_bytes test::stream::state::nwrite_bytes][indexterm2 nwrite_bytes..test::stream::state][heading Synopsis]```std::size_t nwrite_bytes = 0;```[heading Description][endsect][section:op test::stream::state::op][indexterm2 op..test::stream::state][heading Synopsis]```std::unique_ptr< read_op_base > op;```[heading Description][endsect][section:read_max test::stream::state::read_max][indexterm2 read_max..test::stream::state][heading Synopsis]```std::size_t read_max =
            (std::numeric_limits<std::size_t>::max)();```[heading Description][endsect][section:remove test::stream::state::remove][indexterm2 remove..test::stream::state][heading Synopsis]```voidremove();```[heading Description][endsect][section:state test::stream::state::state][indexterm2 state..test::stream::state][heading Synopsis]```state(    net::io_context& ioc_,    boost::weak_ptr< service_impl > wp_,    fail_count* fc_);```[heading Description][endsect][section:wp test::stream::state::wp][indexterm2 wp..test::stream::state][heading Synopsis]```boost::weak_ptr< service_impl > wp;```[heading Description][endsect][section:write_max test::stream::state::write_max][indexterm2 write_max..test::stream::state][heading Synopsis]```std::size_t write_max =
            (std::numeric_limits<std::size_t>::max)();```[heading Description][endsect][section:state_dtor_ test::stream::state::~state][indexterm2 ~state..test::stream::state][heading Synopsis]```~state();```[heading Description][endsect][endsect][section:boost__beast__test__success_handler test::success_handler][indexterm1 test::success_handler]
Return a test CompletionHandler which requires success. [heading Synopsis]Defined in header [include_file boost/beast/_experimental/test/handler.hpp]```handlersuccess_handler();```[heading Description]
The returned handler can be invoked with any signature whose first parameter is an `error_code`. The handler fails the test if:

* The handler is destroyed without being invoked, or


* The handler is invoked with a non-successful error code. 

[endsect][section:boost__beast__to_static_string to_static_string][indexterm1 to_static_string]
Returns a static string representing an integer as a decimal. [heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    class Integer>static_string< detail::max_digits(sizeof(Integer))>to_static_string(    Integer x);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`x`][    
The signed or unsigned integer to convert. This must be an integral type.  ]]]
[heading Return Value]
A [link beast.ref.boost__beast__static_string `static_string`] with an implementation defined maximum size large enough to hold the longest possible decimal representation of any integer of the given type. 
Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__unlimited_rate_policy unlimited_rate_policy]
A rate policy with unlimited throughput. [heading Synopsis]Defined in header [include_file boost/beast/core/rate_policy.hpp]```class unlimited_rate_policy```[heading Description]
This rate policy object does not apply any rate limit.
[heading Concepts]


* ['RatePolicy]

[heading See Also]
[link beast.ref.boost__beast__basic_stream `basic_stream`], [link beast.ref.boost__beast__tcp_stream `tcp_stream`] 
Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__websocket__async_teardown websocket::async_teardown][indexterm1 websocket::async_teardown]
Start tearing down a connection. ```template<    class Socket,    class TeardownHandler>void``[link beast.ref.boost__beast__websocket__async_teardown.overload1 async_teardown]``(    role_type role,    Socket& socket,    TeardownHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__async_teardown.overload1 more...]]`````
Start tearing down a `net::ip::tcp::socket`. ```template<    class __Protocol__,    class __Executor__,    class TeardownHandler>void``[link beast.ref.boost__beast__websocket__async_teardown.overload2 async_teardown]``(    role_type role,    net::basic_stream_socket< Protocol, Executor >& socket,    TeardownHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__async_teardown.overload2 more...]]`````[section:overload1 websocket::async_teardown (1 of 2 overloads)]
Start tearing down a connection. [heading Synopsis]Defined in header [include_file boost/beast/websocket/teardown.hpp]```template<    class Socket,    class TeardownHandler>voidasync_teardown(    role_type role,    Socket& socket,    TeardownHandler&& handler);```[heading Description]
This begins tearing down a connection asynchronously. The implementation will call the overload of this function based on the `Socket` parameter used to consruct the socket. When `Stream` is a user defined type, and not a `net::ip::tcp::socket` or any `net::ssl::stream`, callers are responsible for providing a suitable overload of this function.
[heading Parameters][table [[Name][Description]]  [[`role`][    
The role of the local endpoint  ]]  [[`socket`][    
The socket to tear down.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      error_code const& error // result of operation
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.   ]]]
Convenience header [include_file boost/beast/websocket.hpp][endsect][section:overload2 websocket::async_teardown (2 of 2 overloads)]
Start tearing down a `net::ip::tcp::socket`. [heading Synopsis]Defined in header [include_file boost/beast/websocket/teardown.hpp]```template<    class __Protocol__,    class __Executor__,    class TeardownHandler>voidasync_teardown(    role_type role,    net::basic_stream_socket< Protocol, Executor >& socket,    TeardownHandler&& handler);```[heading Description]
This begins tearing down a connection asynchronously. The implementation will call the overload of this function based on the `Stream` parameter used to consruct the socket. When `Stream` is a user defined type, and not a `net::ip::tcp::socket` or any `net::ssl::stream`, callers are responsible for providing a suitable overload of this function.
[heading Parameters][table [[Name][Description]]  [[`role`][    
The role of the local endpoint  ]]  [[`socket`][    
The socket to tear down.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      error_code const& error // result of operation
  );
```  ]]]
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`. Convenience header [include_file boost/beast/websocket.hpp][endsect][endsect][section:boost__beast__websocket__close_code websocket::close_code][indexterm1 websocket::close_code]
Close status codes. [heading Synopsis]Defined in header [include_file boost/beast/websocket/rfc6455.hpp]```enum close_code```[indexterm2 normal..websocket::close_code][indexterm2 going_away..websocket::close_code][indexterm2 protocol_error..websocket::close_code][indexterm2 unknown_data..websocket::close_code][indexterm2 bad_payload..websocket::close_code][indexterm2 policy_error..websocket::close_code][indexterm2 too_big..websocket::close_code][indexterm2 needs_extension..websocket::close_code][indexterm2 internal_error..websocket::close_code][indexterm2 service_restart..websocket::close_code][indexterm2 try_again_later..websocket::close_code][indexterm2 none..websocket::close_code][indexterm2 reserved1..websocket::close_code][indexterm2 no_status..websocket::close_code][indexterm2 abnormal..websocket::close_code][indexterm2 reserved2..websocket::close_code][indexterm2 reserved3..websocket::close_code][heading Values][table [[Name][Description]]  [[[^normal]][Normal closure; the connection successfully completed whatever purpose for which it was created. ]]  [[[^going_away]][The endpoint is going away, either because of a server failure or because the browser is navigating away from the page that opened the connection. ]]  [[[^protocol_error]][The endpoint is terminating the connection due to a protocol error. ]]  [[[^unknown_data]][The connection is being terminated because the endpoint received data of a type it cannot accept (for example, a text-only endpoint received binary data). ]]  [[[^bad_payload]][The endpoint is terminating the connection because a message was received that contained inconsistent data (e.g., non-UTF-8 data within a text message). ]]  [[[^policy_error]][The endpoint is terminating the connection because it received a message that violates its policy. This is a generic status code, used when codes 1003 and 1009 are not suitable. ]]  [[[^too_big]][The endpoint is terminating the connection because a data frame was received that is too large. ]]  [[[^needs_extension]][The client is terminating the connection because it expected the server to negotiate one or more extension, but the server didn't. ]]  [[[^internal_error]][The server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request. ]]  [[[^service_restart]][The server is terminating the connection because it is restarting. ]]  [[[^try_again_later]][The server is terminating the connection due to a temporary condition, e.g. it is overloaded and is casting off some of its clients. ]]  [[[^none]][Used internally to mean "no error". This code is reserved and may not be sent.
 ]]  [[[^reserved1]][Reserved for future use by the WebSocket standard. This code is reserved and may not be sent.
 ]]  [[[^no_status]][No status code was provided even though one was expected. This code is reserved and may not be sent.
 ]]  [[[^abnormal]][Connection was closed without receiving a close frame. This code is reserved and may not be sent.
 ]]  [[[^reserved2]][Reserved for future use by the WebSocket standard. This code is reserved and may not be sent.
 ]]  [[[^reserved3]][Reserved for future use by the WebSocket standard. This code is reserved and may not be sent.
 ]]][heading Description]
These codes accompany close frames.
[heading See Also]
[@https://tools.ietf.org/html/rfc6455#section-7.4.1 RFC 6455 7.4.1 Defined Status Codes] 
Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__close_reason websocket::close_reason]
Description of the close reason. [heading Synopsis]Defined in header [include_file boost/beast/websocket/rfc6455.hpp]```struct close_reason```[heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__websocket__close_reason.close_reason [*close_reason]]]    [      Default constructor.       Construct from a code.       Construct from a reason string. code is close_code::normal.       Construct from a reason string literal. code is close_code::normal.       Construct from a close code and reason string.     ]  ]  [    [[link beast.ref.boost__beast__websocket__close_reason.operator_bool [*operator bool]]]    [      Returns true if a code was specified.     ]  ]][heading Data Members][table [[Name][Description]]  [    [[link beast.ref.boost__beast__websocket__close_reason.code [*code]]]    [      The close code.     ]  ]  [    [[link beast.ref.boost__beast__websocket__close_reason.reason [*reason]]]    [      The optional utf8-encoded reason string.     ]  ]][heading Description]
This object stores the close code (if any) and the optional utf-8 encoded implementation defined reason string. [section:close_reason websocket::close_reason::close_reason][indexterm2 close_reason..websocket::close_reason]
Default constructor. `````[link beast.ref.boost__beast__websocket__close_reason.close_reason.overload1 close_reason]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__close_reason.close_reason.overload1 more...]]`````
Construct from a code. `````[link beast.ref.boost__beast__websocket__close_reason.close_reason.overload2 close_reason]``(    std::uint16_t code_);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__close_reason.close_reason.overload2 more...]]`````
Construct from a reason string. code is close\_code::normal. `````[link beast.ref.boost__beast__websocket__close_reason.close_reason.overload3 close_reason]``(    string_view s);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__close_reason.close_reason.overload3 more...]]`````
Construct from a reason string literal. code is close\_code::normal. `````[link beast.ref.boost__beast__websocket__close_reason.close_reason.overload4 close_reason]``(    char const* s);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__close_reason.close_reason.overload4 more...]]`````
Construct from a close code and reason string. `````[link beast.ref.boost__beast__websocket__close_reason.close_reason.overload5 close_reason]``(    close_code code_,    string_view s);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__close_reason.close_reason.overload5 more...]]`````[section:overload1 websocket::close_reason::close_reason (1 of 5 overloads)]
Default constructor. [heading Synopsis]```close_reason();```[heading Description]
The code will be none. Default constructed objects will explicitly convert to bool as `false`. [endsect][section:overload2 websocket::close_reason::close_reason (2 of 5 overloads)]
Construct from a code. [heading Synopsis]```close_reason(    std::uint16_t code_);```[heading Description][endsect][section:overload3 websocket::close_reason::close_reason (3 of 5 overloads)]
Construct from a reason string. code is close\_code::normal. [heading Synopsis]```close_reason(    string_view s);```[heading Description][endsect][section:overload4 websocket::close_reason::close_reason (4 of 5 overloads)]
Construct from a reason string literal. code is close\_code::normal. [heading Synopsis]```close_reason(    char const* s);```[heading Description][endsect][section:overload5 websocket::close_reason::close_reason (5 of 5 overloads)]
Construct from a close code and reason string. [heading Synopsis]```close_reason(    close_code code_,    string_view s);```[heading Description][endsect][endsect][section:code websocket::close_reason::code][indexterm2 code..websocket::close_reason]
The close code. [heading Synopsis]```std::uint16_t code = close_code::none;```[heading Description][endsect][section:operator_bool websocket::close_reason::operator bool][indexterm2 operator bool..websocket::close_reason]
Returns `true` if a code was specified. [heading Synopsis]```operator bool() const;```[heading Description][endsect][section:reason websocket::close_reason::reason][indexterm2 reason..websocket::close_reason]
The optional utf8-encoded reason string. [heading Synopsis]```reason_string reason;```[heading Description][endsect]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__condition websocket::condition][indexterm1 websocket::condition]
Error conditions corresponding to sets of error codes. [heading Synopsis]Defined in header [include_file boost/beast/websocket/error.hpp]```enum condition```[indexterm2 handshake_failed..websocket::condition][indexterm2 protocol_violation..websocket::condition][heading Values][table [[Name][Description]]  [[[^handshake_failed]][The WebSocket handshake failed. This condition indicates that the WebSocket handshake failed. If
the corresponding HTTP response indicates the keep-alive behavior,
then the handshake may be reattempted.
 ]]  [[[^protocol_violation]][A WebSocket protocol violation occurred. This condition indicates that the remote peer on the WebSocket
connection sent data which violated the protocol.
 ]]][heading Description]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__error websocket::error][indexterm1 websocket::error]
Error codes returned from [link beast.ref.boost__beast__websocket__stream `websocket::stream`] operations. [heading Synopsis]Defined in header [include_file boost/beast/websocket/error.hpp]```enum error```[indexterm2 closed..websocket::error][indexterm2 buffer_overflow..websocket::error][indexterm2 partial_deflate_block..websocket::error][indexterm2 message_too_big..websocket::error][indexterm2 bad_http_version..websocket::error][indexterm2 bad_method..websocket::error][indexterm2 no_host..websocket::error][indexterm2 no_connection..websocket::error][indexterm2 no_connection_upgrade..websocket::error][indexterm2 no_upgrade..websocket::error][indexterm2 no_upgrade_websocket..websocket::error][indexterm2 no_sec_key..websocket::error][indexterm2 bad_sec_key..websocket::error][indexterm2 no_sec_version..websocket::error][indexterm2 bad_sec_version..websocket::error][indexterm2 no_sec_accept..websocket::error][indexterm2 bad_sec_accept..websocket::error][indexterm2 upgrade_declined..websocket::error][indexterm2 bad_opcode..websocket::error][indexterm2 bad_data_frame..websocket::error][indexterm2 bad_continuation..websocket::error][indexterm2 bad_reserved_bits..websocket::error][indexterm2 bad_control_fragment..websocket::error][indexterm2 bad_control_size..websocket::error][indexterm2 bad_unmasked_frame..websocket::error][indexterm2 bad_masked_frame..websocket::error][indexterm2 bad_size..websocket::error][indexterm2 bad_frame_payload..websocket::error][indexterm2 bad_close_code..websocket::error][indexterm2 bad_close_size..websocket::error][indexterm2 bad_close_payload..websocket::error][heading Values][table [[Name][Description]]  [[[^closed]][The WebSocket stream was gracefully closed at both endpoints. ]]  [[[^buffer_overflow]][The WebSocket operation caused a dynamic buffer overflow. ]]  [[[^partial_deflate_block]][The WebSocket stream produced an incomplete deflate block. ]]  [[[^message_too_big]][The WebSocket message exceeded the locally configured limit. ]]  [[[^bad_http_version]][The WebSocket handshake was not HTTP/1.1. Error codes with this value will compare equal to @ref condition::handshake_failed
 ]]  [[[^bad_method]][The WebSocket handshake method was not GET. Error codes with this value will compare equal to @ref condition::handshake_failed
 ]]  [[[^no_host]][The WebSocket handshake Host field is missing. Error codes with this value will compare equal to @ref condition::handshake_failed
 ]]  [[[^no_connection]][The WebSocket handshake Connection field is missing. Error codes with this value will compare equal to @ref condition::handshake_failed
 ]]  [[[^no_connection_upgrade]][The WebSocket handshake Connection field is missing the upgrade token. Error codes with this value will compare equal to @ref condition::handshake_failed
 ]]  [[[^no_upgrade]][The WebSocket handshake Upgrade field is missing. Error codes with this value will compare equal to @ref condition::handshake_failed
 ]]  [[[^no_upgrade_websocket]][The WebSocket handshake Upgrade field is missing the websocket token. Error codes with this value will compare equal to @ref condition::handshake_failed
 ]]  [[[^no_sec_key]][The WebSocket handshake Sec-WebSocket-Key field is missing. Error codes with this value will compare equal to @ref condition::handshake_failed
 ]]  [[[^bad_sec_key]][The WebSocket handshake Sec-WebSocket-Key field is invalid. Error codes with this value will compare equal to @ref condition::handshake_failed
 ]]  [[[^no_sec_version]][The WebSocket handshake Sec-WebSocket-Version field is missing. Error codes with this value will compare equal to @ref condition::handshake_failed
 ]]  [[[^bad_sec_version]][The WebSocket handshake Sec-WebSocket-Version field is invalid. Error codes with this value will compare equal to @ref condition::handshake_failed
 ]]  [[[^no_sec_accept]][The WebSocket handshake Sec-WebSocket-Accept field is missing. Error codes with this value will compare equal to @ref condition::handshake_failed
 ]]  [[[^bad_sec_accept]][The WebSocket handshake Sec-WebSocket-Accept field is invalid. Error codes with this value will compare equal to @ref condition::handshake_failed
 ]]  [[[^upgrade_declined]][The WebSocket handshake was declined by the remote peer. Error codes with this value will compare equal to @ref condition::handshake_failed
 ]]  [[[^bad_opcode]][The WebSocket frame contained an illegal opcode. Error codes with this value will compare equal to @ref condition::protocol_violation
 ]]  [[[^bad_data_frame]][The WebSocket data frame was unexpected. Error codes with this value will compare equal to @ref condition::protocol_violation
 ]]  [[[^bad_continuation]][The WebSocket continuation frame was unexpected. Error codes with this value will compare equal to @ref condition::protocol_violation
 ]]  [[[^bad_reserved_bits]][The WebSocket frame contained illegal reserved bits. Error codes with this value will compare equal to @ref condition::protocol_violation
 ]]  [[[^bad_control_fragment]][The WebSocket control frame was fragmented. Error codes with this value will compare equal to @ref condition::protocol_violation
 ]]  [[[^bad_control_size]][The WebSocket control frame size was invalid. Error codes with this value will compare equal to @ref condition::protocol_violation
 ]]  [[[^bad_unmasked_frame]][The WebSocket frame was unmasked. Error codes with this value will compare equal to @ref condition::protocol_violation
 ]]  [[[^bad_masked_frame]][The WebSocket frame was masked. Error codes with this value will compare equal to @ref condition::protocol_violation
 ]]  [[[^bad_size]][The WebSocket frame size was not canonical. Error codes with this value will compare equal to @ref condition::protocol_violation
 ]]  [[[^bad_frame_payload]][The WebSocket frame payload was not valid utf8. Error codes with this value will compare equal to @ref condition::protocol_violation
 ]]  [[[^bad_close_code]][The WebSocket close frame reason code was invalid. Error codes with this value will compare equal to @ref condition::protocol_violation
 ]]  [[[^bad_close_size]][The WebSocket close frame payload size was invalid. Error codes with this value will compare equal to @ref condition::protocol_violation
 ]]  [[[^bad_close_payload]][The WebSocket close frame payload was not valid utf8. Error codes with this value will compare equal to @ref condition::protocol_violation
 ]]][heading Description]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__frame_type websocket::frame_type][indexterm1 websocket::frame_type]
The type of received control frame. [heading Synopsis]Defined in header [include_file boost/beast/websocket/stream.hpp]```enum frame_type```[indexterm2 close..websocket::frame_type][indexterm2 ping..websocket::frame_type][indexterm2 pong..websocket::frame_type][heading Values][table [[Name][Description]]  [[[^close]][A close frame was received. ]]  [[[^ping]][A ping frame was received. ]]  [[[^pong]][A pong frame was received. ]]][heading Description]
Values of this type are passed to the control frame callback set using [link beast.ref.boost__beast__websocket__stream.control_callback `websocket::stream::control_callback`]. Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__is_upgrade websocket::is_upgrade][indexterm1 websocket::is_upgrade]
Returns `true` if the specified HTTP request is a WebSocket Upgrade. [heading Synopsis]Defined in header [include_file boost/beast/websocket/rfc6455.hpp]```template<    class __Allocator__>boolis_upgrade(    beast::http::header< true, http::basic_fields< Allocator >> const& req);```[heading Description]
This function returns `true` when the passed HTTP Request indicates a WebSocket Upgrade. It does not validate the contents of the fields: it just trivially accepts requests which could only possibly be a valid or invalid WebSocket Upgrade message.
Callers who wish to manually read HTTP requests in their server implementation can use this function to determine if the request should be routed to an instance of [link beast.ref.boost__beast__websocket__stream `websocket::stream`].
[heading Example]
```  void handle_connection(net::ip::tcp::socket& sock)
  {
      boost::beast::flat_buffer buffer;
      boost::beast::http::request<boost::beast::http::string_body> req;
      boost::beast::http::read(sock, buffer, req);
      if(boost::beast::websocket::is_upgrade(req))
      {
          boost::beast::websocket::stream<decltype(sock)> ws{std::move(sock)};
          ws.accept(req);
      }
  }
```
[heading Parameters][table [[Name][Description]]  [[`req`][    
The HTTP Request object to check.  ]]]
[heading Return Value]
`true` if the request is a WebSocket Upgrade. 
Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__permessage_deflate websocket::permessage_deflate]
permessage-deflate extension options. [heading Synopsis]Defined in header [include_file boost/beast/websocket/option.hpp]```struct permessage_deflate```[heading Data Members][table [[Name][Description]]  [    [[link beast.ref.boost__beast__websocket__permessage_deflate.client_enable [*client_enable]]]    [      true to offer the extension in the client role     ]  ]  [    [[link beast.ref.boost__beast__websocket__permessage_deflate.client_max_window_bits [*client_max_window_bits]]]    [      Maximum client window bits to offer.     ]  ]  [    [[link beast.ref.boost__beast__websocket__permessage_deflate.client_no_context_takeover [*client_no_context_takeover]]]    [      true if client_no_context_takeover desired     ]  ]  [    [[link beast.ref.boost__beast__websocket__permessage_deflate.compLevel [*compLevel]]]    [      Deflate compression level 0..9.     ]  ]  [    [[link beast.ref.boost__beast__websocket__permessage_deflate.memLevel [*memLevel]]]    [      Deflate memory level, 1..9.     ]  ]  [    [[link beast.ref.boost__beast__websocket__permessage_deflate.server_enable [*server_enable]]]    [      true to offer the extension in the server role     ]  ]  [    [[link beast.ref.boost__beast__websocket__permessage_deflate.server_max_window_bits [*server_max_window_bits]]]    [      Maximum server window bits to offer.     ]  ]  [    [[link beast.ref.boost__beast__websocket__permessage_deflate.server_no_context_takeover [*server_no_context_takeover]]]    [      true if server_no_context_takeover desired     ]  ]][heading Description]
These settings control the permessage-deflate extension, which allows messages to be compressed.
[heading Remarks]
Objects of this type are used with [link beast.ref.boost__beast__websocket__stream.set_option `websocket::stream::set_option`]. 
[section:client_enable websocket::permessage_deflate::client_enable][indexterm2 client_enable..websocket::permessage_deflate]
`true` to offer the extension in the client role [heading Synopsis]```bool client_enable = false;```[heading Description][endsect][section:client_max_window_bits websocket::permessage_deflate::client_max_window_bits][indexterm2 client_max_window_bits..websocket::permessage_deflate]
Maximum client window bits to offer. [heading Synopsis]```int client_max_window_bits = 15;```[heading Description]
[heading Remarks]
Due to a bug in ZLib, this value must be greater than 8. 
[endsect][section:client_no_context_takeover websocket::permessage_deflate::client_no_context_takeover][indexterm2 client_no_context_takeover..websocket::permessage_deflate]
`true` if client\_no\_context\_takeover desired [heading Synopsis]```bool client_no_context_takeover = false;```[heading Description][endsect][section:compLevel websocket::permessage_deflate::compLevel][indexterm2 compLevel..websocket::permessage_deflate]
Deflate compression level 0..9. [heading Synopsis]```int compLevel = 8;```[heading Description][endsect][section:memLevel websocket::permessage_deflate::memLevel][indexterm2 memLevel..websocket::permessage_deflate]
Deflate memory level, 1..9. [heading Synopsis]```int memLevel = 4;```[heading Description][endsect][section:server_enable websocket::permessage_deflate::server_enable][indexterm2 server_enable..websocket::permessage_deflate]
`true` to offer the extension in the server role [heading Synopsis]```bool server_enable = false;```[heading Description][endsect][section:server_max_window_bits websocket::permessage_deflate::server_max_window_bits][indexterm2 server_max_window_bits..websocket::permessage_deflate]
Maximum server window bits to offer. [heading Synopsis]```int server_max_window_bits = 15;```[heading Description]
[heading Remarks]
Due to a bug in ZLib, this value must be greater than 8. 
[endsect][section:server_no_context_takeover websocket::permessage_deflate::server_no_context_takeover][indexterm2 server_no_context_takeover..websocket::permessage_deflate]
`true` if server\_no\_context\_takeover desired [heading Synopsis]```bool server_no_context_takeover = false;```[heading Description][endsect]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__ping_data websocket::ping_data][indexterm1 websocket::ping_data]
The type representing the payload of ping and pong messages. [heading Synopsis]Defined in header [include_file boost/beast/websocket/rfc6455.hpp]```using ping_data = static_string< 125, char >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__static_string.const_iterator [*const_iterator]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.const_pointer [*const_pointer]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.const_reference [*const_reference]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.const_reverse_iterator [*const_reverse_iterator]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.difference_type [*difference_type]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.iterator [*iterator]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.pointer [*pointer]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.reference [*reference]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.reverse_iterator [*reverse_iterator]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.size_type [*size_type]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.string_view_type [*string_view_type]]]    [      The type of string_view returned by the interface.     ]  ]  [    [[link beast.ref.boost__beast__static_string.traits_type [*traits_type]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.value_type [*value_type]]]    [          ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__static_string.append [*append]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.assign [*assign]]]    [      Assign count copies of ch.       Assign from another static_string       Assign count characterss starting at npos from other.       Assign the first count characters of s, including nulls.       Assign a null terminated string.       Assign from an iterator range of characters.       Assign from any object convertible to string_view_type.     ]  ]  [    [[link beast.ref.boost__beast__static_string.at [*at]]]    [      Access specified character with bounds checking.     ]  ]  [    [[link beast.ref.boost__beast__static_string.back [*back]]]    [      Accesses the last character.     ]  ]  [    [[link beast.ref.boost__beast__static_string.begin [*begin]]]    [      Returns an iterator to the beginning.     ]  ]  [    [[link beast.ref.boost__beast__static_string.c_str [*c_str]]]    [      Returns a non-modifiable standard C character array version of the string.     ]  ]  [    [[link beast.ref.boost__beast__static_string.capacity [*capacity]]]    [      Returns the number of characters that can be held in currently allocated storage.     ]  ]  [    [[link beast.ref.boost__beast__static_string.cbegin [*cbegin]]]    [      Returns an iterator to the beginning.     ]  ]  [    [[link beast.ref.boost__beast__static_string.cend [*cend]]]    [      Returns an iterator to the end.     ]  ]  [    [[link beast.ref.boost__beast__static_string.clear [*clear]]]    [      Clears the contents.     ]  ]  [    [[link beast.ref.boost__beast__static_string.compare [*compare]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.copy [*copy]]]    [      Copy a substring (pos, pos+count) to character string pointed to by dest.     ]  ]  [    [[link beast.ref.boost__beast__static_string.crbegin [*crbegin]]]    [      Returns a reverse iterator to the beginning.     ]  ]  [    [[link beast.ref.boost__beast__static_string.crend [*crend]]]    [      Returns a reverse iterator to the end.     ]  ]  [    [[link beast.ref.boost__beast__static_string.data [*data]]]    [      Returns a pointer to the first character of a string.     ]  ]  [    [[link beast.ref.boost__beast__static_string.empty [*empty]]]    [      Returns true if the string is empty.     ]  ]  [    [[link beast.ref.boost__beast__static_string.end [*end]]]    [      Returns an iterator to the end.     ]  ]  [    [[link beast.ref.boost__beast__static_string.erase [*erase]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.front [*front]]]    [      Accesses the first character.     ]  ]  [    [[link beast.ref.boost__beast__static_string.insert [*insert]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.length [*length]]]    [      Returns the number of characters, excluding the null terminator.     ]  ]  [    [[link beast.ref.boost__beast__static_string.max_size [*max_size]]]    [      Returns the maximum number of characters that can be stored, excluding the null terminator.     ]  ]  [    [[link beast.ref.boost__beast__static_string.operator_string_view_type [*operator string_view_type]]]    [      Convert a static string to a string_view_type     ]  ]  [    [[link beast.ref.boost__beast__static_string.operator_plus__eq_ [*operator+=]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.operator_eq_ [*operator=]]]    [      Copy assignment.       Assign from null-terminated string.       Assign from single character.       Assign from initializer list.       Assign from string_view_type.     ]  ]  [    [[link beast.ref.boost__beast__static_string.operator_lb__rb_ [*operator\[\]]]]    [      Access specified character.     ]  ]  [    [[link beast.ref.boost__beast__static_string.pop_back [*pop_back]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.push_back [*push_back]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.rbegin [*rbegin]]]    [      Returns a reverse iterator to the beginning.     ]  ]  [    [[link beast.ref.boost__beast__static_string.rend [*rend]]]    [      Returns a reverse iterator to the end.     ]  ]  [    [[link beast.ref.boost__beast__static_string.reserve [*reserve]]]    [      Reserves storage.     ]  ]  [    [[link beast.ref.boost__beast__static_string.resize [*resize]]]    [      Changes the number of characters stored.     ]  ]  [    [[link beast.ref.boost__beast__static_string.shrink_to_fit [*shrink_to_fit]]]    [      Reduces memory usage by freeing unused memory.     ]  ]  [    [[link beast.ref.boost__beast__static_string.size [*size]]]    [      Returns the number of characters, excluding the null terminator.     ]  ]  [    [[link beast.ref.boost__beast__static_string.static_string [*static_string]]]    [      Default constructor (empty string).       Construct with count copies of character ch.       Construct with a substring (pos, other.size()) of other.       Construct with a substring (pos, count) of other.       Construct with the first count characters of s, including nulls.       Construct from a null terminated string.       Construct from a range of characters.       Copy constructor.       Construct from an initializer list.       Construct from a string_view       Construct from any object convertible to string_view_type.     ]  ]  [    [[link beast.ref.boost__beast__static_string.substr [*substr]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.swap [*swap]]]    [      Exchange the contents of this string with another.     ]  ]][heading Data Members][table [[Name][Description]]  [    [[link beast.ref.boost__beast__static_string.max_size_n [*max_size_n]]]    [      Maximum size of the string excluding the null terminator.     ]  ]  [    [[link beast.ref.boost__beast__static_string.npos [*npos]]]    [      A special index.     ]  ]]
These objects behave like `std::string` except that the storage is not dynamically allocated but rather fixed in size.
These strings offer performance advantages when a protocol imposes a natural small upper limit on the size of a value.
[heading Remarks]
The stored string is always null-terminated.
[heading See Also]
[link beast.ref.boost__beast__to_static_string `to_static_string`] 
[heading Description]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__reason_string websocket::reason_string][indexterm1 websocket::reason_string]
The type representing the reason string in a close frame. [heading Synopsis]Defined in header [include_file boost/beast/websocket/rfc6455.hpp]```using reason_string = static_string< 123, char >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__static_string.const_iterator [*const_iterator]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.const_pointer [*const_pointer]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.const_reference [*const_reference]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.const_reverse_iterator [*const_reverse_iterator]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.difference_type [*difference_type]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.iterator [*iterator]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.pointer [*pointer]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.reference [*reference]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.reverse_iterator [*reverse_iterator]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.size_type [*size_type]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.string_view_type [*string_view_type]]]    [      The type of string_view returned by the interface.     ]  ]  [    [[link beast.ref.boost__beast__static_string.traits_type [*traits_type]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.value_type [*value_type]]]    [          ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__static_string.append [*append]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.assign [*assign]]]    [      Assign count copies of ch.       Assign from another static_string       Assign count characterss starting at npos from other.       Assign the first count characters of s, including nulls.       Assign a null terminated string.       Assign from an iterator range of characters.       Assign from any object convertible to string_view_type.     ]  ]  [    [[link beast.ref.boost__beast__static_string.at [*at]]]    [      Access specified character with bounds checking.     ]  ]  [    [[link beast.ref.boost__beast__static_string.back [*back]]]    [      Accesses the last character.     ]  ]  [    [[link beast.ref.boost__beast__static_string.begin [*begin]]]    [      Returns an iterator to the beginning.     ]  ]  [    [[link beast.ref.boost__beast__static_string.c_str [*c_str]]]    [      Returns a non-modifiable standard C character array version of the string.     ]  ]  [    [[link beast.ref.boost__beast__static_string.capacity [*capacity]]]    [      Returns the number of characters that can be held in currently allocated storage.     ]  ]  [    [[link beast.ref.boost__beast__static_string.cbegin [*cbegin]]]    [      Returns an iterator to the beginning.     ]  ]  [    [[link beast.ref.boost__beast__static_string.cend [*cend]]]    [      Returns an iterator to the end.     ]  ]  [    [[link beast.ref.boost__beast__static_string.clear [*clear]]]    [      Clears the contents.     ]  ]  [    [[link beast.ref.boost__beast__static_string.compare [*compare]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.copy [*copy]]]    [      Copy a substring (pos, pos+count) to character string pointed to by dest.     ]  ]  [    [[link beast.ref.boost__beast__static_string.crbegin [*crbegin]]]    [      Returns a reverse iterator to the beginning.     ]  ]  [    [[link beast.ref.boost__beast__static_string.crend [*crend]]]    [      Returns a reverse iterator to the end.     ]  ]  [    [[link beast.ref.boost__beast__static_string.data [*data]]]    [      Returns a pointer to the first character of a string.     ]  ]  [    [[link beast.ref.boost__beast__static_string.empty [*empty]]]    [      Returns true if the string is empty.     ]  ]  [    [[link beast.ref.boost__beast__static_string.end [*end]]]    [      Returns an iterator to the end.     ]  ]  [    [[link beast.ref.boost__beast__static_string.erase [*erase]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.front [*front]]]    [      Accesses the first character.     ]  ]  [    [[link beast.ref.boost__beast__static_string.insert [*insert]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.length [*length]]]    [      Returns the number of characters, excluding the null terminator.     ]  ]  [    [[link beast.ref.boost__beast__static_string.max_size [*max_size]]]    [      Returns the maximum number of characters that can be stored, excluding the null terminator.     ]  ]  [    [[link beast.ref.boost__beast__static_string.operator_string_view_type [*operator string_view_type]]]    [      Convert a static string to a string_view_type     ]  ]  [    [[link beast.ref.boost__beast__static_string.operator_plus__eq_ [*operator+=]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.operator_eq_ [*operator=]]]    [      Copy assignment.       Assign from null-terminated string.       Assign from single character.       Assign from initializer list.       Assign from string_view_type.     ]  ]  [    [[link beast.ref.boost__beast__static_string.operator_lb__rb_ [*operator\[\]]]]    [      Access specified character.     ]  ]  [    [[link beast.ref.boost__beast__static_string.pop_back [*pop_back]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.push_back [*push_back]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.rbegin [*rbegin]]]    [      Returns a reverse iterator to the beginning.     ]  ]  [    [[link beast.ref.boost__beast__static_string.rend [*rend]]]    [      Returns a reverse iterator to the end.     ]  ]  [    [[link beast.ref.boost__beast__static_string.reserve [*reserve]]]    [      Reserves storage.     ]  ]  [    [[link beast.ref.boost__beast__static_string.resize [*resize]]]    [      Changes the number of characters stored.     ]  ]  [    [[link beast.ref.boost__beast__static_string.shrink_to_fit [*shrink_to_fit]]]    [      Reduces memory usage by freeing unused memory.     ]  ]  [    [[link beast.ref.boost__beast__static_string.size [*size]]]    [      Returns the number of characters, excluding the null terminator.     ]  ]  [    [[link beast.ref.boost__beast__static_string.static_string [*static_string]]]    [      Default constructor (empty string).       Construct with count copies of character ch.       Construct with a substring (pos, other.size()) of other.       Construct with a substring (pos, count) of other.       Construct with the first count characters of s, including nulls.       Construct from a null terminated string.       Construct from a range of characters.       Copy constructor.       Construct from an initializer list.       Construct from a string_view       Construct from any object convertible to string_view_type.     ]  ]  [    [[link beast.ref.boost__beast__static_string.substr [*substr]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.swap [*swap]]]    [      Exchange the contents of this string with another.     ]  ]][heading Data Members][table [[Name][Description]]  [    [[link beast.ref.boost__beast__static_string.max_size_n [*max_size_n]]]    [      Maximum size of the string excluding the null terminator.     ]  ]  [    [[link beast.ref.boost__beast__static_string.npos [*npos]]]    [      A special index.     ]  ]]
These objects behave like `std::string` except that the storage is not dynamically allocated but rather fixed in size.
These strings offer performance advantages when a protocol imposes a natural small upper limit on the size of a value.
[heading Remarks]
The stored string is always null-terminated.
[heading See Also]
[link beast.ref.boost__beast__to_static_string `to_static_string`] 
[heading Description]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__request_type websocket::request_type][indexterm1 websocket::request_type]
The type of object holding HTTP Upgrade requests. [heading Synopsis]Defined in header [include_file boost/beast/websocket/rfc6455.hpp]```using request_type = http::request< http::empty_body >;```[heading Description]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__response_type websocket::response_type][indexterm1 websocket::response_type]
The type of object holding HTTP Upgrade responses. [heading Synopsis]Defined in header [include_file boost/beast/websocket/rfc6455.hpp]```using response_type = http::response< http::string_body >;```[heading Description]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__seed_prng websocket::seed_prng][indexterm1 websocket::seed_prng]
Manually provide a one-time seed to initialize the PRNG. [heading Synopsis]Defined in header [include_file boost/beast/websocket/stream.hpp]```voidseed_prng(    std::seed_seq& ss);```[heading Description]
This function invokes the specified seed sequence to produce a seed suitable for use with the pseudo-random number generator used to create masks and perform WebSocket protocol handshakes.
If a seed is not manually provided, the implementation will perform a one-time seed generation using `std::random_device`. This function may be used when the application runs in an environment where the random device is unreliable or does not provide sufficient entropy.
[heading Preconditions]

This function may not be called after any websocket [link beast.ref.boost__beast__websocket__stream `websocket::stream`] objects have been constructed.
[heading Parameters][table [[Name][Description]]  [[`ss`][    
A reference to a `std::seed_seq` which will be used to seed the pseudo-random number generator. The seed sequence should have at least 256 bits of entropy.  ]]]
[heading See Also]
[link beast.ref.boost__beast__websocket__stream.secure_prng `websocket::stream::secure_prng`] 
Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__stream websocket::stream]
Provides message-oriented functionality using WebSocket. [heading Synopsis]Defined in header [include_file boost/beast/websocket/stream.hpp]```template<    class NextLayer,    bool deflateSupported>class stream```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__websocket__stream.executor_type [*executor_type]]]    [      The type of the executor associated with the object.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.is_deflate_supported [*is_deflate_supported]]]    [      Indicates if the permessage-deflate extension is supported.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.next_layer_type [*next_layer_type]]]    [      The type of the next layer.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__websocket__stream.accept [*accept]]]    [      Perform the WebSocket handshake in the server role.       Read and respond to a WebSocket HTTP Upgrade request.       Respond to a WebSocket HTTP Upgrade request.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.async_accept [*async_accept]]]    [      Perform the WebSocket handshake asynchronously in the server role.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.async_close [*async_close]]]    [      Send a websocket close control frame asynchronously.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.async_handshake [*async_handshake]]]    [      Perform the WebSocket handshake asynchronously in the client role.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.async_ping [*async_ping]]]    [      Send a websocket ping control frame asynchronously.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.async_pong [*async_pong]]]    [      Send a websocket pong control frame asynchronously.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.async_read [*async_read]]]    [      Read a complete message asynchronously.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.async_read_some [*async_read_some]]]    [      Read some message data asynchronously.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.async_write [*async_write]]]    [      Write a complete message asynchronously.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.async_write_some [*async_write_some]]]    [      Write some message data asynchronously.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.auto_fragment [*auto_fragment]]]    [      Set the automatic fragmentation option.       Returns true if the automatic fragmentation option is set.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.binary [*binary]]]    [      Set the binary message write option.       Returns true if the binary message write option is set.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.close [*close]]]    [      Send a websocket close control frame.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.control_callback [*control_callback]]]    [      Set a callback to be invoked on each incoming control frame.       Reset the control frame callback.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.get_executor [*get_executor]]]    [      Get the executor associated with the object.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.get_option [*get_option]]]    [            Get the permessage-deflate extension options.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.got_binary [*got_binary]]]    [      Returns true if the latest message data indicates binary.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.got_text [*got_text]]]    [      Returns true if the latest message data indicates text.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.handshake [*handshake]]]    [      Perform the WebSocket handshake in the client role.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.is_message_done [*is_message_done]]]    [      Returns true if the last completed read finished the current message.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.is_open [*is_open]]]    [      Returns true if the stream is open.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.next_layer [*next_layer]]]    [      Get a reference to the next layer.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.operator_eq_ [*operator=]]]    [      Move assignment (deleted)     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.ping [*ping]]]    [      Send a websocket ping control frame.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.pong [*pong]]]    [      Send a websocket pong control frame.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.read [*read]]]    [      Read a complete message.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.read_message_max [*read_message_max]]]    [      Set the maximum incoming message size option.       Returns the maximum incoming message size setting.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.read_size_hint [*read_size_hint]]]    [      Returns a suggested maximum buffer size for the next call to read.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.read_some [*read_some]]]    [      Read some message data.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.reason [*reason]]]    [      Returns the close reason received from the remote peer.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.secure_prng [*secure_prng]]]    [      Set whether the PRNG is cryptographically secure.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.set_option [*set_option]]]    [            Set the permessage-deflate extension options.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.stream [*stream]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.text [*text]]]    [      Set the text message write option.       Returns true if the text message write option is set.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.write [*write]]]    [      Write a complete message.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.write_buffer_bytes [*write_buffer_bytes]]]    [      Set the write buffer size option.       Returns the size of the write buffer.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.write_some [*write_some]]]    [      Write some message data.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.stream_dtor_ [*~stream]]]    [      Destructor.     ]  ]][heading Description]
The [link beast.ref.boost__beast__websocket__stream `websocket::stream`] class template provides asynchronous and blocking message-oriented functionality necessary for clients and servers to utilize the WebSocket protocol.
For asynchronous operations, the application must ensure that they are are all performed within the same implicit or explicit strand.
[heading Thread Safety]
['Distinct] ['objects:] Safe.['Shared] ['objects:] Unsafe. The application must also ensure that all asynchronous operations are performed within the same implicit or explicit strand.
[heading Example]
To declare the [link beast.ref.boost__beast__websocket__stream `websocket::stream`] object with a [link beast.ref.boost__beast__tcp_stream `tcp_stream`] in a multi-threaded asynchronous program using a strand, you may write: ```  websocket::stream<tcp_stream> ws{net::io_context::strand(ioc)};
```Alternatively, for a single-threaded or synchronous application you may write: ```  websocket::stream<tcp_stream> ws(ioc);
```
[heading Template Parameters][table [[Type][Description]]  [[`NextLayer`][    
The type representing the next layer, to which data will be read and written during operations. For synchronous operations, the type must support the ['SyncStream] concept. For asynchronous operations, the type must support the ['AsyncStream] concept.  ]]  [[`deflateSupported`][    
A `bool` indicating whether or not the stream will be capable of negotiating the permessage-deflate websocket extension. Note that even if this is set to `true`, the permessage deflate options (set by the caller at runtime) must still have the feature enabled for a successful negotiation to occur.  ]]]
[heading Remarks]
A stream object must not be moved or destroyed while there are pending asynchronous operations associated with it.
[heading Concepts]

* ['AsyncStream] 
* ['DynamicBuffer] 
* ['SyncStream]


[heading See Also]

* [@https://tools.ietf.org/html/rfc6455#section-4.1 Websocket Opening Handshake Client Requirements (RFC6455)] 
* [@https://tools.ietf.org/html/rfc6455#section-4.2 Websocket Opening Handshake Server Requirements (RFC6455)] 
* [@https://tools.ietf.org/html/rfc6455#section-7.1.2 Websocket Closing Handshake (RFC6455)] 
* [@https://tools.ietf.org/html/rfc6455#section-5.5.1 Websocket Close (RFC6455)] 
* [@https://tools.ietf.org/html/rfc6455#section-5.5.2 WebSocket Ping (RFC6455)] 
* [@https://tools.ietf.org/html/rfc6455#section-5.5.3 WebSocket Pong (RFC6455)] 
* [@https://tools.ietf.org/html/rfc7230#section-5.4 Host field (RFC7230)] 
* [@https://tools.ietf.org/html/rfc7230#section-3.1.1 request-target (RFC7230)] 
* [@https://tools.ietf.org/html/rfc7230#section-5.3.1 origin-form (RFC7230)] 


[section:accept websocket::stream::accept][indexterm2 accept..websocket::stream]
Perform the WebSocket handshake in the server role. ```void``[link beast.ref.boost__beast__websocket__stream.accept.overload1 accept]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.accept.overload1 more...]]`````
Read and respond to a WebSocket HTTP Upgrade request. ```void``[link beast.ref.boost__beast__websocket__stream.accept.overload2 accept]``(    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.accept.overload2 more...]]``template<    class __ConstBufferSequence__>void``[link beast.ref.boost__beast__websocket__stream.accept.overload3 accept]``(    ConstBufferSequence const& buffers);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.accept.overload3 more...]]``template<    class __ConstBufferSequence__>void``[link beast.ref.boost__beast__websocket__stream.accept.overload4 accept]``(    ConstBufferSequence const& buffers,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.accept.overload4 more...]]`````
Respond to a WebSocket HTTP Upgrade request. ```template<    class __Body__,    class __Allocator__>void``[link beast.ref.boost__beast__websocket__stream.accept.overload5 accept]``(    http::request< Body, http::basic_fields< Allocator >> const& req);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.accept.overload5 more...]]``template<    class __Body__,    class __Allocator__>void``[link beast.ref.boost__beast__websocket__stream.accept.overload6 accept]``(    http::request< Body, http::basic_fields< Allocator >> const& req,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.accept.overload6 more...]]`````[section:overload1 websocket::stream::accept (1 of 6 overloads)]
Perform the WebSocket handshake in the server role. [heading Synopsis]```voidaccept();```[heading Description]
This function is used to perform the [@https://en.wikipedia.org/wiki/WebSocket#Protocol_handshake WebSocket handshake], required before messages can be sent and received. During the handshake, the client sends the Websocket Upgrade HTTP request, and the server replies with an HTTP response indicating the result of the handshake.
The call blocks until one of the following conditions is true:

* The request is received and the response is sent.


* An error occurs.

The algorithm, known as a ['composed operation], is implemented in terms of calls to the next layer's `read_some` and `write_some` functions.
If a valid upgrade request is received, an HTTP response with a [@https://tools.ietf.org/html/rfc7230#section-3.1.2 status-code] of [link beast.ref.boost__beast__http__status `http::switching_protocols`] is sent to the peer, otherwise a non-successful error is associated with the operation.
If the request size exceeds the capacity of the stream's internal buffer, the error [link beast.ref.boost__beast__websocket__error `websocket::buffer_overflow`] will be indicated. To handle larger requests, an application should read the HTTP request directly using [link beast.ref.boost__beast__http__read `http::read`] and then pass the request to the appropriate overload of [link beast.ref.boost__beast__websocket__stream.accept `websocket::stream::accept`] or [link beast.ref.boost__beast__websocket__stream.async_accept `websocket::stream::async_accept`]
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    
Thrown on failure.  ]]]
[heading See Also]

* [@https://tools.ietf.org/html/rfc6455#section-4.2 Websocket Opening Handshake Server Requirements (RFC6455)] 


[endsect][section:overload2 websocket::stream::accept (2 of 6 overloads)]
Read and respond to a WebSocket HTTP Upgrade request. [heading Synopsis]```voidaccept(    error_code& ec);```[heading Description]
This function is used to perform the [@https://en.wikipedia.org/wiki/WebSocket#Protocol_handshake WebSocket handshake], required before messages can be sent and received. During the handshake, the client sends the Websocket Upgrade HTTP request, and the server replies with an HTTP response indicating the result of the handshake.
The call blocks until one of the following conditions is true:

* The request is received and the response is sent.


* An error occurs.

The algorithm, known as a ['composed operation], is implemented in terms of calls to the next layer's `read_some` and `write_some` functions.
If a valid upgrade request is received, an HTTP response with a [@https://tools.ietf.org/html/rfc7230#section-3.1.2 status-code] of [link beast.ref.boost__beast__http__status `http::switching_protocols`] is sent to the peer, otherwise a non-successful error is associated with the operation.
If the request size exceeds the capacity of the stream's internal buffer, the error [link beast.ref.boost__beast__websocket__error `websocket::buffer_overflow`] will be indicated. To handle larger requests, an application should read the HTTP request directly using [link beast.ref.boost__beast__http__read `http::read`] and then pass the request to the appropriate overload of [link beast.ref.boost__beast__websocket__stream.accept `websocket::stream::accept`] or [link beast.ref.boost__beast__websocket__stream.async_accept `websocket::stream::async_accept`]
[heading Parameters][table [[Name][Description]]  [[`ec`][    
Set to indicate what error occurred, if any.  ]]]
[heading See Also]

* [@https://tools.ietf.org/html/rfc6455#section-4.2 Websocket Opening Handshake Server Requirements (RFC6455)] 


[endsect][section:overload3 websocket::stream::accept (3 of 6 overloads)]
Read and respond to a WebSocket HTTP Upgrade request. [heading Synopsis]```template<    class __ConstBufferSequence__>voidaccept(    ConstBufferSequence const& buffers);```[heading Description]
This function is used to perform the [@https://en.wikipedia.org/wiki/WebSocket#Protocol_handshake WebSocket handshake], required before messages can be sent and received. During the handshake, the client sends the Websocket Upgrade HTTP request, and the server replies with an HTTP response indicating the result of the handshake.
The call blocks until one of the following conditions is true:

* The request is received and the response is sent.


* An error occurs.

The algorithm, known as a ['composed operation], is implemented in terms of calls to the next layer's `read_some` and `write_some` functions.
If a valid upgrade request is received, an HTTP response with a [@https://tools.ietf.org/html/rfc7230#section-3.1.2 status-code] of [link beast.ref.boost__beast__http__status `http::switching_protocols`] is sent to the peer, otherwise a non-successful error is associated with the operation.
If the request size exceeds the capacity of the stream's internal buffer, the error [link beast.ref.boost__beast__websocket__error `websocket::buffer_overflow`] will be indicated. To handle larger requests, an application should read the HTTP request directly using [link beast.ref.boost__beast__http__read `http::read`] and then pass the request to the appropriate overload of [link beast.ref.boost__beast__websocket__stream.accept `websocket::stream::accept`] or [link beast.ref.boost__beast__websocket__stream.async_accept `websocket::stream::async_accept`]
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
Caller provided data that has already been received on the stream. The implementation will copy the caller provided data before the function returns.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    
Thrown on failure.  ]]]
[heading See Also]

* [@https://tools.ietf.org/html/rfc6455#section-4.2 Websocket Opening Handshake Server Requirements (RFC6455)] 


[endsect][section:overload4 websocket::stream::accept (4 of 6 overloads)]
Read and respond to a WebSocket HTTP Upgrade request. [heading Synopsis]```template<    class __ConstBufferSequence__>voidaccept(    ConstBufferSequence const& buffers,    error_code& ec);```[heading Description]
This function is used to perform the [@https://en.wikipedia.org/wiki/WebSocket#Protocol_handshake WebSocket handshake], required before messages can be sent and received. During the handshake, the client sends the Websocket Upgrade HTTP request, and the server replies with an HTTP response indicating the result of the handshake.
The call blocks until one of the following conditions is true:

* The request is received and the response is sent.


* An error occurs.

The algorithm, known as a ['composed operation], is implemented in terms of calls to the next layer's `read_some` and `write_some` functions.
If a valid upgrade request is received, an HTTP response with a [@https://tools.ietf.org/html/rfc7230#section-3.1.2 status-code] of [link beast.ref.boost__beast__http__status `http::switching_protocols`] is sent to the peer, otherwise a non-successful error is associated with the operation.
If the request size exceeds the capacity of the stream's internal buffer, the error [link beast.ref.boost__beast__websocket__error `websocket::buffer_overflow`] will be indicated. To handle larger requests, an application should read the HTTP request directly using [link beast.ref.boost__beast__http__read `http::read`] and then pass the request to the appropriate overload of [link beast.ref.boost__beast__websocket__stream.accept `websocket::stream::accept`] or [link beast.ref.boost__beast__websocket__stream.async_accept `websocket::stream::async_accept`]
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
Caller provided data that has already been received on the stream. The implementation will copy the caller provided data before the function returns.  ]]  [[`ec`][    
Set to indicate what error occurred, if any.  ]]]
[heading See Also]

* [@https://tools.ietf.org/html/rfc6455#section-4.2 Websocket Opening Handshake Server Requirements (RFC6455)] 


[endsect][section:overload5 websocket::stream::accept (5 of 6 overloads)]
Respond to a WebSocket HTTP Upgrade request. [heading Synopsis]```template<    class __Body__,    class __Allocator__>voidaccept(    http::request< Body, http::basic_fields< Allocator >> const& req);```[heading Description]
This function is used to perform the [@https://en.wikipedia.org/wiki/WebSocket#Protocol_handshake WebSocket handshake], required before messages can be sent and received. During the handshake, the client sends the Websocket Upgrade HTTP request, and the server replies with an HTTP response indicating the result of the handshake.
The call blocks until one of the following conditions is true:

* The response is sent.


* An error occurs.

The algorithm, known as a ['composed operation], is implemented in terms of calls to the next layer's `read_some` and `write_some` functions.
If a valid upgrade request is received, an HTTP response with a [@https://tools.ietf.org/html/rfc7230#section-3.1.2 status-code] of [link beast.ref.boost__beast__http__status `http::switching_protocols`] is sent to the peer, otherwise a non-successful error is associated with the operation.
[heading Parameters][table [[Name][Description]]  [[`req`][    
An object containing the HTTP Upgrade request. Ownership is not transferred, the implementation will not access this object from other threads.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    
Thrown on failure.  ]]]
[heading See Also]

* [@https://tools.ietf.org/html/rfc6455#section-4.2 Websocket Opening Handshake Server Requirements (RFC6455)] 


[endsect][section:overload6 websocket::stream::accept (6 of 6 overloads)]
Respond to a WebSocket HTTP Upgrade request. [heading Synopsis]```template<    class __Body__,    class __Allocator__>voidaccept(    http::request< Body, http::basic_fields< Allocator >> const& req,    error_code& ec);```[heading Description]
This function is used to perform the [@https://en.wikipedia.org/wiki/WebSocket#Protocol_handshake WebSocket handshake], required before messages can be sent and received. During the handshake, the client sends the Websocket Upgrade HTTP request, and the server replies with an HTTP response indicating the result of the handshake.
The call blocks until one of the following conditions is true:

* The response is sent.


* An error occurs.

The algorithm, known as a ['composed operation], is implemented in terms of calls to the next layer's `read_some` and `write_some` functions.
If a valid upgrade request is received, an HTTP response with a [@https://tools.ietf.org/html/rfc7230#section-3.1.2 status-code] of [link beast.ref.boost__beast__http__status `http::switching_protocols`] is sent to the peer, otherwise a non-successful error is associated with the operation.
[heading Parameters][table [[Name][Description]]  [[`req`][    
An object containing the HTTP Upgrade request. Ownership is not transferred, the implementation will not access this object from other threads.  ]]  [[`ec`][    
Set to indicate what error occurred, if any.  ]]]
[heading See Also]

* [@https://tools.ietf.org/html/rfc6455#section-4.2 Websocket Opening Handshake Server Requirements (RFC6455)] 


[endsect][endsect][section:async_accept websocket::stream::async_accept][indexterm2 async_accept..websocket::stream]
Perform the WebSocket handshake asynchronously in the server role. ```template<    class AcceptHandler>``__deduced__````[link beast.ref.boost__beast__websocket__stream.async_accept.overload1 async_accept]``(    AcceptHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.async_accept.overload1 more...]]``template<    class __ConstBufferSequence__,    class AcceptHandler>``__deduced__````[link beast.ref.boost__beast__websocket__stream.async_accept.overload2 async_accept]``(    ConstBufferSequence const& buffers,    AcceptHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.async_accept.overload2 more...]]``template<    class __Body__,    class __Allocator__,    class AcceptHandler>``__deduced__````[link beast.ref.boost__beast__websocket__stream.async_accept.overload3 async_accept]``(    http::request< Body, http::basic_fields< Allocator >> const& req,    AcceptHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.async_accept.overload3 more...]]`````[section:overload1 websocket::stream::async_accept (1 of 3 overloads)]
Perform the WebSocket handshake asynchronously in the server role. [heading Synopsis]```template<    class AcceptHandler>``__deduced__``async_accept(    AcceptHandler&& handler);```[heading Description]
This initiating function is used to asynchronously begin performing the [@https://en.wikipedia.org/wiki/WebSocket#Protocol_handshake WebSocket handshake], required before messages can be sent and received. During the handshake, the client sends the Websocket Upgrade HTTP request, and the server replies with an HTTP response indicating the result of the handshake.
This call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:

* The request is received and the response is sent.


* An error occurs.

The algorithm, known as a ['composed asynchronous operation], is implemented in terms of calls to the next layer's `async_read_some` and `async_write_some` functions. No other operation may be performed on the stream until this operation completes.
If a valid upgrade request is received, an HTTP response with a [@https://tools.ietf.org/html/rfc7230#section-3.1.2 status-code] of [link beast.ref.boost__beast__http__status `http::switching_protocols`] is sent to the peer, otherwise a non-successful error is associated with the operation.
If the request size exceeds the capacity of the stream's internal buffer, the error [link beast.ref.boost__beast__websocket__error `websocket::buffer_overflow`] will be indicated. To handle larger requests, an application should read the HTTP request directly using [link beast.ref.boost__beast__http__async_read `http::async_read`] and then pass the request to the appropriate overload of [link beast.ref.boost__beast__websocket__stream.accept `websocket::stream::accept`] or [link beast.ref.boost__beast__websocket__stream.async_accept `websocket::stream::async_accept`]
[heading Parameters][table [[Name][Description]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      error_code const& ec    // Result of operation
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.  ]]]
[heading See Also]

* [@https://tools.ietf.org/html/rfc6455#section-4.2 Websocket Opening Handshake Server Requirements (RFC6455)] 


[endsect][section:overload2 websocket::stream::async_accept (2 of 3 overloads)]
Perform the WebSocket handshake asynchronously in the server role. [heading Synopsis]```template<    class __ConstBufferSequence__,    class AcceptHandler>``__deduced__``async_accept(    ConstBufferSequence const& buffers,    AcceptHandler&& handler);```[heading Description]
This initiating function is used to asynchronously begin performing the [@https://en.wikipedia.org/wiki/WebSocket#Protocol_handshake WebSocket handshake], required before messages can be sent and received. During the handshake, the client sends the Websocket Upgrade HTTP request, and the server replies with an HTTP response indicating the result of the handshake.
This call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:

* The request is received and the response is sent.


* An error occurs.

The algorithm, known as a ['composed asynchronous operation], is implemented in terms of calls to the next layer's `async_read_some` and `async_write_some` functions. No other operation may be performed on the stream until this operation completes.
If a valid upgrade request is received, an HTTP response with a [@https://tools.ietf.org/html/rfc7230#section-3.1.2 status-code] of [link beast.ref.boost__beast__http__status `http::switching_protocols`] is sent to the peer, otherwise a non-successful error is associated with the operation.
If the request size exceeds the capacity of the stream's internal buffer, the error [link beast.ref.boost__beast__websocket__error `websocket::buffer_overflow`] will be indicated. To handle larger requests, an application should read the HTTP request directly using [link beast.ref.boost__beast__http__async_read `http::async_read`] and then pass the request to the appropriate overload of [link beast.ref.boost__beast__websocket__stream.accept `websocket::stream::accept`] or [link beast.ref.boost__beast__websocket__stream.async_accept `websocket::stream::async_accept`]
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
Caller provided data that has already been received on the stream. This may be used for implementations allowing multiple protocols on the same stream. The buffered data will first be applied to the handshake, and then to received WebSocket frames. The implementation will copy the caller provided data before the function returns.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      error_code const& ec    // Result of operation
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.  ]]]
[heading See Also]

* [@https://tools.ietf.org/html/rfc6455#section-4.2 Websocket Opening Handshake Server Requirements (RFC6455)] 


[endsect][section:overload3 websocket::stream::async_accept (3 of 3 overloads)]
Perform the WebSocket handshake asynchronously in the server role. [heading Synopsis]```template<    class __Body__,    class __Allocator__,    class AcceptHandler>``__deduced__``async_accept(    http::request< Body, http::basic_fields< Allocator >> const& req,    AcceptHandler&& handler);```[heading Description]
This initiating function is used to asynchronously begin performing the [@https://en.wikipedia.org/wiki/WebSocket#Protocol_handshake WebSocket handshake], required before messages can be sent and received. During the handshake, the client sends the Websocket Upgrade HTTP request, and the server replies with an HTTP response indicating the result of the handshake.
This call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:

* The request is received and the response is sent.


* An error occurs.

The algorithm, known as a ['composed asynchronous operation], is implemented in terms of calls to the next layer's `async_read_some` and `async_write_some` functions. No other operation may be performed on the stream until this operation completes.
If a valid upgrade request is received, an HTTP response with a [@https://tools.ietf.org/html/rfc7230#section-3.1.2 status-code] of [link beast.ref.boost__beast__http__status `http::switching_protocols`] is sent to the peer, otherwise a non-successful error is associated with the operation.
[heading Parameters][table [[Name][Description]]  [[`req`][    
An object containing the HTTP Upgrade request. Ownership is not transferred, the implementation will not access this object from other threads.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      error_code const& ec    // Result of operation
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.  ]]]
[heading See Also]

* [@https://tools.ietf.org/html/rfc6455#section-4.2 Websocket Opening Handshake Server Requirements (RFC6455)] 


[endsect][endsect][section:async_close websocket::stream::async_close][indexterm2 async_close..websocket::stream]
Send a websocket close control frame asynchronously. [heading Synopsis]```template<    class CloseHandler>``__deduced__``async_close(    close_reason const& cr,    CloseHandler&& handler);```[heading Description]
This function is used to asynchronously send a [@https://tools.ietf.org/html/rfc6455#section-5.5.1 close frame], which begins the websocket closing handshake. The session ends when both ends of the connection have sent and received a close frame.
This call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:

* The close frame finishes sending.


* An error occurs.

The algorithm, known as a ['composed asynchronous operation], is implemented in terms of calls to the next layer's `async_write_some` function. No other operations except for message reading operations should be initiated on the stream after a close operation is started.
After beginning the closing handshake, the program should not write further message data, pings, or pongs. Instead, the program should continue reading message data until an error occurs. A read returning [link beast.ref.boost__beast__websocket__error `websocket::closed`] indicates a successful connection closure.
[heading Parameters][table [[Name][Description]]  [[`cr`][    
The reason for the close. If the close reason specifies a close code other than beast::websocket::close\_code::none, the close frame is sent with the close code and optional reason string. Otherwise, the close frame is sent with no payload.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      error_code const& ec     // Result of operation
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.  ]]]
[heading See Also]

* [@https://tools.ietf.org/html/rfc6455#section-7.1.2 Websocket Closing Handshake (RFC6455)] 


[endsect][section:async_handshake websocket::stream::async_handshake][indexterm2 async_handshake..websocket::stream]
Perform the WebSocket handshake asynchronously in the client role. ```template<    class HandshakeHandler>``__deduced__````[link beast.ref.boost__beast__websocket__stream.async_handshake.overload1 async_handshake]``(    string_view host,    string_view target,    HandshakeHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.async_handshake.overload1 more...]]``template<    class HandshakeHandler>``__deduced__````[link beast.ref.boost__beast__websocket__stream.async_handshake.overload2 async_handshake]``(    response_type& res,    string_view host,    string_view target,    HandshakeHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.async_handshake.overload2 more...]]`````[section:overload1 websocket::stream::async_handshake (1 of 2 overloads)]
Perform the WebSocket handshake asynchronously in the client role. [heading Synopsis]```template<    class HandshakeHandler>``__deduced__``async_handshake(    string_view host,    string_view target,    HandshakeHandler&& handler);```[heading Description]
This initiating function is used to asynchronously begin performing the [@https://en.wikipedia.org/wiki/WebSocket#Protocol_handshake WebSocket handshake], required before messages can be sent and received. During the handshake, the client sends the Websocket Upgrade HTTP request, and the server replies with an HTTP response indicating the result of the handshake.
This call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:

* The request is sent and the response is received.


* An error occurs.

The algorithm, known as a ['composed asynchronous operation], is implemented in terms of calls to the next layer's `async_read_some` and `async_write_some` functions. No other operation may be performed on the stream until this operation completes.
The handshake is successful if the received HTTP response indicates the upgrade was accepted by the server, represented by a [@https://tools.ietf.org/html/rfc7230#section-3.1.2 status-code] of [link beast.ref.boost__beast__http__status `http::switching_protocols`].
[heading Parameters][table [[Name][Description]]  [[`host`][    
The name of the remote host. This is required by the HTTP protocol to set the "Host" header field. The implementation will not access the string data after the initiating function returns.  ]]  [[`target`][    
The request-target, in origin-form. The server may use the target to distinguish different services on the same listening port. The implementation will not access the string data after the initiating function returns.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      error_code const& ec    // Result of operation
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.  ]]]
[heading Example]
```  ws.async_handshake("localhost", "/",
      [](error_code ec)
      {
          if(ec)
              std::cerr << "Error: " << ec.message() << "\n";
      });
```
[heading See Also]

* [@https://tools.ietf.org/html/rfc6455#section-4.1 Websocket Opening Handshake Client Requirements (RFC6455)] 
* [@https://tools.ietf.org/html/rfc7230#section-5.4 Host field (RFC7230)] 
* [@https://tools.ietf.org/html/rfc7230#section-3.1.1 request-target (RFC7230)] 
* [@https://tools.ietf.org/html/rfc7230#section-5.3.1 origin-form (RFC7230)] 


[endsect][section:overload2 websocket::stream::async_handshake (2 of 2 overloads)]
Perform the WebSocket handshake asynchronously in the client role. [heading Synopsis]```template<    class HandshakeHandler>``__deduced__``async_handshake(    response_type& res,    string_view host,    string_view target,    HandshakeHandler&& handler);```[heading Description]
This initiating function is used to asynchronously begin performing the [@https://en.wikipedia.org/wiki/WebSocket#Protocol_handshake WebSocket handshake], required before messages can be sent and received. During the handshake, the client sends the Websocket Upgrade HTTP request, and the server replies with an HTTP response indicating the result of the handshake.
This call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:

* The request is sent and the response is received.


* An error occurs.

The algorithm, known as a ['composed asynchronous operation], is implemented in terms of calls to the next layer's `async_read_some` and `async_write_some` functions. No other operation may be performed on the stream until this operation completes.
The handshake is successful if the received HTTP response indicates the upgrade was accepted by the server, represented by a [@https://tools.ietf.org/html/rfc7230#section-3.1.2 status-code] of [link beast.ref.boost__beast__http__status `http::switching_protocols`].
[heading Parameters][table [[Name][Description]]  [[`res`][    
The HTTP Upgrade response returned by the remote endpoint. The caller may use the response to access any additional information sent by the server. This object will be assigned before the completion handler is invoked.  ]]  [[`host`][    
The name of the remote host. This is required by the HTTP protocol to set the "Host" header field. The implementation will not access the string data after the initiating function returns.  ]]  [[`target`][    
The request-target, in origin-form. The server may use the target to distinguish different services on the same listening port. The implementation will not access the string data after the initiating function returns.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      error_code const& ec    // Result of operation
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.  ]]]
[heading Example]
```  response_type res;
  ws.async_handshake(res, "localhost", "/",
      [&res](error_code ec)
      {
          if(ec)
              std::cerr << "Error: " << ec.message() << "\n";
          else
              std::cout << res;

      });
```
[heading See Also]

* [@https://tools.ietf.org/html/rfc6455#section-4.1 Websocket Opening Handshake Client Requirements (RFC6455)] 
* [@https://tools.ietf.org/html/rfc7230#section-5.4 Host field (RFC7230)] 
* [@https://tools.ietf.org/html/rfc7230#section-3.1.1 request-target (RFC7230)] 
* [@https://tools.ietf.org/html/rfc7230#section-5.3.1 origin-form (RFC7230)] 


[endsect][endsect][section:async_ping websocket::stream::async_ping][indexterm2 async_ping..websocket::stream]
Send a websocket ping control frame asynchronously. [heading Synopsis]```template<    class __WriteHandler__>``__deduced__``async_ping(    ping_data const& payload,    WriteHandler&& handler);```[heading Description]
This function is used to asynchronously send a [@https://tools.ietf.org/html/rfc6455#section-5.5.2 ping frame], which usually elicits an automatic pong control frame response from the peer.

* The ping frame is written.


* An error occurs.

The algorithm, known as a ['composed asynchronous operation], is implemented in terms of calls to the next layer's `async_write_some` function. The program must ensure that no other calls to [link beast.ref.boost__beast__websocket__stream.ping `websocket::stream::ping`], [link beast.ref.boost__beast__websocket__stream.pong `websocket::stream::pong`], [link beast.ref.boost__beast__websocket__stream.async_ping `websocket::stream::async_ping`], or [link beast.ref.boost__beast__websocket__stream.async_pong `websocket::stream::async_pong`] are performed until this operation completes.
If a close frame is sent or received before the ping frame is sent, the error received by this completion handler will be `net::error::operation_aborted`.
[heading Parameters][table [[Name][Description]]  [[`payload`][    
The payload of the ping message, which may be empty. The implementation will not access the contents of this object after the initiating function returns.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      error_code const& ec     // Result of operation
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.   ]]]
[endsect][section:async_pong websocket::stream::async_pong][indexterm2 async_pong..websocket::stream]
Send a websocket pong control frame asynchronously. [heading Synopsis]```template<    class __WriteHandler__>``__deduced__``async_pong(    ping_data const& payload,    WriteHandler&& handler);```[heading Description]
This function is used to asynchronously send a [@https://tools.ietf.org/html/rfc6455#section-5.5.3 pong frame], which is usually sent automatically in response to a ping frame from the remote peer.

* The pong frame is written.


* An error occurs.

The algorithm, known as a ['composed asynchronous operation], is implemented in terms of calls to the next layer's `async_write_some` function. The program must ensure that no other calls to [link beast.ref.boost__beast__websocket__stream.ping `websocket::stream::ping`], [link beast.ref.boost__beast__websocket__stream.pong `websocket::stream::pong`], [link beast.ref.boost__beast__websocket__stream.async_ping `websocket::stream::async_ping`], or [link beast.ref.boost__beast__websocket__stream.async_pong `websocket::stream::async_pong`] are performed until this operation completes.
If a close frame is sent or received before the pong frame is sent, the error received by this completion handler will be `net::error::operation_aborted`.
WebSocket allows pong frames to be sent at any time, without first receiving a ping. An unsolicited pong sent in this fashion may indicate to the remote peer that the connection is still active.
[heading Parameters][table [[Name][Description]]  [[`payload`][    
The payload of the pong message, which may be empty. The implementation will not access the contents of this object after the initiating function returns.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      error_code const& ec     // Result of operation
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.   ]]]
[endsect][section:async_read websocket::stream::async_read][indexterm2 async_read..websocket::stream]
Read a complete message asynchronously. [heading Synopsis]```template<    class __DynamicBuffer__,    class __ReadHandler__>``__deduced__``async_read(    DynamicBuffer& buffer,    ReadHandler&& handler);```[heading Description]
This function is used to asynchronously read a complete message.
This call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:

* A complete message is received.


* A close frame is received. In this case the error indicated by the function will be [link beast.ref.boost__beast__websocket__error `websocket::closed`].


* An error occurs.

The algorithm, known as a ['composed asynchronous operation], is implemented in terms of calls to the next layer's `async_read_some` and `async_write_some` functions. The program must ensure that no other calls to [link beast.ref.boost__beast__websocket__stream.read `websocket::stream::read`], [link beast.ref.boost__beast__websocket__stream.read_some `websocket::stream::read_some`], [link beast.ref.boost__beast__websocket__stream.async_read `websocket::stream::async_read`], or [link beast.ref.boost__beast__websocket__stream.async_read_some `websocket::stream::async_read_some`] are performed until this operation completes.
Received message data is appended to the buffer. The functions [link beast.ref.boost__beast__websocket__stream.got_binary `websocket::stream::got_binary`] and [link beast.ref.boost__beast__websocket__stream.got_text `websocket::stream::got_text`] may be used to query the stream and determine the type of the last received message.
Until the operation completes, the implementation will read incoming control frames and handle them automatically as follows:

* The [link beast.ref.boost__beast__websocket__stream.control_callback `websocket::stream::control_callback`] will be invoked for each control frame.


* For each received ping frame, a pong frame will be automatically sent.


* If a close frame is received, the WebSocket close procedure is performed. In this case, when the function returns, the error [link beast.ref.boost__beast__websocket__error `websocket::closed`] will be indicated.

Pong frames and close frames sent by the implementation while the read operation is outstanding do not prevent the application from also writing message data, sending pings, sending pongs, or sending close frames.
[heading Parameters][table [[Name][Description]]  [[`buffer`][    
A dynamic buffer to append message data to.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      error_code const& ec,       // Result of operation
      std::size_t bytes_written   // Number of bytes appended to buffer
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.   ]]]
[endsect][section:async_read_some websocket::stream::async_read_some][indexterm2 async_read_some..websocket::stream]
Read some message data asynchronously. ```template<    class __DynamicBuffer__,    class __ReadHandler__>``__deduced__````[link beast.ref.boost__beast__websocket__stream.async_read_some.overload1 async_read_some]``(    DynamicBuffer& buffer,    std::size_t limit,    ReadHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.async_read_some.overload1 more...]]``template<    class __MutableBufferSequence__,    class __ReadHandler__>``__deduced__````[link beast.ref.boost__beast__websocket__stream.async_read_some.overload2 async_read_some]``(    MutableBufferSequence const& buffers,    ReadHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.async_read_some.overload2 more...]]`````[section:overload1 websocket::stream::async_read_some (1 of 2 overloads)]
Read some message data asynchronously. [heading Synopsis]```template<    class __DynamicBuffer__,    class __ReadHandler__>``__deduced__``async_read_some(    DynamicBuffer& buffer,    std::size_t limit,    ReadHandler&& handler);```[heading Description]
This function is used to asynchronously read some message data.
This call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:

* Some message data is received.


* A close frame is received. In this case the error indicated by the function will be [link beast.ref.boost__beast__websocket__error `websocket::closed`].


* An error occurs.

The algorithm, known as a ['composed asynchronous operation], is implemented in terms of calls to the next layer's `async_read_some` and `async_write_some` functions. The program must ensure that no other calls to [link beast.ref.boost__beast__websocket__stream.read `websocket::stream::read`], [link beast.ref.boost__beast__websocket__stream.read_some `websocket::stream::read_some`], [link beast.ref.boost__beast__websocket__stream.async_read `websocket::stream::async_read`], or [link beast.ref.boost__beast__websocket__stream.async_read_some `websocket::stream::async_read_some`] are performed until this operation completes.
Received message data is appended to the buffer. The functions [link beast.ref.boost__beast__websocket__stream.got_binary `websocket::stream::got_binary`] and [link beast.ref.boost__beast__websocket__stream.got_text `websocket::stream::got_text`] may be used to query the stream and determine the type of the last received message.
Until the operation completes, the implementation will read incoming control frames and handle them automatically as follows:

* The [link beast.ref.boost__beast__websocket__stream.control_callback `websocket::stream::control_callback`] will be invoked for each control frame.


* For each received ping frame, a pong frame will be automatically sent.


* If a close frame is received, the WebSocket close procedure is performed. In this case, when the function returns, the error [link beast.ref.boost__beast__websocket__error `websocket::closed`] will be indicated.

Pong frames and close frames sent by the implementation while the read operation is outstanding do not prevent the application from also writing message data, sending pings, sending pongs, or sending close frames.
[heading Parameters][table [[Name][Description]]  [[`buffer`][    
A dynamic buffer to append message data to.  ]]  [[`limit`][    
An upper limit on the number of bytes this function will append into the buffer. If this value is zero, then a reasonable size will be chosen automatically.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      error_code const& ec,       // Result of operation
      std::size_t bytes_written   // Number of bytes appended to buffer
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.   ]]]
[endsect][section:overload2 websocket::stream::async_read_some (2 of 2 overloads)]
Read some message data asynchronously. [heading Synopsis]```template<    class __MutableBufferSequence__,    class __ReadHandler__>``__deduced__``async_read_some(    MutableBufferSequence const& buffers,    ReadHandler&& handler);```[heading Description]
This function is used to asynchronously read some message data.
This call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:

* Some message data is received.


* A close frame is received. In this case the error indicated by the function will be [link beast.ref.boost__beast__websocket__error `websocket::closed`].


* An error occurs.

The algorithm, known as a ['composed asynchronous operation], is implemented in terms of calls to the next layer's `async_read_some` and `async_write_some` functions. The program must ensure that no other calls to [link beast.ref.boost__beast__websocket__stream.read `websocket::stream::read`], [link beast.ref.boost__beast__websocket__stream.read_some `websocket::stream::read_some`], [link beast.ref.boost__beast__websocket__stream.async_read `websocket::stream::async_read`], or [link beast.ref.boost__beast__websocket__stream.async_read_some `websocket::stream::async_read_some`] are performed until this operation completes.
Received message data is appended to the buffer. The functions [link beast.ref.boost__beast__websocket__stream.got_binary `websocket::stream::got_binary`] and [link beast.ref.boost__beast__websocket__stream.got_text `websocket::stream::got_text`] may be used to query the stream and determine the type of the last received message.
Until the operation completes, the implementation will read incoming control frames and handle them automatically as follows:

* The [link beast.ref.boost__beast__websocket__stream.control_callback `websocket::stream::control_callback`] will be invoked for each control frame.


* For each received ping frame, a pong frame will be automatically sent.


* If a close frame is received, the WebSocket close procedure is performed. In this case, when the function returns, the error [link beast.ref.boost__beast__websocket__error `websocket::closed`] will be indicated.

Pong frames and close frames sent by the implementation while the read operation is outstanding do not prevent the application from also writing message data, sending pings, sending pongs, or sending close frames.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
A buffer sequence to write message data into. The previous contents of the buffers will be overwritten, starting from the beginning. The implementation will make copies of this object as needed, but but ownership of the underlying memory is not transferred. The caller is responsible for ensuring that the memory locations pointed to by the buffer sequence remain valid until the completion handler is called.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      error_code const& ec,       // Result of operation
      std::size_t bytes_written   // Number of bytes written to the buffers
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.   ]]]
[endsect][endsect][section:async_write websocket::stream::async_write][indexterm2 async_write..websocket::stream]
Write a complete message asynchronously. [heading Synopsis]```template<    class __ConstBufferSequence__,    class __WriteHandler__>``__deduced__``async_write(    ConstBufferSequence const& buffers,    WriteHandler&& handler);```[heading Description]
This function is used to asynchronously write a complete message.
This call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:

* The complete message is written.


* An error occurs.

The algorithm, known as a ['composed asynchronous operation], is implemented in terms of calls to the next layer's `async_write_some` function. The program must ensure that no other calls to [link beast.ref.boost__beast__websocket__stream.write `websocket::stream::write`], [link beast.ref.boost__beast__websocket__stream.write_some `websocket::stream::write_some`], [link beast.ref.boost__beast__websocket__stream.async_write `websocket::stream::async_write`], or [link beast.ref.boost__beast__websocket__stream.async_write_some `websocket::stream::async_write_some`] are performed until this operation completes.
The current setting of the [link beast.ref.boost__beast__websocket__stream.binary `websocket::stream::binary`] option controls whether the message opcode is set to text or binary. If the [link beast.ref.boost__beast__websocket__stream.auto_fragment `websocket::stream::auto_fragment`] option is set, the message will be split into one or more frames as necessary. The actual payload contents sent may be transformed as per the WebSocket protocol settings.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
A buffer sequence containing the entire message payload. The implementation will make copies of this object as needed, but ownership of the underlying memory is not transferred. The caller is responsible for ensuring that the memory locations pointed to by buffers remains valid until the completion handler is called.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      error_code const& ec,           // Result of operation
      std::size_t bytes_transferred   // Number of bytes sent from the
                                      // buffers. If an error occurred,
                                      // this will be less than the buffer_size.
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.   ]]]
[endsect][section:async_write_some websocket::stream::async_write_some][indexterm2 async_write_some..websocket::stream]
Write some message data asynchronously. [heading Synopsis]```template<    class __ConstBufferSequence__,    class __WriteHandler__>``__deduced__``async_write_some(    bool fin,    ConstBufferSequence const& buffers,    WriteHandler&& handler);```[heading Description]
This function is used to asynchronously write part of a message.
This call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:

* The message data is written.


* An error occurs.

The algorithm, known as a ['composed asynchronous operation], is implemented in terms of calls to the next layer's `async_write_some` function. The program must ensure that no other calls to [link beast.ref.boost__beast__websocket__stream.write `websocket::stream::write`], [link beast.ref.boost__beast__websocket__stream.write_some `websocket::stream::write_some`], [link beast.ref.boost__beast__websocket__stream.async_write `websocket::stream::async_write`], or [link beast.ref.boost__beast__websocket__stream.async_write_some `websocket::stream::async_write_some`] are performed until this operation completes.
If this is the beginning of a new message, the message opcode will be set to text or binary based on the current setting of the [link beast.ref.boost__beast__websocket__stream.binary `websocket::stream::binary`] (or [link beast.ref.boost__beast__websocket__stream.text `websocket::stream::text`]) option. The actual payload sent may be transformed as per the WebSocket protocol settings.
[heading Parameters][table [[Name][Description]]  [[`fin`][    
`true` if this is the last part of the message.  ]]  [[`buffers`][    
The buffers containing the message part to send. The implementation will make copies of this object as needed, but ownership of the underlying memory is not transferred. The caller is responsible for ensuring that the memory locations pointed to by buffers remains valid until the completion handler is called.  ]]  [[`handler`][    
The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: ```  void handler(
      error_code const& ec,           // Result of operation
      std::size_t bytes_transferred   // Number of bytes sent from the
                                      // buffers. If an error occurred,
                                      // this will be less than the buffer_size.
  );
```Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `net::post`.   ]]]
[endsect][section:auto_fragment websocket::stream::auto_fragment][indexterm2 auto_fragment..websocket::stream]
Set the automatic fragmentation option. ```void``[link beast.ref.boost__beast__websocket__stream.auto_fragment.overload1 auto_fragment]``(    bool value);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.auto_fragment.overload1 more...]]`````
Returns `true` if the automatic fragmentation option is set. ```bool``[link beast.ref.boost__beast__websocket__stream.auto_fragment.overload2 auto_fragment]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.auto_fragment.overload2 more...]]`````[section:overload1 websocket::stream::auto_fragment (1 of 2 overloads)]
Set the automatic fragmentation option. [heading Synopsis]```voidauto_fragment(    bool value);```[heading Description]
Determines if outgoing message payloads are broken up into multiple pieces.
When the automatic fragmentation size is turned on, outgoing message payloads are broken up into multiple frames no larger than the write buffer size.
The default setting is to fragment messages.
[heading Parameters][table [[Name][Description]]  [[`value`][    
A `bool` indicating if auto fragmentation should be on.  ]]]
[heading Example]
Setting the automatic fragmentation option: ```  ws.auto_fragment(true);
```
[endsect][section:overload2 websocket::stream::auto_fragment (2 of 2 overloads)]
Returns `true` if the automatic fragmentation option is set. [heading Synopsis]```boolauto_fragment() const;```[heading Description][endsect][endsect][section:binary websocket::stream::binary][indexterm2 binary..websocket::stream]
Set the binary message write option. ```void``[link beast.ref.boost__beast__websocket__stream.binary.overload1 binary]``(    bool value);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.binary.overload1 more...]]`````
Returns `true` if the binary message write option is set. ```bool``[link beast.ref.boost__beast__websocket__stream.binary.overload2 binary]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.binary.overload2 more...]]`````[section:overload1 websocket::stream::binary (1 of 2 overloads)]
Set the binary message write option. [heading Synopsis]```voidbinary(    bool value);```[heading Description]
This controls whether or not outgoing message opcodes are set to binary or text. The setting is only applied at the start when a caller begins a new message. Changing the opcode after a message is started will only take effect after the current message being sent is complete.
The default setting is to send text messages.
[heading Parameters][table [[Name][Description]]  [[`value`][    
`true` if outgoing messages should indicate binary, or `false` if they should indicate text.  ]]]
[heading Example]
Setting the message type to binary. ```  ws.binary(true);
```
[endsect][section:overload2 websocket::stream::binary (2 of 2 overloads)]
Returns `true` if the binary message write option is set. [heading Synopsis]```boolbinary() const;```[heading Description][endsect][endsect][section:close websocket::stream::close][indexterm2 close..websocket::stream]
Send a websocket close control frame. ```void``[link beast.ref.boost__beast__websocket__stream.close.overload1 close]``(    close_reason const& cr);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.close.overload1 more...]]``void``[link beast.ref.boost__beast__websocket__stream.close.overload2 close]``(    close_reason const& cr,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.close.overload2 more...]]`````[section:overload1 websocket::stream::close (1 of 2 overloads)]
Send a websocket close control frame. [heading Synopsis]```voidclose(    close_reason const& cr);```[heading Description]
This function is used to send a [@https://tools.ietf.org/html/rfc6455#section-5.5.1 close frame], which begins the websocket closing handshake. The session ends when both ends of the connection have sent and received a close frame.
The call blocks until one of the following conditions is true:

* The close frame is written.


* An error occurs.

The algorithm, known as a ['composed operation], is implemented in terms of calls to the next layer's `write_some` function.
After beginning the closing handshake, the program should not write further message data, pings, or pongs. Instead, the program should continue reading message data until an error occurs. A read returning [link beast.ref.boost__beast__websocket__error `websocket::closed`] indicates a successful connection closure.
[heading Parameters][table [[Name][Description]]  [[`cr`][    
The reason for the close. If the close reason specifies a close code other than beast::websocket::close\_code::none, the close frame is sent with the close code and optional reason string. Otherwise, the close frame is sent with no payload.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    
Thrown on failure.  ]]]
[heading See Also]

* [@https://tools.ietf.org/html/rfc6455#section-7.1.2 Websocket Closing Handshake (RFC6455)] 


[endsect][section:overload2 websocket::stream::close (2 of 2 overloads)]
Send a websocket close control frame. [heading Synopsis]```voidclose(    close_reason const& cr,    error_code& ec);```[heading Description]
This function is used to send a [@https://tools.ietf.org/html/rfc6455#section-5.5.1 close frame], which begins the websocket closing handshake. The session ends when both ends of the connection have sent and received a close frame.
The call blocks until one of the following conditions is true:

* The close frame is written.


* An error occurs.

The algorithm, known as a ['composed operation], is implemented in terms of calls to the next layer's `write_some` function.
After beginning the closing handshake, the program should not write further message data, pings, or pongs. Instead, the program should continue reading message data until an error occurs. A read returning [link beast.ref.boost__beast__websocket__error `websocket::closed`] indicates a successful connection closure.
[heading Parameters][table [[Name][Description]]  [[`cr`][    
The reason for the close. If the close reason specifies a close code other than beast::websocket::close\_code::none, the close frame is sent with the close code and optional reason string. Otherwise, the close frame is sent with no payload.  ]]  [[`ec`][    
Set to indicate what error occurred, if any.  ]]]
[heading See Also]

* [@https://tools.ietf.org/html/rfc6455#section-7.1.2 Websocket Closing Handshake (RFC6455)] 


[endsect][endsect][section:control_callback websocket::stream::control_callback][indexterm2 control_callback..websocket::stream]
Set a callback to be invoked on each incoming control frame. ```void``[link beast.ref.boost__beast__websocket__stream.control_callback.overload1 control_callback]``(    std::function< void(frame_type, string_view)> cb);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.control_callback.overload1 more...]]`````
Reset the control frame callback. ```void``[link beast.ref.boost__beast__websocket__stream.control_callback.overload2 control_callback]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.control_callback.overload2 more...]]`````[section:overload1 websocket::stream::control_callback (1 of 2 overloads)]
Set a callback to be invoked on each incoming control frame. [heading Synopsis]```voidcontrol_callback(    std::function< void(frame_type, string_view)> cb);```[heading Description]
Sets the callback to be invoked whenever a ping, pong, or close control frame is received during a call to one of the following functions:

* [link beast.ref.boost__beast__websocket__stream.read `websocket::stream::read`] 
* [link beast.ref.boost__beast__websocket__stream.read_some `websocket::stream::read_some`] 
* [link beast.ref.boost__beast__websocket__stream.async_read `websocket::stream::async_read`] 
* [link beast.ref.boost__beast__websocket__stream.async_read_some `websocket::stream::async_read_some`]

Unlike completion handlers, the callback will be invoked for each control frame during a call to any synchronous or asynchronous read function. The operation is passive, with no associated error code, and triggered by reads.
For close frames, the close reason code may be obtained by calling the function [link beast.ref.boost__beast__websocket__stream.reason `websocket::stream::reason`].
[heading Parameters][table [[Name][Description]]  [[`cb`][    
The function object to call, which must be invocable with this equivalent signature: ```  void
  callback(
      frame_type kind,       // The type of frame
      string_view payload    // The payload in the frame
  );
```The implementation type-erases the callback which may require a dynamic allocation. To prevent the possibility of a dynamic allocation, use `std::ref` to wrap the callback. If the read operation which receives the control frame is an asynchronous operation, the callback will be invoked using the same method as that used to invoke the final handler.  ]]]
[heading Remarks]
Incoming ping and close frames are automatically handled. Pings are responded to with pongs, and a close frame is responded to with a close frame leading to the closure of the stream. It is not necessary to manually send pings, pongs, or close frames from inside the control callback. Attempting to manually send a close frame from inside the control callback after receiving a close frame will result in undefined behavior. 
[endsect][section:overload2 websocket::stream::control_callback (2 of 2 overloads)]
Reset the control frame callback. [heading Synopsis]```voidcontrol_callback();```[heading Description]
This function removes any previously set control frame callback. [endsect][endsect][section:executor_type websocket::stream::executor_type][indexterm2 executor_type..websocket::stream]
The type of the executor associated with the object. [heading Synopsis]```using executor_type = beast::executor_type< next_layer_type >;```[heading Description][endsect][section:get_executor websocket::stream::get_executor][indexterm2 get_executor..websocket::stream]
Get the executor associated with the object. [heading Synopsis]```executor_typeget_executor();```[heading Description]
This function may be used to obtain the executor object that the stream uses to dispatch handlers for asynchronous operations.
[heading Return Value]
A copy of the executor that stream will use to dispatch handlers. 
[endsect][section:get_option websocket::stream::get_option][indexterm2 get_option..websocket::stream]```template<    class Option>void``[link beast.ref.boost__beast__websocket__stream.get_option.overload1 get_option]``(    Option& opt);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.get_option.overload1 more...]]`````
Get the permessage-deflate extension options. ```void``[link beast.ref.boost__beast__websocket__stream.get_option.overload2 get_option]``(    permessage_deflate& o);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.get_option.overload2 more...]]`````[section:overload1 websocket::stream::get_option (1 of 2 overloads)][heading Synopsis]```template<    class Option>voidget_option(    Option& opt);```[heading Description][endsect][section:overload2 websocket::stream::get_option (2 of 2 overloads)]
Get the permessage-deflate extension options. [heading Synopsis]```voidget_option(    permessage_deflate& o);```[heading Description][endsect][endsect][section:got_binary websocket::stream::got_binary][indexterm2 got_binary..websocket::stream]
Returns `true` if the latest message data indicates binary. [heading Synopsis]```boolgot_binary() const;```[heading Description]
This function informs the caller of whether the last received message frame represents a message with the binary opcode.
If there is no last message frame, the return value is undefined. [endsect][section:got_text websocket::stream::got_text][indexterm2 got_text..websocket::stream]
Returns `true` if the latest message data indicates text. [heading Synopsis]```boolgot_text() const;```[heading Description]
This function informs the caller of whether the last received message frame represents a message with the text opcode.
If there is no last message frame, the return value is undefined. [endsect][section:handshake websocket::stream::handshake][indexterm2 handshake..websocket::stream]
Perform the WebSocket handshake in the client role. ```void``[link beast.ref.boost__beast__websocket__stream.handshake.overload1 handshake]``(    string_view host,    string_view target);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.handshake.overload1 more...]]``void``[link beast.ref.boost__beast__websocket__stream.handshake.overload2 handshake]``(    response_type& res,    string_view host,    string_view target);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.handshake.overload2 more...]]``void``[link beast.ref.boost__beast__websocket__stream.handshake.overload3 handshake]``(    string_view host,    string_view target,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.handshake.overload3 more...]]``void``[link beast.ref.boost__beast__websocket__stream.handshake.overload4 handshake]``(    response_type& res,    string_view host,    string_view target,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.handshake.overload4 more...]]`````[section:overload1 websocket::stream::handshake (1 of 4 overloads)]
Perform the WebSocket handshake in the client role. [heading Synopsis]```voidhandshake(    string_view host,    string_view target);```[heading Description]
This function is used to perform the [@https://en.wikipedia.org/wiki/WebSocket#Protocol_handshake WebSocket handshake], required before messages can be sent and received. During the handshake, the client sends the Websocket Upgrade HTTP request, and the server replies with an HTTP response indicating the result of the handshake.
The call blocks until one of the following conditions is true:

* The request is sent and the response is received.


* An error occurs.

The algorithm, known as a ['composed operation], is implemented in terms of calls to the next layer's `read_some` and `write_some` functions.
The handshake is successful if the received HTTP response indicates the upgrade was accepted by the server, represented by a [@https://tools.ietf.org/html/rfc7230#section-3.1.2 status-code] of [link beast.ref.boost__beast__http__status `http::switching_protocols`].
[heading Parameters][table [[Name][Description]]  [[`host`][    
The name of the remote host. This is required by the HTTP protocol to set the "Host" header field.  ]]  [[`target`][    
The request-target, in origin-form. The server may use the target to distinguish different services on the same listening port.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    
Thrown on failure.  ]]]
[heading Example]
```  ws.handshake("localhost", "/");
```
[heading See Also]

* [@https://tools.ietf.org/html/rfc6455#section-4.1 Websocket Opening Handshake Client Requirements (RFC6455)] 
* [@https://tools.ietf.org/html/rfc7230#section-5.4 Host field (RFC7230)] 
* [@https://tools.ietf.org/html/rfc7230#section-3.1.1 request-target (RFC7230)] 
* [@https://tools.ietf.org/html/rfc7230#section-5.3.1 origin-form (RFC7230)] 


[endsect][section:overload2 websocket::stream::handshake (2 of 4 overloads)]
Perform the WebSocket handshake in the client role. [heading Synopsis]```voidhandshake(    response_type& res,    string_view host,    string_view target);```[heading Description]
This function is used to perform the [@https://en.wikipedia.org/wiki/WebSocket#Protocol_handshake WebSocket handshake], required before messages can be sent and received. During the handshake, the client sends the Websocket Upgrade HTTP request, and the server replies with an HTTP response indicating the result of the handshake.
The call blocks until one of the following conditions is true:

* The request is sent and the response is received.


* An error occurs.

The algorithm, known as a ['composed operation], is implemented in terms of calls to the next layer's `read_some` and `write_some` functions.
The handshake is successful if the received HTTP response indicates the upgrade was accepted by the server, represented by a [@https://tools.ietf.org/html/rfc7230#section-3.1.2 status-code] of [link beast.ref.boost__beast__http__status `http::switching_protocols`].
[heading Parameters][table [[Name][Description]]  [[`res`][    
The HTTP Upgrade response returned by the remote endpoint. The caller may use the response to access any additional information sent by the server.  ]]  [[`host`][    
The name of the remote host. This is required by the HTTP protocol to set the "Host" header field.  ]]  [[`target`][    
The request-target, in origin-form. The server may use the target to distinguish different services on the same listening port.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    
Thrown on failure.  ]]]
[heading Example]
```  response_type res;
  ws.handshake(res, "localhost", "/");
  std::cout << res;
```
[heading See Also]

* [@https://tools.ietf.org/html/rfc6455#section-4.1 Websocket Opening Handshake Client Requirements (RFC6455)] 
* [@https://tools.ietf.org/html/rfc7230#section-5.4 Host field (RFC7230)] 
* [@https://tools.ietf.org/html/rfc7230#section-3.1.1 request-target (RFC7230)] 
* [@https://tools.ietf.org/html/rfc7230#section-5.3.1 origin-form (RFC7230)] 


[endsect][section:overload3 websocket::stream::handshake (3 of 4 overloads)]
Perform the WebSocket handshake in the client role. [heading Synopsis]```voidhandshake(    string_view host,    string_view target,    error_code& ec);```[heading Description]
This function is used to perform the [@https://en.wikipedia.org/wiki/WebSocket#Protocol_handshake WebSocket handshake], required before messages can be sent and received. During the handshake, the client sends the Websocket Upgrade HTTP request, and the server replies with an HTTP response indicating the result of the handshake.
The call blocks until one of the following conditions is true:

* The request is sent and the response is received.


* An error occurs.

The algorithm, known as a ['composed operation], is implemented in terms of calls to the next layer's `read_some` and `write_some` functions.
The handshake is successful if the received HTTP response indicates the upgrade was accepted by the server, represented by a [@https://tools.ietf.org/html/rfc7230#section-3.1.2 status-code] of [link beast.ref.boost__beast__http__status `http::switching_protocols`].
[heading Parameters][table [[Name][Description]]  [[`host`][    
The name of the remote host. This is required by the HTTP protocol to set the "Host" header field.  ]]  [[`target`][    
The request-target, in origin-form. The server may use the target to distinguish different services on the same listening port.  ]]  [[`ec`][    
Set to indicate what error occurred, if any.  ]]]
[heading Example]
```  error_code ec;
  ws.handshake("localhost", "/", ec);
```
[heading See Also]

* [@https://tools.ietf.org/html/rfc6455#section-4.1 Websocket Opening Handshake Client Requirements (RFC6455)] 
* [@https://tools.ietf.org/html/rfc7230#section-5.4 Host field (RFC7230)] 
* [@https://tools.ietf.org/html/rfc7230#section-3.1.1 request-target (RFC7230)] 
* [@https://tools.ietf.org/html/rfc7230#section-5.3.1 origin-form (RFC7230)] 


[endsect][section:overload4 websocket::stream::handshake (4 of 4 overloads)]
Perform the WebSocket handshake in the client role. [heading Synopsis]```voidhandshake(    response_type& res,    string_view host,    string_view target,    error_code& ec);```[heading Description]
This function is used to perform the [@https://en.wikipedia.org/wiki/WebSocket#Protocol_handshake WebSocket handshake], required before messages can be sent and received. During the handshake, the client sends the Websocket Upgrade HTTP request, and the server replies with an HTTP response indicating the result of the handshake.
The call blocks until one of the following conditions is true:

* The request is sent and the response is received.


* An error occurs.

The algorithm, known as a ['composed operation], is implemented in terms of calls to the next layer's `read_some` and `write_some` functions.
The handshake is successful if the received HTTP response indicates the upgrade was accepted by the server, represented by a [@https://tools.ietf.org/html/rfc7230#section-3.1.2 status-code] of [link beast.ref.boost__beast__http__status `http::switching_protocols`].
[heading Parameters][table [[Name][Description]]  [[`res`][    
The HTTP Upgrade response returned by the remote endpoint. The caller may use the response to access any additional information sent by the server.  ]]  [[`host`][    
The name of the remote host. This is required by the HTTP protocol to set the "Host" header field.  ]]  [[`target`][    
The request-target, in origin-form. The server may use the target to distinguish different services on the same listening port.  ]]  [[`ec`][    
Set to indicate what error occurred, if any.  ]]]
[heading Example]
```  error_code ec;
  response_type res;
  ws.handshake(res, "localhost", "/", ec);
  if(! ec)
      std::cout << res;
```
[heading See Also]

* [@https://tools.ietf.org/html/rfc6455#section-4.1 Websocket Opening Handshake Client Requirements (RFC6455)] 
* [@https://tools.ietf.org/html/rfc7230#section-5.4 Host field (RFC7230)] 
* [@https://tools.ietf.org/html/rfc7230#section-3.1.1 request-target (RFC7230)] 
* [@https://tools.ietf.org/html/rfc7230#section-5.3.1 origin-form (RFC7230)] 


[endsect][endsect][section:is_deflate_supported websocket::stream::is_deflate_supported][indexterm2 is_deflate_supported..websocket::stream]
Indicates if the permessage-deflate extension is supported. [heading Synopsis]```using is_deflate_supported = std::integral_constant< bool, deflateSupported >;```[heading Description][endsect][section:is_message_done websocket::stream::is_message_done][indexterm2 is_message_done..websocket::stream]
Returns `true` if the last completed read finished the current message. [heading Synopsis]```boolis_message_done() const;```[heading Description][endsect][section:is_open websocket::stream::is_open][indexterm2 is_open..websocket::stream]
Returns `true` if the stream is open. [heading Synopsis]```boolis_open() const;```[heading Description]
The stream is open after a successful handshake, and when no error has occurred. [endsect][section:next_layer websocket::stream::next_layer][indexterm2 next_layer..websocket::stream]
Get a reference to the next layer. ```next_layer_type&``[link beast.ref.boost__beast__websocket__stream.next_layer.overload1 next_layer]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.next_layer.overload1 more...]]``next_layer_type const &``[link beast.ref.boost__beast__websocket__stream.next_layer.overload2 next_layer]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.next_layer.overload2 more...]]`````[section:overload1 websocket::stream::next_layer (1 of 2 overloads)]
Get a reference to the next layer. [heading Synopsis]```next_layer_type&next_layer();```[heading Description]
This function returns a reference to the next layer in a stack of stream layers.
[heading Return Value]
A reference to the next layer in the stack of stream layers. 
[endsect][section:overload2 websocket::stream::next_layer (2 of 2 overloads)]
Get a reference to the next layer. [heading Synopsis]```next_layer_type const &next_layer() const;```[heading Description]
This function returns a reference to the next layer in a stack of stream layers.
[heading Return Value]
A reference to the next layer in the stack of stream layers. 
[endsect][endsect][section:next_layer_type websocket::stream::next_layer_type][indexterm2 next_layer_type..websocket::stream]
The type of the next layer. [heading Synopsis]```using next_layer_type = typename std::remove_reference< NextLayer >::type;```[heading Description][endsect][section:operator_eq_ websocket::stream::operator=][indexterm2 operator=..websocket::stream]
Move assignment (deleted) [heading Synopsis]```stream&operator=(    stream&&);```[heading Description][endsect][section:ping websocket::stream::ping][indexterm2 ping..websocket::stream]
Send a websocket ping control frame. ```void``[link beast.ref.boost__beast__websocket__stream.ping.overload1 ping]``(    ping_data const& payload);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.ping.overload1 more...]]``void``[link beast.ref.boost__beast__websocket__stream.ping.overload2 ping]``(    ping_data const& payload,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.ping.overload2 more...]]`````[section:overload1 websocket::stream::ping (1 of 2 overloads)]
Send a websocket ping control frame. [heading Synopsis]```voidping(    ping_data const& payload);```[heading Description]
This function is used to send a [@https://tools.ietf.org/html/rfc6455#section-5.5.2 ping frame], which usually elicits an automatic pong control frame response from the peer.
The call blocks until one of the following conditions is true:

* The ping frame is written.


* An error occurs.

The algorithm, known as a ['composed operation], is implemented in terms of calls to the next layer's `write_some` function.
[heading Parameters][table [[Name][Description]]  [[`payload`][    
The payload of the ping message, which may be empty.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    
Thrown on failure.   ]]]
[endsect][section:overload2 websocket::stream::ping (2 of 2 overloads)]
Send a websocket ping control frame. [heading Synopsis]```voidping(    ping_data const& payload,    error_code& ec);```[heading Description]
This function is used to send a [@https://tools.ietf.org/html/rfc6455#section-5.5.2 ping frame], which usually elicits an automatic pong control frame response from the peer.
The call blocks until one of the following conditions is true:

* The ping frame is written.


* An error occurs.

The algorithm, known as a ['composed operation], is implemented in terms of calls to the next layer's `write_some` function.
[heading Parameters][table [[Name][Description]]  [[`payload`][    
The payload of the ping message, which may be empty.  ]]  [[`ec`][    
Set to indicate what error occurred, if any.   ]]]
[endsect][endsect][section:pong websocket::stream::pong][indexterm2 pong..websocket::stream]
Send a websocket pong control frame. ```void``[link beast.ref.boost__beast__websocket__stream.pong.overload1 pong]``(    ping_data const& payload);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.pong.overload1 more...]]``void``[link beast.ref.boost__beast__websocket__stream.pong.overload2 pong]``(    ping_data const& payload,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.pong.overload2 more...]]`````[section:overload1 websocket::stream::pong (1 of 2 overloads)]
Send a websocket pong control frame. [heading Synopsis]```voidpong(    ping_data const& payload);```[heading Description]
This function is used to send a [@https://tools.ietf.org/html/rfc6455#section-5.5.3 pong frame], which is usually sent automatically in response to a ping frame from the remote peer.
The call blocks until one of the following conditions is true:

* The pong frame is written.


* An error occurs.

The algorithm, known as a ['composed operation], is implemented in terms of calls to the next layer's `write_some` function.
WebSocket allows pong frames to be sent at any time, without first receiving a ping. An unsolicited pong sent in this fashion may indicate to the remote peer that the connection is still active.
[heading Parameters][table [[Name][Description]]  [[`payload`][    
The payload of the pong message, which may be empty.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    
Thrown on failure.   ]]]
[endsect][section:overload2 websocket::stream::pong (2 of 2 overloads)]
Send a websocket pong control frame. [heading Synopsis]```voidpong(    ping_data const& payload,    error_code& ec);```[heading Description]
This function is used to send a [@https://tools.ietf.org/html/rfc6455#section-5.5.3 pong frame], which is usually sent automatically in response to a ping frame from the remote peer.
The call blocks until one of the following conditions is true:

* The pong frame is written.


* An error occurs.

The algorithm, known as a ['composed operation], is implemented in terms of calls to the next layer's `write_some` function.
WebSocket allows pong frames to be sent at any time, without first receiving a ping. An unsolicited pong sent in this fashion may indicate to the remote peer that the connection is still active.
[heading Parameters][table [[Name][Description]]  [[`payload`][    
The payload of the pong message, which may be empty.  ]]  [[`ec`][    
Set to indicate what error occurred, if any.   ]]]
[endsect][endsect][section:read websocket::stream::read][indexterm2 read..websocket::stream]
Read a complete message. ```template<    class __DynamicBuffer__>std::size_t``[link beast.ref.boost__beast__websocket__stream.read.overload1 read]``(    DynamicBuffer& buffer);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.read.overload1 more...]]``template<    class __DynamicBuffer__>std::size_t``[link beast.ref.boost__beast__websocket__stream.read.overload2 read]``(    DynamicBuffer& buffer,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.read.overload2 more...]]`````[section:overload1 websocket::stream::read (1 of 2 overloads)]
Read a complete message. [heading Synopsis]```template<    class __DynamicBuffer__>std::size_tread(    DynamicBuffer& buffer);```[heading Description]
This function is used to read a complete message.
The call blocks until one of the following is true:

* A complete message is received.


* A close frame is received. In this case the error indicated by the function will be [link beast.ref.boost__beast__websocket__error `websocket::closed`].


* An error occurs.

The algorithm, known as a ['composed operation], is implemented in terms of calls to the next layer's `read_some` and `write_some` functions.
Received message data is appended to the buffer. The functions [link beast.ref.boost__beast__websocket__stream.got_binary `websocket::stream::got_binary`] and [link beast.ref.boost__beast__websocket__stream.got_text `websocket::stream::got_text`] may be used to query the stream and determine the type of the last received message.
Until the call returns, the implementation will read incoming control frames and handle them automatically as follows:

* The [link beast.ref.boost__beast__websocket__stream.control_callback `websocket::stream::control_callback`] will be invoked for each control frame.


* For each received ping frame, a pong frame will be automatically sent.


* If a close frame is received, the WebSocket closing handshake is performed. In this case, when the function returns, the error [link beast.ref.boost__beast__websocket__error `websocket::closed`] will be indicated.

[heading Return Value]
The number of message payload bytes appended to the buffer.
[heading Parameters][table [[Name][Description]]  [[`buffer`][    
A dynamic buffer to append message data to.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    
Thrown on failure.   ]]]
[endsect][section:overload2 websocket::stream::read (2 of 2 overloads)]
Read a complete message. [heading Synopsis]```template<    class __DynamicBuffer__>std::size_tread(    DynamicBuffer& buffer,    error_code& ec);```[heading Description]
This function is used to read a complete message.
The call blocks until one of the following is true:

* A complete message is received.


* A close frame is received. In this case the error indicated by the function will be [link beast.ref.boost__beast__websocket__error `websocket::closed`].


* An error occurs.

The algorithm, known as a ['composed operation], is implemented in terms of calls to the next layer's `read_some` and `write_some` functions.
Received message data is appended to the buffer. The functions [link beast.ref.boost__beast__websocket__stream.got_binary `websocket::stream::got_binary`] and [link beast.ref.boost__beast__websocket__stream.got_text `websocket::stream::got_text`] may be used to query the stream and determine the type of the last received message.
Until the call returns, the implementation will read incoming control frames and handle them automatically as follows:

* The [link beast.ref.boost__beast__websocket__stream.control_callback `websocket::stream::control_callback`] will be invoked for each control frame.


* For each received ping frame, a pong frame will be automatically sent.


* If a close frame is received, the WebSocket closing handshake is performed. In this case, when the function returns, the error [link beast.ref.boost__beast__websocket__error `websocket::closed`] will be indicated.

[heading Return Value]
The number of message payload bytes appended to the buffer.
[heading Parameters][table [[Name][Description]]  [[`buffer`][    
A dynamic buffer to append message data to.  ]]  [[`ec`][    
Set to indicate what error occurred, if any.   ]]]
[endsect][endsect][section:read_message_max websocket::stream::read_message_max][indexterm2 read_message_max..websocket::stream]
Set the maximum incoming message size option. ```void``[link beast.ref.boost__beast__websocket__stream.read_message_max.overload1 read_message_max]``(    std::size_t amount);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.read_message_max.overload1 more...]]`````
Returns the maximum incoming message size setting. ```std::size_t``[link beast.ref.boost__beast__websocket__stream.read_message_max.overload2 read_message_max]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.read_message_max.overload2 more...]]`````[section:overload1 websocket::stream::read_message_max (1 of 2 overloads)]
Set the maximum incoming message size option. [heading Synopsis]```voidread_message_max(    std::size_t amount);```[heading Description]
Sets the largest permissible incoming message size. Message frame fields indicating a size that would bring the total message size over this limit will cause a protocol failure.
The default setting is 16 megabytes. A value of zero indicates a limit of the maximum value of a `std::uint64_t`.
[heading Example]
Setting the maximum read message size. ```  ws.read_message_max(65536);
```
[heading Parameters][table [[Name][Description]]  [[`amount`][    
The limit on the size of incoming messages.   ]]]
[endsect][section:overload2 websocket::stream::read_message_max (2 of 2 overloads)]
Returns the maximum incoming message size setting. [heading Synopsis]```std::size_tread_message_max() const;```[heading Description][endsect][endsect][section:read_size_hint websocket::stream::read_size_hint][indexterm2 read_size_hint..websocket::stream]
Returns a suggested maximum buffer size for the next call to read. ```std::size_t``[link beast.ref.boost__beast__websocket__stream.read_size_hint.overload1 read_size_hint]``(    std::size_t initial_size = +tcp_frame_size) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.read_size_hint.overload1 more...]]``template<    class __DynamicBuffer__>std::size_t``[link beast.ref.boost__beast__websocket__stream.read_size_hint.overload2 read_size_hint]``(    DynamicBuffer& buffer) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.read_size_hint.overload2 more...]]`````[section:overload1 websocket::stream::read_size_hint (1 of 2 overloads)]
Returns a suggested maximum buffer size for the next call to read. [heading Synopsis]```std::size_tread_size_hint(    std::size_t initial_size = +tcp_frame_size) const;```[heading Description]
This function returns a reasonable upper limit on the number of bytes for the size of the buffer passed in the next call to read. The number is determined by the state of the current frame and whether or not the permessage-deflate extension is enabled.
[heading Parameters][table [[Name][Description]]  [[`initial_size`][    
A non-zero size representing the caller's desired buffer size for when there is no information which may be used to calculate a more specific value. For example, when reading the first frame header of a message.   ]]]
[endsect][section:overload2 websocket::stream::read_size_hint (2 of 2 overloads)]
Returns a suggested maximum buffer size for the next call to read. [heading Synopsis]```template<    class __DynamicBuffer__>std::size_tread_size_hint(    DynamicBuffer& buffer) const;```[heading Description]
This function returns a reasonable upper limit on the number of bytes for the size of the buffer passed in the next call to read. The number is determined by the state of the current frame and whether or not the permessage-deflate extension is enabled.
[heading Parameters][table [[Name][Description]]  [[`buffer`][    
The buffer which will be used for reading. The implementation will query the buffer to obtain the optimum size of a subsequent call to `buffer.prepare` based on the state of the current frame, if any.   ]]]
[endsect][endsect][section:read_some websocket::stream::read_some][indexterm2 read_some..websocket::stream]
Read some message data. ```template<    class __DynamicBuffer__>std::size_t``[link beast.ref.boost__beast__websocket__stream.read_some.overload1 read_some]``(    DynamicBuffer& buffer,    std::size_t limit);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.read_some.overload1 more...]]``template<    class __DynamicBuffer__>std::size_t``[link beast.ref.boost__beast__websocket__stream.read_some.overload2 read_some]``(    DynamicBuffer& buffer,    std::size_t limit,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.read_some.overload2 more...]]``template<    class __MutableBufferSequence__>std::size_t``[link beast.ref.boost__beast__websocket__stream.read_some.overload3 read_some]``(    MutableBufferSequence const& buffers);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.read_some.overload3 more...]]``template<    class __MutableBufferSequence__>std::size_t``[link beast.ref.boost__beast__websocket__stream.read_some.overload4 read_some]``(    MutableBufferSequence const& buffers,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.read_some.overload4 more...]]`````[section:overload1 websocket::stream::read_some (1 of 4 overloads)]
Read some message data. [heading Synopsis]```template<    class __DynamicBuffer__>std::size_tread_some(    DynamicBuffer& buffer,    std::size_t limit);```[heading Description]
This function is used to read some message data.
The call blocks until one of the following is true:

* Some message data is received.


* A close frame is received. In this case the error indicated by the function will be [link beast.ref.boost__beast__websocket__error `websocket::closed`].


* An error occurs.

The algorithm, known as a ['composed operation], is implemented in terms of calls to the next layer's `read_some` and `write_some` functions.
Received message data is appended to the buffer. The functions [link beast.ref.boost__beast__websocket__stream.got_binary `websocket::stream::got_binary`] and [link beast.ref.boost__beast__websocket__stream.got_text `websocket::stream::got_text`] may be used to query the stream and determine the type of the last received message. The function [link beast.ref.boost__beast__websocket__stream.is_message_done `websocket::stream::is_message_done`] may be called to determine if the message received by the last read operation is complete.
Until the call returns, the implementation will read incoming control frames and handle them automatically as follows:

* The [link beast.ref.boost__beast__websocket__stream.control_callback `websocket::stream::control_callback`] will be invoked for each control frame.


* For each received ping frame, a pong frame will be automatically sent.


* If a close frame is received, the WebSocket closing handshake is performed. In this case, when the function returns, the error [link beast.ref.boost__beast__websocket__error `websocket::closed`] will be indicated.

[heading Return Value]
The number of message payload bytes appended to the buffer.
[heading Parameters][table [[Name][Description]]  [[`buffer`][    
A dynamic buffer to append message data to.  ]]  [[`limit`][    
An upper limit on the number of bytes this function will append into the buffer. If this value is zero, then a reasonable size will be chosen automatically.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    
Thrown on failure.   ]]]
[endsect][section:overload2 websocket::stream::read_some (2 of 4 overloads)]
Read some message data. [heading Synopsis]```template<    class __DynamicBuffer__>std::size_tread_some(    DynamicBuffer& buffer,    std::size_t limit,    error_code& ec);```[heading Description]
This function is used to read some message data.
The call blocks until one of the following is true:

* Some message data is received.


* A close frame is received. In this case the error indicated by the function will be [link beast.ref.boost__beast__websocket__error `websocket::closed`].


* An error occurs.

The algorithm, known as a ['composed operation], is implemented in terms of calls to the next layer's `read_some` and `write_some` functions.
Received message data is appended to the buffer. The functions [link beast.ref.boost__beast__websocket__stream.got_binary `websocket::stream::got_binary`] and [link beast.ref.boost__beast__websocket__stream.got_text `websocket::stream::got_text`] may be used to query the stream and determine the type of the last received message. The function [link beast.ref.boost__beast__websocket__stream.is_message_done `websocket::stream::is_message_done`] may be called to determine if the message received by the last read operation is complete.
Until the call returns, the implementation will read incoming control frames and handle them automatically as follows:

* The [link beast.ref.boost__beast__websocket__stream.control_callback `websocket::stream::control_callback`] will be invoked for each control frame.


* For each received ping frame, a pong frame will be automatically sent.


* If a close frame is received, the WebSocket closing handshake is performed. In this case, when the function returns, the error [link beast.ref.boost__beast__websocket__error `websocket::closed`] will be indicated.

[heading Return Value]
The number of message payload bytes appended to the buffer.
[heading Parameters][table [[Name][Description]]  [[`buffer`][    
A dynamic buffer to append message data to.  ]]  [[`limit`][    
An upper limit on the number of bytes this function will append into the buffer. If this value is zero, then a reasonable size will be chosen automatically.  ]]  [[`ec`][    
Set to indicate what error occurred, if any.   ]]]
[endsect][section:overload3 websocket::stream::read_some (3 of 4 overloads)]
Read some message data. [heading Synopsis]```template<    class __MutableBufferSequence__>std::size_tread_some(    MutableBufferSequence const& buffers);```[heading Description]
This function is used to read some message data.
The call blocks until one of the following is true:

* Some message data is received.


* A close frame is received. In this case the error indicated by the function will be [link beast.ref.boost__beast__websocket__error `websocket::closed`].


* An error occurs.

The algorithm, known as a ['composed operation], is implemented in terms of calls to the next layer's `read_some` and `write_some` functions.
The functions [link beast.ref.boost__beast__websocket__stream.got_binary `websocket::stream::got_binary`] and [link beast.ref.boost__beast__websocket__stream.got_text `websocket::stream::got_text`] may be used to query the stream and determine the type of the last received message. The function [link beast.ref.boost__beast__websocket__stream.is_message_done `websocket::stream::is_message_done`] may be called to determine if the message received by the last read operation is complete.
Until the call returns, the implementation will read incoming control frames and handle them automatically as follows:

* The [link beast.ref.boost__beast__websocket__stream.control_callback `websocket::stream::control_callback`] will be invoked for each control frame.


* For each received ping frame, a pong frame will be automatically sent.


* If a close frame is received, the WebSocket closing handshake is performed. In this case, when the function returns, the error [link beast.ref.boost__beast__websocket__error `websocket::closed`] will be indicated.

[heading Return Value]
The number of message payload bytes appended to the buffer.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
A buffer sequence to write message data into. The previous contents of the buffers will be overwritten, starting from the beginning.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    
Thrown on failure.   ]]]
[endsect][section:overload4 websocket::stream::read_some (4 of 4 overloads)]
Read some message data. [heading Synopsis]```template<    class __MutableBufferSequence__>std::size_tread_some(    MutableBufferSequence const& buffers,    error_code& ec);```[heading Description]
This function is used to read some message data.
The call blocks until one of the following is true:

* Some message data is received.


* A close frame is received. In this case the error indicated by the function will be [link beast.ref.boost__beast__websocket__error `websocket::closed`].


* An error occurs.

The algorithm, known as a ['composed operation], is implemented in terms of calls to the next layer's `read_some` and `write_some` functions.
The functions [link beast.ref.boost__beast__websocket__stream.got_binary `websocket::stream::got_binary`] and [link beast.ref.boost__beast__websocket__stream.got_text `websocket::stream::got_text`] may be used to query the stream and determine the type of the last received message. The function [link beast.ref.boost__beast__websocket__stream.is_message_done `websocket::stream::is_message_done`] may be called to determine if the message received by the last read operation is complete.
Until the call returns, the implementation will read incoming control frames and handle them automatically as follows:

* The [link beast.ref.boost__beast__websocket__stream.control_callback `websocket::stream::control_callback`] will be invoked for each control frame.


* For each received ping frame, a pong frame will be automatically sent.


* If a close frame is received, the WebSocket closing handshake is performed. In this case, when the function returns, the error [link beast.ref.boost__beast__websocket__error `websocket::closed`] will be indicated.

[heading Return Value]
The number of message payload bytes appended to the buffer.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
A buffer sequence to write message data into. The previous contents of the buffers will be overwritten, starting from the beginning.  ]]  [[`ec`][    
Set to indicate what error occurred, if any.   ]]]
[endsect][endsect][section:reason websocket::stream::reason][indexterm2 reason..websocket::stream]
Returns the close reason received from the remote peer. [heading Synopsis]```close_reason const &reason() const;```[heading Description]
This is only valid after a read completes with [link beast.ref.boost__beast__websocket__error `websocket::closed`]. [endsect][section:secure_prng websocket::stream::secure_prng][indexterm2 secure_prng..websocket::stream]
Set whether the PRNG is cryptographically secure. [heading Synopsis]```voidsecure_prng(    bool value);```[heading Description]
This controls whether or not the source of pseudo-random numbers used to produce the masks required by the WebSocket protocol are of cryptographic quality. When the setting is `true`, a strong algorithm is used which cannot be guessed by observing outputs. When the setting is `false`, a much faster algorithm is used. Masking is only performed by streams operating in the client mode. For streams operating in the server mode, this setting has no effect. By default, newly constructed streams use a secure PRNG.
If the WebSocket stream is used with an encrypted SSL or TLS next layer, if it is known to the application that intermediate proxies are not vulnerable to cache poisoning, or if the application is designed such that an attacker cannot send arbitrary inputs to the stream interface, then the faster algorithm may be used.
For more information please consult the WebSocket protocol RFC.
[heading Parameters][table [[Name][Description]]  [[`value`][    
`true` if the PRNG algorithm should be cryptographically secure.   ]]]
[endsect][section:set_option websocket::stream::set_option][indexterm2 set_option..websocket::stream]```template<    class Option>void``[link beast.ref.boost__beast__websocket__stream.set_option.overload1 set_option]``(    Option opt);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.set_option.overload1 more...]]`````
Set the permessage-deflate extension options. ```void``[link beast.ref.boost__beast__websocket__stream.set_option.overload2 set_option]``(    permessage_deflate const& o);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.set_option.overload2 more...]]`````[section:overload1 websocket::stream::set_option (1 of 2 overloads)][heading Synopsis]```template<    class Option>voidset_option(    Option opt);```[heading Description][endsect][section:overload2 websocket::stream::set_option (2 of 2 overloads)]
Set the permessage-deflate extension options. [heading Synopsis]```voidset_option(    permessage_deflate const& o);```[heading Description]
[heading Exceptions][table [[Type][Thrown On]]  [[`invalid_argument`][    
if `deflateSupported == false`, and either `client_enable` or `server_enable` is `true`.   ]]]
[endsect][endsect][section:stream websocket::stream::stream][indexterm2 stream..websocket::stream]
Constructor. `````[link beast.ref.boost__beast__websocket__stream.stream.overload1 stream]``(    stream&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.stream.overload1 more...]]``template<    class... Args>explicit``[link beast.ref.boost__beast__websocket__stream.stream.overload2 stream]``(    Args&&... args);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.stream.overload2 more...]]`````[section:overload1 websocket::stream::stream (1 of 2 overloads)]
Constructor. [heading Synopsis]```stream(    stream&&);```[heading Description]
If `NextLayer` is move constructible, this function will move-construct a new stream from the existing stream.
After the move, the only valid operation on the moved-from object is destruction. [endsect][section:overload2 websocket::stream::stream (2 of 2 overloads)]
Constructor. [heading Synopsis]```template<    class... Args>stream(    Args&&... args);```[heading Description]
This constructor creates a websocket stream and initializes the next layer object.
[heading Exceptions][table [[Type][Thrown On]]  [[`Any`][    
exceptions thrown by the NextLayer constructor.  ]]]
[heading Parameters][table [[Name][Description]]  [[`args`][    
The arguments to be passed to initialize the next layer object. The arguments are forwarded to the next layer's constructor.   ]]]
[endsect][endsect][section:text websocket::stream::text][indexterm2 text..websocket::stream]
Set the text message write option. ```void``[link beast.ref.boost__beast__websocket__stream.text.overload1 text]``(    bool value);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.text.overload1 more...]]`````
Returns `true` if the text message write option is set. ```bool``[link beast.ref.boost__beast__websocket__stream.text.overload2 text]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.text.overload2 more...]]`````[section:overload1 websocket::stream::text (1 of 2 overloads)]
Set the text message write option. [heading Synopsis]```voidtext(    bool value);```[heading Description]
This controls whether or not outgoing message opcodes are set to binary or text. The setting is only applied at the start when a caller begins a new message. Changing the opcode after a message is started will only take effect after the current message being sent is complete.
The default setting is to send text messages.
[heading Parameters][table [[Name][Description]]  [[`value`][    
`true` if outgoing messages should indicate text, or `false` if they should indicate binary.  ]]]
[heading Example]
Setting the message type to text. ```  ws.text(true);
```
[endsect][section:overload2 websocket::stream::text (2 of 2 overloads)]
Returns `true` if the text message write option is set. [heading Synopsis]```booltext() const;```[heading Description][endsect][endsect][section:write websocket::stream::write][indexterm2 write..websocket::stream]
Write a complete message. ```template<    class __ConstBufferSequence__>std::size_t``[link beast.ref.boost__beast__websocket__stream.write.overload1 write]``(    ConstBufferSequence const& buffers);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.write.overload1 more...]]``template<    class __ConstBufferSequence__>std::size_t``[link beast.ref.boost__beast__websocket__stream.write.overload2 write]``(    ConstBufferSequence const& buffers,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.write.overload2 more...]]`````[section:overload1 websocket::stream::write (1 of 2 overloads)]
Write a complete message. [heading Synopsis]```template<    class __ConstBufferSequence__>std::size_twrite(    ConstBufferSequence const& buffers);```[heading Description]
This function is used to write a complete message.
The call blocks until one of the following is true:

* The message is written.


* An error occurs.

The algorithm, known as a ['composed operation], is implemented in terms of calls to the next layer's `write_some` function.
The current setting of the [link beast.ref.boost__beast__websocket__stream.binary `websocket::stream::binary`] option controls whether the message opcode is set to text or binary. If the [link beast.ref.boost__beast__websocket__stream.auto_fragment `websocket::stream::auto_fragment`] option is set, the message will be split into one or more frames as necessary. The actual payload contents sent may be transformed as per the WebSocket protocol settings.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The buffers containing the message to send.  ]]]
[heading Return Value]
The number of bytes sent from the buffers.
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    
Thrown on failure.   ]]]
[endsect][section:overload2 websocket::stream::write (2 of 2 overloads)]
Write a complete message. [heading Synopsis]```template<    class __ConstBufferSequence__>std::size_twrite(    ConstBufferSequence const& buffers,    error_code& ec);```[heading Description]
This function is used to write a complete message.
The call blocks until one of the following is true:

* The complete message is written.


* An error occurs.

The algorithm, known as a ['composed operation], is implemented in terms of calls to the next layer's `write_some` function.
The current setting of the [link beast.ref.boost__beast__websocket__stream.binary `websocket::stream::binary`] option controls whether the message opcode is set to text or binary. If the [link beast.ref.boost__beast__websocket__stream.auto_fragment `websocket::stream::auto_fragment`] option is set, the message will be split into one or more frames as necessary. The actual payload contents sent may be transformed as per the WebSocket protocol settings.
[heading Parameters][table [[Name][Description]]  [[`buffers`][    
The buffers containing the message to send.  ]]  [[`ec`][    
Set to indicate what error occurred, if any.  ]]]
[heading Return Value]
The number of bytes sent from the buffers. 
[endsect][endsect][section:write_buffer_bytes websocket::stream::write_buffer_bytes][indexterm2 write_buffer_bytes..websocket::stream]
Set the write buffer size option. ```void``[link beast.ref.boost__beast__websocket__stream.write_buffer_bytes.overload1 write_buffer_bytes]``(    std::size_t amount);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.write_buffer_bytes.overload1 more...]]`````
Returns the size of the write buffer. ```std::size_t``[link beast.ref.boost__beast__websocket__stream.write_buffer_bytes.overload2 write_buffer_bytes]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.write_buffer_bytes.overload2 more...]]`````[section:overload1 websocket::stream::write_buffer_bytes (1 of 2 overloads)]
Set the write buffer size option. [heading Synopsis]```voidwrite_buffer_bytes(    std::size_t amount);```[heading Description]
Sets the size of the write buffer used by the implementation to send frames. The write buffer is needed when masking payload data in the client role, compressing frames, or auto-fragmenting message data.
Lowering the size of the buffer can decrease the memory requirements for each connection, while increasing the size of the buffer can reduce the number of calls made to the next layer to write data.
The default setting is 4096. The minimum value is 8.
The write buffer size can only be changed when the stream is not open. Undefined behavior results if the option is modified after a successful WebSocket handshake.
[heading Example]
Setting the write buffer size. ```  ws.write_buffer_bytes(8192);
```
[heading Parameters][table [[Name][Description]]  [[`amount`][    
The size of the write buffer in bytes.   ]]]
[endsect][section:overload2 websocket::stream::write_buffer_bytes (2 of 2 overloads)]
Returns the size of the write buffer. [heading Synopsis]```std::size_twrite_buffer_bytes() const;```[heading Description][endsect][endsect][section:write_some websocket::stream::write_some][indexterm2 write_some..websocket::stream]
Write some message data. ```template<    class __ConstBufferSequence__>std::size_t``[link beast.ref.boost__beast__websocket__stream.write_some.overload1 write_some]``(    bool fin,    ConstBufferSequence const& buffers);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.write_some.overload1 more...]]``template<    class __ConstBufferSequence__>std::size_t``[link beast.ref.boost__beast__websocket__stream.write_some.overload2 write_some]``(    bool fin,    ConstBufferSequence const& buffers,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.write_some.overload2 more...]]`````[section:overload1 websocket::stream::write_some (1 of 2 overloads)]
Write some message data. [heading Synopsis]```template<    class __ConstBufferSequence__>std::size_twrite_some(    bool fin,    ConstBufferSequence const& buffers);```[heading Description]
This function is used to send part of a message.
The call blocks until one of the following is true:

* The message data is written.


* An error occurs.

The algorithm, known as a ['composed operation], is implemented in terms of calls to the next layer's `write_some` function.
If this is the beginning of a new message, the message opcode will be set to text or binary based on the current setting of the [link beast.ref.boost__beast__websocket__stream.binary `websocket::stream::binary`] (or [link beast.ref.boost__beast__websocket__stream.text `websocket::stream::text`]) option. The actual payload sent may be transformed as per the WebSocket protocol settings.
[heading Parameters][table [[Name][Description]]  [[`fin`][    
`true` if this is the last part of the message.  ]]  [[`buffers`][    
The buffers containing the message part to send.  ]]]
[heading Return Value]
The number of bytes sent from the buffers.
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    
Thrown on failure.   ]]]
[endsect][section:overload2 websocket::stream::write_some (2 of 2 overloads)]
Write some message data. [heading Synopsis]```template<    class __ConstBufferSequence__>std::size_twrite_some(    bool fin,    ConstBufferSequence const& buffers,    error_code& ec);```[heading Description]
This function is used to send part of a message.
The call blocks until one of the following is true:

* The message data is written.


* An error occurs.

The algorithm, known as a ['composed operation], is implemented in terms of calls to the next layer's `write_some` function.
If this is the beginning of a new message, the message opcode will be set to text or binary based on the current setting of the [link beast.ref.boost__beast__websocket__stream.binary `websocket::stream::binary`] (or [link beast.ref.boost__beast__websocket__stream.text `websocket::stream::text`]) option. The actual payload sent may be transformed as per the WebSocket protocol settings.
[heading Parameters][table [[Name][Description]]  [[`fin`][    
`true` if this is the last part of the message.  ]]  [[`buffers`][    
The buffers containing the message part to send.  ]]  [[`ec`][    
Set to indicate what error occurred, if any.  ]]]
[heading Return Value]
The number of bytes sent from the buffers.
[heading Return Value]
The number of bytes consumed in the input buffers. 
[endsect][endsect][section:stream_dtor_ websocket::stream::~stream][indexterm2 ~stream..websocket::stream]
Destructor. [heading Synopsis]```~stream();```[heading Description]
Destroys the stream and all associated resources.
[heading Remarks]
A stream object must not be destroyed while there are pending asynchronous operations associated with it. 
[endsect]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__stream__accept_op websocket::stream::accept_op][heading Synopsis]Defined in header [include_file boost/beast/websocket/stream.hpp]```template<    [role red error.class-detail-template.1][role red error.class-detail-template.2],    [role red error.class-detail-template.1][role red error.class-detail-template.2]>class accept_op```[heading Description]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__stream__close_op websocket::stream::close_op][heading Synopsis]Defined in header [include_file boost/beast/websocket/stream.hpp]```template<    [role red error.class-detail-template.1][role red error.class-detail-template.2]>class close_op```[heading Description]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__stream__handshake_op websocket::stream::handshake_op][heading Synopsis]Defined in header [include_file boost/beast/websocket/stream.hpp]```template<    [role red error.class-detail-template.1][role red error.class-detail-template.2]>class handshake_op```[heading Description]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__stream__idle_ping_op websocket::stream::idle_ping_op][heading Synopsis]Defined in header [include_file boost/beast/websocket/stream.hpp]```template<    [role red error.class-detail-template.1][role red error.class-detail-template.2]>class idle_ping_op```[heading Description]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__stream__ping_op websocket::stream::ping_op][heading Synopsis]Defined in header [include_file boost/beast/websocket/stream.hpp]```template<    [role red error.class-detail-template.1][role red error.class-detail-template.2]>class ping_op```[heading Description]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__stream__read_op websocket::stream::read_op][heading Synopsis]Defined in header [include_file boost/beast/websocket/stream.hpp]```template<    [role red error.class-detail-template.1][role red error.class-detail-template.2],    [role red error.class-detail-template.1][role red error.class-detail-template.2]>class read_op```[heading Description]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__stream__read_some_op websocket::stream::read_some_op][heading Synopsis]Defined in header [include_file boost/beast/websocket/stream.hpp]```template<    [role red error.class-detail-template.1][role red error.class-detail-template.2],    [role red error.class-detail-template.1][role red error.class-detail-template.2]>class read_some_op```[heading Description]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__stream__response_op websocket::stream::response_op][heading Synopsis]Defined in header [include_file boost/beast/websocket/stream.hpp]```template<    [role red error.class-detail-template.1][role red error.class-detail-template.2]>class response_op```[heading Description]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__stream__write_op websocket::stream::write_op][heading Synopsis]Defined in header [include_file boost/beast/websocket/stream.hpp]```template<    [role red error.class-detail-template.1][role red error.class-detail-template.2],    [role red error.class-detail-template.1][role red error.class-detail-template.2]>class write_op```[heading Description]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__stream__write_some_op websocket::stream::write_some_op][heading Synopsis]Defined in header [include_file boost/beast/websocket/stream.hpp]```template<    [role red error.class-detail-template.1][role red error.class-detail-template.2],    [role red error.class-detail-template.1][role red error.class-detail-template.2]>class write_some_op```[heading Description]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__stream_base websocket::stream_base]
This class is used as a base for the [link beast.ref.boost__beast__websocket__stream `websocket::stream`] class template to group common types and constants. [heading Synopsis]Defined in header [include_file boost/beast/websocket/stream_base.hpp]```struct stream_base```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__websocket__stream_base__decorator [*decorator]]]    [      Stream option used to adjust HTTP fields of WebSocket upgrade request and responses.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream_base__timeout [*timeout]]]    [      Stream option to control the behavior of websocket timeouts.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream_base.duration [*duration]]]    [      The type used to represent durations.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream_base.time_point [*time_point]]]    [      The type used to represent time points.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__websocket__stream_base.never [*never]]]    [      Returns the special time_point value meaning "never".     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream_base.none [*none]]]    [      Returns the special duration value meaning "none".     ]  ]][heading Description][section:duration websocket::stream_base::duration][indexterm2 duration..websocket::stream_base]
The type used to represent durations. [heading Synopsis]```using duration = std::chrono::steady_clock::duration;```[heading Description][endsect][section:never websocket::stream_base::never][indexterm2 never..websocket::stream_base]
Returns the special time\_point value meaning "never". [heading Synopsis]```statictime_pointnever();```[heading Description][endsect][section:none websocket::stream_base::none][indexterm2 none..websocket::stream_base]
Returns the special duration value meaning "none". [heading Synopsis]```staticdurationnone();```[heading Description][endsect][section:time_point websocket::stream_base::time_point][indexterm2 time_point..websocket::stream_base]
The type used to represent time points. [heading Synopsis]```using time_point = std::chrono::steady_clock::time_point;```[heading Description][endsect]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__stream_base__decorator websocket::stream_base::decorator]
Stream option used to adjust HTTP fields of WebSocket upgrade request and responses. [heading Synopsis]Defined in header [include_file boost/beast/websocket/stream_base.hpp]```class decorator```[heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__websocket__stream_base__decorator.decorator [*decorator]]]    [            Construct a decorator option.     ]  ]][heading Description][section:decorator websocket::stream_base::decorator::decorator][indexterm2 decorator..websocket::stream_base::decorator]`````[link beast.ref.boost__beast__websocket__stream_base__decorator.decorator.overload1 decorator]``(    decorator&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream_base__decorator.decorator.overload1 more...]]`````
Construct a decorator option. ```template<    class Decorator>explicit``[link beast.ref.boost__beast__websocket__stream_base__decorator.decorator.overload2 decorator]``(    Decorator&& f);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream_base__decorator.decorator.overload2 more...]]`````[section:overload1 websocket::stream_base::decorator::decorator (1 of 2 overloads)][heading Synopsis]```decorator(    decorator&&);```[heading Description][endsect][section:overload2 websocket::stream_base::decorator::decorator (2 of 2 overloads)]
Construct a decorator option. [heading Synopsis]```template<    class Decorator>decorator(    Decorator&& f);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`f`][    
An invocable function object. Ownership of the function object is transferred by decay-copy.   ]]]
[endsect][endsect]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__stream_base__timeout websocket::stream_base::timeout]
Stream option to control the behavior of websocket timeouts. [heading Synopsis]Defined in header [include_file boost/beast/websocket/stream_base.hpp]```struct timeout```[heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__websocket__stream_base__timeout.suggested [*suggested]]]    [      Construct timeout settings with suggested values for a role.     ]  ]][heading Data Members][table [[Name][Description]]  [    [[link beast.ref.boost__beast__websocket__stream_base__timeout.handshake_timeout [*handshake_timeout]]]    [      Time limit on handshake, accept, and close operations:     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream_base__timeout.idle_timeout [*idle_timeout]]]    [      The time limit after which a connection is considered idle.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream_base__timeout.keep_alive_pings [*keep_alive_pings]]]    [      Automatic ping setting.     ]  ]][heading Description]
Timeout features are available for asynchronous operations only. [section:handshake_timeout websocket::stream_base::timeout::handshake_timeout][indexterm2 handshake_timeout..websocket::stream_base::timeout]
Time limit on handshake, accept, and close operations: [heading Synopsis]```duration handshake_timeout;```[heading Description]
This value whether or not there is a time limit, and the duration of that time limit, for asynchronous handshake, accept, and close operations. If this is equal to the value [link beast.ref.boost__beast__websocket__stream_base.none `websocket::stream_base::none`] then there will be no time limit. Otherwise, if any of the applicable operations takes longer than this amount of time, the operation will be canceled and a timeout error delivered to the completion handler. [endsect][section:idle_timeout websocket::stream_base::timeout::idle_timeout][indexterm2 idle_timeout..websocket::stream_base::timeout]
The time limit after which a connection is considered idle. [heading Synopsis]```duration idle_timeout;```[heading Description][endsect][section:keep_alive_pings websocket::stream_base::timeout::keep_alive_pings][indexterm2 keep_alive_pings..websocket::stream_base::timeout]
Automatic ping setting. [heading Synopsis]```bool keep_alive_pings;```[heading Description]
If the idle interval is set, this setting affects the behavior of the stream when no data is received for the timeout interval as follows:

* When `keep_alive_pings` is `true`, an idle ping will be sent automatically. If another timeout interval elapses with no received data then the connection will be closed. An outstanding read operation must be pending, which will complete immediately the error [link beast.ref.boost__beast__error `timeout`].


* When `keep_alive_pings` is `false`, the connection will be closed. An outstanding read operation must be pending, which will complete immediately the error [link beast.ref.boost__beast__error `timeout`]. 

[endsect][section:suggested websocket::stream_base::timeout::suggested][indexterm2 suggested..websocket::stream_base::timeout]
Construct timeout settings with suggested values for a role. [heading Synopsis]```statictimeoutsuggested(    role_type role);```[heading Description]
This constructs the timeout settings with a predefined set of values which varies depending on the desired role. The values are selected upon construction, regardless of the current or actual role in use on the stream.
[heading Example]
This statement sets the timeout settings of the stream to the suggested values for the server role: ``````
[heading Parameters][table [[Name][Description]]  [[`role`][    
The role of the websocket stream ([link beast.ref.boost__beast__role_type `client`] or [link beast.ref.boost__beast__role_type `server`]).   ]]]
[endsect]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__teardown websocket::teardown][indexterm1 websocket::teardown]
Tear down a connection. ```template<    class Socket>void``[link beast.ref.boost__beast__websocket__teardown.overload1 teardown]``(    role_type role,    Socket& socket,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__teardown.overload1 more...]]`````
Tear down a `net::ip::tcp::socket`. ```template<    class __Protocol__,    class __Executor__>void``[link beast.ref.boost__beast__websocket__teardown.overload2 teardown]``(    role_type role,    net::basic_stream_socket< Protocol, Executor >& socket,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__teardown.overload2 more...]]`````[section:overload1 websocket::teardown (1 of 2 overloads)]
Tear down a connection. [heading Synopsis]Defined in header [include_file boost/beast/websocket/teardown.hpp]```template<    class Socket>voidteardown(    role_type role,    Socket& socket,    error_code& ec);```[heading Description]
This tears down a connection. The implementation will call the overload of this function based on the `Socket` parameter used to consruct the socket. When `Socket` is a user defined type, and not a `net::ip::tcp::socket` or any `net::ssl::stream`, callers are responsible for providing a suitable overload of this function.
[heading Parameters][table [[Name][Description]]  [[`role`][    
The role of the local endpoint  ]]  [[`socket`][    
The socket to tear down.  ]]  [[`ec`][    
Set to the error if any occurred.   ]]]
Convenience header [include_file boost/beast/websocket.hpp][endsect][section:overload2 websocket::teardown (2 of 2 overloads)]
Tear down a `net::ip::tcp::socket`. [heading Synopsis]Defined in header [include_file boost/beast/websocket/teardown.hpp]```template<    class __Protocol__,    class __Executor__>voidteardown(    role_type role,    net::basic_stream_socket< Protocol, Executor >& socket,    error_code& ec);```[heading Description]
This tears down a connection. The implementation will call the overload of this function based on the `Stream` parameter used to consruct the socket. When `Stream` is a user defined type, and not a `net::ip::tcp::socket` or any `net::ssl::stream`, callers are responsible for providing a suitable overload of this function.
[heading Parameters][table [[Name][Description]]  [[`role`][    
The role of the local endpoint  ]]  [[`socket`][    
The socket to tear down.  ]]  [[`ec`][    
Set to the error if any occurred.   ]]]
Convenience header [include_file boost/beast/websocket.hpp][endsect][endsect][section:boost__beast__zlib__Byte zlib::Byte][indexterm1 zlib::Byte][heading Synopsis]Defined in header [include_file boost/beast/zlib/zlib.hpp]```using Byte = unsigned char;```[heading Description]Convenience header [include_file boost/beast/zlib.hpp][endsect][section:boost__beast__zlib__Flush zlib::Flush][indexterm1 zlib::Flush]
Flush option. [heading Synopsis]Defined in header [include_file boost/beast/zlib/zlib.hpp]```enum Flush```[indexterm2 none..zlib::Flush][indexterm2 block..zlib::Flush][indexterm2 partial..zlib::Flush][indexterm2 sync..zlib::Flush][indexterm2 full..zlib::Flush][indexterm2 finish..zlib::Flush][indexterm2 trees..zlib::Flush][heading Values][table [[Name][Description]]  [[[^none]][]]  [[[^block]][]]  [[[^partial]][]]  [[[^sync]][]]  [[[^full]][]]  [[[^finish]][]]  [[[^trees]][]]][heading Description]Convenience header [include_file boost/beast/zlib.hpp][endsect][section:boost__beast__zlib__Strategy zlib::Strategy][indexterm1 zlib::Strategy]
Compression strategy. [heading Synopsis]Defined in header [include_file boost/beast/zlib/zlib.hpp]```enum Strategy```[indexterm2 normal..zlib::Strategy][indexterm2 filtered..zlib::Strategy][indexterm2 huffman..zlib::Strategy][indexterm2 rle..zlib::Strategy][indexterm2 fixed..zlib::Strategy][heading Values][table [[Name][Description]]  [[[^normal]][Default strategy. This is suitable for general purpose compression, and works
well in the majority of cases.
 ]]  [[[^filtered]][Filtered strategy. This strategy should be used when the data be compressed
is produced by a filter or predictor.
 ]]  [[[^huffman]][Huffman-only strategy. This strategy only performs Huffman encoding, without doing
any string matching.
 ]]  [[[^rle]][Run Length Encoding strategy. This strategy limits match distances to one, making it
equivalent to run length encoding. This can give better
performance for things like PNG image data.
 ]]  [[[^fixed]][Fixed table strategy. This strategy prevents the use of dynamic Huffman codes,
allowing for a simpler decoder for special applications.
 ]]][heading Description]
These are used when compressing streams. Convenience header [include_file boost/beast/zlib.hpp][endsect][section:boost__beast__zlib__compression zlib::compression][indexterm1 zlib::compression][heading Synopsis]Defined in header [include_file boost/beast/zlib/zlib.hpp]```enum compression```[indexterm2 none..zlib::compression][indexterm2 none..zlib::compression][indexterm2 best_speed..zlib::compression][indexterm2 best_size..zlib::compression][indexterm2 default_size..zlib::compression][heading Values][table [[Name][Description]]  [[[^none]][]]  [[[^none]][]]  [[[^best_speed]][]]  [[[^best_size]][]]  [[[^default_size]][]]][heading Description]Convenience header [include_file boost/beast/zlib.hpp][endsect][section:boost__beast__zlib__deflate_stream zlib::deflate_stream]
Raw deflate compressor. [heading Synopsis]Defined in header [include_file boost/beast/zlib/deflate_stream.hpp]```class deflate_stream :    private deflate_stream```[heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__zlib__deflate_stream.clear [*clear]]]    [      Clear the stream.     ]  ]  [    [[link beast.ref.boost__beast__zlib__deflate_stream.deflate_stream [*deflate_stream]]]    [      Construct a default deflate stream.     ]  ]  [    [[link beast.ref.boost__beast__zlib__deflate_stream.params [*params]]]    [      Update the compression level and strategy.     ]  ]  [    [[link beast.ref.boost__beast__zlib__deflate_stream.pending [*pending]]]    [      Return bits pending in the output.     ]  ]  [    [[link beast.ref.boost__beast__zlib__deflate_stream.prime [*prime]]]    [      Insert bits into the compressed output stream.     ]  ]  [    [[link beast.ref.boost__beast__zlib__deflate_stream.reset [*reset]]]    [      Reset the stream and compression settings.       Reset the stream without deallocating memory.     ]  ]  [    [[link beast.ref.boost__beast__zlib__deflate_stream.tune [*tune]]]    [      Fine tune internal compression parameters.     ]  ]  [    [[link beast.ref.boost__beast__zlib__deflate_stream.upper_bound [*upper_bound]]]    [      Returns the upper limit on the size of a compressed block.     ]  ]  [    [[link beast.ref.boost__beast__zlib__deflate_stream.write [*write]]]    [      Compress input and write output.     ]  ]][heading Description]
This is a port of zlib's "deflate" functionality to C++. [section:clear zlib::deflate_stream::clear][indexterm2 clear..zlib::deflate_stream]
Clear the stream. [heading Synopsis]```voidclear();```[heading Description]
This function resets the stream and frees all dynamically allocated internal buffers. The compression settings are left unchanged.
[heading Remarks]
Any unprocessed input or pending output from previous calls are discarded. 
[endsect][section:deflate_stream zlib::deflate_stream::deflate_stream][indexterm2 deflate_stream..zlib::deflate_stream]
Construct a default deflate stream. [heading Synopsis]```deflate_stream();```[heading Description]
Upon construction, the stream settings will be set to these default values:

* `level = 6`


* `windowBits = 15`


* `memLevel = 8`


* `strategy = Strategy::normal`

Although the stream is ready to be used immediately after construction, any required internal buffers are not dynamically allocated until needed. [endsect][section:params zlib::deflate_stream::params][indexterm2 params..zlib::deflate_stream]
Update the compression level and strategy. [heading Synopsis]```voidparams(    z_params& zs,    int level,    Strategy strategy,    error_code& ec);```[heading Description]
This function dynamically updates the compression level and compression strategy. The interpretation of level and strategy is as in [link beast.ref.boost__beast__zlib__deflate_stream.reset `zlib::deflate_stream::reset`]. This can be used to switch between compression and straight copy of the input data, or to switch to a different kind of input data requiring a different strategy. If the compression level is changed, the input available so far is compressed with the old level (and may be flushed); the new level will take effect only at the next call of [link beast.ref.boost__beast__zlib__deflate_stream.write `zlib::deflate_stream::write`].
Before the call of `params`, the stream state must be set as for a call of [link beast.ref.boost__beast__zlib__deflate_stream.write `zlib::deflate_stream::write`], since the currently available input may have to be compressed and flushed. In particular, `zs.avail_out` must be non-zero.
[heading Return Value]
`Z_OK` if success, `Z_STREAM_ERROR` if the source stream state was inconsistent or if a parameter was invalid, `error::need_buffers` if `zs.avail_out` was zero. 
[endsect][section:pending zlib::deflate_stream::pending][indexterm2 pending..zlib::deflate_stream]
Return bits pending in the output. [heading Synopsis]```voidpending(    unsigned* value,    int* bits);```[heading Description]
This function returns the number of bytes and bits of output that have been generated, but not yet provided in the available output. The bytes not provided would be due to the available output space having being consumed. The number of bits of output not provided are between 0 and 7, where they await more bits to join them in order to fill out a full byte. If pending or bits are `nullptr`, then those values are not set.
[heading Return Value]
`Z_OK` if success, or `Z_STREAM_ERROR` if the source stream state was inconsistent. 
[endsect][section:prime zlib::deflate_stream::prime][indexterm2 prime..zlib::deflate_stream]
Insert bits into the compressed output stream. [heading Synopsis]```voidprime(    int bits,    int value,    error_code& ec);```[heading Description]
This function inserts bits in the deflate output stream. The intent is that this function is used to start off the deflate output with the bits leftover from a previous deflate stream when appending to it. As such, this function can only be used for raw deflate, and must be used before the first `write` call after an initialization. `bits` must be less than or equal to 16, and that many of the least significant bits of `value` will be inserted in the output.
[heading Return Value]
`error::need_buffers` if there was not enough room in the internal buffer to insert the bits. 
[endsect][section:reset zlib::deflate_stream::reset][indexterm2 reset..zlib::deflate_stream]
Reset the stream and compression settings. ```void``[link beast.ref.boost__beast__zlib__deflate_stream.reset.overload1 reset]``(    int level,    int windowBits,    int memLevel,    Strategy strategy);  ``[''''&raquo;''' [link beast.ref.boost__beast__zlib__deflate_stream.reset.overload1 more...]]`````
Reset the stream without deallocating memory. ```void``[link beast.ref.boost__beast__zlib__deflate_stream.reset.overload2 reset]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__zlib__deflate_stream.reset.overload2 more...]]`````[section:overload1 zlib::deflate_stream::reset (1 of 2 overloads)]
Reset the stream and compression settings. [heading Synopsis]```voidreset(    int level,    int windowBits,    int memLevel,    Strategy strategy);```[heading Description]
This function initializes the stream to the specified compression settings.
Although the stream is ready to be used immediately after a reset, any required internal buffers are not dynamically allocated until needed.
[heading Remarks]
Any unprocessed input or pending output from previous calls are discarded. 
[endsect][section:overload2 zlib::deflate_stream::reset (2 of 2 overloads)]
Reset the stream without deallocating memory. [heading Synopsis]```voidreset();```[heading Description]
This function performs the equivalent of calling `clear` followed by `reset` with the same compression settings, without deallocating the internal buffers.
[heading Remarks]
Any unprocessed input or pending output from previous calls are discarded. 
[endsect][endsect][section:tune zlib::deflate_stream::tune][indexterm2 tune..zlib::deflate_stream]
Fine tune internal compression parameters. [heading Synopsis]```voidtune(    int good_length,    int max_lazy,    int nice_length,    int max_chain);```[heading Description]
Compression parameters should only be tuned by someone who understands the algorithm used by zlib's deflate for searching for the best matching string, and even then only by the most fanatic optimizer trying to squeeze out the last compressed bit for their specific input data. Read the deflate.c source code (ZLib) for the meaning of the max\_lazy, good\_length, nice\_length, and max\_chain parameters. [endsect][section:upper_bound zlib::deflate_stream::upper_bound][indexterm2 upper_bound..zlib::deflate_stream]
Returns the upper limit on the size of a compressed block. [heading Synopsis]```std::size_tupper_bound(    std::size_t sourceLen) const;```[heading Description]
This function makes a conservative estimate of the maximum number of bytes needed to store the result of compressing a block of data based on the current compression level and strategy.
[heading Parameters][table [[Name][Description]]  [[`sourceLen`][    
The size of the uncompressed data.  ]]]
[heading Return Value]
The maximum number of resulting compressed bytes. 
[endsect][section:write zlib::deflate_stream::write][indexterm2 write..zlib::deflate_stream]
Compress input and write output. [heading Synopsis]```voidwrite(    z_params& zs,    Flush flush,    error_code& ec);```[heading Description]
This function compresses as much data as possible, and stops when the input buffer becomes empty or the output buffer becomes full. It may introduce some output latency (reading input without producing any output) except when forced to flush.
In each call, one or both of these actions are performed:

* Compress more input starting at `zs.next_in` and update `zs.next_in` and `zs.avail_in` accordingly. If not all input can be processed (because there is not enough room in the output buffer), `zs.next_in` and `zs.avail_in` are updated and processing will resume at this point for the next call.


* Provide more output starting at `zs.next_out` and update `zs.next_out` and `zs.avail_out` accordingly. This action is forced if the parameter flush is not `Flush::none`. Forcing flush frequently degrades the compression ratio, so this parameter should be set only when necessary (in interactive applications). Some output may be provided even if flush is not set.

Before the call, the application must ensure that at least one of the actions is possible, by providing more input and/or consuming more output, and updating `zs.avail_in` or `zs.avail_out` accordingly; `zs.avail_out` should never be zero before the call. The application can consume the compressed output when it wants, for example when the output buffer is full (`zs.avail_out == 0`), or after each call of `write`. If `write` returns no error with zero `zs.avail_out`, it must be called again after making room in the output buffer because there might be more output pending.
Normally the parameter flush is set to `Flush::none`, which allows deflate to decide how much data to accumulate before producing output, in order to maximize compression.
If the parameter flush is set to `Flush::sync`, all pending output is flushed to the output buffer and the output is aligned on a byte boundary, so that the decompressor can get all input data available so far. In particular `zs.avail_in` is zero after the call if enough output space has been provided before the call. Flushing may degrade compression for some compression algorithms and so it should be used only when necessary. This completes the current deflate block and follows it with an empty stored block that is three bits plus filler bits to the next byte, followed by the four bytes `{ 0x00, 0x00 0xff 0xff }`.
If flush is set to `Flush::partial`, all pending output is flushed to the output buffer, but the output is not aligned to a byte boundary. All of the input data so far will be available to the decompressor, as for Z\_SYNC\_FLUSH. This completes the current deflate block and follows it with an empty fixed codes block that is 10 bits long. This assures that enough bytes are output in order for the decompressor to finish the block before the empty fixed code block.
If flush is set to `Flush::block`, a deflate block is completed and emitted, as for `Flush::sync`, but the output is not aligned on a byte boundary, and up to seven bits of the current block are held to be written as the next byte after the next deflate block is completed. In this case, the decompressor may not be provided enough bits at this point in order to complete decompression of the data provided so far to the compressor. It may need to wait for the next block to be emitted. This is for advanced applications that need to control the emission of deflate blocks.
If flush is set to `Flush::full`, all output is flushed as with `Flush::sync`, and the compression state is reset so that decompression can restart from this point if previous compressed data has been damaged or if random access is desired. Using `Flush::full` too often can seriously degrade compression.
If `write` returns with `zs.avail_out == 0`, this function must be called again with the same value of the flush parameter and more output space (updated `zs.avail_out`), until the flush is complete (`write` returns with non-zero `zs.avail_out`). In the case of a `Flush::full`or `Flush::sync`, make sure that `zs.avail_out` is greater than six to avoid repeated flush markers due to `zs.avail_out == 0` on return.
If the parameter flush is set to `Flush::finish`, pending input is processed, pending output is flushed and deflate returns the error `error::end_of_stream` if there was enough output space; if deflate returns with no error, this function must be called again with `Flush::finish` and more output space (updated `zs.avail_out`) but no more input data, until it returns the error `error::end_of_stream` or another error. After `write` has returned the `error::end_of_stream` error, the only possible operations on the stream are to reset or destroy.
`Flush::finish` can be used immediately after initialization if all the compression is to be done in a single step. In this case, `zs.avail_out` must be at least value returned by `upper_bound` (see below). Then `write` is guaranteed to return the `error::end_of_stream` error. If not enough output space is provided, deflate will not return `error::end_of_stream`, and it must be called again as described above.
`write` returns no error if some progress has been made (more input processed or more output produced), `error::end_of_stream` if all input has been consumed and all output has been produced (only when flush is set to `Flush::finish`), `error::stream_error` if the stream state was inconsistent (for example if `zs.next_in` or `zs.next_out` was `nullptr`), `error::need_buffers` if no progress is possible (for example `zs.avail_in` or `zs.avail_out` was zero). Note that `error::need_buffers` is not fatal, and `write` can be called again with more input and more output space to continue compressing. [endsect]Convenience header [include_file boost/beast/zlib.hpp][endsect][section:boost__beast__zlib__deflate_upper_bound zlib::deflate_upper_bound][indexterm1 zlib::deflate_upper_bound]
Returns the upper limit on the size of a compressed block. [heading Synopsis]Defined in header [include_file boost/beast/zlib/deflate_stream.hpp]```std::size_tdeflate_upper_bound(    std::size_t bytes);```[heading Description]
This function makes a conservative estimate of the maximum number of bytes needed to store the result of compressing a block of data.
[heading Parameters][table [[Name][Description]]  [[`bytes`][    
The size of the uncompressed data.  ]]]
[heading Return Value]
The maximum number of resulting compressed bytes. 
Convenience header [include_file boost/beast/zlib.hpp][endsect][section:boost__beast__zlib__error zlib::error][indexterm1 zlib::error]
Error codes returned by the deflate codecs. [heading Synopsis]Defined in header [include_file boost/beast/zlib/error.hpp]```enum error```[indexterm2 need_buffers..zlib::error][indexterm2 end_of_stream..zlib::error][indexterm2 stream_error..zlib::error][indexterm2 invalid_block_type..zlib::error][indexterm2 invalid_stored_length..zlib::error][indexterm2 too_many_symbols..zlib::error][indexterm2 invalid_code_lenths..zlib::error][indexterm2 invalid_bit_length_repeat..zlib::error][indexterm2 missing_eob..zlib::error][indexterm2 invalid_literal_length..zlib::error][indexterm2 invalid_distance_code..zlib::error][indexterm2 invalid_distance..zlib::error][indexterm2 over_subscribed_length..zlib::error][indexterm2 incomplete_length_set..zlib::error][indexterm2 general..zlib::error][heading Values][table [[Name][Description]]  [[[^need_buffers]][Additional buffers are required. This error indicates that one or both of the buffers
provided buffers do not have sufficient available bytes
to make forward progress.

This does not always indicate a failure condition.

@note This is the same as `Z_BUF_ERROR` returned by ZLib.
 ]]  [[[^end_of_stream]][End of stream reached. @note This is the same as `Z_STREAM_END` returned by ZLib.
 ]]  [[[^stream_error]][Invalid stream or parameters. This error is returned when invalid parameters are passed,
or the operation being performed is not consistent with the
state of the stream. For example, attempting to write data
when the end of stream is already reached.

@note This is the same as `Z_STREAM_ERROR` returned by ZLib.
 ]]  [[[^invalid_block_type]][Invalid block type. ]]  [[[^invalid_stored_length]][Invalid stored block length. ]]  [[[^too_many_symbols]][Too many length or distance symbols. ]]  [[[^invalid_code_lenths]][Invalid code lengths. ]]  [[[^invalid_bit_length_repeat]][Invalid bit length repeat. ]]  [[[^missing_eob]][Missing end of block code. ]]  [[[^invalid_literal_length]][Invalid literal/length code. ]]  [[[^invalid_distance_code]][Invalid distance code. ]]  [[[^invalid_distance]][Invalid distance too far back. ]]  [[[^over_subscribed_length]][Over-subscribed length code. ]]  [[[^incomplete_length_set]][Incomplete length set. ]]  [[[^general]][general error ]]][heading Description]Convenience header [include_file boost/beast/zlib.hpp][endsect][section:boost__beast__zlib__inflate_stream zlib::inflate_stream]
Raw deflate stream decompressor. [heading Synopsis]Defined in header [include_file boost/beast/zlib/inflate_stream.hpp]```class inflate_stream :    private inflate_stream```[heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__zlib__inflate_stream.clear [*clear]]]    [      Put the stream in a newly constructed state.     ]  ]  [    [[link beast.ref.boost__beast__zlib__inflate_stream.inflate_stream [*inflate_stream]]]    [      Construct a raw deflate decompression stream.     ]  ]  [    [[link beast.ref.boost__beast__zlib__inflate_stream.reset [*reset]]]    [      Reset the stream.     ]  ]  [    [[link beast.ref.boost__beast__zlib__inflate_stream.write [*write]]]    [      Decompress input and produce output.     ]  ]][heading Description]
This implements a raw deflate stream decompressor. The deflate protocol is a compression protocol described in "DEFLATE Compressed Data Format Specification version 1.3" located here: [@https://tools.ietf.org/html/rfc1951 https://tools.ietf.org/html/rfc1951]
The implementation is a refactored port to C++ of ZLib's "inflate". A more detailed description of ZLib is at [@http://zlib.net/ http://zlib.net/].
Compression can be done in a single step if the buffers are large enough (for example if an input file is memory mapped), or can be done by repeated calls of the compression function. In the latter case, the application must provide more input and/or consume the output (providing more output space) before each call. [section:clear zlib::inflate_stream::clear][indexterm2 clear..zlib::inflate_stream]
Put the stream in a newly constructed state. [heading Synopsis]```voidclear();```[heading Description]
All dynamically allocated memory is de-allocated. [endsect][section:inflate_stream zlib::inflate_stream::inflate_stream][indexterm2 inflate_stream..zlib::inflate_stream]
Construct a raw deflate decompression stream. [heading Synopsis]```inflate_stream();```[heading Description]
The window size is set to the default of 15 bits. [endsect][section:reset zlib::inflate_stream::reset][indexterm2 reset..zlib::inflate_stream]
Reset the stream. ```void``[link beast.ref.boost__beast__zlib__inflate_stream.reset.overload1 reset]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__zlib__inflate_stream.reset.overload1 more...]]``void``[link beast.ref.boost__beast__zlib__inflate_stream.reset.overload2 reset]``(    int windowBits);  ``[''''&raquo;''' [link beast.ref.boost__beast__zlib__inflate_stream.reset.overload2 more...]]`````[section:overload1 zlib::inflate_stream::reset (1 of 2 overloads)]
Reset the stream. [heading Synopsis]```voidreset();```[heading Description]
This puts the stream in a newly constructed state with the previously specified window size, but without de-allocating any dynamically created structures. [endsect][section:overload2 zlib::inflate_stream::reset (2 of 2 overloads)]
Reset the stream. [heading Synopsis]```voidreset(    int windowBits);```[heading Description]
This puts the stream in a newly constructed state with the specified window size, but without de-allocating any dynamically created structures. [endsect][endsect][section:write zlib::inflate_stream::write][indexterm2 write..zlib::inflate_stream]
Decompress input and produce output. [heading Synopsis]```voidwrite(    z_params& zs,    Flush flush,    error_code& ec);```[heading Description]
This function decompresses as much data as possible, and stops when the input buffer becomes empty or the output buffer becomes full. It may introduce some output latency (reading input without producing any output) except when forced to flush.
One or both of the following actions are performed:

* Decompress more input starting at `zs.next_in` and update `zs.next_in` and `zs.avail_in` accordingly. If not all input can be processed (because there is not enough room in the output buffer), `zs.next_in` is updated and processing will resume at this point for the next call.


* Provide more output starting at `zs.next_out` and update `zs.next_out` and `zs.avail_out` accordingly. `write` provides as much output as possible, until there is no more input data or no more space in the output buffer (see below about the flush parameter).

Before the call, the application should ensure that at least one of the actions is possible, by providing more input and/or consuming more output, and updating the values in `zs` accordingly. The application can consume the uncompressed output when it wants, for example when the output buffer is full (`zs.avail_out == 0`), or after each call. If `write` returns no error and with zero `zs.avail_out`, it must be called again after making room in the output buffer because there might be more output pending.
The flush parameter may be `Flush::none`, `Flush::sync`, `Flush::finish`, `Flush::block`, or `Flush::trees`. `Flush::sync` requests to flush as much output as possible to the output buffer. `Flush::block` requests to stop if and when it gets to the next deflate block boundary. When decoding the zlib or gzip format, this will cause `write` to return immediately after the header and before the first block. When doing a raw inflate, `write` will go ahead and process the first block, and will return when it gets to the end of that block, or when it runs out of data.
The `Flush::block` option assists in appending to or combining deflate streams. Also to assist in this, on return `write` will set `zs.data_type` to the number of unused bits in the last byte taken from `zs.next_in`, plus 64 if `write` is currently decoding the last block in the deflate stream, plus 128 if `write` returned immediately after decoding an end-of-block code or decoding the complete header up to just before the first byte of the deflate stream. The end-of-block will not be indicated until all of the uncompressed data from that block has been written to `zs.next_out`. The number of unused bits may in general be greater than seven, except when bit 7 of `zs.data_type` is set, in which case the number of unused bits will be less than eight. `zs.data_type` is set as noted here every time `write` returns for all flush options, and so can be used to determine the amount of currently consumed input in bits.
The `Flush::trees` option behaves as `Flush::block` does, but it also returns when the end of each deflate block header is reached, before any actual data in that block is decoded. This allows the caller to determine the length of the deflate block header for later use in random access within a deflate block. 256 is added to the value of `zs.data_type` when `write` returns immediately after reaching the end of the deflate block header.
`write` should normally be called until it returns `error::end_of_stream` or another error. However if all decompression is to be performed in a single step (a single call of `write`), the parameter flush should be set to `Flush::finish`. In this case all pending input is processed and all pending output is flushed; `zs.avail_out` must be large enough to hold all of the uncompressed data for the operation to complete. (The size of the uncompressed data may have been saved by the compressor for this purpose.) The use of `Flush::finish` is not required to perform an inflation in one step. However it may be used to inform inflate that a faster approach can be used for the single call. `Flush::finish` also informs inflate to not maintain a sliding window if the stream completes, which reduces inflate's memory footprint. If the stream does not complete, either because not all of the stream is provided or not enough output space is provided, then a sliding window will be allocated and `write` can be called again to continue the operation as if `Flush::none` had been used.
In this implementation, `write` always flushes as much output as possible to the output buffer, and always uses the faster approach on the first call. So the effects of the flush parameter in this implementation are on the return value of `write` as noted below, when `write` returns early when `Flush::block` or `Flush::trees` is used, and when `write` avoids the allocation of memory for a sliding window when `Flush::finsih` is used.
If a preset dictionary is needed after this call, `write` sets `zs.adler` to the Adler-32 checksum of the dictionary chosen by the compressor and returns `error::need_dictionary`; otherwise it sets `zs.adler` to the Adler-32 checksum of all output produced so far (that is, `zs.total_out bytes`) and returns no error, `error::end_of_stream`, or an error code as described below. At the end of the stream, `write` checks that its computed adler32 checksum is equal to that saved by the compressor and returns `error::end_of_stream` only if the checksum is correct.
This function returns no error if some progress has been made (more input processed or more output produced), `error::end_of_stream` if the end of the compressed data has been reached and all uncompressed output has been produced, `error::need_dictionary` if a preset dictionary is needed at this point, `error::invalid_data` if the input data was corrupted (input stream not conforming to the zlib format or incorrect check value), `error::stream_error` if the stream structure was inconsistent (for example if `zs.next_in` or `zs.next_out` was null), `error::need_buffers` if no progress is possible or if there was not enough room in the output buffer when `Flush::finish` is used. Note that `error::need_buffers` is not fatal, and `write` can be called again with more input and more output space to continue decompressing. [endsect]Convenience header [include_file boost/beast/zlib.hpp][endsect][section:boost__beast__zlib__kind zlib::kind][indexterm1 zlib::kind][heading Synopsis]Defined in header [include_file boost/beast/zlib/zlib.hpp]```enum kind```[indexterm2 binary..zlib::kind][indexterm2 text..zlib::kind][indexterm2 unknown..zlib::kind][heading Values][table [[Name][Description]]  [[[^binary]][]]  [[[^text]][]]  [[[^unknown]][]]][heading Description]Convenience header [include_file boost/beast/zlib.hpp][endsect][section:boost__beast__zlib__uInt zlib::uInt][indexterm1 zlib::uInt][heading Synopsis]Defined in header [include_file boost/beast/zlib/zlib.hpp]```using uInt = unsigned int;```[heading Description]Convenience header [include_file boost/beast/zlib.hpp][endsect][section:boost__beast__zlib__z_params zlib::z_params]
Deflate codec parameters. [heading Synopsis]Defined in header [include_file boost/beast/zlib/zlib.hpp]```struct z_params```[heading Data Members][table [[Name][Description]]  [    [[link beast.ref.boost__beast__zlib__z_params.avail_in [*avail_in]]]    [      The number of bytes of input available at next_in.     ]  ]  [    [[link beast.ref.boost__beast__zlib__z_params.avail_out [*avail_out]]]    [      The remaining bytes of space at next_out.     ]  ]  [    [[link beast.ref.boost__beast__zlib__z_params.data_type [*data_type]]]    [          ]  ]  [    [[link beast.ref.boost__beast__zlib__z_params.next_in [*next_in]]]    [      A pointer to the next input byte.     ]  ]  [    [[link beast.ref.boost__beast__zlib__z_params.next_out [*next_out]]]    [      A pointer to the next output byte.     ]  ]  [    [[link beast.ref.boost__beast__zlib__z_params.total_in [*total_in]]]    [      The total number of input bytes read so far.     ]  ]  [    [[link beast.ref.boost__beast__zlib__z_params.total_out [*total_out]]]    [      The total number of bytes output so far.     ]  ]][heading Description]
Objects of this type are filled in by callers and provided to the deflate codec to define the input and output areas for the next compress or decompress operation.
The application must update next\_in and avail\_in when avail\_in has dropped to zero. It must update next\_out and avail\_out when avail\_out has dropped to zero. The application must initialize zalloc, zfree and opaque before calling the init function. All other fields are set by the compression library and must not be updated by the application.
The fields total\_in and total\_out can be used for statistics or progress reports. After compression, total\_in holds the total size of the uncompressed data and may be saved for use in the decompressor (particularly if the decompressor wants to decompress everything in a single step). [section:avail_in zlib::z_params::avail_in][indexterm2 avail_in..zlib::z_params]
The number of bytes of input available at `next_in`. [heading Synopsis]```std::size_t avail_in;```[heading Description]
If there is no more input, this should be set to zero. [endsect][section:avail_out zlib::z_params::avail_out][indexterm2 avail_out..zlib::z_params]
The remaining bytes of space at `next_out`. [heading Synopsis]```std::size_t avail_out;```[heading Description][endsect][section:data_type zlib::z_params::data_type][indexterm2 data_type..zlib::z_params][heading Synopsis]```int data_type = unknown;```[heading Description][endsect][section:next_in zlib::z_params::next_in][indexterm2 next_in..zlib::z_params]
A pointer to the next input byte. [heading Synopsis]```void const  * next_in;```[heading Description]
If there is no more input, this may be set to `nullptr`. [endsect][section:next_out zlib::z_params::next_out][indexterm2 next_out..zlib::z_params]
A pointer to the next output byte. [heading Synopsis]```void * next_out;```[heading Description][endsect][section:total_in zlib::z_params::total_in][indexterm2 total_in..zlib::z_params]
The total number of input bytes read so far. [heading Synopsis]```std::size_t total_in = 0;```[heading Description][endsect][section:total_out zlib::z_params::total_out][indexterm2 total_out..zlib::z_params]
The total number of bytes output so far. [heading Synopsis]```std::size_t total_out = 0;```[heading Description][endsect]Convenience header [include_file boost/beast/zlib.hpp][endsect]