<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<meta name="keywords" content="c++, boost, matrix, vector, quaternion">
<meta name="author" content="Generic C&#43;&#43; library for working with Quaternions Vectors and Matrices">
<title>QVM</title>
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Uncomment @import statement below to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/

/* Zajo's custom font import. The rest of the customizations are at the bottom of this css file,  which is otherwise kept unchanged */
@import "https://fonts.googleapis.com/css?family=Anonymous+Pro|Istok+Web|Quicksand|Press+Start+2P";

article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
*:not(pre)>code.nobreak{word-wrap:normal}
*:not(pre)>code.nowrap{white-space:nowrap}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock pre.nowrap,.literalblock pre.nowrap pre,.listingblock pre.nowrap,.listingblock pre.nowrap pre{white-space:pre;word-wrap:normal}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #dddddf}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt,.quoteblock .quoteblock{margin:0 0 1.25em;padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd){background:#f8f8f7}
table.stripes-none tr,table.stripes-odd tr:nth-of-type(even){background:none}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}

/* Zajo's customizations applied on top of the standard asciidoctor css above */
h1{font-size:4em}
h2{font-size:1.74em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.5em}
h4{font-size:1.2em}
h5{font-size:1em}
h6{font-size:1em}
h1 code{color:#4101a7; font-size:113%}
h2 code{color:#4101a7; font-size:113%}
h3 code{color:#4101a7; font-size:113%}
h4 code{color:#4101a7; font-size:113%}
h5 code{color:#4101a7; font-size:113%}
#toc {text-align:left}
#toc ul code{font-size:111%}
#toc a:hover code {color:#4101a7}
a:focus{outline:0}
body{text-align:left; background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Istok Web","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#a0a0a0;font-weight:400;margin-top:0;margin-bottom:.25em}
a{color:#000000;text-decoration:underline;line-height:inherit}
a:hover{color:#4101a7}
a:focus{color:#000000}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Quicksand","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#4101a7;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
code{font-family:"Anonymous Pro","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
*:not(pre)>code{font-size:1.09em;font-style:normal!important;letter-spacing:0;padding:0 0;word-spacing:-.15em;background-color:transparent;-webkit-border-radius:0;border-radius:0;line-height:1.45;text-rendering:optimizeLegibility;word-wrap:break-word}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Anonymous Pro","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeLegibility;font-size:1.05em}
kbd{font-family:"Anonymous Pro","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
#header>h1:first-child{font-family:"Press Start 2P";color:#ff5100;margin-top:2.25rem;margin-bottom:0;letter-spacing:.3em}
#toc ul{font-family:"Quicksand","DejaVu Sans",sans-serif;list-style-type:none}
#toc a:hover{color:#4101a7}
#toc.toc2{background-color:#f7f8f7}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#606060}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";color:#606060;text-shadow:none}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#ff5100}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#ff5100}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#ff5100}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:#606060;-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.exampleblock>.content{background-color:#ffffff;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.quoteblock blockquote::before{margin-left:-.8em;color:#4101a7}
.quoteblock blockquote{font-family:"Istok Web","DejaVu Serif"; font-size:1.0625rem; padding:0.5em}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
/*pre.CodeRay {background-color:#f7f7f8;}*/
.CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
.CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
.CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
table.CodeRay td{vertical-align: top;line-height:1.45}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
table.CodeRay td.code{padding:0 0 0 .5em}
table.CodeRay td.code>pre{padding:0}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>QVM</h1>
<div class="details">
<span id="author" class="author">Generic C&#43;&#43; library for working with Quaternions Vectors and Matrices</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_abstract">Abstract</a></li>
<li><a href="#tutorial">Tutorial</a>
<ul class="sectlevel2">
<li><a href="#_quaternions_vectors_matrices">Quaternions, Vectors, Matrices</a></li>
<li><a href="#_c_arrays">C Arrays</a></li>
<li><a href="#view_proxy">View proxies</a></li>
<li><a href="#_swizzling">Swizzling</a></li>
<li><a href="#enable_if">SFINAE/enable_if</a></li>
<li><a href="#_interoperability">Interoperability</a>
<ul class="sectlevel3">
<li><a href="#_specifying_return_types_for_binary_operations">Specifying return types for binary operations</a></li>
<li><a href="#_specifying_return_types_for_unary_operations">Specifying return types for unary operations</a></li>
<li><a href="#_converting_between_different_quaternion_vector_and_matrix_types">Converting between different quaternion, vector and matrix types</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#reference">Reference</a>
<ul class="sectlevel2">
<li><a href="#_header_files">Header Files</a></li>
<li><a href="#type_traits">Type Traits System</a>
<ul class="sectlevel3">
<li><a href="#scalar_requirements">Scalar Requirements</a></li>
<li><a href="#is_scalar"><code>is_scalar</code></a></li>
<li><a href="#scalar_traits"><code>scalar_traits</code></a></li>
<li><a href="#deduce_scalar"><code>deduce_scalar</code></a></li>
<li><a href="#scalar"><code>scalar</code></a></li>
<li><a href="#is_quat"><code>is_quat</code></a></li>
<li><a href="#quat_traits"><code>quat_traits</code></a></li>
<li><a href="#quat_traits_defaults"><code>quat_traits_defaults</code></a></li>
<li><a href="#deduce_quat"><code>deduce_quat</code></a></li>
<li><a href="#deduce_quat2"><code>deduce_quat2</code></a></li>
<li><a href="#is_vec"><code>is_vec</code></a></li>
<li><a href="#vec_traits"><code>vec_traits</code></a></li>
<li><a href="#vec_traits_defaults"><code>vec_traits_defaults</code></a></li>
<li><a href="#deduce_vec"><code>deduce_vec</code></a></li>
<li><a href="#deduce_vec2"><code>deduce_vec2</code></a></li>
<li><a href="#is_mat"><code>is_mat</code></a></li>
<li><a href="#mat_traits"><code>mat_traits</code></a></li>
<li><a href="#mat_traits_defaults"><code>mat_traits_defaults</code></a></li>
<li><a href="#deduce_mat"><code>deduce_mat</code></a></li>
<li><a href="#deduce_mat2"><code>deduce_mat2</code></a></li>
</ul>
</li>
<li><a href="#_built_in_quaternion_vector_and_matrix_types">Built-in Quaternion, Vector and Matrix Types</a>
<ul class="sectlevel3">
<li><a href="#quat"><code>quat</code></a></li>
<li><a href="#vec"><code>vec</code></a></li>
<li><a href="#mat"><code>mat</code></a></li>
</ul>
</li>
<li><a href="#_element_access">Element Access</a>
<ul class="sectlevel3">
<li><a href="#quat_access">Quaternions</a></li>
<li><a href="#vec_access">Vectors</a></li>
<li><a href="#swizzling">Vector Element Swizzling</a></li>
<li><a href="#mat_access">Matrices</a></li>
</ul>
</li>
<li><a href="#_quaternion_operations">Quaternion Operations</a>
<ul class="sectlevel3">
<li><a href="#quat_assign"><code>assign</code></a></li>
<li><a href="#quat_convert_to"><code>convert_to</code></a></li>
<li><a href="#quat_minus_eq"><code>operator-=</code></a></li>
<li><a href="#quat_minus_unary"><code>operator-</code> (unary)</a></li>
<li><a href="#quat_minus"><code>operator-</code> (binary)</a></li>
<li><a href="#quat_plus_eq"><code>operator+=</code></a></li>
<li><a href="#quat_plus"><code>operator+</code></a></li>
<li><a href="#quat_div_eq_scalar"><code>operator/=</code> (scalar)</a></li>
<li><a href="#quat_div_scalar"><code>operator/</code> (scalar)</a></li>
<li><a href="#quat_mul_eq_scalar"><code>operator*=</code> (scalar)</a></li>
<li><a href="#quat_mul_eq"><code>operator*=</code></a></li>
<li><a href="#quat_mul_scalar"><code>operator*</code> (scalar)</a></li>
<li><a href="#quat_mul"><code>operator*</code></a></li>
<li><a href="#quat_eq"><code>operator==</code></a></li>
<li><a href="#quat_neq"><code>operator!=</code></a></li>
<li><a href="#quat_cmp"><code>cmp</code></a></li>
<li><a href="#quat_mag_sqr"><code>mag_sqr</code></a></li>
<li><a href="#quat_mag"><code>mag</code></a></li>
<li><a href="#quat_normalized"><code>normalized</code></a></li>
<li><a href="#quat_normalize"><code>normalize</code></a></li>
<li><a href="#quat_dot"><code>dot</code></a></li>
<li><a href="#conjugate"><code>conjugate</code></a></li>
<li><a href="#quat_inverse"><code>inverse</code></a></li>
<li><a href="#slerp"><code>slerp</code></a></li>
<li><a href="#zero_quat"><code>zero_quat</code></a></li>
<li><a href="#quat_set_zero"><code>set_zero</code></a></li>
<li><a href="#identity_quat"><code>identity_quat</code></a></li>
<li><a href="#quat_set_identity"><code>set_identity</code></a></li>
<li><a href="#rot_quat"><code>rot_quat</code></a></li>
<li><a href="#quat_set_rot"><code>set_rot</code></a></li>
<li><a href="#quat_rotate"><code>rotate</code></a></li>
<li><a href="#rotx_quat"><code>rotx_quat</code></a></li>
<li><a href="#quat_set_rotx"><code>set_rotx</code></a></li>
<li><a href="#quat_rotate_x"><code>rotate_x</code></a></li>
<li><a href="#roty_quat"><code>roty_quat</code></a></li>
<li><a href="#quat_set_roty"><code>set_roty</code></a></li>
<li><a href="#quat_rotate_y"><code>rotate_y</code></a></li>
<li><a href="#rotz_quat"><code>rotz_quat</code></a></li>
<li><a href="#quat_set_rotz"><code>set_rotz</code></a></li>
<li><a href="#quat_rotate_z"><code>rotate_z</code></a></li>
<li><a href="#quat_scalar_cast"><code>scalar_cast</code></a></li>
<li><a href="#qref"><code>qref</code></a></li>
</ul>
</li>
<li><a href="#_vector_operations">Vector Operations</a>
<ul class="sectlevel3">
<li><a href="#vec_assign"><code>assign</code></a></li>
<li><a href="#vec_convert_to"><code>convert_to</code></a></li>
<li><a href="#vec_minus_eq"><code>operator-=</code></a></li>
<li><a href="#vec_minus_unary"><code>operator-</code> (unary)</a></li>
<li><a href="#vec_minus"><code>operator-</code> (binary)</a></li>
<li><a href="#vec_plus_eq"><code>operator+=</code></a></li>
<li><a href="#vec_plus"><code>operator+</code></a></li>
<li><a href="#vec_div_eq_scalar"><code>operator/=</code> (scalar)</a></li>
<li><a href="#vec_div_scalar"><code>operator/</code></a></li>
<li><a href="#vec_mul_eq_scalar"><code>operator*=</code></a></li>
<li><a href="#vec_mul_scalar"><code>operator*</code></a></li>
<li><a href="#vec_eq"><code>operator==</code></a></li>
<li><a href="#vec_neq"><code>operator!=</code></a></li>
<li><a href="#vec_cmp"><code>cmp</code></a></li>
<li><a href="#vec_mag_sqr"><code>mag_sqr</code></a></li>
<li><a href="#vec_mag"><code>mag</code></a></li>
<li><a href="#vec_normalized"><code>normalized</code></a></li>
<li><a href="#vec_normalize"><code>normalize</code></a></li>
<li><a href="#vec_dot"><code>dot</code></a></li>
<li><a href="#vec_cross"><code>cross</code></a></li>
<li><a href="#zero_vec"><code>zero_vec</code></a></li>
<li><a href="#vec_set_zero"><code>set_zero</code></a></li>
<li><a href="#vec_scalar_cast"><code>scalar_cast</code></a></li>
<li><a href="#vref"><code>vref</code></a></li>
</ul>
</li>
<li><a href="#_matrix_operations">Matrix Operations</a>
<ul class="sectlevel3">
<li><a href="#mat_assign"><code>assign</code></a></li>
<li><a href="#mat_convert_to"><code>convert_to</code></a></li>
<li><a href="#mat_minus_eq_scalar"><code>operator-=</code></a></li>
<li><a href="#mat_minus_unary"><code>operator-</code> (unary)</a></li>
<li><a href="#mat_minus"><code>operator-</code></a></li>
<li><a href="#mat_plus_eq_scalar"><code>operator+=</code></a></li>
<li><a href="#mat_plus"><code>operator+</code></a></li>
<li><a href="#mat_div_eq_scalar"><code>operator/=</code> (scalar)</a></li>
<li><a href="#mat_div_scalar"><code>operator/</code> (scalar)</a></li>
<li><a href="#mat_mul_eq"><code>operator*=</code></a></li>
<li><a href="#mat_mul_eq_scalar"><code>operator*=</code> (scalar)</a></li>
<li><a href="#mat_mul"><code>operator*</code></a></li>
<li><a href="#mat_mul_scalar"><code>operator*</code> (scalar)</a></li>
<li><a href="#mat_eq"><code>operator==</code></a></li>
<li><a href="#mat_neq"><code>operator!=</code></a></li>
<li><a href="#mat_cmp"><code>cmp</code></a></li>
<li><a href="#mat_inverse"><code>inverse</code></a></li>
<li><a href="#zero_mat"><code>zero_mat</code></a></li>
<li><a href="#mat_set_zero"><code>set_zero</code></a></li>
<li><a href="#identity_mat"><code>identity_mat</code></a></li>
<li><a href="#mat_set_identity"><code>set_identity</code></a></li>
<li><a href="#rot_mat"><code>rot_mat</code> / Euler angles</a></li>
<li><a href="#mat_set_rot"><code>set_rot</code> / Euler angles</a></li>
<li><a href="#mat_rotate"><code>rotate</code> / Euler angles</a></li>
<li><a href="#rotx_mat"><code>rotx_mat</code></a></li>
<li><a href="#mat_set_rotx"><code>set_rotx</code></a></li>
<li><a href="#mat_rotate_x"><code>rotate_x</code></a></li>
<li><a href="#roty_mat"><code>roty_mat</code></a></li>
<li><a href="#mat_set_roty"><code>set_roty</code></a></li>
<li><a href="#mat_rotate_y"><code>rotate_y</code></a></li>
<li><a href="#rotz_mat"><code>rotz_mat</code></a></li>
<li><a href="#mat_set_rotz"><code>set_rotz</code></a></li>
<li><a href="#mat_rotate_z"><code>rotate_z</code></a></li>
<li><a href="#determinant"><code>determinant</code></a></li>
<li><a href="#perspective_lh"><code>perspective_lh</code></a></li>
<li><a href="#perspective_rh"><code>perspective_rh</code></a></li>
<li><a href="#mat_scalar_cast"><code>scalar_cast</code></a></li>
<li><a href="#mref"><code>mref</code></a></li>
</ul>
</li>
<li><a href="#_quaternion_vector_operations">Quaternion-Vector Operations</a>
<ul class="sectlevel3">
<li><a href="#quat_vec_mul"><code>operator*</code></a></li>
</ul>
</li>
<li><a href="#_matrix_vector_operations">Matrix-Vector Operations</a>
<ul class="sectlevel3">
<li><a href="#mat_vec_mul"><code>operator*</code></a></li>
<li><a href="#transform_vector"><code>transform_vector</code></a></li>
<li><a href="#transform_point"><code>transform_point</code></a></li>
</ul>
</li>
<li><a href="#_matrix_to_matrix_view_proxies">Matrix-to-Matrix View Proxies</a>
<ul class="sectlevel3">
<li><a href="#del_row"><code>del_row</code></a></li>
<li><a href="#del_col"><code>del_col</code></a></li>
<li><a href="#del_row_col"><code>del_row_col</code></a></li>
<li><a href="#neg_row"><code>neg_row</code></a></li>
<li><a href="#neg_col"><code>neg_col</code></a></li>
<li><a href="#swap_rows"><code>swap_rows</code></a></li>
<li><a href="#swap_cols"><code>swap_cols</code></a></li>
<li><a href="#transposed"><code>transposed</code></a></li>
</ul>
</li>
<li><a href="#_vector_to_matrix_view_proxies">Vector-to-Matrix View Proxies</a>
<ul class="sectlevel3">
<li><a href="#col_mat"><code>col_mat</code></a></li>
<li><a href="#row_mat"><code>row_mat</code></a></li>
<li><a href="#translation_mat"><code>translation_mat</code></a></li>
<li><a href="#diag_mat"><code>diag_mat</code></a></li>
</ul>
</li>
<li><a href="#_matrix_to_vector_view_proxies">Matrix-to-Vector View Proxies</a>
<ul class="sectlevel3">
<li><a href="#col"><code>col</code></a></li>
<li><a href="#row"><code>row</code></a></li>
<li><a href="#diag"><code>diag</code></a></li>
<li><a href="#translation"><code>translation</code></a></li>
</ul>
</li>
<li><a href="#_exceptions">Exceptions</a>
<ul class="sectlevel3">
<li><a href="#error"><code>error</code></a></li>
<li><a href="#zero_magnitude_error"><code>zero_magnitude_error</code></a></li>
<li><a href="#zero_determinant_error"><code>zero_determinant_error</code></a></li>
</ul>
</li>
<li><a href="#_macros_and_configuration_boost_qvm">Macros and Configuration: BOOST_QVM_</a>
<ul class="sectlevel3">
<li><a href="#BOOST_QVM_INLINE"><code>INLINE</code></a></li>
<li><a href="#BOOST_QVM_FORCE_INLINE"><code>FORCE_INLINE</code></a></li>
<li><a href="#BOOST_QVM_INLINE_TRIVIAL"><code>INLINE_TRIVIAL</code></a></li>
<li><a href="#BOOST_QVM_INLINE_CRITICAL"><code>INLINE_CRITICAL</code></a></li>
<li><a href="#BOOST_QVM_INLINE_OPERATIONS"><code>INLINE_OPERATIONS</code></a></li>
<li><a href="#BOOST_QVM_INLINE_RECURSION"><code>INLINE_RECURSION</code></a></li>
<li><a href="#BOOST_QVM_ASSERT"><code>ASSERT</code></a></li>
<li><a href="#BOOST_QVM_STATIC_ASSERT"><code>STATIC_ASSERT</code></a></li>
<li><a href="#BOOST_QVM_THROW_EXCEPTION"><code>THROW_EXCEPTION</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#rationale">Design Rationale</a></li>
<li><a href="#_code_generator">Code Generator</a></li>
<li><a href="#_known_quirks_and_issues">Known Quirks and Issues</a>
<ul class="sectlevel2">
<li><a href="#_capturing_view_proxies_with_auto">Capturing View Proxies with <code>auto</code></a></li>
<li><a href="#_binding_qvm_overloads_from_an_unrelated_namespace">Binding QVM Overloads From an Unrelated Namespace</a></li>
<li><a href="#_link_errors_when_calling_math_functions_with_int_arguments">Link Errors When Calling Math Functions with <code>int</code> Arguments</a></li>
</ul>
</li>
<li><a href="#_distribution">Distribution</a></li>
<li><a href="#_portability">Portability</a></li>
<li><a href="#_feedback_support">Feedback / Support</a></li>
<li><a href="#_qa">Q&amp;A</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_abstract">Abstract</h2>
<div class="sectionbody">
<div class="paragraph">
<p>QVM is a generic library for working with Quaternions, Vectors and Matrices of static size. Features:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Emphasis on 2, 3 and 4-dimensional operations needed in graphics, video games and simulation applications.</p>
</li>
<li>
<p>Free function templates operate on any compatible user-defined quaternion, vector or matrix type.</p>
</li>
<li>
<p>Quaternion, vector and matrix types from different libraries or subsystems can be safely mixed in the same expression.</p>
</li>
<li>
<p>Type-safe mapping between compatible lvalue types with no temporary objects; e.g. transpose remaps the elements, rather than transforming the matrix.</p>
</li>
</ul>
</div>
<div class="paragraph text-right">
<p><a href="https://github.com/boostorg/qvm">GitHub</a> | <a href="#tutorial">Tutorial</a> | <a href="#reference">Reference</a> | <a href="#rationale">Design Rationale</a></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="tutorial">Tutorial</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_quaternions_vectors_matrices">Quaternions, Vectors, Matrices</h3>
<div class="paragraph">
<p>Out of the box QVM defines generic yet simple <a href="#quat"><code>quat</code></a>, <a href="#vec"><code>vec</code></a> and <a href="#mat"><code>mat</code></a> types. For example, the following snippet creates a quaternion object that rotates around the X axis:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">quat&lt;float&gt; rx = rotx_quat(3.14159f);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, a matrix that translates by a given vector can be created as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">vec&lt;float,3&gt; v = {0,0,7};
mat&lt;float,4,4&gt; tr = translation_mat(v);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The usual quaternion, vector and matrix operations work on these QVM types, however the operations are decoupled from any specific type: they work on any suitable type that has been registered by specializing the <a href="#quat_traits"><code>quat_traits</code></a>, <a href="#vec_traits"><code>vec_traits</code></a> and <a href="#mat_traits"><code>mat_traits</code></a> templates.</p>
</div>
<div class="paragraph">
<p>For example, a user-defined 3D vector type <code>float3</code> can be introduced to QVM as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">struct float3 { float a[3]; };

namespace boost { namespace qvm {

  template &lt;&gt;
  struct vec_traits&lt;float3&gt; {

    static int const dim=3;
    typedef float scalar_type;

    template &lt;int I&gt;
    static inline scalar_type &amp; write_element( float3 &amp; v ) {
      return v.a[I];
    }

    template &lt;int I&gt;
    static inline scalar_type read_element( float3 const &amp; v ) {
      return v.a[I];
    }

    static inline scalar_type &amp; write_element_idx( int i, float3 &amp; v ) {
      return v.a[i];
    } //optional

    static inline scalar_type read_element_idx( int i, float3 const &amp; v ) {
      return v.a[i];
    } //optional

  };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalently, using the <a href="#vec_traits_defaults"><code>vec_traits_defaults</code></a> template the above can be shortened to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;&gt;
  struct vec_traits&lt;float3&gt;: vec_traits_defaults&lt;float3,float,3&gt; {

    template &lt;int I&gt;
    static inline scalar_type &amp; write_element( float3 &amp; v ) {
      return v.a[I];
    }

    static inline scalar_type &amp; write_element_idx( int i, float3 &amp; v ) {
      return v.a[i];
    } //optional

  };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>After a similar specialization of the <a href="#mat_traits"><code>mat_traits</code></a> template for a user-defined 3x3 matrix type <code>float33</code>, the full range of vector and matrix operations defined by QVM headers becomes available automatically:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">float3 v;
X(v) = 0;
Y(v) = 0;
Z(v) = 7;
float vmag = mag(v);
float33 m = rotx_mat&lt;3&gt;(3.14159f);
float3 vrot = m * v;</code></pre>
</div>
</div>
<div class="paragraph">
<p>User-defined quaternion types are similarly introduced to QVM by specializing the <a href="#quat_traits"><code>quat_traits</code></a> template.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_c_arrays">C Arrays</h3>
<div class="paragraph">
<p>In <a href="#boost/qvm/quat_traits_array.hpp"><code>boost/qvm/quat_traits_array.hpp</code></a>, <a href="#boost/qvm/vec_traits_array.hpp"><code>boost/qvm/vec_traits_array.hpp</code></a> and <a href="#boost/qvm/mat_traits_array.hpp"><code>boost/qvm/mat_traits_array.hpp</code></a> QVM defines appropriate <a href="#quat_traits"><code>quat_traits</code></a>, <a href="#vec_traits"><code>vec_traits</code></a> and <a href="#mat_traits"><code>mat_traits</code></a> specializations that allow QVM functions to operate directly on plain old C arrays:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">float v[3] = {0,0,7};
float3 vrot = rotx_mat&lt;3&gt;(3.14159f) * v;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Naturally, operator overloads cannot kick in if all elements of an expression are of built-in types. The following is still illegal:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">float v[3] = {0,0,7};
v *= 42;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <a href="#vref"><code>vref</code></a> and <a href="#mref"><code>mref</code></a> function templates can be used to work around this issue:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">float v[3] = {0,0,7};
vref(v) *= 42;</code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="view_proxy">View proxies</h3>
<div class="paragraph">
<p>QVM defines various function templates that provide static mapping between (possibly user-defined) quaternion, vector and matrix types. The example below multiplies column 1 (QVM indexes are always zero-based) of the matrix <code>m</code> by a scalar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">void multiply_column1( float33 &amp; m, float scalar ) {
  col&lt;1&gt;(m) *= scalar;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The expression <a href="#col"><code>col&lt;1&gt;(m)</code></a> is an lvalue of an unspecified 3D vector type that refers to column 1 of <code>m</code>. Note however that this does not create any temporary objects; instead <code>operator*=</code> above works directly with a reference to <code>m</code>.</p>
</div>
<div class="paragraph">
<p>Here is another example, multiplying a transposed view of a matrix by a vector of some user-defined type <code>float3</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">float3 v = {0,0,7};
float3 vrot = transposed(rotx_mat&lt;3&gt;(3.14159f)) * v;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In general, the various view proxy functions return references of unspecified, non-copyable types that refer to the original object. They can be assigned from or converted to any compatible vector or matrix type.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_swizzling">Swizzling</h3>
<div class="paragraph">
<p>QVM allows accessing vector elements by swizzling, exposing vector views of different dimensions, and/or views with reordered elements. The example below rotates <code>v</code> around the X axis, and stores the resulting vector back in <code>v</code> but with the X and Y elements swapped:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">float3 v = {0,0,7};
YXZ(v) = rotx_mat&lt;3&gt;(3.14159f) * v;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A special case of swizzling provides next-dimension-view of a vector object, adding either 0 or 1 as its last component. Assuming <code>float3</code> is a 3D vector type, and <code>float4</code> is a 4D vector type, the following statements are valid:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">float3 v = {0,0,7};
float4 point = XYZ1(v); //{0,0,7,1}
float4 vector = XYZ0(v); //{0,0,7,0}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also valid for swizzling to address vector elements more than once:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">float3 v = {0,0,7};
float4 v1 = ZZZZ(v); //{7,7,7,7}</code></pre>
</div>
</div>
<div class="paragraph">
<p>QVM defines all permutations of <code>X</code>, <code>Y</code>, <code>Z</code>, <code>W</code> for 1D, 2D, 3D and 4D swizzling, plus each dimension defines variants with 0 or 1 used at any position (if 0 or 1 appear at the first position, the swizzling function name begins with underscore, e.g. <code>_1XY</code>).</p>
</div>
<div class="paragraph">
<p>The swizzling syntax can also be used to bind scalars as vectors. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">float3 v = _00X(42.0f); //{0,0,42}</code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="enable_if">SFINAE/enable_if</h3>
<div class="paragraph">
<p>SFINAE stands for Substitution Failure Is Not An Error. This refers to a situation in C&#43;&#43; where an invalid substitution of template parameters (including when those parameters are deduced implicitly as a result of an unqualified call) is not in itself an error.</p>
</div>
<div class="paragraph">
<p>In absence of concepts support, SFINAE can be used to disable function template overloads that would otherwise present a signature that is too generic. More formally, this is supported by the Boost <code>enable_if</code> library.</p>
</div>
<div class="paragraph">
<p>For example, QVM defines <code>operator*</code> overload which works with any user-defined matrix and vector types. The naive approach would be to declare this overload as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">template &lt;class Matrix,class Vector&gt;
Vector operator*( Matrix const &amp; m, Vector const &amp; v );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Even if the function definition might contain code that would compile only for <code>Matrix</code> and <code>Vector</code> types, because the function declaration itself is valid, it will participate in overload rezolutions when multiplying objects of any two types whatsoever. This typically renders overload resolutions ambiguous and the compiler (correctly) issues an error.</p>
</div>
<div class="paragraph">
<p>Using <code>enable_if</code>, QVM declares such overloads in a way that preserves their generic signature but only participate in overload resolutions if the passed parameters make sense depending on the semantics of the operation being defined:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">template &lt;class A,class B&gt;
typename enable_if_c&lt;
  is_mat&lt;A&gt;::value &amp;&amp; is_vec&lt;B&gt;::value &amp;&amp; mat_traits&lt;A&gt;::cols==vec_traits&lt;B&gt;::dim, //Condition
  B&gt;::type //Return type
operator*( A const &amp; a, B const &amp; b );</code></pre>
</div>
</div>
<div class="paragraph">
<p>For brevity, function declarations throughout this documentation specify the condition which controls whether they are enabled or not without specifying exactly what <code>enable_if</code> construct is used to achieve this effect.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_interoperability">Interoperability</h3>
<div class="paragraph">
<p>An important design goal of QVM is that it works seamlessly with 3rd-party quaternion, vector and matrix types and libraries. Even when such libraries overload the same C&#43;&#43; operators as QVM, it is safe to bring the entire <code>boost::qvm</code> namespace in scope by specifying:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">using namespace boost::qvm;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above using directive does not introduce ambiguities with function and operator overloads defined by a 3rd-party library because:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Most <code>boost::qvm</code> function overloads and all operator overloads use SFINAE/<code>enable_if</code>, which makes them "disappear" unless an expression uses types that have the appropriate QVM-specific type traits defined;</p>
</li>
<li>
<p>Whenever such overloads are compatible with a given expression, their signature is extremely generic, which means that any other (user-defined) compatible overload will be a better match in any overload resolution.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Bringing the entire boost::qvm namespace in scope may introduce ambiguities when accessing types (as opposed to functions) defined by 3rd-party libraries. In that case, you can safely bring namespace <code>boost::qvm::sfinae</code> in scope instead, which contains only function and operator overloads that use SFINAE/<code>enable_if</code>.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_specifying_return_types_for_binary_operations">Specifying return types for binary operations</h4>
<div class="paragraph">
<p>Bringing the <code>boost::qvm</code> namespace in scope lets you mix vector and matrix types that come from different APIs into a common, type-safe framework. In this case however, it should be considered what types should be returned by binary operations that return an object by value. For example, if you multiply a 3x3 matrix <code>m1</code> of type <code>user_matrix1</code> by a 3x3 matrix <code>m2</code> of type <code>user_matrix2</code>, what type should that operation return?</p>
</div>
<div class="paragraph">
<p>The answer is that by default, QVM returns some kind of compatible matrix type, so it is always safe to write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">auto &amp; m = m1 * m2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, the type deduced by default converts implicitly to any compatible matrix type, so the following is also valid, at the cost of a temporary:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">user_matrix1 m = m1 * m2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>While the temporary object can be optimized away by many compilers, it can be avoided altogether by specializing the <a href="#deduce_mat2"><code>deduce_mat2</code></a> template. For example, to specify that multiplying a <code>user_matrix1</code> by a <code>user_matrix2</code> should always produce a <code>user_matrix1</code> object, you could write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;&gt;
  struct deduce_mat2&lt;user_matrix1,user_matrix2,3,3&gt; {
    typedef user_matrix1 type;
  };

  template &lt;&gt;
  struct deduce_mat2&lt;user_matrix2,user_matrix1,3,3&gt; {
    typedef user_matrix1 type;
  };

} }</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Be mindful of potential ODR violation when using <a href="#deduce_quat2"><code>deduce_quat2</code></a>, <a href="#deduce_vec2"><code>deduce_vec2</code></a> and <a href="#deduce_mat2"><code>deduce_mat2</code></a> in independent libraries. For example, this could happen if <code>lib1</code> defines <code>deduce_vec2&lt;lib1::vec,lib2::vec&gt;::type</code> as <code>lib1::vec</code> and in the same program <code>lib2</code> defines <code>deduce_vec2&lt;lib1::vec,lib2::vec&gt;::type</code> as <code>lib2::vec</code>.</p>
</div>
<div class="paragraph">
<p>It is best to keep such specializations out of <code>lib1</code> and <code>lib2</code>. Of course, it is always safe for <code>lib1</code> and <code>lib2</code> to use <a href="#convert_to"><code>convert_to</code></a> to convert between the <code>lib1::vec</code> and <code>lib2::vec</code> types as needed.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_specifying_return_types_for_unary_operations">Specifying return types for unary operations</h4>
<div class="paragraph">
<p>Perhaps surprisingly, unary operations that return an object by value have a similar, though simpler issue. That&#8217;s because the argument they&#8217;re called with may not be copyable, as in:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">float m[3][3];
auto &amp; inv = inverse(m);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Above, the object returned by <a href="#mat_inverse"><code>inverse</code></a> and captured by <code>inv</code> can not be of type <code>float[3][3]</code>, because that type isn&#8217;t copyable. By default, QVM "just works", returning an object of suitable matrix type that is copyable. This deduction process can be controlled, by specializing the <a href="#deduce_mat"><code>deduce_mat</code></a> template.</p>
</div>
</div>
<div class="sect3">
<h4 id="_converting_between_different_quaternion_vector_and_matrix_types">Converting between different quaternion, vector and matrix types</h4>
<div class="paragraph">
<p>Any time you need to create a matrix of a particular C&#43;&#43; type from any other compatible matrix type, you can use the <a href="#convert_to"><code>convert_to</code></a> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">user_matrix2 m=convert_to&lt;user_matrix2&gt;(m1 * m2);</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reference">Reference</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_header_files">Header Files</h3>
<div class="paragraph">
<p>QVM is split into multiple headers to allow different compilation units to <code>#include</code> only the components they need. Each function in this document specifies the exact header that must be <code>#included</code> in order to use it.</p>
</div>
<div class="paragraph">
<p>The tables below list commonly used components and the headers they&#8217;re found in. Header names containing a number define functions that only work with objects of that dimension; e.g. <code>vec_operations2.hpp</code> contains only functions for working with 2D vectors.</p>
</div>
<div class="paragraph">
<p>The header <code>boost/qvm/all.hpp</code> is provided for convenience. It includes all other QVM headers.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Quaternion header files</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Quaternion traits</p></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre>#include &lt;boost/qvm/quat_traits.hpp&gt;
#include &lt;boost/qvm/quat_traits_array.hpp&gt;
#include &lt;boost/qvm/deduce_quat.hpp&gt;</pre></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Quaternion element access</p></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre>#include &lt;boost/qvm/quat_access.hpp&gt;</pre></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Quaternion operations</p></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre>#include &lt;boost/qvm/quat_operations.hpp&gt;</pre></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#quat"><code>quat</code></a> class template</p></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre>#include &lt;boost/qvm/quat.hpp&gt;</pre></div></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. Vector header files</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Vector traits</p></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre>#include &lt;boost/qvm/vec_traits.hpp&gt;
#include &lt;boost/qvm/vec_traits_array.hpp&gt;
#include &lt;boost/qvm/deduce_vec.hpp&gt;</pre></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Vector element access</p></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre>#include &lt;boost/qvm/vec_access.hpp&gt;</pre></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Vector <a href="#swizzling">swizzling</a></p></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre>#include &lt;boost/qvm/swizzle.hpp&gt;
#include &lt;boost/qvm/swizzle2.hpp&gt;
#include &lt;boost/qvm/swizzle3.hpp&gt;
#include &lt;boost/qvm/swizzle4.hpp&gt;</pre></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Vector operations</p></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> #include &lt;boost/qvm/vec_operations.hpp&gt;
#include &lt;boost/qvm/vec_operations2.hpp&gt;
#include &lt;boost/qvm/vec_operations3.hpp&gt;
#include &lt;boost/qvm/vec_operations4.hpp&gt;</pre></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Quaternion-vector operations</p></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> #include &lt;boost/qvm/quat_vec_operations.hpp&gt;</pre></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Vector-matrix operations</p></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> #include &lt;boost/qvm/vec_mat_operations.hpp&gt;</pre></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Vector-matrix <a href="#view_proxy">view proxies</a></p></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> #include &lt;boost/qvm/map_vec_mat.hpp&gt;</pre></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#vec"><code>vec</code></a> class template</p></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> #include &lt;boost/qvm/vec.hpp&gt;</pre></div></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 3. Matrix header files</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Matrix traits</p></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre>#include &lt;boost/qvm/mat_traits.hpp&gt;
#include &lt;boost/qvm/mat_traits_array.hpp&gt;
#include &lt;boost/qvm/deduce_mat.hpp&gt;</pre></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Matrix element access</p></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre>#include &lt;boost/qvm/mat_access.hpp&gt;</pre></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Matrix operations</p></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre>#include &lt;boost/qvm/mat_operations.hpp&gt;
#include &lt;boost/qvm/mat_operations2.hpp&gt;
#include &lt;boost/qvm/mat_operations3.hpp&gt;
#include &lt;boost/qvm/mat_operations4.hpp&gt;</pre></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Matrix-matrix <a href="#view_proxy">view proxies</a></p></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> #include &lt;boost/qvm/map_mat_mat.hpp&gt;</pre></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Matrix-vector <a href="#view_proxy">view proxies</a></p></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> #include &lt;boost/qvm/map_mat_vec.hpp&gt;</pre></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#mat"><code>mat</code></a> class template</p></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> #include &lt;boost/qvm/mat.hpp&gt;</pre></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="type_traits">Type Traits System</h3>
<div class="paragraph">
<p>QVM is designed to work with user-defined quaternion, vector and matrix types, as well as user-defined scalar types. This section formally defines the way such types can be integrated.</p>
</div>
<hr>
<div class="sect3">
<h4 id="scalar_requirements">Scalar Requirements</h4>
<div class="paragraph">
<p>A valid scalar type <code>S</code> must have accessible destructor, default constructor, copy constructor and assignment operator, and must support the following operations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">S operator*( S, S );
S operator/( S, S );
S operator+( S, S );
S operator-( S, S );

S &amp; operator*=( S &amp;, S );
S &amp; operator/=( S &amp;, S );
S &amp; operator+=( S &amp;, S );
S &amp; operator-=( S &amp;, S );

bool operator==( S, S );
bool operator!=( S, S );</code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition, the expression <code>S(0)</code> should construct a scalar of value zero, and <code>S(1)</code> should construct a scalar of value one, or else the <a href="#scalar_traits"><code>scalar_traits</code></a> template must be specialized appropriately.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="is_scalar"><code>is_scalar</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/scalar_traits.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;class T&gt;
  struct is_scalar {
    static bool const value=false;
  };

  template &lt;&gt; struct is_scalar&lt;char&gt;       { static bool const value=true; };
  template &lt;&gt; struct is_scalar&lt;signed char&gt;  { static bool const value=true; };
  template &lt;&gt; struct is_scalar&lt;unsigned char&gt;  { static bool const value=true; };
  template &lt;&gt; struct is_scalar&lt;signed short&gt;   { static bool const value=true; };
  template &lt;&gt; struct is_scalar&lt;unsigned short&gt; { static bool const value=true; };
  template &lt;&gt; struct is_scalar&lt;signed int&gt;   { static bool const value=true; };
  template &lt;&gt; struct is_scalar&lt;unsigned int&gt;   { static bool const value=true; };
  template &lt;&gt; struct is_scalar&lt;signed long&gt;  { static bool const value=true; };
  template &lt;&gt; struct is_scalar&lt;unsigned long&gt;  { static bool const value=true; };
  template &lt;&gt; struct is_scalar&lt;float&gt;      { static bool const value=true; };
  template &lt;&gt; struct is_scalar&lt;double&gt;     { static bool const value=true; };
  template &lt;&gt; struct is_scalar&lt;long double&gt;  { static bool const value=true; };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This template defines a compile-time boolean constant value which can be used to determine whether a type <code>T</code> is a valid scalar type. It must be specialized together with the <a href="#scalar_traits"><code>scalar_traits</code></a> template in order to introduce a user-defined scalar type to QVM. Such types must satisfy the <a href="#scalar_requirements">scalar requirements</a>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="scalar_traits"><code>scalar_traits</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/scalar_traits.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;class Scalar&gt;
  struct scalar_traits {

    BOOST_QVM_INLINE_CRITICAL
    static Scalar value( int v ) {
      return Scalar(v);
    }

  };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This template may be specialized for user-defined scalar types to define the appropriate conversion from <code>int</code>; this is primarily used whenever QVM needs to deduce a zero or one value.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="deduce_scalar"><code>deduce_scalar</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/deduce_scalar.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;class A,class B&gt;
  struct deduce_scalar
  {
    typedef typename impl&lt;A,B&gt;::type type;
  };

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements: </dt>
<dd>
<p><code>A</code> and <code>B</code> satisfy the <a href="#scalar_requirements">scalar requirements</a>.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>If <code>A</code> and <code>B</code> are the same type, <code>impl&lt;A,B&gt;::type</code> returns that type. Otherwise, <code>impl&lt;A,B&gt;::type</code> is well defined for the following types only: <code>signed</code>/<code>unsigned char</code>, <code>signed</code>/<code>unsigned short</code>, <code>signed</code>/<code>unsigned int</code>, <code>signed</code>/<code>unsigned long</code>, <code>float</code> and <code>double</code>. The deduction logic is as follows:</p>
<div class="ulist">
<ul>
<li>
<p>if either of <code>A</code> and <code>B</code> is <code>double</code>, the result is <code>double</code>;</p>
</li>
<li>
<p>else, if one of <code>A</code> or <code>B</code> is an integer type and the other is <code>float</code>, the result is <code>float</code>;</p>
</li>
<li>
<p>else, if one of <code>A</code> or <code>B</code> is a signed integer and the other type is unsigned integer, the signed type is changed to unsigned, and then the lesser of the two integers is promoted to the other.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This template is used by generic binary operations that return a scalar, to deduce the return type based on the (possibly different) scalars of their arguments.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="scalar"><code>scalar</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/scalar_traits.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;class T&gt;
  struct scalar {
    typedef /*exact definition unspecified*/ type;
  };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The expression <a href="#quat_traits"><code>quat_traits&lt;T&gt;::scalar_type</code></a> evaluates to the scalar type of the quaternion type <code>T</code> (if <a href="#is_quat"><code>is_quat&lt;T&gt;::value</code></a> is <code>true</code>).</p>
</div>
<div class="paragraph">
<p>The expression <a href="#vec_traits"><code>vec_traits&lt;T&gt;::scalar_type</code></a> evaluates to the scalar type of the vector type <code>T</code> (if <a href="#is_vec"><code>is_vec&lt;T&gt;::value</code></a> is <code>true</code>).</p>
</div>
<div class="paragraph">
<p>The expression <a href="#mat_traits"><code>mat_traits&lt;T&gt;::scalar_type</code></a> evaluates to the scalar type of the matrix type <code>T</code> (if <a href="#is_mat"><code>is_mat&lt;T&gt;::value</code></a> is <code>true</code>).</p>
</div>
<div class="paragraph">
<p>The expression <code>scalar&lt;T&gt;::type</code> is similar, except that it automatically detects whether <code>T</code> is a vector or a matrix or a quaternion type.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="is_quat"><code>is_quat</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_traits.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;class T&gt;
  struct is_quat {

    static bool const value = false;

  };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This type template defines a compile-time boolean constant value which can be used to determine whether a type <code>T</code> is a quaternion type. For quaternion types, the <a href="#quat_traits"><code>quat_traits</code></a> template can be used to access their elements generically, or to obtain their <code>scalar type</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="quat_traits"><code>quat_traits</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_traits.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;class Q&gt;
  struct quat_traits {

    /*main template members unspecified*/

  };

  /*
  User-defined (possibly partial) specializations:

  template &lt;&gt;
  struct quat_traits&lt;Q&gt; {

    typedef &lt;&lt;user-defined&gt;&gt; scalar_type;

    template &lt;int I&gt;
    static inline scalar_type read_element( Quaternion const &amp; q );

    template &lt;int I&gt;
    static inline scalar_type &amp; write_element( Quaternion &amp; q );

  };
  */

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>quat_traits</code> template must be specialized for (user-defined) quaternion types in order to enable quaternion operations defined in QVM headers for objects of those types.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
QVM quaternion operations do not require that quaternion types are copyable.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The main <code>quat_traits</code> template members are not specified. Valid specializations are required to define the following members:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>scalar_type</code>: the expression <code>quat_traits&lt;Quaternion&gt;::scalar_type</code> must be a value type which satisfies the <a href="#scalar_requirements"><code>scalar requirements</code></a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In addition, valid specializations of the <code>quat_traits</code> template must define at least one of the following access functions as static members, where <code>q</code> is an object of type <code>Quaternion</code>, and <code>I</code> is compile-time integer constant:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>read_element</code>: the expression <code>quat_traits&lt;Quaternion&gt;::read_element&lt;I&gt;(q)</code> returns either a copy of or a <code>const</code> reference to the <code>I</code>-th element of <code>q</code>.</p>
</li>
<li>
<p><code>write_element</code>: the expression <code>quat_traits&lt;Quaternion&gt;::write_element&lt;I&gt;(q)</code> returns mutable reference to the <code>I</code>-th element of <code>q</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For the quaternion <code>a + bi + cj + dk</code>, the elements are assumed to be in the following order: <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>; that is, <code>I</code>=<code>0</code>/<code>1</code>/<code>2</code>/<code>3</code> would access <code>a</code>/<code>b</code>/<code>c</code>/<code>d</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It is illegal to call any of the above functions unless <code>is_quat&lt;Quaternion&gt;::value</code> is true. Even then, quaternion types are allowed to define only a subset of the access functions.</p>
</div>
<div class="paragraph">
<p>Below is an example of a user-defined quaternion type, and its corresponding specialization of the quat_traits template:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">#include &lt;boost/qvm/quat_traits.hpp&gt;

struct fquat { float a[4]; };

namespace boost { namespace qvm {

  template &lt;&gt;
  struct quat_traits&lt;fquat&gt; {

    typedef float scalar_type;

    template &lt;int I&gt;
    static inline scalar_type &amp; write_element( fquat &amp; q ) {
      return q.a[I];
    }

    template &lt;int I&gt;
    static inline scalar_type read_element( fquat const &amp; q ) {
      return q.a[I];
    }

  };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalently, using the <a href="#quat_traits_defaults"><code>quat_traits_defaults</code></a> template the above can be shortened to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;&gt;
  struct quat_traits&lt;fquat&gt;: quat_traits_defaults&lt;fquat,float&gt; {

    template &lt;int I&gt;
    static inline scalar_type &amp; write_element( fquat &amp; q ) {
      return q.a[I];
    }

  };

} }</code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="quat_traits_defaults"><code>quat_traits_defaults</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_traits_defaults.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;class QuatType,class ScalarType&gt;
  struct quat_traits_defaults {

    typedef QuatType quat_type;

    typedef ScalarType scalar_type;

    template &lt;int I&gt;
    static BOOST_QVM_INLINE_CRITICAL
    scalar_type read_element( quat_type const &amp; x ) {
      return quat_traits&lt;quat_type&gt;::template
        write_element&lt;I&gt;(const_cast&lt;quat_type &amp;&gt;(x));
    }

  };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>quat_traits_defaults</code> template is designed to be used as a public base for user-defined specializations of the <a href="#quat_traits"><code>quat_traits</code></a> template, to easily define the required members. If it is used, the only member that must be defined by the user in a <code>quat_traits</code> specialization is <code>write_element</code>; the <code>quat_traits_defaults</code> base will define <code>read_element</code>, as well as <code>scalar_type</code> automatically.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="deduce_quat"><code>deduce_quat</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/deduce_quat.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;class Q&gt;
  struct deduce_quat {
    typedef Q type;
  };

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code><a href="#is_quat">is_quat</a>&lt;Q&gt;::value</code> is <code>true</code>;</p>
</li>
<li>
<p><code><a href="#is_quat">is_quat</a>&lt;deduce_quat&lt;Q&gt;::type&gt;::value</code> must be <code>true</code>;</p>
</li>
<li>
<p><code>deduce_quat&lt;Q&gt;::type</code> must be copyable.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>This template is used by QVM whenever it needs to deduce a copyable quaternion type from a single user-supplied function parameter of quaternion type. Note that <code>Q</code> itself may be non-copyable.</p>
</div>
<div class="paragraph">
<p>The main template definition returns <code>Q</code>, which means that it is suitable only for copyable quaternion types. QVM also defines (partial) specializations for the non-copyable quaternion types it produces. Users can define other (partial) specializations for their own types.</p>
</div>
<div class="paragraph">
<p>A typical use of the <code>deduce_quat</code> template is for specifying the preferred quaternion type to be returned by the generic function template overloads in QVM depending on the type of their arguments.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="deduce_quat2"><code>deduce_quat2</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/deduce_quat.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;class A,class B&gt;
  struct deduce_quat2 {
    typedef /*unspecified*/ type;
  };

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Both <code><a href="#scalar">scalar</a>&lt;A&gt;::type</code> and <code>scalar&lt;B&gt;::type</code> are well defined;</p>
</li>
<li>
<p><code><a href="#is_quat">is_quat</a>&lt;A&gt;::value</code> || <code>is_quat&lt;B&gt;::value</code> is <code>true</code>;</p>
</li>
<li>
<p><code>is_quat&lt;deduce_quat2&lt;A,B&gt;::type&gt;::value</code> must be <code>true</code>;</p>
</li>
<li>
<p><code>deduce_quat2&lt;A,B&gt;::type</code> must be copyable.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>This template is used by QVM whenever it needs to deduce a quaternion type from the types of two user-supplied function parameters. The returned type must have accessible copy constructor (the <code>A</code> and <code>B</code> types themselves could be non-copyable, and either one of them may not be a quaternion type.)</p>
</div>
<div class="paragraph">
<p>The main template definition returns an unspecified quaternion type with <a href="#quat_traits"><code>scalar_type</code></a> obtained by <code><a href="#deduce_scalar">deduce_scalar</a>&lt;A,B&gt;::type</code>, except if <code>A</code> and <code>B</code> are the same quaternion type <code>Q</code>, in which case <code>Q</code> is returned, which is only suitable for copyable types. QVM also defines (partial) specializations for the non-copyable quaternion types it produces. Users can define other (partial) specializations for their own types.</p>
</div>
<div class="paragraph">
<p>A typical use of the <code>deduce_quat2</code> template is for specifying the preferred quaternion type to be returned by the generic function template overloads in QVM depending on the type of their arguments.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="is_vec"><code>is_vec</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/vec_traits.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;class T&gt;
  struct is_vec {

    static bool const value = false;

  };

 } }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This type template defines a compile-time boolean constant value which can be used to determine whether a type <code>T</code> is a vector type. For vector types, the <a href="#vec_traits"><code>vec_traits</code></a> template can be used to access their elements generically, or to obtain their dimension and <code>scalar type</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="vec_traits"><code>vec_traits</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/vec_traits.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;class V&gt;
  struct vec_traits {

    /*main template members unspecified*/

  };

  /*
  User-defined (possibly partial) specializations:

  template &lt;&gt;
  struct vec_traits&lt;V&gt; {

    static int const dim = &lt;&lt;user-defined&gt;&gt;;

    typedef &lt;&lt;user-defined&gt;&gt; scalar_type;

    template &lt;int I&gt;
    static inline scalar_type read_element( Vector const &amp; v );

    template &lt;int I&gt;
    static inline scalar_type &amp; write_element( Vector &amp; v );

    static inline scalar_type read_element_idx( int i, Vector const &amp; v );
    static inline scalar_type &amp; write_element_idx( int i, Vector &amp; v );

  };
  */

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>vec_traits</code> template must be specialized for (user-defined) vector types in order to enable vector and matrix operations defined in QVM headers for objects of those types.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
QVM vector operations do not require that vector types are copyable.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The main <code>vec_traits</code> template members are not specified. Valid specializations are required to define the following members:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>dim</code>: the expression <code>vec_traits&lt;Vector&gt;::dim</code> must evaluate to a compile-time integer constant greater than 0 that specifies the vector size.</p>
</li>
<li>
<p><code>scalar_type</code>: the expression <code>vec_traits&lt;Vector&gt;::scalar_type</code> must be a value type which satisfies the <a href="#scalar_requirements"><code>scalar requirements</code></a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In addition, valid specializations of the <code>vec_traits</code> template may define the following access functions as static members, where <code>v</code> is an object of type <code>Vector</code>, <code>I</code> is a compile-time integer constant, and <code>i</code> is a variable of type <code>int</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>read_element</code>: the expression <code>vec_traits&lt;Vector&gt;::read_element&lt;I&gt;(v)</code> returns either a copy of or a const reference to the <code>I</code>-th element of <code>v</code>.</p>
</li>
<li>
<p><code>write_element</code>: the expression <code>vec_traits&lt;Vector&gt;::write_element&lt;I&gt;(v)</code> returns mutable reference to the <code>I</code>-th element of <code>v</code>.</p>
</li>
<li>
<p><code>read_element_idx</code>: the expression <code>vec_traits&lt;Vector&gt;::read_element_idx(i,v)</code> returns either a copy of or a <code>const</code> reference to the <code>i</code>-th element of <code>v</code>.</p>
</li>
<li>
<p><code>write_element_idx</code>: the expression <code>vec_traits&lt;Vector&gt;::write_element_idx(i,v)</code> returns mutable reference to the <code>i</code>-th element of <code>v</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It is illegal to call any of the above functions unless <code>is_vec&lt;Vector&gt;::value</code> is true. Even then, vector types are allowed to define only a subset of the access functions. The general requirements are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>At least one of <code>read_element</code> or <code>write_element</code> must be defined;</p>
</li>
<li>
<p>If <code>read_element_idx</code> is defined, <code>read_element</code> must also be defined;</p>
</li>
<li>
<p>If <code>write_element_idx</code> is defined, <code>write_element</code> must also be defined.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Below is an example of a user-defined 3D vector type, and its corresponding specialization of the <code>vec_traits</code> template:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">#include &lt;boost/qvm/vec_traits.hpp&gt;

struct float3 { float a[3]; };

namespace boost { namespace qvm {

  template &lt;&gt;
  struct vec_traits&lt;float3&gt; {

    static int const dim=3;

    typedef float scalar_type;

    template &lt;int I&gt;
    static inline scalar_type &amp; write_element( float3 &amp; v ) {
      return v.a[I];
    }

    template &lt;int I&gt;
    static inline scalar_type read_element( float3 const &amp; v ) {
      return v.a[I];
    }

    static inline scalar_type &amp; write_element_idx( int i, float3 &amp; v ) {
      return v.a[i];
    } //optional

    static inline scalar_type read_element_idx( int i, float3 const &amp; v ) {
      return v.a[i];
    } //optional

  };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalently, using the <a href="#vec_traits_defaults"><code>vec_traits_defaults</code></a> template the above can be shortened to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;&gt;
  struct vec_traits&lt;float3&gt;: vec_traits_defaults&lt;float3,float,3&gt;
  {

    template &lt;int I&gt;
    static inline scalar_type &amp; write_element( float3 &amp; v ) {
      return v.a[I];
    }

    static inline scalar_type &amp; write_element_idx( int i, float3 &amp; v ) {
      return v.a[i];
    } //optional

  };

} }</code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="vec_traits_defaults"><code>vec_traits_defaults</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/vec_traits_defaults.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;class VecType,class ScalarType,int Dim&gt;
  struct vec_traits_defaults {

    typedef VecType vec_type;
    typedef ScalarType scalar_type;
    static int const dim=Dim;

    template &lt;int I&gt;
    static BOOST_QVM_INLINE_CRITICAL
    scalar_type write_element( vec_type const &amp; x ) {
      return vec_traits&lt;vec_type&gt;::template write_element&lt;I&gt;(const_cast&lt;vec_type &amp;&gt;(x));
    }

    static BOOST_QVM_INLINE_CRITICAL
    scalar_type read_element_idx( int i, vec_type const &amp; x ) {
      return vec_traits&lt;vec_type&gt;::write_element_idx(i,const_cast&lt;vec_type &amp;&gt;(x));
    }

    protected:

    static BOOST_QVM_INLINE_TRIVIAL
    scalar_type &amp; write_element_idx( int i, vec_type &amp; m ) {
      /* unspecified */
    }
  };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>vec_traits_defaults</code> template is designed to be used as a public base for user-defined specializations of the <a href="#vec_traits"><code>vec_traits</code></a> template, to easily define the required members. If it is used, the only member that must be defined by the user in a <code>vec_traits</code> specialization is <code>write_element</code>; the <code>vec_traits_defaults</code> base will define <code>read_element</code>, as well as <code>scalar_type</code> and <code>dim</code> automatically.</p>
</div>
<div class="paragraph">
<p>Optionally, the user may also define <code>write_element_idx</code>, in which case the <code>vec_traits_defaults</code> base will provide a suitable <code>read_element_idx</code> definition automatically. If not, <code>vec_traits_defaults</code> defines a protected implementation of <code>write_element_idx</code> which may be made publicly available by the deriving <code>vec_traits</code> specialization in case the vector type for which it is being specialized can not be indexed efficiently. This <code>write_element_idx</code> function is less efficient (using meta-programming), implemented in terms of the required user-defined <code>write_element</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="deduce_vec"><code>deduce_vec</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/deduce_vec.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;class V, int Dim=vec_traits&lt;Vector&gt;::dim&gt;
  struct deduce_vec {

    typedef /*unspecified*/ type;

  };

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code><a href="#is_vec">is_vec</a>&lt;V&gt;::value</code> is <code>true</code>;</p>
</li>
<li>
<p><code>is_vec&lt;deduce_vec&lt;V&gt;::type&gt;::value</code> must be <code>true</code>;</p>
</li>
<li>
<p><code>deduce_vec&lt;V&gt;::type</code> must be copyable;</p>
</li>
<li>
<p><code>vec_traits&lt;deduce_vec&lt;V&gt;::type&gt;::dim==Dim</code>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>This template is used by QVM whenever it needs to deduce a copyable vector type of certain dimension from a single user-supplied function parameter of vector type. The returned type must have accessible copy constructor. Note that <code>V</code> may be non-copyable.</p>
</div>
<div class="paragraph">
<p>The main template definition returns an unspecified copyable vector type of size <code>Dim</code>, except if <code><a href="#vec_traits">vec_traits</a>&lt;V&gt;::dim==Dim</code>, in which case it returns <code>V</code>, which is suitable only if <code>V</code> is a copyable type. QVM also defines (partial) specializations for the non-copyable vector types it produces. Users can define other (partial) specializations for their own types.</p>
</div>
<div class="paragraph">
<p>A typical use of the <code>deduce_vec</code> template is for specifying the preferred vector type to be returned by the generic function template overloads in QVM depending on the type of their arguments.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="deduce_vec2"><code>deduce_vec2</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/deduce_vec.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;class A,class B,int Dim&gt;
  struct deduce_vec2 {
    typedef /*unspecified*/ type;
  };

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Both <code><a href="#scalar">scalar</a>&lt;A&gt;::type</code> and <code>scalar&lt;B&gt;::type</code> are well defined;</p>
</li>
<li>
<p><code><a href="#is_vec">is_vec</a>&lt;A&gt;::value || is_vec&lt;B&gt;::value</code> is <code>true</code>;</p>
</li>
<li>
<p><code>is_vec&lt;deduce_vec2&lt;A,B&gt;::type&gt;::value</code> must be <code>true</code>;</p>
</li>
<li>
<p><code>deduce_vec2&lt;A,B&gt;::type</code> must be copyable;</p>
</li>
<li>
<p><code>vec_traits&lt;deduce_vec2&lt;A,B&gt;::type&gt;::dim==Dim</code>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>This template is used by QVM whenever it needs to deduce a vector type of certain dimension from the types of two user-supplied function parameters. The returned type must have accessible copy constructor (the <code>A</code> and <code>B</code> types themselves could be non-copyable, and either one of them may not be a vector type.)</p>
</div>
<div class="paragraph">
<p>The main template definition returns an unspecified vector type of the requested dimension with <a href="#vec_traits"><code>scalar_type</code></a> obtained by <code><a href="#deduce_scalar">deduce_scalar</a>&lt;A,B&gt;::type</code>, except if <code>A</code> and <code>B</code> are the same vector type <code>V</code> of dimension <code>Dim</code>, in which case <code>V</code> is returned, which is only suitable for copyable types. QVM also defines (partial) specializations for the non-copyable vector types it produces. Users can define other (partial) specializations for their own types.</p>
</div>
<div class="paragraph">
<p>A typical use of the <code>deduce_vec2</code> template is for specifying the preferred vector type to be returned by the generic function template overloads in QVM depending on the type of their arguments.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="is_mat"><code>is_mat</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_traits.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;class T&gt;
  struct is_mat {

    static bool const value = false;

  };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This type template defines a compile-time boolean constant value which can be used to determine whether a type <code>T</code> is a matrix type. For matrix types, the <a href="#mat_traits"><code>mat_traits</code></a> template can be used to access their elements generically, or to obtain their dimensions and scalar type.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="mat_traits"><code>mat_traits</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_traits.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;class M&gt;
  struct mat_traits {

    /*main template members unspecified*/

  };

  /*
  User-defined (possibly partial) specializations:

  template &lt;&gt;
  struct mat_traits&lt;M&gt; {

    static int const rows = &lt;&lt;user-defined&gt;&gt;;
    static int const cols = &lt;&lt;user-defined&gt;&gt;;
    typedef &lt;&lt;user-defined&gt;&gt; scalar_type;

    template &lt;int R,int C&gt;
    static inline scalar_type read_element( Matrix const &amp; m );

    template &lt;int R,int C&gt;
    static inline scalar_type &amp; write_element( Matrix &amp; m );

    static inline scalar_typeread_element_idx( int r, int c, Matrix const &amp; m );
    static inline scalar_type &amp; write_element_idx( int r, int c, Matrix &amp; m );

  };
  */

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>mat_traits</code> template must be specialized for (user-defined) matrix types in order to enable vector and matrix operations defined in QVM headers for objects of those types.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The matrix operations defined by QVM do not require matrix types to be copyable.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The main <code>mat_traits</code> template members are not specified. Valid specializations are required to define the following members:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>rows</code>: the expression <code>mat_traits&lt;Matrix&gt;::rows</code> must evaluate to a compile-time integer constant greater than 0 that specifies the number of rows in a matrix.</p>
</li>
<li>
<p><code>cols</code> must evaluate to a compile-time integer constant greater than 0 that specifies the number of columns in a matrix.</p>
</li>
<li>
<p><code>scalar_type</code>: the expression <code>mat_traits&lt;Matrix&gt;::scalar_type</code> must be a value type which satisfies the scalar requirements.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In addition, valid specializations of the <code>mat_traits</code> template may define the following access functions as static members, where <code>m</code> is an object of type <code>Matrix</code>, <code>R</code> and <code>C</code> are compile-time integer constants, and <code>r</code> and <code>c</code> are variables of type <code>int</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>read_element</code>: the expression <code>mat_traits&lt;Matrix&gt;::read_element&lt;R,C&gt;(m)</code> returns either a copy of or a const reference to the element at row <code>R</code> and column <code>C</code> of <code>m</code>.</p>
</li>
<li>
<p><code>write_element</code>: the expression <code>mat_traits&lt;Matrix&gt;::write_element&lt;R,C&gt;(m)</code> returns mutable reference to the element at row <code>R</code> and column <code>C</code> of <code>m</code>.</p>
</li>
<li>
<p><code>read_element_idx</code>: the expression <code>mat_traits&lt;Matrix&gt;::read_element_idx(r,c,m)</code> returns either a copy of or a const reference to the element at row <code>r</code> and column <code>c</code> of <code>m</code>.</p>
</li>
<li>
<p><code>write_element_idx</code>: the expression <code>mat_traits&lt;Matrix&gt;::write_element_idx(r,c,m)</code> returns mutable reference to the element at row <code>r</code> and column <code>c</code> of <code>m</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It is illegal to call any of the above functions unless <code>is_mat&lt;Matrix&gt;::value</code> is true. Even then, matrix types are allowed to define only a subset of the access functions. The general requirements are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>At least one of <code>read_element</code> or <code>write_element</code> must be defined;</p>
</li>
<li>
<p>If <code>read_element_idx</code> is defined, <code>read_element</code> must also be defined;</p>
</li>
<li>
<p>If <code>write_element_idx</code> is defined, <code>write_element</code> must also be defined.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Below is an example of a user-defined 3x3 matrix type, and its corresponding specialization of the <code>mat_traits</code> template:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">#include &lt;boost/qvm/mat_traits.hpp&gt;

struct float33 { float a[3][3]; };

namespace boost { namespace qvm {

  template &lt;&gt;
  struct mat_traits&lt;float33&gt; {

    static int const rows=3;
    static int const cols=3;
    typedef float scalar_type;

    template &lt;int R,int C&gt;
    static inline scalar_type &amp; write_element( float33 &amp; m ) {
      return m.a[R][C];
    }

    template &lt;int R,int C&gt;
    static inline scalar_type read_element( float33 const &amp; m ) {
      return m.a[R][C];
    }

    static inline scalar_type &amp; write_element_idx( int r, int c, float33 &amp; m ) {
      return m.a[r][c];
    }

    static inline scalar_type read_element_idx( int r, int c, float33 const &amp; m ) {
      return m.a[r][c];
    }

  };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalently, we could use the &lt;&lt;mat_traits_defaults,<code>mat_traits_defaults</code> template to shorten the above to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;&gt;
  struct mat_traits&lt;float33&gt;: mat_traits_defaults&lt;float33,float,3,3&gt; {

    template &lt;int R,int C&gt; static inline scalar_type &amp; write_element( float33 &amp; m ) { return m.a[R][C]; }

    static inline scalar_type &amp; write_element_idx( int r, int c, float33 &amp; m ) {
      return m.a[r][c];
    }

  };

} }</code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="mat_traits_defaults"><code>mat_traits_defaults</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_traits_defaults.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;class MatType,class ScalarType,int Rows,int Cols&gt;
  struct mat_traits_defaults
  {
    typedef MatType mat_type;
    typedef ScalarType scalar_type;
    static int const rows=Rows;
    static int const cols=Cols;

    template &lt;int Row,int Col&gt;
    static BOOST_QVM_INLINE_CRITICAL
    scalar_type write_element( mat_type const &amp; x ) {
      return mat_traits&lt;mat_type&gt;::template write_element&lt;Row,Col&gt;(const_cast&lt;mat_type &amp;&gt;(x));
    }

    static BOOST_QVM_INLINE_CRITICAL
    scalar_type read_element_idx( int r, int c, mat_type const &amp; x ) {
      return mat_traits&lt;mat_type&gt;::write_element_idx(r,c,const_cast&lt;mat_type &amp;&gt;(x));
    }

    protected:

    static BOOST_QVM_INLINE_TRIVIAL
    scalar_type &amp; write_element_idx( int r, int c, mat_type &amp; m ) {
      /* unspecified */
    }
  };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>mat_traits_defaults</code> template is designed to be used as a public base for user-defined specializations of the <a href="#mat_traits"><code>mat_traits</code></a> template, to easily define the required members. If it is used, the only member that must be defined by the user in a <code>mat_traits</code> specialization is <code>write_element</code>; the <code>mat_traits_defaults</code> base will define <code>read_element</code>, as well as <code>scalar_type</code>, <code>rows</code> and <code>cols</code> automatically.</p>
</div>
<div class="paragraph">
<p>Optionally, the user may also define <code>write_element_idx</code>, in which case the <code>mat_traits_defaults</code> base will provide a suitable <code>read_element_idx</code> definition automatically. Otherwise, <code>mat_traits_defaults</code> defines a protected implementation of <code>write_element_idx</code> which may be made publicly available by the deriving <code>mat_traits</code> specialization in case the matrix type for which it is being specialized can not be indexed efficiently. This <code>write_element_idx</code> function is less efficient (using meta-programming), implemented in terms of the required user-defined <code>write_element</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="deduce_mat"><code>deduce_mat</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/deduce_mat.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;
    class M,
    int Rows=mat_traits&lt;Matrix&gt;::rows,
    int Cols=mat_traits&lt;Matrix&gt;::cols&gt;
  struct deduce_mat {

    typedef /*unspecified*/ type;

  };

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code><a href="#is_mat">is_mat</a>&lt;M&gt;::value</code> is <code>true</code>;</p>
</li>
<li>
<p><code>is_mat&lt;deduce_mat&lt;M&gt;::type&gt;::value</code> must be <code>true</code>;</p>
</li>
<li>
<p><code>deduce_mat&lt;M&gt;::type</code> must be copyable;</p>
</li>
<li>
<p><code><a href="#mat_traits">mat_traits</a>&lt;deduce_mat&lt;M&gt;::type&gt;::rows==Rows</code>;</p>
</li>
<li>
<p><code>mat_traits&lt;deduce_mat&lt;M&gt;::type&gt;::cols==Cols</code>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>This template is used by QVM whenever it needs to deduce a copyable matrix type of certain dimensions from a single user-supplied function parameter of matrix type. The returned type must have accessible copy constructor. Note that M itself may be non-copyable.</p>
</div>
<div class="paragraph">
<p>The main template definition returns an unspecified copyable matrix type of size <code>Rows</code> x <code>Cols</code>, except if <code><a href="#mat_traits">mat_traits</a>&lt;M&gt;::rows==Rows &amp;&amp; mat_traits&lt;M&gt;::cols==Cols</code>, in which case it returns <code>M</code>, which is suitable only if <code>M</code> is a copyable type. QVM also defines (partial) specializations for the non-copyable matrix types it produces. Users can define other (partial) specializations for their own types.</p>
</div>
<div class="paragraph">
<p>A typical use of the deduce_mat template is for specifying the preferred matrix type to be returned by the generic function template overloads in QVM depending on the type of their arguments.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="deduce_mat2"><code>deduce_mat2</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/deduce_mat.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;class A,class B,int Rows,int Cols&gt;
  struct deduce_mat2 {

    typedef /*unspecified*/ type;

  };

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Both <code><a href="#scalar">scalar</a>&lt;A&gt;::type</code> and <code>scalar&lt;B&gt;::type</code> are well defined;</p>
</li>
<li>
<p><code><a href="#is_mat">is_mat</a>&lt;A&gt;::value || is_mat&lt;B&gt;::value</code> is <code>true</code>;</p>
</li>
<li>
<p><code>is_mat&lt;deduce_mat2&lt;A,B&gt;::type&gt;::value</code> must be <code>true</code>;</p>
</li>
<li>
<p><code>deduce_mat2&lt;A,B&gt;::type</code> must be copyable;</p>
</li>
<li>
<p><code><a href="#mat_traits">mat_traits</a>&lt;deduce_mat2&lt;A,B&gt;::type&gt;::rows==Rows</code>;</p>
</li>
<li>
<p><code>mat_traits&lt;deduce_mat2&lt;A,B&gt;::type&gt;::cols==Cols</code>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>This template is used by QVM whenever it needs to deduce a matrix type of certain dimensions from the types of two user-supplied function parameters. The returned type must have accessible copy constructor (the <code>A</code> and <code>B</code> types themselves could be non-copyable, and either one of them may be a non-matrix type.)</p>
</div>
<div class="paragraph">
<p>The main template definition returns an unspecified matrix type of the requested dimensions with <a href="#mat_traits"><code>scalar_type</code></a> obtained by <code><a href="#deduce_scalar">deduce_scalar</a>&lt;A,B&gt;::type</code>, except if <code>A</code> and <code>B</code> are the same matrix type <code>M</code> of dimensions <code>Rows</code> x <code>Cols</code>, in which case <code>M</code> is returned, which is only suitable for copyable types. QVM also defines (partial) specializations for the non-copyable matrix types it produces. Users can define other (partial) specializations for their own types.</p>
</div>
<div class="paragraph">
<p>A typical use of the <code>deduce_mat2</code> template is for specifying the preferred matrix type to be returned by the generic function template overloads in QVM depending on the type of their arguments.</p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_built_in_quaternion_vector_and_matrix_types">Built-in Quaternion, Vector and Matrix Types</h3>
<div class="paragraph">
<p>QVM defines several class templates (together with appropriate specializations of <a href="#quat_traits"><code>quat_traits</code></a>, <a href="#vec_traits"><code>vec_traits</code></a> and <a href="#mat_traits"><code>mat_traits</code></a> templates) which can be used as generic quaternion, vector and matrix types. Using these types directly wouldn&#8217;t be typical though, the main design goal of QVM is to allow users to plug in their own quaternion, vector and matrix types.</p>
</div>
<div class="sect3">
<h4 id="quat"><code>quat</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

    template &lt;class T&gt;
    struct quat {

      T a[4];

      template &lt;class R&gt;
      operator R() const {
        R r;
        assign(r,*this);
        return r;
      }

    };

    template &lt;class Quaternion&gt;
    struct quat_traits;

    template &lt;class T&gt;
    struct quat_traits&lt; quat&lt;T&gt; &gt; {

      typedef T scalar_type;

      template &lt;int I&gt;
      static scalar_type read_element( quat&lt;T&gt; const &amp; x ) {
        return x.a[I];
      }

      template &lt;int I&gt;
      static scalar_type &amp; write_element( quat&lt;T&gt; &amp; x ) {
        return x.a[I];
      }

    };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a simple quaternion type. It converts to any other quaternion type.</p>
</div>
<div class="paragraph">
<p>The partial specialization of the <a href="#quat_traits"><code>quat_traits</code></a> template makes the <code>quat</code> template compatible with the generic operations defined by QVM.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="vec"><code>vec</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/vec.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

    template &lt;class T,int Dim&gt;
    struct vec {

      T a[Dim];

      template &lt;class R&gt;
      operator R() const {
        R r;
        assign(r,*this);
        return r;
      }

    };

    template &lt;class Vector&gt;
    struct vec_traits;

    template &lt;class T,int Dim&gt;
    struct vec_traits&lt; vec&lt;T,Dim&gt; &gt; {

      typedef T scalar_type;
      static int const dim=Dim;

      template &lt;int I&gt;
      static scalar_type read_element( vec&lt;T,Dim&gt; const &amp; x ) {
        return x.a[I];
      }

      template &lt;int I&gt;
      static scalar_type &amp; write_element( vec&lt;T,Dim&gt; &amp; x ) {
        return x.a[I];
      }

      static scalar_type read_element_idx( int i, vec&lt;T,Dim&gt; const &amp; x ) {
        return x.a[i];
      }

      static scalar_type &amp; write_element_idx( int i, vec&lt;T,Dim&gt; &amp; x ) {
        return x.a[i];
      }
    };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a simple vector type. It converts to any other vector type of compatible size.</p>
</div>
<div class="paragraph">
<p>The partial specialization of the <a href="#vec_traits"><code>vec_traits</code></a> template makes the <code>vec</code> template compatible with the generic operations defined by QVM.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="mat"><code>mat</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;class T,int Rows,int Cols&gt;
  struct mat {

    T a[Rows][Cols];

    template &lt;class R&gt;
    operator R() const {
      R r;
      assign(r,*this);
      return r;
    }

  };

  template &lt;class Matrix&gt;
  struct mat_traits;

  template &lt;class T,int Rows,int Cols&gt;
  struct mat_traits&lt; mat&lt;T,Rows,Cols&gt; &gt; {

    typedef T scalar_type;
    static int const rows=Rows;
    static int const cols=Cols;

    template &lt;int Row,int Col&gt;
    static scalar_type read_element( mat&lt;T,Rows,Cols&gt; const &amp; x ) {
      return x.a[Row][Col];
    }

    template &lt;int Row,int Col&gt;
    static scalar_type &amp; write_element( mat&lt;T,Rows,Cols&gt; &amp; x ) {
      return x.a[Row][Col];
    }

    static scalar_type read_element_idx( int row, int col, mat&lt;T,Rows,Cols&gt; const &amp; x ) {
      return x.a[row][col];
    }

    static scalar_type &amp; write_element_idx( int row, int col, mat&lt;T,Rows,Cols&gt; &amp; x ) {
      return x.a[row][col];
    }

  };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a simple matrix type. It converts to any other matrix type of compatible size.</p>
</div>
<div class="paragraph">
<p>The partial specialization of the <a href="#mat_traits"><code>mat_traits</code></a> template makes the <code>mat</code> template compatible with the generic operations defined by QVM.</p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_element_access">Element Access</h3>
<div class="sect3">
<h4 id="quat_access">Quaternions</h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_access.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_quat&lt;Q&gt;::value

  template &lt;class Q&gt; -unspecified-return-type- S( Q &amp; q );
  template &lt;class Q&gt; -unspecified-return-type- V( Q &amp; q );
  template &lt;class Q&gt; -unspecified-return-type- X( Q &amp; q );
  template &lt;class Q&gt; -unspecified-return-type- Y( Q &amp; q );
  template &lt;class Q&gt; -unspecified-return-type- Z( Q &amp; q );

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>An expression of the form <code>S(q)</code> can be used to access the scalar component of the quaternion <code>q</code>. For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">S(q) *= 42;</code></pre>
</div>
</div>
<div class="paragraph">
<p>multiplies the scalar component of <code>q</code> by the scalar 42.</p>
</div>
<div class="paragraph">
<p>An expression of the form <code>V(q)</code> can be used to access the vector component of the quaternion <code>q</code>. For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">V(q) *= 42</code></pre>
</div>
</div>
<div class="paragraph">
<p>multiplies the vector component of <code>q</code> by the scalar 42.</p>
</div>
<div class="paragraph">
<p>The <code>X</code>, <code>Y</code> and <code>Z</code> elements of the vector component can also be accessed directly using <code>X(q)</code>, <code>Y(q)</code> and <code>Z(q)</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The return types are lvalues.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="vec_access">Vectors</h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/vec_access.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_vec&lt;V&gt;::value

  template &lt;int I,class V&gt; -unspecified-return-type- A( V &amp; v );
  template &lt;class V&gt; -unspecified-return-type- A0( V &amp; v );
  template &lt;class V&gt; -unspecified-return-type- A1( V &amp; v );
  ...
  template &lt;class V&gt; -unspecified-return-type- A9( V &amp; v );

  template &lt;class V&gt; -unspecified-return-type- X( V &amp; v );
  template &lt;class V&gt; -unspecified-return-type- Y( V &amp; v );
  template &lt;class V&gt; -unspecified-return-type- Z( V &amp; v );
  template &lt;class V&gt; -unspecified-return-type- W( V &amp; v );

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>An expression of the form of <code>A&lt;I&gt;(v)</code> can be used to access the <code>I</code>-th element a vector object <code>v</code>. For example, the expression:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">A&lt;1&gt;(v) *= 42;</code></pre>
</div>
</div>
<div class="paragraph">
<p>can be used to multiply the element at index 1 (indexing in QVM is always zero-based) of a vector <code>v</code> by 42.</p>
</div>
<div class="paragraph">
<p>For convenience, there are also non-template overloads for <code>I</code> from 0 to 9; an alternative way to write the above expression is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">A1(v) *= 42;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>X</code>, <code>Y</code>, <code>Z</code> and <code>W</code> act the same as <code>A0</code>/<code>A1</code>/<code>A2</code>/<code>A3</code>; yet another alternative way to write the above expression is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">Y(v) *= 42;</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The return types are lvalues.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="swizzling">Vector Element Swizzling</h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/swizzle.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //*** Accessing vector elements by swizzling ***

  //2D view proxies, only enabled if:
  //  is_vec&lt;V&gt;::value
  template &lt;class V&gt; -unspecified-2D-vector-type- XX( V &amp; v );
  template &lt;class V&gt; -unspecified-2D-vector-type- XY( V &amp; v );
  template &lt;class V&gt; -unspecified-2D-vector-type- XZ( V &amp; v );
  template &lt;class V&gt; -unspecified-2D-vector-type- XW( V &amp; v );
  template &lt;class V&gt; -unspecified-2D-vector-type- X0( V &amp; v );
  template &lt;class V&gt; -unspecified-2D-vector-type- X1( V &amp; v );
  template &lt;class V&gt; -unspecified-2D-vector-type- YX( V &amp; v );
  template &lt;class V&gt; -unspecified-2D-vector-type- YY( V &amp; v );
  template &lt;class V&gt; -unspecified-2D-vector-type- YZ( V &amp; v );
  template &lt;class V&gt; -unspecified-2D-vector-type- YW( V &amp; v );
  template &lt;class V&gt; -unspecified-2D-vector-type- Y0( V &amp; v );
  template &lt;class V&gt; -unspecified-2D-vector-type- Y1( V &amp; v );
  template &lt;class V&gt; -unspecified-2D-vector-type- ZX( V &amp; v );
  template &lt;class V&gt; -unspecified-2D-vector-type- ZY( V &amp; v );
  template &lt;class V&gt; -unspecified-2D-vector-type- ZZ( V &amp; v );
  template &lt;class V&gt; -unspecified-2D-vector-type- ZW( V &amp; v );
  template &lt;class V&gt; -unspecified-2D-vector-type- Z0( V &amp; v );
  template &lt;class V&gt; -unspecified-2D-vector-type- Z1( V &amp; v );
  template &lt;class V&gt; -unspecified-2D-vector-type- WX( V &amp; v );
  template &lt;class V&gt; -unspecified-2D-vector-type- WY( V &amp; v );
  template &lt;class V&gt; -unspecified-2D-vector-type- WZ( V &amp; v );
  template &lt;class V&gt; -unspecified-2D-vector-type- WW( V &amp; v );
  template &lt;class V&gt; -unspecified-2D-vector-type- W0( V &amp; v );
  template &lt;class V&gt; -unspecified-2D-vector-type- W1( V &amp; v );
  ...
  //2D view proxies, only enabled if:
  //  is_scalar&lt;S&gt;::value
  template &lt;class S&gt; -unspecified-2D-vector-type- X0( S &amp; s );
  template &lt;class S&gt; -unspecified-2D-vector-type- X1( S &amp; s );
  template &lt;class S&gt; -unspecified-2D-vector-type- XX( S &amp; s );
  ...
  -unspecified-2D-vector-type- _00();
  -unspecified-2D-vector-type- _01();
  -unspecified-2D-vector-type- _10();
  -unspecified-2D-vector-type- _11();

  //3D view proxies, only enabled if:
  //  is_vec&lt;V&gt;::value
  template &lt;class V&gt; -unspecified-3D-vector-type- XXX( V &amp; v );
  ...
  template &lt;class V&gt; -unspecified-3D-vector-type- XXW( V &amp; v );
  template &lt;class V&gt; -unspecified-3D-vector-type- XX0( V &amp; v );
  template &lt;class V&gt; -unspecified-3D-vector-type- XX1( V &amp; v );
  template &lt;class V&gt; -unspecified-3D-vector-type- XYX( V &amp; v );
  ...
  template &lt;class V&gt; -unspecified-3D-vector-type- XY1( V &amp; v );
  ...
  template &lt;class V&gt; -unspecified-3D-vector-type- WW1( V &amp; v );
  ...
  //3D view proxies, only enabled if:
  //  is_scalar&lt;S&gt;::value
  template &lt;class S&gt; -unspecified-3D-vector-type- X00( S &amp; s );
  template &lt;class S&gt; -unspecified-3D-vector-type- X01( S &amp; s );
  ...
  template &lt;class S&gt; -unspecified-3D-vector-type- XXX( S &amp; s );
  template &lt;class S&gt; -unspecified-3D-vector-type- XX0( S &amp; s );
  ...
  -unspecified-3D-vector-type- _000();
  -unspecified-3D-vector-type- _001();
  -unspecified-3D-vector-type- _010();
  ...
  -unspecified-3D-vector-type- _111();

  //4D view proxies, only enabled if:
  //  is_vec&lt;V&gt;::value
  template &lt;class V&gt; -unspecified-4D-vector-type- XXXX( V &amp; v );
  ...
  template &lt;class V&gt; -unspecified-4D-vector-type- XXXW( V &amp; v );
  template &lt;class V&gt; -unspecified-4D-vector-type- XXX0( V &amp; v );
  template &lt;class V&gt; -unspecified-4D-vector-type- XXX1( V &amp; v );
  template &lt;class V&gt; -unspecified-4D-vector-type- XXYX( V &amp; v );
  ...
  template &lt;class V&gt; -unspecified-4D-vector-type- XXY1( V &amp; v );
  ...
  template &lt;class V&gt; -unspecified-4D-vector-type- WWW1( V &amp; v );
  ...
  //4D view proxies, only enabled if:
  //  is_scalar&lt;S&gt;::value
  template &lt;class S&gt; -unspecified-4D-vector-type- X000( S &amp; s );
  template &lt;class S&gt; -unspecified-4D-vector-type- X001( S &amp; s );
  ...
  template &lt;class S&gt; -unspecified-4D-vector-type- XXXX( S &amp; s );
  template &lt;class S&gt; -unspecified-4D-vector-type- XX00( S &amp; s );
  ...
  -unspecified-4D-vector-type- _0000();
  -unspecified-4D-vector-type- _0001();
  -unspecified-4D-vector-type- _0010();
  ...
  -unspecified-4D-vector-type- _1111();

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Swizzling allows zero-overhead direct access to a (possibly rearranged) subset of the elements of 2D, 3D and 4D vectors. For example, if <code>v</code> is a 4D vector, the expression <code>YX(v) is a 2D view proxy whose `X</code> element refers to the <code>Y</code> element of <code>v</code>, and whose <code>Y</code> element refers to the <code>X</code> element of <code>v</code>. Like other view proxies <code>YX</code> is an lvalue, that is, if <code>v2</code> is a 2D vector, one could write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">YX(v) = v2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above will leave the <code>Z</code> and <code>W</code> elements of <code>v</code> unchanged but assign the <code>Y</code> element of <code>v2</code> to the <code>X</code> element of <code>v</code> and the <code>X</code> element of <code>v2</code> to the <code>Y</code> element of <code>v</code>.</p>
</div>
<div class="paragraph">
<p>All permutations of <code>X</code>, <code>Y</code>, <code>Z</code>, <code>W</code>, <code>0</code>, <code>1</code> for 2D, 3D and 4D swizzling are available (if the first character of the swizzle identifier is <code>0</code> or <code>1</code>, it is preceded by a <code>_</code>, for example <code>_11XY</code>).</p>
</div>
<div class="paragraph">
<p>It is valid to use the same vector element more than once: the expression <code>ZZZ(v)</code> is a 3D vector whose <code>X</code>, <code>Y</code> and <code>Z</code> elements all refer to the <code>Z</code> element of <code>v</code>.</p>
</div>
<div class="paragraph">
<p>Finally, scalars can be "swizzled" to access them as vectors: the expression <code>_0X01(42.0f)</code> is a 4D vector with <code>X</code>=0, <code>Y</code>=42.0, <code>Z</code>=0, <code>W</code>=1.</p>
</div>
</div>
<div class="sect3">
<h4 id="mat_access">Matrices</h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_access.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_quat&lt;Q&gt;::value

  template &lt;int R,int C,class M&gt; -unspecified-return-type- A( M &amp; m );

  template &lt;class M&gt; -unspecified-return-type- A00( M &amp; m );
  template &lt;class M&gt; -unspecified-return-type- A01( M &amp; m );
  ...
  template &lt;class M&gt; -unspecified-return-type- A09( M &amp; m );
  template &lt;class M&gt; -unspecified-return-type- A10( M &amp; m );
  ...
  template &lt;class M&gt; -unspecified-return-type- A99( M &amp; m );

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>An expression of the form <code>A&lt;R,C&gt;(m)</code> can be used to access the element at row <code>R</code> and column <code>C</code> of a matrix object <code>m</code>. For example, the expression:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">A&lt;4,2&gt;(m) *= 42;</code></pre>
</div>
</div>
<div class="paragraph">
<p>can be used to multiply the element at row 4 and column 2 of a matrix <code>m</code> by 42.</p>
</div>
<div class="paragraph">
<p>For convenience, there are also non-template overloads for <code>R</code> from <code>0</code> to <code>9</code> and <code>C</code> from <code>0</code> to <code>9</code>; an alternative way to write the above expression is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">A42(m) *= 42;</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The return types are lvalues.
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_quaternion_operations">Quaternion Operations</h3>
<div class="sect3">
<h4 id="quat_assign"><code>assign</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_quat&lt;A&gt;::value &amp;&amp; is_quat&lt;B&gt;::value
  template &lt;class A,class B&gt;
  A &amp; assign( A &amp; a, B const &amp; b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Copies all elements of the quaternion <code>b</code> to the quaternion <code>a</code>.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>a</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="quat_convert_to"><code>convert_to</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_quat&lt;R&gt;::value &amp;&amp; is_quat&lt;A&gt;::value
  template &lt;class R,class A&gt;
  R convert_to( A const &amp; a );

  //Only enabled if:
  //  is_quat&lt;R&gt;::value &amp;&amp; is_mat&lt;A&gt;::value &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==3 &amp;&amp; mat_traits&lt;A&gt;::cols==3
  template &lt;class R,class A&gt;
  R convert_to( A const &amp; m );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements: </dt>
<dd>
<p><code>R</code> must be copyable.</p>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>The first overload is equivalent to: <code>R r; assign(r,a); return r;</code></p>
</li>
<li>
<p>The second overload assumes that <code>m</code> is an orthonormal rotation matrix and converts it to a quaternion that performs the same rotation.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="quat_minus_eq"><code>operator-=</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_quat&lt;A&gt;::value &amp;&amp; is_quat&lt;B&gt;::value
  template &lt;class A,class B&gt;
  A &amp; operator-=( A &amp; a, B const &amp; b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Subtracts the elements of <code>b</code> from the corresponding elements of <code>a</code>.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>a</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="quat_minus_unary"><code>operator-</code> (unary)</h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

   //Only enabled if: is_quat&lt;A&gt;::value
  template &lt;class A&gt;
  typename deduce_quat&lt;A&gt;::type
  operator-( A const &amp; a );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A quaternion of the negated elements of <code>a</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <a href="#deduce_quat"><code>deduce_quat</code></a> template can be specialized to deduce the desired return type from the type <code>A</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="quat_minus"><code>operator-</code> (binary)</h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_quat&lt;A&gt;::value &amp;&amp; is_quat&lt;B&gt;::value
  template &lt;class A,class B&gt;
  typename deduce_quat2&lt;A,B&gt;::type
  operator-( A const &amp; a, B const &amp; b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A quaternion with elements equal to the elements of <code>b</code> subtracted from the corresponding elements of <code>a</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <a href="#deduce_quat2"><code>deduce_quat2</code></a> template can be specialized to deduce the desired return type, given the types <code>A</code> and <code>B</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="quat_plus_eq"><code>operator+=</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_quat&lt;A&gt;::value &amp;&amp; is_quat&lt;B&gt;::value
  template &lt;class A,class B&gt;
  A &amp; operator+=( A &amp; a, B const &amp; b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Adds the elements of <code>b</code> to the corresponding elements of <code>a</code>.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>a</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="quat_plus"><code>operator+</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_quat&lt;A&gt;::value &amp;&amp; is_quat&lt;B&gt;::value &amp;&amp;
  template &lt;class A,class B&gt;
  typename deduce_quat2&lt;A,B&gt;::type
  operator+( A const &amp; a, B const &amp; b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A quaternion with elements equal to the elements of <code>a</code> added to the corresponding elements of <code>b</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <a href="#deduce_quat2"><code>deduce_quat2</code></a> template can be specialized to deduce the desired return type, given the types <code>A</code> and <code>B</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="quat_div_eq_scalar"><code>operator/=</code> (scalar)</h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if: is_quat&lt;A&gt;::value &amp;&amp; is_scalar&lt;B&gt;::value
  template &lt;class A,class B&gt;
  A &amp; operator/=( A &amp; a, B b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>This operation divides a quaternion by a scalar.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>a</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="quat_div_scalar"><code>operator/</code> (scalar)</h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if: is_quat&lt;A&gt;::value &amp;&amp; is_scalar&lt;B&gt;::value
  template &lt;class A,class B&gt;
  typename deduce_quat&lt;A&gt;::type
  operator/( A const &amp; a, B b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A quaternion that is the result of dividing the quaternion <code>a</code> by the scalar <code>b</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <a href="#deduce_quat"><code>deduce_quat</code></a> template can be specialized to deduce the desired return type from the type <code>A</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="quat_mul_eq_scalar"><code>operator*=</code> (scalar)</h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if: is_quat&lt;A&gt;::value &amp;&amp; is_scalar&lt;B&gt;::value
  template &lt;class A,class B&gt;
  A &amp; operator*=( A &amp; a, B b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>This operation multiplies the quaternion <code>a</code> by the scalar <code>b</code>.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>a</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="quat_mul_eq"><code>operator*=</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_quat&lt;A&gt;::value &amp;&amp; is_quat&lt;B&gt;::value
  template &lt;class A,class B&gt;
  A &amp; operator*=( A &amp; a, B const &amp; b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>As if:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">A tmp(a);
a = tmp * b;
return a;</code></pre>
</div>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="quat_mul_scalar"><code>operator*</code> (scalar)</h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if: is_quat&lt;A&gt;::value &amp;&amp; is_scalar&lt;B&gt;::value
  template &lt;class A,class B&gt;
  typename deduce_quat&lt;A&gt;::type
  operator*( A const &amp; a, B b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A quaternion that is the result of multiplying the quaternion <code>a</code> by the scalar <code>b</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <a href="#deduce_quat"><code>deduce_quat</code></a> template can be specialized to deduce the desired return type from the type <code>A</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="quat_mul"><code>operator*</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_quat&lt;A&gt;::value &amp;&amp; is_quat&lt;B&gt;::value
  template &lt;class A,class B&gt;
  typename deduce_quat2&lt;A,B&gt;::type
  operator*( A const &amp; a, B const &amp; b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The result of multiplying the quaternions <code>a</code> and <code>b</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <a href="#deduce_quat2"><code>deduce_quat2</code></a> template can be specialized to deduce the desired return type, given the types <code>A</code> and <code>B</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="quat_eq"><code>operator==</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_quat&lt;A&gt;::value &amp;&amp; is_quat&lt;B&gt;::value
  template &lt;class A,class B&gt;
  bool operator==( A const &amp; a, B const &amp; b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>true</code> if each element of <code>a</code> compares equal to its corresponding element of <code>b</code>, <code>false</code> otherwise.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="quat_neq"><code>operator!=</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_quat&lt;A&gt;::value &amp;&amp; is_quat&lt;B&gt;::value
  template &lt;class A,class B&gt;
  bool operator!=( A const &amp; a, B const &amp; b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>!(a == b)</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="quat_cmp"><code>cmp</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_quat&lt;A&gt;::value &amp;&amp; is_quat&lt;B&gt;::value
  template &lt;class A,class B,class Cmp&gt;
  bool cmp( A const &amp; a, B const &amp; b, Cmp pred );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>Similar to <a href="#quat_eq"><code>operator==</code></a>, except that it uses the binary predicate <code>pred</code> to compare the individual quaternion elements.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="quat_mag_sqr"><code>mag_sqr</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if: is_quat&lt;A&gt;::value
  template &lt;class A&gt;
  typename quat_traits&lt;A&gt;::scalar_type
  mag_sqr( A const &amp; a );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The squared magnitude of the quaternion <code>a</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="quat_mag"><code>mag</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if: is_quat&lt;A&gt;::value
  template &lt;class A&gt;
  typename quat_traits&lt;A&gt;::scalar_type
  mag( A const &amp; a );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The magnitude of the quaternion <code>a</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="quat_normalized"><code>normalized</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if: is_quat&lt;A&gt;::value
  template &lt;class A&gt;
  typename deduce_quat&lt;A&gt;::type
  normalized( A const &amp; a );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>As if:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">typename deduce_quat&lt;A&gt;::type tmp;
assign(tmp,a);
normalize(tmp);
return tmp;</code></pre>
</div>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <a href="#deduce_quat"><code>deduce_quat</code></a> template can be specialized to deduce the desired return type from the type <code>A</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="quat_normalize"><code>normalize</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if: is_quat&lt;A&gt;::value
  template &lt;class A&gt;
  void normalize( A &amp; a );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Normalizes <code>a</code>.</p>
</dd>
<dt class="hdlist1">Postcondition: </dt>
<dd>
<p><code>mag(a)==scalar_traits&lt;typename quat_traits&lt;A&gt;::scalar_type&gt;::value(1).</code></p>
</dd>
<dt class="hdlist1">Throws: </dt>
<dd>
<p>If the magnitude of <code>a</code> is zero, throws <a href="#zero_magnitude_error"><code>zero_magnitude_error</code></a>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="quat_dot"><code>dot</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_quat&lt;A&gt;::value &amp;&amp; is_quat&lt;B&gt;::value
  template &lt;class A,class B&gt;
  typename deduce_scalar&lt;A,B&gt;::type
  dot( A const &amp; a, B const &amp; b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The dot product of the quaternions <code>a</code> and <code>b</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <a href="#deduce_scalar"><code>deduce_scalar</code></a> template can be specialized to deduce the desired return type, given the types <code>A</code> and <code>B</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="conjugate"><code>conjugate</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if: is_quat&lt;A&gt;::value
  template &lt;class A&gt;
  typename deduce_quat&lt;A&gt;::type
  conjugate( A const &amp; a );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>Computes the conjugate of <code>a</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <a href="#deduce_quat"><code>deduce_quat</code></a> template can be specialized to deduce the desired return type from the type <code>A</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="quat_inverse"><code>inverse</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if: is_quat&lt;A&gt;::value
  template &lt;class A&gt;
  typename deduce_quat&lt;A&gt;::type
  inverse( A const &amp; a );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>Computes the multiplicative inverse of <code>a</code>, or the conjugate-to-norm ratio.</p>
</dd>
<dt class="hdlist1">Throws: </dt>
<dd>
<p>If the magnitude of <code>a</code> is zero, throws <a href="#zero_magnitude_error"><code>zero_magnitude_error</code></a>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If <code>a</code> is known to be unit length, <code>conjugate</code> is equivalent to <a href="#quat_inverse"><code>inverse</code></a>, yet it is faster to compute.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <a href="#deduce_quat"><code>deduce_quat</code></a> template can be specialized to deduce the desired return type from the type <code>A</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="slerp"><code>slerp</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_quat&lt;A&gt;::value &amp;&amp; is_quat&lt;B&gt;::value &amp;&amp; is_scalar&lt;C&gt;
  template &lt;class A,class B,class C&gt;
  typename deduce_quat2&lt;A,B&gt; &gt;::type
  slerp( A const &amp; a, B const &amp; b, C c );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Preconditions: </dt>
<dd>
<p><code>t&gt;=0 &amp;&amp; t&lt;=1</code>.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A quaternion that is the result of Spherical Linear Interpolation of the quaternions <code>a</code> and <code>b</code> and the interpolation parameter <code>c</code>. When <code>slerp</code> is applied to unit quaternions, the quaternion path maps to a path through 3D rotations in a standard way. The effect is a rotation with uniform angular velocity around a fixed rotation axis.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <a href="#deduce_quat2"><code>deduce_quat2</code></a> template can be specialized to deduce the desired return type, given the types <code>A</code> and <code>B</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="zero_quat"><code>zero_quat</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;class T&gt;
  -unspecified-return-type- zero_quat();

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A read-only quaternion of unspecified type with <a href="#scalar_traits"><code>scalar_type</code></a> <code>T</code>, with all elements equal to <a href="#scalar_traits"><code>scalar_traits&lt;T&gt;::value(0)</code></a>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="quat_set_zero"><code>set_zero</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if: is_quat&lt;A&gt;::value
  template &lt;class A&gt;
  void set_zero( A &amp; a );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>As if:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">assign(a,
  zero_quat&lt;typename quat_traits&lt;A&gt;::scalar_type&gt;());</code></pre>
</div>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="identity_quat"><code>identity_quat</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;class S&gt;
  -unspecified-return-type- identity_quat();

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>An identity quaternion with scalar type <code>S</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="quat_set_identity"><code>set_identity</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if: is_quat&lt;A&gt;::value
  template &lt;class A&gt;
  void set_identity( A &amp; a );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>As if:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">assign(
  a,
  identity_quat&lt;typename quat_traits&lt;A&gt;::scalar_type&gt;());</code></pre>
</div>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="rot_quat"><code>rot_quat</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_vec&lt;A&gt;::value &amp;&amp; vec_traits&lt;A&gt;::dim==3
  template &lt;class A&gt;
  -unspecified-return-type- rot_quat( A const &amp; axis, typename vec_traits&lt;A&gt;::scalar_type angle );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A quaternion of unspecified type which performs a rotation around the <code>axis</code> at <code>angle</code> radians.</p>
</dd>
<dt class="hdlist1">Throws: </dt>
<dd>
<p>In case the axis vector has zero magnitude, throws <a href="#zero_magnitude_error"><code>zero_magnitude_error</code></a>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>rot_quat</code> function is not a <a href="#view_proxy">view proxy</a>; it returns a temp object.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="quat_set_rot"><code>set_rot</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_quat&lt;A&gt;::value &amp;&amp;
  //  is_vec&lt;B&gt;::value &amp;&amp; vec_traits&lt;B&gt;::dim==3
  template &lt;class A&gt;
  void set_rot( A &amp; a, B const &amp; axis, typename vec_traits&lt;B&gt;::scalar_type angle );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>As if:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">assign(
  a,
  rot_quat(axis,angle));</code></pre>
</div>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="quat_rotate"><code>rotate</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_quat&lt;A&gt;::value &amp;&amp;
  //  is_vec&lt;B&gt;::value &amp;&amp; vec_traits&lt;B&gt;::dim==3
  template &lt;class A,class B&gt;
  void rotate( A &amp; a, B const &amp; axis, typename quat_traits&lt;A&gt;::scalar_type angle );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>As if: <code>a *= <a href="#rot_quat">rot_quat</a>(axis,angle)</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="rotx_quat"><code>rotx_quat</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;class Angle&gt;
  -unspecified-return-type- rotx_quat( Angle const &amp; angle );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A <a href="#view_proxy">view proxy</a> quaternion of unspecified type and scalar type <code>Angle</code>, which performs a rotation around the X axis at <code>angle</code> radians.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="quat_set_rotx"><code>set_rotx</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if: is_quat&lt;A&gt;::value
  template &lt;class A&gt;
  void set_rotx( A &amp; a, typename quat_traits&lt;A&gt;::scalar_type angle );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>As if:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">assign(
  a,
  rotx_quat(angle));</code></pre>
</div>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="quat_rotate_x"><code>rotate_x</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if: is_quat&lt;A&gt;::value
  template &lt;class A&gt;
  void rotate_x( A &amp; a, typename quat_traits&lt;A&gt;::scalar_type angle );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>As if: <code>a *= <a href="#rotx_quat">rotx_quat</a>(angle)</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="roty_quat"><code>roty_quat</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;class Angle&gt;
  -unspecified-return-type- roty_quat( Angle const &amp; angle );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A <a href="#view_proxy">view proxy</a> quaternion of unspecified type and scalar type <code>Angle</code>, which performs a rotation around the Y axis at <code>angle</code> radians.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="quat_set_roty"><code>set_roty</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if: is_quat&lt;A&gt;::value
  template &lt;class A&gt;
  void set_rotz( A &amp; a, typename quat_traits&lt;A&gt;::scalar_type angle );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>As if:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">assign(
  a,
  roty_quat(angle));</code></pre>
</div>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="quat_rotate_y"><code>rotate_y</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if: is_quat&lt;A&gt;::value
  template &lt;class A&gt;
  void rotate_y( A &amp; a, typename quat_traits&lt;A&gt;::scalar_type angle );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>As if: <code>a *= <a href="#roty_quat">roty_quat</a>(angle)</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="rotz_quat"><code>rotz_quat</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

    template &lt;class Angle&gt;
    -unspecified-return-type- rotz_quat( Angle const &amp; angle );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A <a href="#view_proxy">view proxy</a> quaternion of unspecified type and scalar type <code>Angle</code>, which performs a rotation around the Z axis at <code>angle</code> radians.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="quat_set_rotz"><code>set_rotz</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if: is_quat&lt;A&gt;::value
  template &lt;class A&gt;
  void set_rotz( A &amp; a, typename quat_traits&lt;A&gt;::scalar_type angle );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>As if:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">assign(
  a,
  rotz_quat(angle));</code></pre>
</div>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="quat_rotate_z"><code>rotate_z</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if: is_quat&lt;A&gt;::value
  template &lt;class A&gt;
  void rotate_z( A &amp; a, typename quat_traits&lt;A&gt;::scalar_type angle );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>As if: <code>a *= <a href="#rotz_quat">rotz_quat</a>(angle)</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="quat_scalar_cast"><code>scalar_cast</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if: is_quat&lt;A&gt;::value
  template &lt;class Scalar,class A&gt;
  -unspecified-return_type- scalar_cast( A const &amp; a );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A read-only <a href="#view_proxy">view proxy</a> of <code>a</code> that looks like a quaternion of the same dimensions as <code>a</code>, but with <a href="#quat_traits"><code>scalar_type</code></a> <code>Scalar</code> and elements constructed from the corresponding elements of <code>a</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="qref"><code>qref</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if: is_quat&lt;A&gt;::value
  template &lt;class A&gt;
  -unspecified-return-type- qref( A &amp; a );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>An identity view proxy of <code>a</code>; that is, it simply accesses the elements of <code>a</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>qref</code> allows calling QVM operations when <code>a</code> is of built-in type, for example a plain old C array.
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_vector_operations">Vector Operations</h3>
<div class="sect3">
<h4 id="vec_assign"><code>assign</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/vec_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

    //Only enabled if:
    //  is_vec&lt;A&gt;::value &amp;&amp; is_vec&lt;B&gt;::value &amp;&amp;
    //  vec_traits&lt;A&gt;::dim==vec_traits&lt;B&gt;::dim
    template &lt;class A,class B&gt;
    A &amp; assign( A &amp; a, B const &amp; b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Copies all elements of the vector <code>b</code> to the vector <code>a</code>.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>a</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="vec_convert_to"><code>convert_to</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/vec_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

    //Only enabled if:
    //  is_vec&lt;R&gt;::value &amp;&amp; is_vec&lt;A&gt;::value &amp;&amp;
    //  vec_traits&lt;R&gt;::dim==vec_traits&lt;A&gt;::dim
    template &lt;class R,class A&gt;
    R convert_to( A const &amp; a );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements: </dt>
<dd>
<p><code>R</code> must be copyable.</p>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>As if: <code>R r; assign(r,a); return r;</code></p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="vec_minus_eq"><code>operator-=</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/vec_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

    //Only enabled if:
    //  is_vec&lt;A&gt;::value &amp;&amp; is_vec&lt;B&gt;::value &amp;&amp;
    //  vec_traits&lt;A&gt;::dim==vec_traits&lt;B&gt;::dim
    template &lt;class A,class B&gt;
    A &amp; operator-=( A &amp; a, B const &amp; b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Subtracts the elements of <code>b</code> from the corresponding elements of <code>a</code>.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>a</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="vec_minus_unary"><code>operator-</code> (unary)</h4>
<div class="paragraph">
<p>operator-(vec)</p>
</div>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/vec_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

    //Only enabled if: is_vec&lt;A&gt;::value
    template &lt;class A&gt;
    typename deduce_vec&lt;A&gt;::type
    operator-( A const &amp; a );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A vector of the negated elements of <code>a</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <a href="#deduce_vec"><code>deduce_vec</code></a> template can be specialized to deduce the desired return type from the type <code>A</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="vec_minus"><code>operator-</code> (binary)</h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/vec_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

    //Only enabled if:
    //  is_vec&lt;A&gt;::value &amp;&amp; is_vec&lt;B&gt;::value &amp;&amp;
    //  vec_traits&lt;A&gt;::dim==vec_traits&lt;B&gt;::dim
    template &lt;class A,class B&gt;
    typename deduce_vec2&lt;A,B,vec_traits&lt;A&gt;::dim&gt;::type
    operator-( A const &amp; a, B const &amp; b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A vector of the same size as <code>a</code> and <code>b</code>, with elements the elements of <code>b</code> subtracted from the corresponding elements of <code>a</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <a href="#deduce_vec2"><code>deduce_vec2</code></a> template can be specialized to deduce the desired return type, given the types <code>A</code> and <code>B</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="vec_plus_eq"><code>operator+=</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/vec_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

    //Only enabled if:
    //  is_vec&lt;A&gt;::value &amp;&amp; is_vec&lt;B&gt;::value &amp;&amp;
    //  vec_traits&lt;A&gt;::dim==vec_traits&lt;B&gt;::dim
    template &lt;class A,class B&gt;
    A &amp; operator+=( A &amp; a, B const &amp; b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Adds the elements of <code>b</code> to the corresponding elements of <code>a</code>.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>a</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="vec_plus"><code>operator+</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/vec_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

    //Only enabled if:
    //  is_vec&lt;A&gt;::value &amp;&amp; is_vec&lt;B&gt;::value &amp;&amp;
    //  vec_traits&lt;A&gt;::dim==vec_traits&lt;B&gt;::dim
    template &lt;class A,class B&gt;
    typename deduce_vec2&lt;A,B,vec_traits&lt;A&gt;::dim&gt;::type
    operator+( A const &amp; a, B const &amp; b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A vector of the same size as <code>a</code> and <code>b</code>, with elements the elements of <code>b</code> added to the corresponding elements of <code>a</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <a href="#deduce_vec2"><code>deduce_vec2</code></a> template can be specialized to deduce the desired return type, given the types <code>A</code> and <code>B</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="vec_div_eq_scalar"><code>operator/=</code> (scalar)</h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/vec_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

    //Only enabled if: is_vec&lt;A&gt;::value &amp;&amp; is_scalar&lt;B&gt;::value
    template &lt;class A,class B&gt;
    A &amp; operator/=( A &amp; a, B b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>This operation divides a vector by a scalar.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>a</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="vec_div_scalar"><code>operator/</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/vec_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

    //Only enabled if: is_vec&lt;A&gt;::value &amp;&amp; is_scalar&lt;B&gt;::value
    template &lt;class A,class B&gt;
    typename deduce_vec&lt;A&gt;::type
    operator/( A const &amp; a, B b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A vector that is the result of dividing the vector <code>a</code> by the scalar <code>b</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <a href="#deduce_vec"><code>deduce_vec</code></a> template can be specialized to deduce the desired return type from the type <code>A</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="vec_mul_eq_scalar"><code>operator*=</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/vec_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

    //Only enabled if: is_vec&lt;A&gt;::value &amp;&amp; is_scalar&lt;B&gt;::value
    template &lt;class A,class B&gt;
    A &amp; operator*=( A &amp; a, B b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>This operation multiplies the vector <code>a</code> by the scalar <code>b</code>.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>a</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="vec_mul_scalar"><code>operator*</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/vec_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

    //Only enabled if: is_vec&lt;A&gt;::value &amp;&amp; is_scalar&lt;B&gt;::value
    template &lt;class A&gt;
    typename deduce_vec&lt;A&gt;::type
    operator*( A const &amp; a, B b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A vector that is the result of multiplying the vector <code>a</code> by the scalar <code>b</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <a href="#deduce_vec"><code>deduce_vec</code></a> template can be specialized to deduce the desired return type from the type <code>A</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="vec_eq"><code>operator==</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/vec_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

    //Only enabled if:
    //  is_vec&lt;A&gt;::value &amp;&amp; is_vec&lt;B&gt;::value &amp;&amp;
    //  vec_traits&lt;A&gt;::dim==vec_traits&lt;B&gt;::dim
    template &lt;class A,class B&gt;
    bool operator==( A const &amp; a, B const &amp; b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>true</code> if each element of <code>a</code> compares equal to its corresponding element of <code>b</code>, <code>false</code> otherwise.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="vec_neq"><code>operator!=</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/vec_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

    //Only enabled if:
    //  is_vec&lt;A&gt;::value &amp;&amp; is_vec&lt;B&gt;::value &amp;&amp;
    //  vec_traits&lt;A&gt;::dim==vec_traits&lt;B&gt;::dim
    template &lt;class A,class B&gt;
    bool operator!=( A const &amp; a, B const &amp; b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>!(a == b)</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="vec_cmp"><code>cmp</code></h4>
<div class="listingblock">
<div class="content">
<pre class="nowrap">.#include &lt;boost/qvm/mat_operations.hpp&gt;

namespace boost
{
  namespace qvm
  {
    //Only enabled if:
    //  is_mat&lt;A&gt;::value &amp;&amp; is_mat&lt;B&gt;::value &amp;&amp;
    //  mat_traits&lt;A&gt;::rows==mat_traits&lt;B&gt;::rows &amp;&amp;
    //  mat_traits&lt;A&gt;::cols==mat_traits&lt;B&gt;::cols
    template &lt;class A,class B,class Cmp&gt;
    bool cmp( A const &amp; a, B const &amp; b, Cmp pred );

} }</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>Similar to <a href="#vec_eq"><code>operator==</code></a>, except that the individual elements of <code>a</code> and <code>b</code> are passed to the binary predicate <code>pred</code> for comparison.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="vec_mag_sqr"><code>mag_sqr</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/vec_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

    //Only enabled if:
    //  is_vec&lt;A&gt;::value
    template &lt;class A&gt;
    typename vec_traits&lt;A&gt;::scalar_type
    mag_sqr( A const &amp; a );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The squared magnitude of the vector <code>a</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="vec_mag"><code>mag</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/vec_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

    //Only enabled if:
    //  is_vec&lt;A&gt;::value
    template &lt;class A&gt;
    typename vec_traits&lt;A&gt;::scalar_type
    mag( A const &amp; a );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The magnitude of the vector <code>a</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="vec_normalized"><code>normalized</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/vec_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

    //Only enabled if:
    //  is_vec&lt;A&gt;::value
    template &lt;class A&gt;
    typename deduce_vec&lt;A&gt;::type
    normalized( A const &amp; a );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>As if:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">typename deduce_vec&lt;A&gt;::type tmp;
assign(tmp,a);
normalize(tmp);
return tmp;</code></pre>
</div>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <a href="#deduce_vec"><code>deduce_vec</code></a> template can be specialized to deduce the desired return type from the type <code>A</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="vec_normalize"><code>normalize</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/vec_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

    //Only enabled if:
    //  is_vec&lt;A&gt;::value
    template &lt;class A&gt;
    void normalize( A &amp; a );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Normalizes <code>a</code>.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Postcondition:</p>
</div>
<div class="paragraph">
<p><code>mag(a)==<a href="#scalar_traits">scalar_traits</a>&lt;typename <a href="#vec_traits">vec_traits&lt;A&gt;::scalar_type</a>&gt;::value(1)</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Throws: </dt>
<dd>
<p>If the magnitude of <code>a</code> is zero, throws <a href="#zero_magnitude_error"><code>zero_magnitude_error</code></a>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="vec_dot"><code>dot</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/vec_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

    //Only enabled if:
    //  is_vec&lt;A&gt;::value &amp;&amp; is_vec&lt;B&gt;::value &amp;&amp;
    //  vec_traits&lt;A&gt;::dim==vec_traits&lt;B&gt;::dim
    template &lt;class A,class B&gt;
    typename deduce_scalar&lt;A,B&gt;::type
    dot( A const &amp; a, B const &amp; b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The dot product of the vectors <code>a</code> and <code>b</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <a href="#deduce_scalar"><code>deduce_scalar</code></a> template can be specialized to deduce the desired return type, given the types <code>A</code> and <code>B</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="vec_cross"><code>cross</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/vec_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

    //Only enabled if:
    //  is_vec&lt;A&gt;::value &amp;&amp; is_vec&lt;B&gt;::value &amp;&amp;
    //  vec_traits&lt;A&gt;::dim==3 &amp;&amp; vec_traits&lt;B&gt;::dim==3
    template &lt;class A,class B&gt;
    typename deduce_vec2&lt;A,B,3&gt;::type
    cross( A const &amp; a, B const &amp; b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The cross product of the vectors <code>a</code> and <code>b</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <a href="#deduce_vec2"><code>deduce_vec2</code></a> template can be specialized to deduce the desired return type, given the types <code>A</code> and <code>B</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="zero_vec"><code>zero_vec</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/vec_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

    template &lt;class T,int S&gt;
    -unspecified-return-type- zero_vec();

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A read-only vector of unspecified type with <a href="#vec_traits"><code>scalar_type</code></a> <code>T</code> and size <code>S</code>, with all elements equal to <a href="#scalar_traits"><code>scalar_traits&lt;T&gt;::value(0)</code></a>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="vec_set_zero"><code>set_zero</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/vec_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

    //Only enabled if:
    //  is_vec&lt;A&gt;::value
    template &lt;class A&gt;
    void set_zero( A &amp; a );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>As if:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">assign(a,
  zero_vec&lt;
    typename vec_traits&lt;A&gt;::scalar_type,
    vec_traits&lt;A&gt;::dim&gt;());</code></pre>
</div>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="vec_scalar_cast"><code>scalar_cast</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/vec_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

    //Only enabled if: is_vec&lt;A&gt;::value
    template &lt;class Scalar,class A&gt;
    -unspecified-return_type- scalar_cast( A const &amp; a );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A read-only <a href="#view_proxy">view proxy</a> of <code>a</code> that looks like a vector of the same dimensions as <code>a</code>, but with <a href="#vec_traits"><code>scalar_type</code></a> <code>Scalar</code> and elements constructed from the corresponding elements of <code>a</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="vref"><code>vref</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/vec_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

    //Only enabled if: is_vec&lt;A&gt;::value
    template &lt;class A&gt;
    -unspecified-return-type- vref( A &amp; a );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>An identity <a href="#view_proxy">view proxy</a> of <code>a</code>; that is, it simply accesses the elements of <code>a</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>vref</code> allows calling QVM operations when <code>a</code> is of built-in type, for example a plain old C array.
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_matrix_operations">Matrix Operations</h3>
<div class="sect3">
<h4 id="mat_assign"><code>assign</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; is_mat&lt;B&gt;::value &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;B&gt;::rows &amp;&amp;
  //  mat_traits&lt;A&gt;::cols==mat_traits&lt;B&gt;::cols
  template &lt;class A,class B&gt;
  A &amp; assign( A &amp; a, B const &amp; b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Copies all elements of the matrix <code>b</code> to the matrix <code>a</code>.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>a</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="mat_convert_to"><code>convert_to</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_mat&lt;R&gt;::value &amp;&amp; is_mat&lt;A&gt;::value &amp;&amp;
  //  mat_traits&lt;R&gt;::rows==mat_traits&lt;A&gt;::rows &amp;&amp;
  //  mat_traits&lt;R&gt;::cols==mat_traits&lt;A&gt;::cols
  template &lt;class R,class A&gt;
  R convert_to( A const &amp; a );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements: </dt>
<dd>
<p><code>R</code> must be copyable.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Effects:</p>
</div>
<div class="paragraph">
<p>As if: <code>R r; <a href="#mat_assign">assign</a>(r,a); return r;</code></p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="mat_minus_eq_scalar"><code>operator-=</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; is_mat&lt;B&gt;::value &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;B&gt;::rows &amp;&amp;
  //  mat_traits&lt;A&gt;::cols==mat_traits&lt;B&gt;::cols
  template &lt;class A,class B&gt;
  A &amp; operator-=( A &amp; a, B const &amp; b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Subtracts the elements of <code>b</code> from the corresponding elements of <code>a</code>.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>a</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="mat_minus_unary"><code>operator-</code> (unary)</h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if: is_mat&lt;A&gt;::value
  template &lt;class A&gt;
  typename deduce_mat&lt;A&gt;::type
  operator-( A const &amp; a );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A matrix of the negated elements of <code>a</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <a href="#deduce_mat"><code>deduce_mat</code></a> template can be specialized to deduce the desired return type from the type <code>A</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="mat_minus"><code>operator-</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; is_mat&lt;B&gt;::value &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;B&gt;::rows &amp;&amp;
  //  mat_traits&lt;A&gt;::cols==mat_traits&lt;B&gt;::cols
  template &lt;class A,class B&gt;
  typename deduce_mat2&lt;A,B,mat_traits&lt;A&gt;::rows,mat_traits&lt;A&gt;::cols&gt;::type
  operator-( A const &amp; a, B const &amp; b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A matrix of the same size as <code>a</code> and <code>b</code>, with elements the elements of <code>b</code> subtracted from the corresponding elements of <code>a</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <a href="#deduce_mat2"><code>deduce_mat2</code></a> template can be specialized to deduce the desired return type, given the types <code>A</code> and <code>B</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="mat_plus_eq_scalar"><code>operator+=</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; is_mat&lt;B&gt;::value &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;B&gt;::rows &amp;&amp;
  //  mat_traits&lt;A&gt;::cols==mat_traits&lt;B&gt;::cols
  template &lt;class A,class B&gt;
  A &amp; operator+=( A &amp; a, B const &amp; b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Adds the elements of <code>b</code> to the corresponding elements of <code>a</code>.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>a</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="mat_plus"><code>operator+</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; is_mat&lt;B&gt;::value &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;B&gt;::rows &amp;&amp;
  //  mat_traits&lt;A&gt;::cols==mat_traits&lt;B&gt;::cols
  template &lt;class A,class B&gt;
  typename deduce_mat2&lt;A,B,mat_traits&lt;A&gt;::rows,mat_traits&lt;A&gt;::cols&gt;::type
  operator+( A const &amp; a, B const &amp; b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A matrix of the same size as <code>a</code> and <code>b</code>, with elements the elements of <code>b</code> added to the corresponding elements of <code>a</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <a href="#deduce_mat2"><code>deduce_mat2</code></a> template can be specialized to deduce the desired return type, given the types <code>A</code> and <code>B</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="mat_div_eq_scalar"><code>operator/=</code> (scalar)</h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if: is_mat&lt;A&gt;::value &amp;&amp; is_scalar&lt;B&gt;::value
  template &lt;class A,class B&gt;
  A &amp; operator/=( A &amp; a, B b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>This operation divides a matrix by a scalar.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>a</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="mat_div_scalar"><code>operator/</code> (scalar)</h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if: is_mat&lt;A&gt;::value &amp;&amp; is_scalar&lt;B&gt;::value
  template &lt;class A,class B&gt;
  typename deduce_mat&lt;A&gt;::type
  operator/( A const &amp; a, B b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A matrix that is the result of dividing the matrix <code>a</code> by the scalar <code>b</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <a href="#deduce_mat"><code>deduce_mat</code></a> template can be specialized to deduce the desired return type from the type <code>A</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="mat_mul_eq"><code>operator*=</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; is_mat&lt;B&gt;::value &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;B&gt;::rows &amp;&amp;
  //  mat_traits&lt;A&gt;::cols==mat_traits&lt;B&gt;::cols
  template &lt;class A,class B&gt;
  A &amp; operator*=( A &amp; a, B const &amp; b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>As if:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">A tmp(a);
a = tmp * b;
return a;</code></pre>
</div>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="mat_mul_eq_scalar"><code>operator*=</code> (scalar)</h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if: is_mat&lt;A&gt;::value &amp;&amp; is_scalar&lt;B&gt;::value
  template &lt;class A,class B&gt;
  A &amp; operator*=( A &amp; a, B b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>This operation multiplies the matrix <code>a</code> matrix by the scalar <code>b</code>.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>a</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="mat_mul"><code>operator*</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; is_mat&lt;B&gt;::value &amp;&amp;
  //  mat_traits&lt;A&gt;::cols==mat_traits&lt;B&gt;::rows
  template &lt;class A,class B&gt;
  typename deduce_mat2&lt;A,B,mat_traits&lt;A&gt;::rows,mat_traits&lt;B&gt;::cols&gt;::type
  operator*( A const &amp; a, B const &amp; b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The result of <a href="https://en.wikipedia.org/wiki/Matrix_multiplication">multiplying</a> the matrices <code>a</code> and <code>b</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <a href="#deduce_mat2"><code>deduce_mat2</code></a> template can be specialized to deduce the desired return type, given the types <code>A</code> and <code>B</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="mat_mul_scalar"><code>operator*</code> (scalar)</h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if: is_mat&lt;A&gt;::value &amp;&amp; is_scalar&lt;B&gt;::value
  template &lt;class A,class B&gt;
  typename deduce_mat&lt;A&gt;::type
  operator*( A const &amp; a, B b );

  //Only enabled if: is_scalar&lt;B&gt;::value &amp;&amp; is_mat&lt;A&gt;::value
  template &lt;class B,class A&gt;
  typename deduce_mat&lt;A&gt;::type
  operator*( B b, A const &amp; a );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A matrix that is the result of multiplying the matrix <code>a</code> by the scalar <code>b</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <a href="#deduce_mat"><code>deduce_mat</code></a> template can be specialized to deduce the desired return type from the type <code>A</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="mat_eq"><code>operator==</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; is_mat&lt;B&gt;::value &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;B&gt;::rows &amp;&amp;
  //  mat_traits&lt;A&gt;::cols==mat_traits&lt;B&gt;::cols
  template &lt;class A,class B&gt;
  bool operator==( A const &amp; a, B const &amp; b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>true</code> if each element of <code>a</code> compares equal to its corresponding element of <code>b</code>, <code>false</code> otherwise.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="mat_neq"><code>operator!=</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; is_mat&lt;B&gt;::value &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;B&gt;::rows &amp;&amp;
  //  mat_traits&lt;A&gt;::cols==mat_traits&lt;B&gt;::cols
  template &lt;class A,class B&gt;
  bool operator!=( A const &amp; a, B const &amp; b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>!( a <a href="#mat_eq">==</a> b )</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="mat_cmp"><code>cmp</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; is_mat&lt;B&gt;::value &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;B&gt;::rows &amp;&amp;
  //  mat_traits&lt;A&gt;::cols==mat_traits&lt;B&gt;::cols
  template &lt;class A,class B,class Cmp&gt;
  bool cmp( A const &amp; a, B const &amp; b, Cmp pred );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>Similar to <a href="#mat_eq"><code>operator==</code></a>, except that the individual elements of <code>a</code> and <code>b</code> are passed to the binary predicate <code>pred</code> for comparison.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="mat_inverse"><code>inverse</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; is_scalar&lt;B&gt;::value
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols

  template &lt;class A,class B&gt;
  typename deduce_mat&lt;A&gt;::type
  inverse( A const &amp; a, B det );

  template &lt;class A&gt;
  typename deduce_mat&lt;A&gt;::type
  inverse( A const &amp; a );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Preconditions: </dt>
<dd>
<p><code>det!=<a href="#scalar_traits">scalar_traits</a>&lt;typename <a href="#mat_traits">mat_traits&lt;A&gt;::scalar_type</a>&gt;::value(0)</code></p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>Both overloads compute the inverse of <code>a</code>. The first overload takes the pre-computed determinant of <code>a</code>.</p>
</dd>
<dt class="hdlist1">Throws: </dt>
<dd>
<p>The second overload computes the determinant automatically and throws <a href="#zero_determinant_error"><code>zero_determinant_error</code></a> if the computed determinant is zero.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <a href="#deduce_mat"><code>deduce_mat</code></a> template can be specialized to deduce the desired return type from the type <code>A</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="zero_mat"><code>zero_mat</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;class T,int D&gt;
  -unspecified-return-type- zero_mat();

  template &lt;class T,int R,int C&gt;
  -unspecified-return-type- zero_mat();

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A read-only matrix of unspecified type with <a href="#mat_traits"><code>scalar_type</code></a> <code>T</code>, <code>R</code> rows and <code>C</code> columns (or <code>D</code> rows and <code>D</code> columns), with all elements equal to <a href="#scalar_traits"><code>scalar_traits&lt;T&gt;::value(0)</code></a>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="mat_set_zero"><code>set_zero</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_mat&lt;A&gt;::value
  template &lt;class A&gt;
  void set_zero( A &amp; a );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>As if:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">assign(a,
  zero_mat&lt;
    typename mat_traits&lt;A&gt;::scalar_type,
    mat_traits&lt;A&gt;::rows,
    mat_traits&lt;A&gt;::cols&gt;());</code></pre>
</div>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="identity_mat"><code>identity_mat</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="nowrap">namespace boost { namespace qvm {

  template &lt;class S,int D&gt;
  -unspecified-return-type- identity_mat();

} }</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>An identity matrix of size <code>D</code> x <code>D</code> and scalar type <code>S</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="mat_set_identity"><code>set_identity</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp;
  //  mat_traits&lt;A&gt;::cols==mat_traits&lt;A&gt;::rows
  template &lt;class A&gt;
  void set_identity( A &amp; a );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>As if:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">assign(
  a,
  identity_mat&lt;
    typename mat_traits&lt;A&gt;::scalar_type,
    mat_traits&lt;A&gt;::rows,
    mat_traits&lt;A&gt;::cols&gt;());</code></pre>
</div>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="rot_mat"><code>rot_mat</code> / Euler angles</h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_vec&lt;A&gt;::value &amp;&amp; vec_traits&lt;A&gt;::dim==3
  template &lt;int Dim,class A,class Angle&gt;
  -unspecified-return-type-
  rot_mat( A const &amp; axis, Angle angle );

  template &lt;int Dim,class Angle&gt;
  -unspecified-return-type-
  rot_mat_xzy( Angle x1, Angle z2, Angle y3 );

  template &lt;int Dim,class Angle&gt;
  -unspecified-return-type-
  rot_mat_xyz( Angle x1, Angle y2, Angle z3 );

  template &lt;int Dim,class Angle&gt;
  -unspecified-return-type-
  rot_mat_yxz( Angle y1, Angle x2, Angle z3 );

  template &lt;int Dim,class Angle&gt;
  -unspecified-return-type-
  rot_mat_yzx( Angle y1, Angle z2, Angle x3 );

  template &lt;int Dim,class Angle&gt;
  -unspecified-return-type-
  rot_mat_zyx( Angle z1, Angle y2, Angle x3 );

  template &lt;int Dim,class Angle&gt;
  -unspecified-return-type-
  rot_mat_zxy( Angle z1, Angle x2, Angle y3 );

  template &lt;int Dim,class Angle&gt;
  -unspecified-return-type-
  rot_mat_xzx( Angle x1, Angle z2, Angle x3 );

  template &lt;int Dim,class Angle&gt;
  -unspecified-return-type-
  rot_mat_xyx( Angle x1, Angle y2, Angle x3 );

  template &lt;int Dim,class Angle&gt;
  -unspecified-return-type-
  rot_mat_yxy( Angle y1, Angle x2, Angle y3 );

  template &lt;int Dim,class Angle&gt;
  -unspecified-return-type-
  rot_mat_yzy( Angle y1, Angle z2, Angle y3 );

  template &lt;int Dim,class Angle&gt;
  -unspecified-return-type-
  rot_mat_zyz( Angle z1, Angle y2, Angle z3 );

  template &lt;int Dim,class Angle&gt;
  -unspecified-return-type-
  rot_mat_zxz( Angle z1, Angle y2, Angle z3 );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A matrix of unspecified type, of <code>Dim</code> rows and <code>Dim</code> columns parameter, which performs a rotation around the <code>axis</code> at <code>angle</code> radians, or Tait–Bryan angles (x-y-z, y-z-x, z-x-y, x-z-y, z-y-x, y-x-z), or proper Euler angles (z-x-z, x-y-x, y-z-y, z-y-z, x-z-x, y-x-y). See <a href="https://en.wikipedia.org/wiki/Euler_angles">Euler angles</a>.</p>
</dd>
<dt class="hdlist1">Throws: </dt>
<dd>
<p>In case the axis vector has zero magnitude, throws <a href="#zero_magnitude_error"><code>zero_magnitude_error</code></a>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
These functions are not view proxies; they return a temp object.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="mat_set_rot"><code>set_rot</code> / Euler angles</h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols &amp;&amp;
  //  is_vec&lt;B&gt;::value &amp;&amp; vec_traits&lt;B&gt;::dim==3
  template &lt;class A&gt;
  void set_rot( A &amp; a, B const &amp; axis, typename vec_traits&lt;B&gt;::scalar_type angle );

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
  template &lt;class A,class Angle&gt;
  void set_rot_xzy( A &amp; a, Angle x1, Angle z2, Angle y3 );

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
  template &lt;class A,class Angle&gt;
  void set_rot_xyz( A &amp; a, Angle x1, Angle y2, Angle z3 );

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
  template &lt;class A,class Angle&gt;
  void set_rot_yxz( A &amp; a, Angle y1, Angle x2, Angle z3 );

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
  template &lt;class A,class Angle&gt;
  void set_rot_yzx( A &amp; a, Angle y1, Angle z2, Angle x3 );

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
  template &lt;class A,class Angle&gt;
  void set_rot_zyx( A &amp; a, Angle z1, Angle y2, Angle x3 );

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
  template &lt;class A,class Angle&gt;
  void set_rot_zxy( A &amp; a, Angle z1, Angle x2, Angle y3 );

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
  template &lt;class A,class Angle&gt;
  void set_rot_xzx( A &amp; a, Angle x1, Angle z2, Angle x3 );

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
  template &lt;class A,class Angle&gt;
  void set_rot_xyx( A &amp; a, Angle x1, Angle y2, Angle x3 );

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
  template &lt;class A,class Angle&gt;
  void set_rot_yxy( A &amp; a, Angle y1, Angle x2, Angle y3 );

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
  template &lt;class A,class Angle&gt;
  void set_rot_yzy( A &amp; a, Angle y1, Angle z2, Angle y3 );

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
  template &lt;class A,class Angle&gt;
  void set_rot_zyz( A &amp; a, Angle z1, Angle y2, Angle z3 );

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
  template &lt;class A,class Angle&gt;
  void set_rot_zxz( A &amp; a, Angle z1, Angle x2, Angle z3 );

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
  template &lt;class A,class Angle&gt;
  void set_rot_xzy( A &amp; a, Angle x1, Angle z2, Angle y3 );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Assigns the return value of the corresponding <a href="#rot_mat"><code>rot_mat</code></a> function to <code>a</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="mat_rotate"><code>rotate</code> / Euler angles</h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols &amp;&amp;
  //  is_vec&lt;B&gt;::value &amp;&amp; vec_traits&lt;B&gt;::dim==3
  template &lt;class A,class B&gt;
  void rotate( A &amp; a, B const &amp; axis, typename mat_traits&lt;A&gt;::scalar_type angle );

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
  template &lt;class A,class Angle&gt;
  void rotate_xzy( A &amp; a, Angle x1, Angle z2, Angle y3 );

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
  template &lt;class A,class Angle&gt;
  void rotate_xyz( A &amp; a, Angle x1, Angle y2, Angle z3 );

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
  template &lt;class A,class Angle&gt;
  void rotate_yxz( A &amp; a, Angle y1, Angle x2, Angle z3 );

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
  template &lt;class A,class Angle&gt;
  void rotate_yzx( A &amp; a, Angle y1, Angle z2, Angle x3 );

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
  template &lt;class A,class Angle&gt;
  void rotate_zyx( A &amp; a, Angle z1, Angle y2, Angle x3 );

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
  template &lt;class A,class Angle&gt;
  void rotate_zxy( A &amp; a, Angle z1, Angle x2, Angle y3 );

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
  template &lt;class A,class Angle&gt;
  void rotate_xzx( A &amp; a, Angle x1, Angle z2, Angle x3 );

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
  template &lt;class A,class Angle&gt;
  void rotate_xyx( A &amp; a, Angle x1, Angle y2, Angle x3 );

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
  template &lt;class A,class Angle&gt;
  void rotate_yxy( A &amp; a, Angle y1, Angle x2, Angle y3 );

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
  template &lt;class A,class Angle&gt;
  void rotate_yzy( A &amp; a, Angle y1, Angle z2, Angle y3 );

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
  template &lt;class A,class Angle&gt;
  void rotate_zyz( A &amp; a, Angle z1, Angle y2, Angle z3 );

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
  template &lt;class A,class Angle&gt;
  void rotate_zxz( A &amp; a, Angle z1, Angle x2, Angle z3 );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Multiplies the matrix <code>a</code> in-place by the return value of the corresponding <a href="#rot_mat"><code>rot_mat</code></a> function.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="rotx_mat"><code>rotx_mat</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;int Dim,class Angle&gt;
  -unspecified-return-type- rotx_mat( Angle const &amp; angle );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A <a href="#view_proxy">view proxy</a> matrix of unspecified type, of <code>Dim</code> rows and <code>Dim</code> columns and scalar type <code>Angle</code>, which performs a rotation around the <code>X</code> axis at <code>angle</code> radians.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="mat_set_rotx"><code>set_rotx</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
  template &lt;class A&gt;
  void set_rotx( A &amp; a, typename mat_traits&lt;A&gt;::scalar_type angle );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>As if:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">assign(
  a,
  rotx_mat&lt;mat_traits&lt;A&gt;::rows&gt;(angle));</code></pre>
</div>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="mat_rotate_x"><code>rotate_x</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
  template &lt;class A&gt;
  void rotate_x( A &amp; a, typename mat_traits&lt;A&gt;::scalar_type angle );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>As if: <code>a <a href="#mat_mul_eq">*=</a> <a href="#rotx_mat">rotx_mat</a>&lt;<a href="#mat_traits">mat_traits&lt;A&gt;::rows</a>&gt;(angle)</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="roty_mat"><code>roty_mat</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;int Dim,class Angle&gt;
  -unspecified-return-type- roty_mat( Angle const &amp; angle );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A <a href="#view_proxy">view proxy</a> matrix of unspecified type, of <code>Dim</code> rows and <code>Dim</code> columns and scalar type <code>Angle</code>, which performs a rotation around the <code>Y</code> axis at <code>angle</code> radians.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="mat_set_roty"><code>set_roty</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
  template &lt;class A&gt;
  void set_roty( A &amp; a, typename mat_traits&lt;A&gt;::scalar_type angle );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>As if:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">assign(
  a,
  roty_mat&lt;mat_traits&lt;A&gt;::rows&gt;(angle));</code></pre>
</div>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="mat_rotate_y"><code>rotate_y</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
  template &lt;class A&gt;
  void rotate_y( A &amp; a, typename mat_traits&lt;A&gt;::scalar_type angle );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>As if: <code>a <a href="#mat_mul_eq">*=</a> <a href="#roty_mat">roty_mat</a>&lt;<a href="#mat_traits">mat_traits&lt;A&gt;::rows</a>&gt;(angle)</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="rotz_mat"><code>rotz_mat</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;int Dim,class Angle&gt;
  -unspecified-return-type- rotz_mat( Angle const &amp; angle );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A <a href="#view_proxy">view proxy</a> matrix of unspecified type, of <code>Dim</code> rows and <code>Dim</code> columns and scalar type <code>Angle</code>, which performs a rotation around the <code>Z</code> axis at <code>angle</code> radians.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="mat_set_rotz"><code>set_rotz</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
  template &lt;class A&gt;
  void set_rotz( A &amp; a, typename mat_traits&lt;A&gt;::scalar_type angle );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>As if:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">assign(
  a,
  rotz_mat&lt;mat_traits&lt;A&gt;::rows&gt;(angle));</code></pre>
</div>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="mat_rotate_z"><code>rotate_z</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
  template &lt;class A&gt;
  void rotate_z( A &amp; a, typename mat_traits&lt;A&gt;::scalar_type angle );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>As if: <code>a <a href="#mat_mul_eq">*=</a> <a href="#rotz_mat">rotz_mat</a>&lt;<a href="#mat_traits">mat_traits&lt;A&gt;::rows</a>&gt;(angle)</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="determinant"><code>determinant</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
  template &lt;class A&gt;
  mat_traits&lt;A&gt;::scalar_type
  determinant( A const &amp; a );

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This function computes the <a href="https://en.wikipedia.org/wiki/Determinant">determinant</a> of the square matrix <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="perspective_lh"><code>perspective_lh</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;class T&gt;
  -unspecified-return-type-
  perspective_lh( T fov_y, T aspect, T zn, T zf );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A 4x4 projection matrix of unspecified type of the following form:</p>
<table class="tableblock frame-all grid-all" style="width: 50%;">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><div class="verse"> <code>xs</code></div></td>
<td class="tableblock halign-center valign-top"><div class="verse"> 0</div></td>
<td class="tableblock halign-center valign-top"><div class="verse">  0</div></td>
<td class="tableblock halign-center valign-top"><div class="verse"> 0</div></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><div class="verse"> 0</div></td>
<td class="tableblock halign-center valign-top"><div class="verse"> <code>ys</code></div></td>
<td class="tableblock halign-center valign-top"><div class="verse"> 0</div></td>
<td class="tableblock halign-center valign-top"><div class="verse"> 0</div></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><div class="verse"> 0</div></td>
<td class="tableblock halign-center valign-top"><div class="verse"> 0</div></td>
<td class="tableblock halign-center valign-top"><div class="verse"> <code>zf</code>/(<code>zf</code>-<code>zn</code>)</div></td>
<td class="tableblock halign-center valign-top"><div class="verse">  -<code>zn</code>*<code>zf</code>/(<code>zf</code>-<code>zn</code>)</div></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><div class="verse"> 0</div></td>
<td class="tableblock halign-center valign-top"><div class="verse"> 0</div></td>
<td class="tableblock halign-center valign-top"><div class="verse"> 1</div></td>
<td class="tableblock halign-center valign-top"><div class="verse"> 0</div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>where <code>ys</code> = cot(<code>fov_y</code>/2) and <code>xs</code> = <code>ys</code>/<code>aspect</code>.</p>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="perspective_rh"><code>perspective_rh</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;class T&gt;
  -unspecified-return-type-
  perspective_rh( T fov_y, T aspect, T zn, T zf );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A 4x4 projection matrix of unspecified type of the following form:</p>
<table class="tableblock frame-all grid-all" style="width: 50%;">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><div class="verse"> <code>xs</code></div></td>
<td class="tableblock halign-center valign-top"><div class="verse"> 0</div></td>
<td class="tableblock halign-center valign-top"><div class="verse"> 0</div></td>
<td class="tableblock halign-center valign-top"><div class="verse"> 0</div></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><div class="verse"> 0</div></td>
<td class="tableblock halign-center valign-top"><div class="verse"> <code>ys</code></div></td>
<td class="tableblock halign-center valign-top"><div class="verse"> 0</div></td>
<td class="tableblock halign-center valign-top"><div class="verse"> 0</div></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><div class="verse"> 0</div></td>
<td class="tableblock halign-center valign-top"><div class="verse"> 0</div></td>
<td class="tableblock halign-center valign-top"><div class="verse"> <code>zf</code>/(<code>zn</code>-<code>zf</code>)</div></td>
<td class="tableblock halign-center valign-top"><div class="verse"> <code>zn</code>*<code>zf</code>/(<code>zn</code>-<code>zf</code>)</div></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><div class="verse"> 0</div></td>
<td class="tableblock halign-center valign-top"><div class="verse"> 0</div></td>
<td class="tableblock halign-center valign-top"><div class="verse"> -1</div></td>
<td class="tableblock halign-center valign-top"><div class="verse"> 0</div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>where <code>ys</code> = cot(<code>fov_y</code>/2), and <code>xs</code> = <code>ys</code>/<code>aspect</code>.</p>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="mat_scalar_cast"><code>scalar_cast</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if: is_mat&lt;A&gt;::value
  template &lt;class Scalar,class A&gt;
  -unspecified-return_type- scalar_cast( A const &amp; a );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A read-only <a href="#view_proxy">view proxy</a> of <code>a</code> that looks like a matrix of the same dimensions as <code>a</code>, but with <a href="#mat_traits"><code>scalar_type</code></a> <code>Scalar</code> and elements constructed from the corresponding elements of <code>a</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="mref"><code>mref</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if: is_mat&lt;A&gt;::value
  template &lt;class A&gt;
  -unspecified-return-type- mref( A &amp; a );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>An identity view proxy of <code>a</code>; that is, it simply accesses the elements of <code>a</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>mref</code> allows calling QVM operations when <code>a</code> is of built-in type, for example a plain old C array.
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_quaternion_vector_operations">Quaternion-Vector Operations</h3>
<div class="sect3">
<h4 id="quat_vec_mul"><code>operator*</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/quat_vec_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; is_vec&lt;B&gt;::value &amp;&amp;
  //  mat_traits&lt;A&gt;::cols==vec_traits&lt;B&gt;::dim
  template &lt;class A,class B&gt;
  typename deduce_vec2&lt;A,B,mat_traits&lt;A&gt;::rows&gt;::type
  operator*( A const &amp; a, B const &amp; b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The result of transforming the vector <code>b</code> by the quaternion <code>a</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <a href="#deduce_vec2"><code>deduce_vec2</code></a> template can be specialized to deduce the desired return type, given the types <code>A</code> and <code>B</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_matrix_vector_operations">Matrix-Vector Operations</h3>
<div class="sect3">
<h4 id="mat_vec_mul"><code>operator*</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/vec_mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; is_vec&lt;B&gt;::value &amp;&amp;
  //  mat_traits&lt;A&gt;::cols==vec_traits&lt;B&gt;::dim
  template &lt;class A,class B&gt;
  typename deduce_vec2&lt;A,B,mat_traits&lt;A&gt;::rows&gt;::type
  operator*( A const &amp; a, B const &amp; b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The result of multiplying the matrix <code>a</code> and the vector <code>b</code>, where <code>b</code> is interpreted as a matrix-column. The resulting matrix-row is returned as a vector type.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <a href="#deduce_vec2"><code>deduce_vec2</code></a> template can be specialized to deduce the desired return type, given the types <code>A</code> and <code>B</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="transform_vector"><code>transform_vector</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/vec_mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; is_vec&lt;B&gt;::value &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==4 &amp;&amp; mat_traits&lt;A&gt;::cols==4 &amp;&amp;
  //  vec_traits&lt;B&gt;::dim==3
  template &lt;class A,class B&gt;
  deduce_vec2&lt;A,B,3&gt; &gt;::type
  transform_vector( A const &amp; a, B const &amp; b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>As if: <code>return a <a href="#mat_vec_mul">*</a> <a href="#swizzling">XYZ0</a>(b)</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="transform_point"><code>transform_point</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/vec_mat_operations.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp; is_vec&lt;B&gt;::value &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==4 &amp;&amp; mat_traits&lt;A&gt;::cols==4 &amp;&amp;
  //  vec_traits&lt;B&gt;::dim==3
  template &lt;class A,class B&gt;
  deduce_vec2&lt;A,B,3&gt; &gt;::type
  transform_point( A const &amp; a, B const &amp; b );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>As if: <code>return a <a href="#mat_vec_mul">*</a> <a href="#swizzling">XYZ1</a>(b)</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_matrix_to_matrix_view_proxies">Matrix-to-Matrix View Proxies</h3>
<div class="sect3">
<h4 id="del_row"><code>del_row</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/map_mat_mat.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;int R&gt;
  -unspecified-return-type- del_row();

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The expression <code>del_row&lt;R&gt;(m)</code> returns an lvalue <a href="#view_proxy">view proxy</a> that looks like the matrix <code>m</code> with row <code>R</code> deleted.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="del_col"><code>del_col</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/map_mat_mat.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;int C&gt;
  -unspecified-return-type- del_col();

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The expression <code>del_col&lt;C&gt;(m)</code> returns an lvalue <a href="#view_proxy">view proxy</a> that looks like the matrix <code>m</code> with column <code>C</code> deleted.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="del_row_col"><code>del_row_col</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/map_mat_mat.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;int R,int C&gt;
  -unspecified-return-type- del_row_col();

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The expression <code>del_row_col&lt;R,C&gt;(m)</code> returns an lvalue <a href="#view_proxy">view proxy</a> that looks like the matrix <code>m</code> with row <code>R</code> and column <code>C</code> deleted.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="neg_row"><code>neg_row</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/map_mat_mat.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;int R&gt;
  -unspecified-return-type- neg_row();

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The expression <code>neg_row&lt;R&gt;(m)</code> returns a read-only <a href="#view_proxy">view proxy</a> that looks like the matrix <code>m</code> with row <code>R</code> negated.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="neg_col"><code>neg_col</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/map_mat_mat.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;int C&gt;
  -unspecified-return-type- neg_col();

} }</code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">The expression `neg_col&lt;C&gt;(m)` returns a read-only &lt;&lt;view_proxy,`view proxy`&gt;&gt; that looks like the matrix `m` with column `C` negated.</pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="swap_rows"><code>swap_rows</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/map_mat_mat.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;int R1,int R2&gt;
  -unspecified-return-type- swap_rows();

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The expression <code>swap_rows&lt;R1,R2&gt;(m)</code> returns an lvalue <a href="#view_proxy">view proxy</a> that looks like the matrix <code>m</code> with rows <code>R1</code> and <code>R2</code> swapped.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="swap_cols"><code>swap_cols</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/map_mat_mat.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  template &lt;int C1,int C2&gt;
  -unspecified-return-type- swap_cols();

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The expression <code>swap_cols&lt;C1,C2&gt;(m)</code> returns an lvalue <a href="#view_proxy">view proxy</a> that looks like the matrix <code>m</code> with columns <code>C1</code> and <code>C2</code> swapped.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="transposed"><code>transposed</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/map_mat_mat.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  -unspecified-return-type- transposed();

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The expression <code>transposed(m)</code> returns an lvalue <a href="#view_proxy">view proxy</a> that transposes the matrix <code>m</code>.</p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_vector_to_matrix_view_proxies">Vector-to-Matrix View Proxies</h3>
<div class="sect3">
<h4 id="col_mat"><code>col_mat</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/map_vec_mat.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if: is_vec&lt;A&gt;::value
  template &lt;iclass A&gt;
  -unspecified-return-type- col_mat( A &amp; a );

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The expression <code>col_mat(v)</code> returns an lvalue <a href="#view_proxy">view proxy</a> that accesses the vector <code>v</code> as a matrix-column.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="row_mat"><code>row_mat</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/map_vec_mat.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if: is_vec&lt;A&gt;::value
  template &lt;iclass A&gt;
  -unspecified-return-type- row_mat( A &amp; a );

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The expression <code>row_mat(v)</code> returns an lvalue <a href="#view_proxy">view proxy</a> that accesses the vector <code>v</code> as a matrix-row.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="translation_mat"><code>translation_mat</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/map_vec_mat.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if: is_vec&lt;A&gt;::value
  template &lt;iclass A&gt;
  -unspecified-return-type- translation_mat( A &amp; a );

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The expression <code>translation_mat(v)</code> returns an lvalue <a href="#view_proxy">view proxy</a> that accesses the vector <code>v</code> as translation matrix of size 1 + <a href="#vec_traits"><code>vec_traits&lt;A&gt;::dim</code></a>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="diag_mat"><code>diag_mat</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/map_vec_mat.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if: is_vec&lt;A&gt;::value
  template &lt;iclass A&gt;
  -unspecified-return-type- diag_mat( A &amp; a );

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The expression <code>diag_mat(v)</code> returns an lvalue <a href="#view_proxy">view proxy</a> that accesses the vector <code>v</code> as a square matrix of the same dimensions in which the elements of <code>v</code> appear as the main diagonal and all other elements are zero.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If <code>v</code> is a 3D vector, the expression <code>diag_mat(XYZ1(v))</code> can be used as a scaling 4D matrix.
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_matrix_to_vector_view_proxies">Matrix-to-Vector View Proxies</h3>
<div class="sect3">
<h4 id="col"><code>col</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/map_mat_vec.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if: is_mat&lt;A&gt;::value
  template &lt;int C,class A&gt;
  -unspecified-return-type- col( A &amp; a );

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The expression <code>col&lt;C&gt;(m)</code> returns an lvalue <a href="#view_proxy">view proxy</a> that accesses column <code>C</code> of the matrix <code>m</code> as a vector.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="row"><code>row</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/map_mat_vec.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if: is_mat&lt;A&gt;::value
  template &lt;int C,class A&gt;
  -unspecified-return-type- row( A &amp; a );

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The expression <code>row&lt;R&gt;(m)</code> returns an lvalue <a href="#view_proxy">view proxy</a> that accesses row <code>R</code> of the matrix <code>m</code> as a vector.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="diag"><code>diag</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/map_mat_vec.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if: is_mat&lt;A&gt;::value
  template &lt;class A&gt;
  -unspecified-return-type- diag( A &amp; a );

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The expression <code>diag(m)</code> returns an lvalue <a href="#view_proxy">view proxy</a> that accesses the main diagonal of the matrix <code>m</code> as a vector.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="translation"><code>translation</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/map_mat_vec.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  //Only enabled if:
  //  is_mat&lt;A&gt;::value &amp;&amp;
  //  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3
  template &lt;class A&gt;
  -unspecified-return-type- translation( A &amp; a );

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The expression <code>translation(m)</code> returns an lvalue <a href="#view_proxy">view proxy</a> that accesses the translation component of the square matrix <code>m</code>, which is a vector of size <code>D</code>-1, where <code>D</code> is the size of <code>m</code>.</p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_exceptions">Exceptions</h3>
<div class="sect3">
<h4 id="error"><code>error</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/error.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  struct error: virtual boost::exception, virtual std::exception { };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is the base for all exceptions thorwn by QVM.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="zero_magnitude_error"><code>zero_magnitude_error</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/error.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  struct zero_magnitude_error: virtual error { };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This exception indicates that an operation requires a vector or a quaternion with non-zero magnitude, but the computed magnitude is zero.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="zero_determinant_error"><code>zero_determinant_error</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/error.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  struct zero_determinant_error: virtual error { };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This exception indicates that an operation requires a matrix with non-zero determinant, but the computed determinant is zero.</p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_macros_and_configuration_boost_qvm">Macros and Configuration: BOOST_QVM_</h3>
<div class="sect3">
<h4 id="BOOST_QVM_INLINE"><code>INLINE</code></h4>
<div class="sect4">
<h5 id="_boost_qvm_inline"><code>BOOST_QVM_INLINE</code></h5>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/inline.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  #ifndef BOOST_QVM_INLINE
  #define BOOST_QVM_INLINE inline
  #endif

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This macro is not used directly by QVM, except as the default value of other macros from <code>&lt;boost/qvm/inline.hpp&gt;</code>. A user-defined <code>BOOST_QVM_INLINE</code> should expand to a value that is valid substitution of the <code>inline</code> keyword in function definitions.</p>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="BOOST_QVM_FORCE_INLINE"><code>FORCE_INLINE</code></h4>
<div class="sect4">
<h5 id="_boost_qvm_force_inline"><code>BOOST_QVM_FORCE_INLINE</code></h5>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/inline.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  #ifndef BOOST_QVM_FORCE_INLINE
  #define BOOST_QVM_FORCE_INLINE /*platform-specific*/
  #endif

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This macro is not used directly by QVM, except as the default value of other macros from <code>&lt;boost/qvm/inline.hpp&gt;</code>. A user-defined <code>BOOST_QVM_FORCE_INLINE</code> should expand to a value that is valid substitution of the <code>inline</code> keyword in function definitions, to indicate that the compiler must inline the function. Of course, actual inlining may or may not occur.</p>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="BOOST_QVM_INLINE_TRIVIAL"><code>INLINE_TRIVIAL</code></h4>
<div class="sect4">
<h5 id="_boost_qvm_inline_trivial"><code>BOOST_QVM_INLINE_TRIVIAL</code></h5>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/inline.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  #ifndef BOOST_QVM_INLINE_TRIVIAL
  #define BOOST_QVM_INLINE_TRIVIAL BOOST_QVM_FORCE_INLINE
  #endif

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>QVM uses <code>BOOST_QVM_INLINE_TRIVIAL</code> in definitions of functions that are not critical for the overall performance of the library but are extremely simple (such as one-liners) and therefore should always be inlined.</p>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="BOOST_QVM_INLINE_CRITICAL"><code>INLINE_CRITICAL</code></h4>
<div class="sect4">
<h5 id="_boost_qvm_inline_critical"><code>BOOST_QVM_INLINE_CRITICAL</code></h5>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/inline.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  #ifndef BOOST_QVM_INLINE_CRITICAL
  #define BOOST_QVM_INLINE_CRITICAL BOOST_QVM_FORCE_INLINE
  #endif

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>QVM uses <code>BOOST_QVM_INLINE_CRITICAL</code> in definitions of functions that are critical for the overall performance of the library, such as functions that access individual vector and matrix elements.</p>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="BOOST_QVM_INLINE_OPERATIONS"><code>INLINE_OPERATIONS</code></h4>
<div class="sect4">
<h5 id="_boost_qvm_inline_operations"><code>BOOST_QVM_INLINE_OPERATIONS</code></h5>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/inline.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  #ifndef BOOST_QVM_INLINE_OPERATIONS
  #define BOOST_QVM_INLINE_OPERATIONS BOOST_QVM_INLINE
  #endif

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>QVM uses <code>BOOST_QVM_INLINE_OPERATIONS</code> in definitions of functions that implement various high-level operations, such as matrix multiplication, computing the magnitude of a vector, etc.</p>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="BOOST_QVM_INLINE_RECURSION"><code>INLINE_RECURSION</code></h4>
<div class="sect4">
<h5 id="_boost_qvm_inline_recursion"><code>BOOST_QVM_INLINE_RECURSION</code></h5>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/inline.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  #ifndef BOOST_QVM_INLINE_RECURSION
  #define BOOST_QVM_INLINE_RECURSION BOOST_QVM_INLINE_OPERATIONS
  #endif

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>QVM uses <code>BOOST_QVM_INLINE_RECURSION</code> in definitions of recursive functions that are not critical for the overall performance of the library (definitions of all critical functions, including critical recursive functions, use <a href="#BOOST_QVM_INLINE_CRITICAL"><code>BOOST_QVM_INLINE_CRITICAL</code></a>).</p>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="BOOST_QVM_ASSERT"><code>ASSERT</code></h4>
<div class="sect4">
<h5 id="_boost_qvm_assert"><code>BOOST_QVM_ASSERT</code></h5>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/assert.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

#ifndef BOOST_QVM_ASSERT
#include &lt;boost/assert.hpp&gt;
#define BOOST_QVM_ASSERT BOOST_ASSERT
#endif

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is the macro QVM uses to assert on precondition violations and logic errors. A user-defined <code>BOOST_QVM_ASSERT</code> should have the semantics of the standard <code>assert</code>.</p>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="BOOST_QVM_STATIC_ASSERT"><code>STATIC_ASSERT</code></h4>
<div class="sect4">
<h5 id="_boost_qvm_static_assert"><code>BOOST_QVM_STATIC_ASSERT</code></h5>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/static_assert.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  #ifndef BOOST_QVM_STATIC_ASSERT
  #include &lt;boost/static_assert.hpp&gt;
  #define BOOST_QVM_STATIC_ASSERT BOOST_STATIC_ASSERT
  #endif

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>All static assertions in QVM use the <code>BOOST_QVM_STATIC_ASSERT</code> macro.</p>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="BOOST_QVM_THROW_EXCEPTION"><code>THROW_EXCEPTION</code></h4>
<div class="sect4">
<h5 id="_boost_qvm_throw_exception"><code>BOOST_QVM_THROW_EXCEPTION</code></h5>
<div class="listingblock">
<div class="title">#include &lt;boost/qvm/throw_exception.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace boost { namespace qvm {

  #ifndef BOOST_QVM_THROW_EXCEPTION
  #include &lt;boost/throw_exception.hpp&gt;
  #define BOOST_QVM_THROW_EXCEPTION BOOST_THROW_EXCEPTION
  #endif

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This macro is used whenever QVM throws an exception. Users who override the standard <code>BOOST_QVM_THROW_EXCEPTION</code> behavior must ensure that when invoked, the substituted implementation does not return control to the caller. Below is a list of all QVM functions that invoke <code>BOOST_QVM_THROW_EXCEPTION</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Quaternion operations:</p>
<div class="ulist">
<ul>
<li>
<p><a href="#quat_inverse"><code>inverse</code></a></p>
</li>
<li>
<p><a href="#rot_quat"><code>rot_quat</code></a></p>
</li>
<li>
<p><a href="#quat_normalize"><code>normalize</code></a></p>
</li>
<li>
<p><a href="#quat_normalized"><code>normalized</code></a></p>
</li>
</ul>
</div>
</li>
<li>
<p>Vector operations:</p>
<div class="ulist">
<ul>
<li>
<p><a href="#vec_normalize"><code>normalize</code></a></p>
</li>
<li>
<p><a href="#vec_normalized"><code>normalized</code></a></p>
</li>
</ul>
</div>
</li>
<li>
<p>Matrix operations:</p>
<div class="ulist">
<ul>
<li>
<p><a href="#mat_inverse"><code>inverse</code></a></p>
</li>
<li>
<p><a href="#rot_mat"><code>rot_mat</code></a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rationale">Design Rationale</h2>
<div class="sectionbody">
<div class="paragraph">
<p>C&#43;&#43; is ideal for 3D graphics and other domains that require 3D transformations: define vector and matrix types and then overload the appropriate operators to implement the standard algebraic operations. Because this is relatively straight-forward, there are many libraries that do this, each providing custom vector and matrix types, and then defining the same operations (e.g. matrix multiply) for these types.</p>
</div>
<div class="paragraph">
<p>Often these libraries are part of a higher level system. For example, video game programmers typically use one set of vector/matrix types with the rendering engine, and another with the physics simulation engine.</p>
</div>
<div class="paragraph">
<p>QVM proides interoperability between all these different types and APIs by decoupling the standard algebraic functions from the types they operate on&#8201;&#8212;&#8201;without compromising type safety. The operations work on any type for which proper traits have been specialized. Using QVM, there is no need to translate between the different quaternion, vector or matrix types; they can be mixed in the same expression safely and efficiently.</p>
</div>
<div class="paragraph">
<p>This design enables QVM to generate types and adaptors at compile time, compatible with any other QVM or user-defined type. For example, transposing a matrix needs not store the result: rather than modifying its argument or returning a new object, it simply binds the original matrix object through a generated type which remaps element access on the fly.</p>
</div>
<div class="paragraph">
<p>In addition, QVM can be helpful in selectively optimizing individual types or operations for maximum performance where that matters. For example, users can overload a specific operation for specific types, or define highly optimized, possibly platform-specific or for some reason cumbersome to use types, then mix and match them with more user-friendly types in parts of the program where performance isn&#8217;t critical.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_code_generator">Code Generator</h2>
<div class="sectionbody">
<div class="paragraph">
<p>While QVM defines generic functions that operate on matrix and vector types of arbitrary static dimensions, it also provides a code generator that can be used to create compatible header files that define much simpler specializations of these functions for specific dimensions. This is useful during debugging since the generated code is much easier to read than the template metaprogramming-heavy generic implementations. It is also potentially friendlier to the optimizer.</p>
</div>
<div class="paragraph">
<p>The code generator is a command-line utility program. Its source code can be found in the <code>boost/libs/qvm/gen</code> directory. It was used to generate the following headers that ship with QVM:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>2D, 3D and 4D matrix operations:</p>
<div class="ulist">
<ul>
<li>
<p><code>boost/qvm/gen/mat_operations2.hpp</code> (matrices of size 2x2, 2x1 and 1x2, included by <code>boost/qvm/mat_operations2.hpp</code>)</p>
</li>
<li>
<p><code>boost/qvm/gen/mat_operations3.hpp</code> (matrices of size 3x3, 3x1 and 1x3, included by <code>boost/qvm/mat_operations3.hpp</code>)</p>
</li>
<li>
<p><code>boost/qvm/gen/mat_operations4.hpp</code> (matrices of size 4x4, 4x1 and 1x4, included by <code>boost/qvm/mat_operations4.hpp</code>)</p>
</li>
</ul>
</div>
</li>
<li>
<p>2D, 3D and 4D vector operations:</p>
<div class="ulist">
<ul>
<li>
<p><code>boost/qvm/gen/v2.hpp</code> (included by <code>boost/qvm/vec_operations2.hpp</code>)</p>
</li>
<li>
<p><code>boost/qvm/gen/v3.hpp</code> (included by <code>boost/qvm/vec_operations3.hpp</code>)</p>
</li>
<li>
<p><code>boost/qvm/gen/v4.hpp</code> (included by <code>boost/qvm/vec_operations4.hpp</code>)</p>
</li>
</ul>
</div>
</li>
<li>
<p>2D, 3D and 4D vector-matrix operations:</p>
<div class="ulist">
<ul>
<li>
<p><code>boost/qvm/gen/vm2.hpp</code> (included by <code>boost/qvm/vec_mat_operations2.hpp</code>)</p>
</li>
<li>
<p><code>boost/qvm/gen/vm3.hpp</code> (included by <code>boost/qvm/vec_mat_operations3.hpp</code>)</p>
</li>
<li>
<p><code>boost/qvm/gen/vm4.hpp</code> (included by <code>boost/qvm/vec_mat_operations4.hpp</code>)</p>
</li>
</ul>
</div>
</li>
<li>
<p>2D, 3D and 4D vector swizzling operations:</p>
<div class="ulist">
<ul>
<li>
<p><code>boost/qvm/gen/sw2.hpp</code> (included by <code>boost/qvm/swizzle2.hpp</code>)</p>
</li>
<li>
<p><code>boost/qvm/gen/sw3.hpp</code> (included by <code>boost/qvm/swizzle3.hpp</code>)</p>
</li>
<li>
<p><code>boost/qvm/gen/sw4.hpp</code> (included by <code>boost/qvm/swizzle4.hpp</code>)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Any such generated headers must be included before the corresponding generic header file is included. For example, if one creates a header <code>boost/qvm/gen/m5.hpp</code>, it must be included before <code>boost/qvm/mat_operations.hpp</code> in included. However, the generic headers (<code>boost/qvm/mat_operations.hpp</code>, <code>boost/qvm/vec_operations.hpp</code>, <code>boost/qvm/vec_mat_operations.hpp</code> and <code>boost/qvm/swizzle.hpp</code>) already include the generated headers from the list above, so the generated headers don&#8217;t need to be included manually.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
headers under <code>boost/qvm/gen</code> are not part of the public interface of QVM. For example, <code>boost/qvm/gen/mat_operations2.hpp</code> should not be included directly; <code>#include &lt;boost/qvm/mat_operations2.hpp&gt;</code> instead.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_known_quirks_and_issues">Known Quirks and Issues</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_capturing_view_proxies_with_auto">Capturing View Proxies with <code>auto</code></h3>
<div class="paragraph">
<p>By design, <a href="#view_proxy">view proxies</a> must not return temporary objects. They return reference to an argument they take by (<code>const</code>) reference, cast to reference of unspecified type that is not copyable. Because of this, the return value of a view proxy can not be captured by value with <code>auto</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">auto tr = transposed(m); //Error: the return type of transposed can not be copied.</code></pre>
</div>
</div>
<div class="paragraph">
<p>The correct use of auto with view proxies is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">auto &amp; tr = transposed(m);</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Many view proxies are not read-only, that is, they&#8217;re lvalues; changes made on the view proxy operate on the original object. This is another reason why they can not be captured by value with  <code>auto</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_binding_qvm_overloads_from_an_unrelated_namespace">Binding QVM Overloads From an Unrelated Namespace</h3>
<div class="paragraph">
<p>The operator overloads in namespace <code>boost::qvm</code> are designed to work with user-defined types. Typically it is sufficient to make these operators available in the namespace where the operator is used, by <code>using namespace boost::qvm</code>. A problem arises if the scope that uses the operator is not controlled by the user. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace ns1 {

  struct float2 { float x, y; };

}

namespace ns2 {

  using namespace boost::qvm;

  void f() {
    ns1::float2 a, b;
    a==b; //OK
    ns1::float2 arr1[2], arr2[2];
    std::equal(arr1,arr1+2,arr2); //Error: operator== is inaccessible from namespace std
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the <code>std::equal</code> expression above, even though <code>boost::qvm::operator==</code> is made visible in namespace <code>ns2</code> by <code>using namespace boost::qvm</code>, the call originates from namespace <code>std</code>. In this case the compiler can&#8217;t bind <code>boost::qvm::operator==</code> because only namespace <code>ns1</code> is visible through ADL, and it does not contain a suitable declaration. The solution is to declare <code>operator==</code> in namespace ns1, which can be done like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">namespace ns1 {

  using boost::qvm::operator==;

}</code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_link_errors_when_calling_math_functions_with_int_arguments">Link Errors When Calling Math Functions with <code>int</code> Arguments</h3>
<div class="paragraph">
<p>QVM does not call standard math functions (e.g. sin, cos, etc.) directly. Instead, it calls function templates declared in <code>boost/qvm/math.hpp</code> in namespace <code>boost::qvm</code>. This allows the user to specialize these templates for user-defined scalar types.</p>
</div>
<div class="paragraph">
<p>QVM itself defines specializations of the math function templates only for <code>float</code> and <code>double</code>, but it does not provide generic definitions. This is done to protect the user from unintentionally writing code that binds standard math functions that take <code>double</code> when passing arguments of lesser types, which would be suboptimal.</p>
</div>
<div class="paragraph">
<p>Because of this, a call to e.g. <code><a href="#rot_mat">rot_mat</a>(axis,1)</code> will compile successfully but fail to link, since it calls e.g. <code>boost::qvm::sin&lt;int&gt;</code>, which is undefined. Because rotations by integer number of radians are rarely needed, in QVM there is no protection against such errors. In such cases the solution is to use <code>rot_mat(axis,1.0f)</code> instead.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_distribution">Distribution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>QVM is part of <a href="https://www.boost.org/">Boost</a> and is distributed under the <a href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License, Version 1.0</a>.</p>
</div>
<div class="paragraph">
<p>The source code is available in <a href="https://github.com/boostorg/qvm">QVM GitHub repository</a>.</p>
</div>
<div class="paragraph">
<p>&#169; 2008-2018 Emil Dotchevski and Reverge Studios, Inc.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_portability">Portability</h2>
<div class="sectionbody">
<div class="paragraph">
<p>See the <a href="https://travis-ci.org/boostorg/qvm">QVM Travis CI Builds</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_feedback_support">Feedback / Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Please use the <a href="https://lists.boost.org/mailman/listinfo.cgi/boost">Boost Developers mailing list</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_qa">Q&amp;A</h2>
<div class="sectionbody">
<div class="qlist qanda">
<ol>
<li>
<p><em>What is the motivation behind QVM? Why not just use uBLAS/Eigen/CML/GLM/etc?</em></p>
<p>The primary domain of QVM is realtime graphics and simulation applications, so it is not a complete linear algebra library. While (naturally) there is some overlap with such libraries, QVM puts the emphasis on 2, 3 and 4 dimensional zero-overhead operations (hence domain-specific features like Swizzling).</p>
</li>
<li>
<p><em>How does the <code>qvm::<a href="#vec">vec</a></code> (or <code>qvm::<a href="#mat">mat</a></code>, or <code>qvm::<a href="#quat">quat</a></code>) template compare to vector types from other libraries?</em></p>
<p>The <code>qvm::vec</code> template is not in any way central to the vector operations defined by QVM. The operations are designed to work with any user-defined vector type or with 3rd-party vector types (e.g. <code>D3DVECTOR</code>), while the <code>qvm::vec</code> template is simply a default return type for expressions that use arguments of different types that would be incompatible outside of QVM. For example, if the <a href="#deduce_mat2"><code>deduce_mat2</code></a> hasn&#8217;t been specialized, calling <a href="#cross"><code>cross</code></a> with a user-defined type <code>vec3</code> and a user-defined type <code>float3</code> returns a <code>qvm::vec</code>.</p>
</li>
<li>
<p><em>Why doesn&#8217;t QVM use [] or () to access vector and matrix elements?</em></p>
<p>Because it&#8217;s designed to work with user-defined types, and the C&#43;&#43; standard requires these operators to be members. Of course if a user-defined type defines <code>operator[]</code> or <code>operator()</code> they are available for use with other QVM functions, but QVM defines its own mechanisms for <a href="#quat_access">accessing quaternion elements</a>, <a href="#vec_access">accessing vector elements</a> (as well as <a href="#swizzling">swizzling</a>), and <a href="#mat_access">accessing matrix elements</a>.</p>
</li>
</ol>
</div>
<hr>
<div class="paragraph text-right">
<p>&#169; 2008-2018 Emil Dotchevski and Reverge Studios, Inc.</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
</div>
</div>
</body>
</html>