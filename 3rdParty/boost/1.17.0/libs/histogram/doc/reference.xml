<?xml version="1.0" standalone="yes"?>
<library-reference><header name="boost/histogram.hpp">
<para>Includes all standard headers of the Boost.histogram library. </para><para>Extra headers not automatically included are:<itemizedlist>
<listitem><para><ulink url="histogram/reference.html#header.boost.histogram.ostream_hpp">boost/histogram/ostream.hpp</ulink></para>
</listitem><listitem><para><ulink url="histogram/reference.html#header.boost.histogram.axis.ostream_hpp">boost/histogram/axis/ostream.hpp</ulink></para>
</listitem><listitem><para><ulink url="histogram/reference.html#header.boost.histogram.accumulators.ostream_hpp">boost/histogram/accumulators/ostream.hpp</ulink></para>
</listitem><listitem><para><ulink url="histogram/reference.html#header.boost.histogram.serialization_hpp">boost/histogram/serialization.hpp</ulink> </para>
</listitem></itemizedlist>
</para></header>
<header name="boost/histogram/histogram.hpp">
<namespace name="boost">
<namespace name="histogram">
<class name="histogram"><template>
      <template-type-parameter name="Axes"><purpose><para>std::tuple of axis types OR std::vector of an axis type or <classname alt="boost::histogram::axis::variant">axis::variant</classname> </para></purpose></template-type-parameter>
      <template-type-parameter name="Storage"><purpose><para>class that implements the storage interface </para></purpose></template-type-parameter>
    </template><purpose>Central class of the histogram library. </purpose><description><para>Histogram uses the call operator to insert data, like the <ulink url="https://www.boost.org/doc/libs/develop/doc/html/accumulators.html">Boost.Accumulators</ulink>.</para><para>Use factory functions (see <ulink url="histogram/reference.html#header.boost.histogram.make_histogram_hpp">make_histogram.hpp</ulink> and <ulink url="histogram/reference.html#header.boost.histogram.make_profile_hpp">make_profile.hpp</ulink>) to conveniently create histograms rather than calling the ctors directly.</para><para>Use the <ulink url="boost/histogram/indexed.html">indexed</ulink> range generator to iterate over filled histograms, which is convenient and faster than hand-written loops for multi-dimensional histograms.</para><para>
</para></description><typedef name="axes_type"><type>Axes</type></typedef>
<typedef name="storage_type"><type>Storage</type></typedef>
<typedef name="value_type"><type>typename storage_type::value_type</type></typedef>
<typedef name="iterator"><type>typename storage_type::iterator</type></typedef>
<typedef name="const_iterator"><type>typename storage_type::const_iterator</type></typedef>
<method-group name="public member functions">
<method name="rank" cv="const noexcept"><type>constexpr unsigned</type><purpose>Number of axes (dimensions). </purpose></method>
<method name="size" cv="const noexcept"><type>std::size_t</type><purpose>Total number of bins (including underflow/overflow). </purpose></method>
<method name="reset"><type>void</type><purpose>Reset all bins to default initialized values. </purpose></method>
<method name="axis" cv="const"><type>decltype(auto)</type><template>
          <template-nontype-parameter name="N"><type>unsigned</type><default>0</default></template-nontype-parameter>
        </template><parameter name=""><paramtype>std::integral_constant&lt; unsigned, N &gt;</paramtype><default>{}</default></parameter><purpose>Get N-th axis using a compile-time number. </purpose><description><para>This version is more efficient than the one accepting a run-time number. </para></description></method>
<method name="axis" cv="const"><type>decltype(auto)</type><parameter name="i"><paramtype>unsigned</paramtype></parameter><purpose>Get N-th axis with run-time number. </purpose><description><para>Prefer the version that accepts a compile-time number, if you can use it. </para></description></method>
<method name="for_each_axis" cv="const"><type>auto</type><template>
          <template-type-parameter name="Unary"/>
        </template><parameter name="unary"><paramtype>Unary &amp;&amp;</paramtype></parameter><purpose>Apply unary functor/function to each axis. </purpose></method>
<method name="operator()"><type>iterator</type><template>
          <template-nontype-parameter name="Ts"><type>class...</type></template-nontype-parameter>
        </template><parameter name="ts"><paramtype>const Ts &amp;...</paramtype></parameter><purpose>Fill histogram with values, an optional weight, and/or a sample. </purpose><description><para>Arguments are passed in order to the axis objects. Passing an argument type that is not convertible to the value type accepted by the axis or passing the wrong number of arguments causes a throw of <computeroutput>std::invalid_argument</computeroutput>.</para><para><emphasis role="bold">Optional weight</emphasis></para><para>An optional weight can be passed as the first or last argument with the <ulink url="boost/histogram/weight.html">weight</ulink> helper function. Compilation fails if the storage elements do not support weights.</para><para><emphasis role="bold">Samples</emphasis></para><para>If the storage elements accept samples, pass them with the sample helper function in addition to the axis arguments, which can be the first or last argument. The <ulink url="boost/histogram/sample.html">sample</ulink> helper function can pass one or more arguments to the storage element. If samples and weights are used together, they can be passed in any order at the beginning or end of the argument list.</para><para><emphasis role="bold">Axis with multiple arguments</emphasis></para><para>If the histogram contains an axis which accepts a <computeroutput>std::tuple</computeroutput> of arguments, the arguments for that axis need to passed as a <computeroutput>std::tuple</computeroutput>, for example, <computeroutput>std::make_tuple(1.2, 2.3)</computeroutput>. If the histogram contains only this axis and no other, the arguments can be passed directly. </para></description></method>
<method name="operator()"><type>iterator</type><template>
          <template-nontype-parameter name="Ts"><type>class...</type></template-nontype-parameter>
        </template><parameter name="t"><paramtype>const std::tuple&lt; Ts... &gt; &amp;</paramtype></parameter><purpose>Fill histogram with values, an optional weight, and/or a sample from a <computeroutput>std::tuple</computeroutput>. </purpose></method>
<method name="at"><type>decltype(auto)</type><template>
          <template-nontype-parameter name="Indices"><type>class...</type></template-nontype-parameter>
        </template><parameter name="i"><paramtype>axis::index_type</paramtype><description><para>index of first axis. </para></description></parameter><parameter name="is"><paramtype>Indices...</paramtype><description><para>indices of second, third, ... axes. </para></description></parameter><purpose>Access cell value at integral indices. </purpose><description><para>You can pass indices as individual arguments, as a std::tuple of integers, or as an interable range of integers. Passing the wrong number of arguments causes a throw of std::invalid_argument. Passing an index which is out of bounds causes a throw of std::out_of_range.</para><para>

</para></description><returns><para>reference to cell value. </para>
</returns></method>
<method name="at" cv="const"><type>decltype(auto)</type><template>
          <template-nontype-parameter name="Indices"><type>class...</type></template-nontype-parameter>
        </template><parameter name="i"><paramtype>axis::index_type</paramtype></parameter><parameter name="is"><paramtype>Indices...</paramtype></parameter><purpose>Access cell value at integral indices (read-only). </purpose></method>
<method name="at"><type>decltype(auto)</type><template>
          <template-nontype-parameter name="Indices"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="is"><paramtype>const std::tuple&lt; Indices... &gt; &amp;</paramtype></parameter><purpose>Access cell value at integral indices stored in <computeroutput>std::tuple</computeroutput>. </purpose></method>
<method name="at" cv="const"><type>decltype(auto)</type><template>
          <template-nontype-parameter name="Indices"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="is"><paramtype>const std::tuple&lt; Indices... &gt; &amp;</paramtype></parameter><purpose>Access cell value at integral indices stored in <computeroutput>std::tuple</computeroutput> (read-only). </purpose></method>
<method name="at"><type>decltype(auto)</type><template>
          <template-type-parameter name="Iterable"/>
          <template-type-parameter name=""><default>detail::requires_iterable&lt;Iterable&gt;</default></template-type-parameter>
        </template><parameter name="is"><paramtype>const Iterable &amp;</paramtype></parameter><purpose>Access cell value at integral indices stored in iterable. </purpose></method>
<method name="at" cv="const"><type>decltype(auto)</type><template>
          <template-type-parameter name="Iterable"/>
          <template-type-parameter name=""><default>detail::requires_iterable&lt;Iterable&gt;</default></template-type-parameter>
        </template><parameter name="is"><paramtype>const Iterable &amp;</paramtype></parameter><purpose>Access cell value at integral indices stored in iterable (read-only). </purpose></method>
<method name="operator[]"><type>decltype(auto)</type><template>
          <template-type-parameter name="Indices"/>
        </template><parameter name="is"><paramtype>const Indices &amp;</paramtype></parameter><purpose>Access value at index (number for rank = 1, else <computeroutput>std::tuple</computeroutput> or iterable). </purpose></method>
<method name="operator[]" cv="const"><type>decltype(auto)</type><template>
          <template-type-parameter name="Indices"/>
        </template><parameter name="is"><paramtype>const Indices &amp;</paramtype></parameter><purpose>Access value at index (read-only). </purpose></method>
<method name="operator==" cv="const noexcept"><type>bool</type><template>
          <template-type-parameter name="A"/>
          <template-type-parameter name="S"/>
        </template><parameter name="rhs"><paramtype>const <classname>histogram</classname>&lt; A, S &gt; &amp;</paramtype></parameter><purpose>Equality operator, tests equality for all axes and the storage. </purpose></method>
<method name="operator!=" cv="const noexcept"><type>bool</type><template>
          <template-type-parameter name="A"/>
          <template-type-parameter name="S"/>
        </template><parameter name="rhs"><paramtype>const <classname>histogram</classname>&lt; A, S &gt; &amp;</paramtype></parameter><purpose>Negation of the equality operator. </purpose></method>
<method name="operator+="><type><classname>histogram</classname> &amp;</type><template>
          <template-type-parameter name="A"/>
          <template-type-parameter name="S"/>
          <template-type-parameter name=""><default>std::enable_if_t&lt;detail::has_operator_radd&lt;                value_type, typename <classname alt="boost::histogram::histogram">histogram</classname>&lt;A, S&gt;::value_type&gt;::value&gt;</default></template-type-parameter>
        </template><parameter name="rhs"><paramtype>const <classname>histogram</classname>&lt; A, S &gt; &amp;</paramtype></parameter><purpose>Add values of another histogram. </purpose></method>
<method name="operator-="><type><classname>histogram</classname> &amp;</type><template>
          <template-type-parameter name="A"/>
          <template-type-parameter name="S"/>
          <template-type-parameter name=""><default>std::enable_if_t&lt;detail::has_operator_rsub&lt;                value_type, typename <classname alt="boost::histogram::histogram">histogram</classname>&lt;A, S&gt;::value_type&gt;::value&gt;</default></template-type-parameter>
        </template><parameter name="rhs"><paramtype>const <classname>histogram</classname>&lt; A, S &gt; &amp;</paramtype></parameter><purpose>Subtract values of another histogram. </purpose></method>
<method name="operator *="><type><classname>histogram</classname> &amp;</type><template>
          <template-type-parameter name="A"/>
          <template-type-parameter name="S"/>
          <template-type-parameter name=""><default>std::enable_if_t&lt;detail::has_operator_rmul&lt;                value_type, typename <classname alt="boost::histogram::histogram">histogram</classname>&lt;A, S&gt;::value_type&gt;::value&gt;</default></template-type-parameter>
        </template><parameter name="rhs"><paramtype>const <classname>histogram</classname>&lt; A, S &gt; &amp;</paramtype></parameter><purpose>Multiply by values of another histogram. </purpose></method>
<method name="operator/="><type><classname>histogram</classname> &amp;</type><template>
          <template-type-parameter name="A"/>
          <template-type-parameter name="S"/>
          <template-type-parameter name=""><default>std::enable_if_t&lt;detail::has_operator_rdiv&lt;                value_type, typename <classname alt="boost::histogram::histogram">histogram</classname>&lt;A, S&gt;::value_type&gt;::value&gt;</default></template-type-parameter>
        </template><parameter name="rhs"><paramtype>const <classname>histogram</classname>&lt; A, S &gt; &amp;</paramtype></parameter><purpose>Divide by values of another histogram. </purpose></method>
<method name="operator *="><type><classname>histogram</classname> &amp;</type><template>
          <template-type-parameter name="V"><default>value_type</default></template-type-parameter>
          <template-type-parameter name=""><default>std::enable_if_t&lt;detail::has_operator_rmul&lt;V, double&gt;::value&gt;</default></template-type-parameter>
        </template><parameter name="x"><paramtype>const double</paramtype></parameter><purpose>Multiply all values with a scalar. </purpose></method>
<method name="operator/="><type><classname>histogram</classname> &amp;</type><template>
          <template-type-parameter name="V"><default>value_type</default></template-type-parameter>
          <template-type-parameter name=""><default>std::enable_if_t&lt;detail::has_operator_rmul&lt;V, double&gt;::value&gt;</default></template-type-parameter>
        </template><parameter name="x"><paramtype>const double</paramtype></parameter><purpose>Divide all values by a scalar. </purpose></method>
<method name="begin" cv="noexcept"><type>iterator</type><purpose>Return value iterator to the beginning of the histogram. </purpose></method>
<method name="end" cv="noexcept"><type>iterator</type><purpose>Return value iterator to the end in the histogram. </purpose></method>
<method name="begin" cv="const noexcept"><type>const_iterator</type><purpose>Return value iterator to the beginning of the histogram (read-only). </purpose></method>
<method name="end" cv="const noexcept"><type>const_iterator</type><purpose>Return value iterator to the end in the histogram (read-only). </purpose></method>
<method name="cbegin" cv="const noexcept"><type>const_iterator</type><purpose>Return value iterator to the beginning of the histogram (read-only). </purpose></method>
<method name="cend" cv="const noexcept"><type>const_iterator</type><purpose>Return value iterator to the end in the histogram (read-only). </purpose></method>
</method-group>
<constructor cv="= default"/>
<constructor><parameter name="rhs"><paramtype>const <classname>histogram</classname> &amp;</paramtype></parameter></constructor>
<constructor><parameter name="rhs"><paramtype><classname>histogram</classname> &amp;&amp;</paramtype></parameter></constructor>
<copy-assignment><type><classname>histogram</classname> &amp;</type><parameter name="rhs"><paramtype><classname>histogram</classname> &amp;&amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>histogram</classname> &amp;</type><parameter name="rhs"><paramtype>const <classname>histogram</classname> &amp;</paramtype></parameter></copy-assignment>
<constructor specifiers="explicit"><template>
          <template-type-parameter name="A"/>
          <template-type-parameter name="S"/>
        </template><parameter name="rhs"><paramtype><classname>histogram</classname>&lt; A, S &gt; &amp;&amp;</paramtype></parameter></constructor>
<constructor specifiers="explicit"><template>
          <template-type-parameter name="A"/>
          <template-type-parameter name="S"/>
        </template><parameter name="rhs"><paramtype>const <classname>histogram</classname>&lt; A, S &gt; &amp;</paramtype></parameter></constructor>
<copy-assignment><type><classname>histogram</classname> &amp;</type><template>
          <template-type-parameter name="A"/>
          <template-type-parameter name="S"/>
        </template><parameter name="rhs"><paramtype><classname>histogram</classname>&lt; A, S &gt; &amp;&amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>histogram</classname> &amp;</type><template>
          <template-type-parameter name="A"/>
          <template-type-parameter name="S"/>
        </template><parameter name="rhs"><paramtype>const <classname>histogram</classname>&lt; A, S &gt; &amp;</paramtype></parameter></copy-assignment>
<constructor><template>
          <template-type-parameter name="A"/>
          <template-type-parameter name="S"/>
        </template><parameter name="a"><paramtype>A &amp;&amp;</paramtype></parameter><parameter name="s"><paramtype>S &amp;&amp;</paramtype></parameter></constructor>
<constructor specifiers="explicit"><template>
          <template-type-parameter name="A"/>
          <template-type-parameter name=""><default>detail::requires_axes&lt;A&gt;</default></template-type-parameter>
        </template><parameter name="a"><paramtype>A &amp;&amp;</paramtype></parameter></constructor>
</class><struct name="sample_type"><template>
      <template-type-parameter name="T"/>
    </template><data-member name="value"><type>T</type></data-member>
</struct><struct name="weight_type"><template>
      <template-type-parameter name="T"/>
    </template><data-member name="value"><type>T</type></data-member>
</struct>















<function name="operator+"><type>auto</type><template>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="S1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="S2"/>
        </template><parameter name="a"><paramtype>const <classname>histogram</classname>&lt; A1, S1 &gt; &amp;</paramtype></parameter><parameter name="b"><paramtype>const <classname>histogram</classname>&lt; A2, S2 &gt; &amp;</paramtype></parameter><purpose>Pairwise add cells of two histograms and return histogram with the sum. </purpose><description><para>The returned histogram type is the most efficient and safest one constructible from the inputs, if they are not the same type. If one histogram has a tuple axis, the result has a tuple axis. The chosen storage is the one with the larger dynamic range. </para></description></function>
<function name="operator*"><type>auto</type><template>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="S1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="S2"/>
        </template><parameter name="a"><paramtype>const <classname>histogram</classname>&lt; A1, S1 &gt; &amp;</paramtype></parameter><parameter name="b"><paramtype>const <classname>histogram</classname>&lt; A2, S2 &gt; &amp;</paramtype></parameter><purpose>Pairwise multiply cells of two histograms and return histogram with the product. </purpose><description><para>For notes on the returned histogram type, see operator+. </para></description></function>
<function name="operator-"><type>auto</type><template>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="S1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="S2"/>
        </template><parameter name="a"><paramtype>const <classname>histogram</classname>&lt; A1, S1 &gt; &amp;</paramtype></parameter><parameter name="b"><paramtype>const <classname>histogram</classname>&lt; A2, S2 &gt; &amp;</paramtype></parameter><purpose>Pairwise subtract cells of two histograms and return histogram with the difference. </purpose><description><para>For notes on the returned histogram type, see operator+. </para></description></function>
<function name="operator/"><type>auto</type><template>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="S1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="S2"/>
        </template><parameter name="a"><paramtype>const <classname>histogram</classname>&lt; A1, S1 &gt; &amp;</paramtype></parameter><parameter name="b"><paramtype>const <classname>histogram</classname>&lt; A2, S2 &gt; &amp;</paramtype></parameter><purpose>Pairwise divide cells of two histograms and return histogram with the quotient. </purpose><description><para>For notes on the returned histogram type, see operator+. </para></description></function>
<function name="operator*"><type>auto</type><template>
          <template-type-parameter name="A"/>
          <template-type-parameter name="S"/>
        </template><parameter name="h"><paramtype>const <classname>histogram</classname>&lt; A, S &gt; &amp;</paramtype></parameter><parameter name="x"><paramtype>double</paramtype></parameter><purpose>Multiply all cells of the histogram by a number and return a new histogram. </purpose><description><para>If the original histogram has integer cells, the result has double cells. </para></description></function>
<function name="operator*"><type>auto</type><template>
          <template-type-parameter name="A"/>
          <template-type-parameter name="S"/>
        </template><parameter name="x"><paramtype>double</paramtype></parameter><parameter name="h"><paramtype>const <classname>histogram</classname>&lt; A, S &gt; &amp;</paramtype></parameter><purpose>Multiply all cells of the histogram by a number and return a new histogram. </purpose><description><para>If the original histogram has integer cells, the result has double cells. </para></description></function>
<function name="operator/"><type>auto</type><template>
          <template-type-parameter name="A"/>
          <template-type-parameter name="S"/>
        </template><parameter name="h"><paramtype>const <classname>histogram</classname>&lt; A, S &gt; &amp;</paramtype></parameter><parameter name="x"><paramtype>double</paramtype></parameter><purpose>Divide all cells of the histogram by a number and return a new histogram. </purpose><description><para>If the original histogram has integer cells, the result has double cells. </para></description></function>
<function name="weight"><type>auto</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;&amp;</paramtype><description><para>argument to be forward to the histogram. </para></description></parameter><purpose>Helper function to mark argument as weight. </purpose><description><para>
</para></description></function>
<function name="sample"><type>auto</type><template>
          <template-nontype-parameter name="Ts"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="ts"><paramtype>Ts &amp;&amp;...</paramtype><description><para>arguments to be forwarded to the accumulator. </para></description></parameter><purpose>Helper function to mark arguments as sample. </purpose><description><para>
</para></description></function>
</namespace>
</namespace>
</header>
<header name="boost/histogram/accumulators.hpp">
</header>
<header name="boost/histogram/accumulators/mean.hpp">
<namespace name="boost">
<namespace name="histogram">
<namespace name="accumulators">
<class name="mean"><template>
      <template-type-parameter name="RealType"/>
    </template><purpose>Calculates mean and variance of sample. </purpose><description><para>Uses Welfords's incremental algorithm to improve the numerical stability of mean and variance computation. </para></description><method-group name="public member functions">
<method name="operator()"><type>void</type><parameter name="x"><paramtype>const RealType &amp;</paramtype></parameter></method>
<method name="operator+="><type><classname>mean</classname> &amp;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="rhs"><paramtype>const <classname>mean</classname>&lt; T &gt; &amp;</paramtype></parameter></method>
<method name="operator *="><type><classname>mean</classname> &amp;</type><parameter name="s"><paramtype>const RealType &amp;</paramtype></parameter></method>
<method name="operator==" cv="const noexcept"><type>bool</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="rhs"><paramtype>const <classname>mean</classname>&lt; T &gt; &amp;</paramtype></parameter></method>
<method name="operator!=" cv="const noexcept"><type>bool</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="rhs"><paramtype>const <classname>mean</classname>&lt; T &gt; &amp;</paramtype></parameter></method>
<method name="count" cv="const noexcept"><type>std::size_t</type></method>
<method name="value" cv="const noexcept"><type>const RealType &amp;</type></method>
<method name="variance" cv="const"><type>RealType</type></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name=""><paramtype>Archive &amp;</paramtype></parameter><parameter name=""><paramtype>unsigned</paramtype></parameter></method>
</method-group>
<constructor cv="= default"/>
<constructor><parameter name="n"><paramtype>const std::size_t</paramtype></parameter><parameter name="mean"><paramtype>const RealType &amp;</paramtype></parameter><parameter name="variance"><paramtype>const RealType &amp;</paramtype></parameter></constructor>
</class></namespace>

























</namespace>
</namespace>
</header>
<header name="boost/histogram/accumulators/sum.hpp">
<namespace name="boost">
<namespace name="histogram">
<namespace name="accumulators">
<class name="sum"><template>
      <template-type-parameter name="RealType"/>
    </template><purpose>Uses Neumaier algorithm to compute accurate sums. </purpose><description><para>The algorithm uses memory for two floats and is three to five times slower compared to a simple floating point number used to accumulate a sum, but the relative error of the sum is at the level of the machine precision, independent of the number of samples.</para><para>A. Neumaier, Zeitschrift fuer Angewandte Mathematik und Mechanik 54 (1974) 39-51. </para></description><method-group name="public member functions">
<method name="operator++"><type><classname>sum</classname> &amp;</type><purpose>Increment sum by one. </purpose></method>
<method name="operator+="><type><classname>sum</classname> &amp;</type><parameter name="value"><paramtype>const RealType &amp;</paramtype></parameter><purpose>Increment sum by value. </purpose></method>
<method name="operator *="><type><classname>sum</classname> &amp;</type><parameter name="value"><paramtype>const RealType &amp;</paramtype></parameter><purpose>Scale by value. </purpose></method>
<method name="operator==" cv="const noexcept"><type>bool</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="rhs"><paramtype>const <classname>sum</classname>&lt; T &gt; &amp;</paramtype></parameter></method>
<method name="operator!=" cv="const noexcept"><type>bool</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="rhs"><paramtype>const T &amp;</paramtype></parameter></method>
<method name="large" cv="const"><type>const RealType &amp;</type><purpose>Return large part of the sum. </purpose></method>
<method name="small" cv="const"><type>const RealType &amp;</type><purpose>Return small part of the sum. </purpose></method>
<method name="conversion-operator" cv="const"><type>RealType</type></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name=""><paramtype>Archive &amp;</paramtype></parameter><parameter name=""><paramtype>unsigned</paramtype></parameter></method>
</method-group>
<constructor cv="= default"/>
<constructor specifiers="explicit" cv="noexcept"><parameter name="value"><paramtype>const RealType &amp;</paramtype></parameter><purpose>Initialize sum to value. </purpose></constructor>
<copy-assignment cv="noexcept"><type><classname>sum</classname> &amp;</type><parameter name="value"><paramtype>const RealType &amp;</paramtype></parameter><purpose>Set sum to value. </purpose></copy-assignment>
</class></namespace>

























</namespace>
</namespace>
</header>
<header name="boost/histogram/algorithm/sum.hpp">
<namespace name="boost">
<namespace name="histogram">
<namespace name="algorithm">
<function name="sum"><type>auto</type><template>
          <template-type-parameter name="A"/>
          <template-type-parameter name="S"/>
        </template><parameter name="h"><paramtype>const <classname>histogram</classname>&lt; A, S &gt; &amp;</paramtype></parameter><purpose>Compute the sum over all histogram cells, including underflow/overflow bins. </purpose><description><para>If the value type of the histogram is an integral or floating point type, boost::accumulators::sum&lt;double&gt; is used to compute the sum, else the original value type is used. Compilation fails, if the value type does not support operator+=.</para><para>Return type is double if the value type of the histogram is integral or floating point, and the original value type otherwise. </para></description></function>














</namespace>

























</namespace>
</namespace>
</header>
<header name="boost/histogram/accumulators/thread_safe.hpp">
<namespace name="boost">
<namespace name="histogram">
<namespace name="accumulators">
<class name="thread_safe"><template>
      <template-type-parameter name="T"><purpose><para>type to adapt, must be supported by std::atomic. </para></purpose></template-type-parameter>
    </template><inherit access="public">std::atomic&lt; T &gt;</inherit><purpose>Thread-safe adaptor for builtin integral and floating point numbers. </purpose><description><para>This adaptor uses std::atomic to make concurrent increments and additions safe for the stored value.</para><para>On common computing platforms, the adapted integer has the same size and alignment as underlying type. The atomicity is implemented with a special CPU instruction. On exotic platforms the size of the adapted number may be larger and/or the type may have different alignment, which means it cannot be tightly packed into arrays.</para><para>
</para></description><typedef name="super_t"><type>std::atomic&lt; T &gt;</type></typedef>
<method-group name="public member functions">
<method name="operator+="><type>void</type><parameter name="arg"><paramtype>T</paramtype></parameter></method>
<method name="operator++"><type>void</type></method>
</method-group>
<constructor cv="noexcept"/>
<constructor cv="noexcept"><parameter name="o"><paramtype>const <classname>thread_safe</classname> &amp;</paramtype></parameter></constructor>
<copy-assignment cv="noexcept"><type><classname>thread_safe</classname> &amp;</type><parameter name="o"><paramtype>const <classname>thread_safe</classname> &amp;</paramtype></parameter></copy-assignment>
<constructor><parameter name="arg"><paramtype>T</paramtype></parameter></constructor>
<copy-assignment><type><classname>thread_safe</classname> &amp;</type><parameter name="arg"><paramtype>T</paramtype></parameter></copy-assignment>
</class></namespace>

























</namespace>
</namespace>
</header>
<header name="boost/histogram/accumulators/weighted_mean.hpp">
<namespace name="boost">
<namespace name="histogram">
<namespace name="accumulators">
<class name="weighted_mean"><template>
      <template-type-parameter name="RealType"/>
    </template><purpose>Calculates mean and variance of weighted sample. </purpose><description><para>Uses West's incremental algorithm to improve numerical stability of mean and variance computation. </para></description><method-group name="public member functions">
<method name="operator()"><type>void</type><parameter name="x"><paramtype>const RealType &amp;</paramtype></parameter></method>
<method name="operator()"><type>void</type><parameter name="w"><paramtype>const RealType &amp;</paramtype></parameter><parameter name="x"><paramtype>const RealType &amp;</paramtype></parameter></method>
<method name="operator+="><type><classname>weighted_mean</classname> &amp;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="rhs"><paramtype>const <classname>weighted_mean</classname>&lt; T &gt; &amp;</paramtype></parameter></method>
<method name="operator *="><type><classname>weighted_mean</classname> &amp;</type><parameter name="s"><paramtype>const RealType &amp;</paramtype></parameter></method>
<method name="operator==" cv="const noexcept"><type>bool</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="rhs"><paramtype>const <classname>weighted_mean</classname>&lt; T &gt; &amp;</paramtype></parameter></method>
<method name="operator!=" cv="const noexcept"><type>bool</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="rhs"><paramtype>const T &amp;</paramtype></parameter></method>
<method name="sum_of_weights" cv="const noexcept"><type>const RealType &amp;</type></method>
<method name="value" cv="const noexcept"><type>const RealType &amp;</type></method>
<method name="variance" cv="const"><type>RealType</type></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name=""><paramtype>Archive &amp;</paramtype></parameter><parameter name=""><paramtype>unsigned</paramtype></parameter></method>
</method-group>
<constructor cv="= default"/>
<constructor><parameter name="wsum"><paramtype>const RealType &amp;</paramtype></parameter><parameter name="wsum2"><paramtype>const RealType &amp;</paramtype></parameter><parameter name="mean"><paramtype>const RealType &amp;</paramtype></parameter><parameter name="variance"><paramtype>const RealType &amp;</paramtype></parameter></constructor>
</class></namespace>

























</namespace>
</namespace>
</header>
<header name="boost/histogram/accumulators/weighted_sum.hpp">
<namespace name="boost">
<namespace name="histogram">
<namespace name="accumulators">
<class name="weighted_sum"><template>
      <template-type-parameter name="RealType"/>
    </template><purpose>Holds sum of weights and its variance estimate. </purpose><method-group name="public member functions">
<method name="operator++"><type><classname>weighted_sum</classname> &amp;</type><purpose>Increment by one. </purpose></method>
<method name="operator+="><type><classname>weighted_sum</classname> &amp;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="value"><paramtype>const T &amp;</paramtype></parameter><purpose>Increment by value. </purpose></method>
<method name="operator+="><type><classname>weighted_sum</classname> &amp;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="rhs"><paramtype>const <classname>weighted_sum</classname>&lt; T &gt; &amp;</paramtype></parameter><purpose>Added another weighted sum. </purpose></method>
<method name="operator *="><type><classname>weighted_sum</classname> &amp;</type><parameter name="x"><paramtype>const RealType &amp;</paramtype></parameter><purpose>Scale by value. </purpose></method>
<method name="operator==" cv="const noexcept"><type>bool</type><parameter name="rhs"><paramtype>const RealType &amp;</paramtype></parameter></method>
<method name="operator==" cv="const noexcept"><type>bool</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="rhs"><paramtype>const <classname>weighted_sum</classname>&lt; T &gt; &amp;</paramtype></parameter></method>
<method name="operator!=" cv="const noexcept"><type>bool</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="rhs"><paramtype>const T &amp;</paramtype></parameter></method>
<method name="value" cv="const noexcept"><type>const RealType &amp;</type><purpose>Return value of the sum. </purpose></method>
<method name="variance" cv="const noexcept"><type>const RealType &amp;</type><purpose>Return estimated variance of the sum. </purpose></method>
<method name="conversion-operator" cv="const" specifiers="explicit"><type>T</type><template>
          <template-type-parameter name="T"/>
        </template></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name=""><paramtype>Archive &amp;</paramtype></parameter><parameter name=""><paramtype>unsigned</paramtype></parameter></method>
</method-group>
<constructor cv="= default"/>
<constructor specifiers="explicit" cv="noexcept"><parameter name="value"><paramtype>const RealType &amp;</paramtype></parameter></constructor>
<constructor cv="noexcept"><parameter name="value"><paramtype>const RealType &amp;</paramtype></parameter><parameter name="variance"><paramtype>const RealType &amp;</paramtype></parameter></constructor>
</class></namespace>

























</namespace>
</namespace>
</header>
<header name="boost/histogram/algorithm/project.hpp">
<namespace name="boost">
<namespace name="histogram">
<namespace name="algorithm">













<function name="project"><type>auto</type><template>
          <template-type-parameter name="A"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="N"><type>unsigned</type></template-nontype-parameter>
          <template-nontype-parameter name="Ns"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="h"><paramtype>const <classname>histogram</classname>&lt; A, S &gt; &amp;</paramtype></parameter><parameter name=""><paramtype>std::integral_constant&lt; unsigned, N &gt;</paramtype></parameter><parameter name=""><paramtype>Ns...</paramtype></parameter><purpose>Returns a lower-dimensional histogram, summing over removed axes. </purpose><description><para>Arguments are the source histogram and compile-time numbers, the remaining indices of the axes. Returns a new histogram which only contains the subset of axes. The source histogram is summed over the removed axes. </para></description></function>
<function name="project"><type>auto</type><template>
          <template-type-parameter name="A"/>
          <template-type-parameter name="S"/>
          <template-type-parameter name="Iterable"/>
          <template-type-parameter name=""><default>detail::requires_iterable&lt;Iterable&gt;</default></template-type-parameter>
        </template><parameter name="h"><paramtype>const <classname>histogram</classname>&lt; A, S &gt; &amp;</paramtype></parameter><parameter name="c"><paramtype>const Iterable &amp;</paramtype></parameter><purpose>Returns a lower-dimensional histogram, summing over removed axes. </purpose><description><para>This version accepts a source histogram and an iterable range containing the remaining indices. </para></description></function>
</namespace>

























</namespace>
</namespace>
</header>
<header name="boost/histogram/algorithm/reduce.hpp">
<namespace name="boost">
<namespace name="histogram">
<namespace name="algorithm">
<typedef name="reduce_option"><type><emphasis>unspecified</emphasis></type></typedef>

<function name="shrink_and_rebin"><type>reduce_option</type><parameter name="iaxis"><paramtype>unsigned</paramtype><description><para>which axis to operate on. </para></description></parameter><parameter name="lower"><paramtype>double</paramtype><description><para>lowest bound that should be kept. </para></description></parameter><parameter name="upper"><paramtype>double</paramtype><description><para>highest bound that should be kept. If upper is inside bin interval, the whole interval is removed. </para></description></parameter><parameter name="merge"><paramtype>unsigned</paramtype><description><para>how many adjacent bins to merge into one. </para></description></parameter><purpose>Shrink and rebin option to be used in reduce(). </purpose><description><para>To shrink and rebin in one command. Equivalent to passing both the shrink() and the rebin() option for the same axis to reduce.</para><para>
</para></description></function>
<function name="slice_and_rebin"><type>reduce_option</type><parameter name="iaxis"><paramtype>unsigned</paramtype><description><para>which axis to operate on. </para></description></parameter><parameter name="begin"><paramtype>axis::index_type</paramtype><description><para>first index that should be kept. </para></description></parameter><parameter name="end"><paramtype>axis::index_type</paramtype><description><para>one past the last index that should be kept. </para></description></parameter><parameter name="merge"><paramtype>unsigned</paramtype><description><para>how many adjacent bins to merge into one. </para></description></parameter><purpose>Slice and rebin option to be used in reduce(). </purpose><description><para>To slice and rebin in one command. Equivalent to passing both the slice() and the rebin() option for the same axis to reduce.</para><para>
</para></description></function>
<function name="shrink"><type>reduce_option</type><parameter name="iaxis"><paramtype>unsigned</paramtype><description><para>which axis to operate on. </para></description></parameter><parameter name="lower"><paramtype>double</paramtype><description><para>lowest bound that should be kept. </para></description></parameter><parameter name="upper"><paramtype>double</paramtype><description><para>highest bound that should be kept. If upper is inside bin interval, the whole interval is removed. </para></description></parameter><purpose>Shrink option to be used in reduce(). </purpose><description><para>
</para></description></function>
<function name="slice"><type>reduce_option</type><parameter name="iaxis"><paramtype>unsigned</paramtype><description><para>which axis to operate on. </para></description></parameter><parameter name="begin"><paramtype>axis::index_type</paramtype><description><para>first index that should be kept. </para></description></parameter><parameter name="end"><paramtype>axis::index_type</paramtype><description><para>one past the last index that should be kept. </para></description></parameter><purpose>Slice option to be used in reduce(). </purpose><description><para>
</para></description></function>
<function name="rebin"><type>reduce_option</type><parameter name="iaxis"><paramtype>unsigned</paramtype><description><para>which axis to operate on. </para></description></parameter><parameter name="merge"><paramtype>unsigned</paramtype><description><para>how many adjacent bins to merge into one. </para></description></parameter><purpose>Rebin option to be used in reduce(). </purpose><description><para>
</para></description></function>
<function name="shrink_and_rebin"><type>reduce_option</type><parameter name="lower"><paramtype>double</paramtype><description><para>lowest bound that should be kept. </para></description></parameter><parameter name="upper"><paramtype>double</paramtype><description><para>highest bound that should be kept. If upper is inside bin interval, the whole interval is removed. </para></description></parameter><parameter name="merge"><paramtype>unsigned</paramtype><description><para>how many adjacent bins to merge into one. </para></description></parameter><purpose>Shrink and rebin option to be used in reduce() (onvenience overload for single axis). </purpose><description><para>
</para></description></function>
<function name="slice_and_rebin"><type>reduce_option</type><parameter name="begin"><paramtype>axis::index_type</paramtype><description><para>first index that should be kept. </para></description></parameter><parameter name="end"><paramtype>axis::index_type</paramtype><description><para>one past the last index that should be kept. </para></description></parameter><parameter name="merge"><paramtype>unsigned</paramtype><description><para>how many adjacent bins to merge into one. </para></description></parameter><purpose>Slice and rebin option to be used in reduce() (convenience for 1D histograms). </purpose><description><para>
</para></description></function>
<function name="shrink"><type>reduce_option</type><parameter name="lower"><paramtype>double</paramtype><description><para>lowest bound that should be kept. </para></description></parameter><parameter name="upper"><paramtype>double</paramtype><description><para>highest bound that should be kept. If upper is inside bin interval, the whole interval is removed. </para></description></parameter><purpose>Shrink option to be used in reduce() (convenience for 1D histograms). </purpose><description><para>
</para></description></function>
<function name="slice"><type>reduce_option</type><parameter name="begin"><paramtype>axis::index_type</paramtype><description><para>first index that should be kept. </para></description></parameter><parameter name="end"><paramtype>axis::index_type</paramtype><description><para>one past the last index that should be kept. </para></description></parameter><purpose>Slice option to be used in reduce() (convenience for 1D histograms). </purpose><description><para>
</para></description></function>
<function name="rebin"><type>reduce_option</type><parameter name="merge"><paramtype>unsigned</paramtype><description><para>how many adjacent bins to merge into one. </para></description></parameter><purpose>Rebin option to be used in reduce() (convenience for 1D histograms). </purpose><description><para>
</para></description></function>
<function name="reduce"><type>decltype(auto)</type><template>
          <template-type-parameter name="Histogram"/>
          <template-type-parameter name="Iterable"/>
          <template-type-parameter name=""><default>detail::requires_iterable&lt;Iterable&gt;</default></template-type-parameter>
        </template><parameter name="hist"><paramtype>const Histogram &amp;</paramtype><description><para>original histogram. </para></description></parameter><parameter name="options"><paramtype>const Iterable &amp;</paramtype><description><para>iterable sequence of reduce options, generated by shrink_and_rebin(), slice_and_rebin(), shrink(), slice(), and rebin(). </para></description></parameter><purpose>Shrink, slice, and/or rebin axes of a histogram. </purpose><description><para>Returns the reduced copy of the histogram.</para><para>Shrinking only works with axes that accept double values. Some axis types do not support the reduce operation, for example, the builtin category axis, which is not ordered. Custom axis types must implement a special constructor (see concepts) to be reducible.</para><para>
</para></description></function>
<function name="reduce"><type>decltype(auto)</type><template>
          <template-type-parameter name="Histogram"/>
          <template-nontype-parameter name="Ts"><type>class...</type></template-nontype-parameter>
        </template><parameter name="hist"><paramtype>const Histogram &amp;</paramtype><description><para>original histogram. </para></description></parameter><parameter name="opt"><paramtype>const reduce_option &amp;</paramtype><description><para>reduce option generated by shrink_and_rebin(), shrink(), and rebin(). </para></description></parameter><parameter name="opts"><paramtype>const Ts &amp;...</paramtype><description><para>more reduce options. </para></description></parameter><purpose>Shrink, slice, and/or rebin axes of a histogram. </purpose><description><para>Returns the reduced copy of the histogram.</para><para>Shrinking only works with axes that accept double values. Some axis types do not support the reduce operation, for example, the builtin category axis, which is not ordered. Custom axis types must implement a special constructor (see concepts) to be reducible.</para><para>
</para></description></function>


</namespace>

























</namespace>
</namespace>
</header>
<header name="boost/histogram/axis.hpp">
</header>
<header name="boost/histogram/axis/category.hpp">
<namespace name="boost">
<namespace name="histogram">
<namespace name="axis">
<class name="category"><template>
      <template-type-parameter name="Value"><purpose><para>input value type, must be equal-comparable. </para></purpose></template-type-parameter>
      <template-type-parameter name="MetaData"><purpose><para>type to store meta data. </para></purpose></template-type-parameter>
      <template-type-parameter name="Options"><purpose><para>see boost::histogram::axis::option. </para></purpose></template-type-parameter>
      <template-type-parameter name="Allocator"><purpose><para>allocator to use for dynamic memory management.</para></purpose></template-type-parameter>
    </template><inherit access="public">boost::histogram::axis::iterator_mixin&lt; category&lt; Value, MetaData, Options, Allocator &gt; &gt;</inherit><purpose>Maps at a set of unique values to bin indices. </purpose><description><para>The axis maps a set of values to bins, following the order of arguments in the constructor. The optional overflow bin for this axis counts input values that are not part of the set. Binning has O(N) complexity, but with a very small factor. For small N (the typical use case) it beats other kinds of lookup.</para><para>
The options <computeroutput>underflow</computeroutput> and <computeroutput>circular</computeroutput> are not allowed. The options <computeroutput>growth</computeroutput> and <computeroutput>overflow</computeroutput> are mutually exclusive. </para></description><method-group name="public member functions">
<method name="index" cv="const noexcept"><type>index_type</type><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><purpose>Return index for value argument. </purpose></method>
<method name="update"><type>auto</type><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><purpose>Returns index and shift (if axis has grown) for the passed argument. </purpose></method>
<method name="value" cv="const"><type>decltype(auto)</type><parameter name="idx"><paramtype>index_type</paramtype></parameter><purpose>Return value for index argument. </purpose><description><para>Throws <computeroutput>std::out_of_range</computeroutput> if the index is out of bounds. </para></description></method>
<method name="bin" cv="const noexcept"><type>decltype(auto)</type><parameter name="idx"><paramtype>index_type</paramtype></parameter><purpose>Return value for index argument. </purpose></method>
<method name="size" cv="const noexcept"><type>index_type</type><purpose>Returns the number of bins, without over- or underflow. </purpose></method>
<method name="metadata" cv="noexcept"><type>metadata_type &amp;</type><purpose>Returns reference to metadata. </purpose></method>
<method name="metadata" cv="const noexcept"><type>const metadata_type &amp;</type><purpose>Returns reference to const metadata. </purpose></method>
<method name="operator==" cv="const noexcept"><type>bool</type><template>
          <template-type-parameter name="V"/>
          <template-type-parameter name="M"/>
          <template-type-parameter name="O"/>
          <template-type-parameter name="A"/>
        </template><parameter name="o"><paramtype>const <classname>category</classname>&lt; V, M, O, A &gt; &amp;</paramtype></parameter></method>
<method name="operator!=" cv="const noexcept"><type>bool</type><template>
          <template-type-parameter name="V"/>
          <template-type-parameter name="M"/>
          <template-type-parameter name="O"/>
          <template-type-parameter name="A"/>
        </template><parameter name="o"><paramtype>const <classname>category</classname>&lt; V, M, O, A &gt; &amp;</paramtype></parameter></method>
<method name="get_allocator" cv="const"><type>auto</type></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name=""><paramtype>Archive &amp;</paramtype></parameter><parameter name=""><paramtype>unsigned</paramtype></parameter></method>
</method-group>
<constructor specifiers="explicit"><parameter name="alloc"><paramtype>allocator_type</paramtype><default>{}</default></parameter></constructor>
<constructor cv="= default"><parameter name=""><paramtype>const <classname>category</classname> &amp;</paramtype></parameter></constructor>
<copy-assignment cv="= default"><type><classname>category</classname> &amp;</type><parameter name=""><paramtype>const <classname>category</classname> &amp;</paramtype></parameter></copy-assignment>
<constructor cv="noexcept"><parameter name="o"><paramtype><classname>category</classname> &amp;&amp;</paramtype></parameter></constructor>
<copy-assignment cv="noexcept"><type><classname>category</classname> &amp;</type><parameter name="o"><paramtype><classname>category</classname> &amp;&amp;</paramtype></parameter></copy-assignment>
<constructor><template>
          <template-type-parameter name="It"/>
          <template-type-parameter name=""><default>detail::requires_iterator&lt;It&gt;</default></template-type-parameter>
        </template><parameter name="begin"><paramtype>It</paramtype><description><para>begin of category range of unique values. </para></description></parameter><parameter name="end"><paramtype>It</paramtype><description><para>end of category range of unique values. </para></description></parameter><parameter name="meta"><paramtype>metadata_type</paramtype><default>{}</default><description><para>description of the axis. </para></description></parameter><parameter name="alloc"><paramtype>allocator_type</paramtype><default>{}</default><description><para>allocator instance to use. </para></description></parameter><purpose>Construct from iterator range of unique values. </purpose><description><para>
</para></description></constructor>
<constructor><template>
          <template-type-parameter name="C"/>
          <template-type-parameter name=""><default>detail::requires_iterable&lt;C&gt;</default></template-type-parameter>
        </template><parameter name="iterable"><paramtype>const C &amp;</paramtype><description><para>sequence of unique values. </para></description></parameter><parameter name="meta"><paramtype>metadata_type</paramtype><default>{}</default><description><para>description of the axis. </para></description></parameter><parameter name="alloc"><paramtype>allocator_type</paramtype><default>{}</default><description><para>allocator instance to use. </para></description></parameter><purpose>Construct axis from iterable sequence of unique values. </purpose><description><para>
</para></description></constructor>
<constructor><template>
          <template-type-parameter name="U"/>
        </template><parameter name="list"><paramtype>std::initializer_list&lt; U &gt;</paramtype><description><para><computeroutput>std::initializer_list</computeroutput> of unique values. </para></description></parameter><parameter name="meta"><paramtype>metadata_type</paramtype><default>{}</default><description><para>description of the axis. </para></description></parameter><parameter name="alloc"><paramtype>allocator_type</paramtype><default>{}</default><description><para>allocator instance to use. </para></description></parameter><purpose>Construct axis from an initializer list of unique values. </purpose><description><para>
</para></description></constructor>
<method-group name="public static functions">
<method name="options" cv="noexcept" specifiers="static"><type>constexpr unsigned</type><purpose>Returns the options. </purpose></method>
</method-group>
</class>











</namespace>

























</namespace>
</namespace>
</header>
<header name="boost/histogram/axis/integer.hpp">
<namespace name="boost">
<namespace name="histogram">
<namespace name="axis">
<class name="integer"><template>
      <template-type-parameter name="Value"><purpose><para>input value type. Must be integer or floating point. </para></purpose></template-type-parameter>
      <template-type-parameter name="MetaData"><purpose><para>type to store meta data. </para></purpose></template-type-parameter>
      <template-type-parameter name="Options"><purpose><para>see boost::histogram::axis::option (all values allowed). </para></purpose></template-type-parameter>
    </template><inherit access="public">boost::histogram::axis::iterator_mixin&lt; integer&lt; Value, MetaData, Options &gt; &gt;</inherit><purpose>Axis for an interval of integer values with unit steps. </purpose><description><para>Binning is a O(1) operation. This axis bins faster than a regular axis.</para><para>
</para></description><method-group name="public member functions">
<method name="index" cv="const noexcept"><type>index_type</type><parameter name="x"><paramtype>value_type</paramtype></parameter><purpose>Return index for value argument. </purpose></method>
<method name="update" cv="noexcept"><type>auto</type><parameter name="x"><paramtype>value_type</paramtype></parameter><purpose>Returns index and shift (if axis has grown) for the passed argument. </purpose></method>
<method name="value" cv="const noexcept"><type>value_type</type><parameter name="i"><paramtype>local_index_type</paramtype></parameter><purpose>Return value for index argument. </purpose></method>
<method name="bin" cv="const noexcept"><type>decltype(auto)</type><parameter name="idx"><paramtype>index_type</paramtype></parameter><purpose>Return bin for index argument. </purpose></method>
<method name="size" cv="const noexcept"><type>index_type</type><purpose>Returns the number of bins, without over- or underflow. </purpose></method>
<method name="metadata" cv="noexcept"><type>metadata_type &amp;</type><purpose>Returns reference to metadata. </purpose></method>
<method name="metadata" cv="const noexcept"><type>const metadata_type &amp;</type><purpose>Returns reference to const metadata. </purpose></method>
<method name="operator==" cv="const noexcept"><type>bool</type><template>
          <template-type-parameter name="V"/>
          <template-type-parameter name="M"/>
          <template-type-parameter name="O"/>
        </template><parameter name="o"><paramtype>const <classname>integer</classname>&lt; V, M, O &gt; &amp;</paramtype></parameter></method>
<method name="operator!=" cv="const noexcept"><type>bool</type><template>
          <template-type-parameter name="V"/>
          <template-type-parameter name="M"/>
          <template-type-parameter name="O"/>
        </template><parameter name="o"><paramtype>const <classname>integer</classname>&lt; V, M, O &gt; &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name=""><paramtype>Archive &amp;</paramtype></parameter><parameter name=""><paramtype>unsigned</paramtype></parameter></method>
</method-group>
<constructor cv="= default"/>
<constructor cv="= default"><parameter name=""><paramtype>const <classname>integer</classname> &amp;</paramtype></parameter></constructor>
<copy-assignment cv="= default"><type><classname>integer</classname> &amp;</type><parameter name=""><paramtype>const <classname>integer</classname> &amp;</paramtype></parameter></copy-assignment>
<constructor cv="noexcept"><parameter name="o"><paramtype><classname>integer</classname> &amp;&amp;</paramtype></parameter></constructor>
<copy-assignment cv="noexcept"><type><classname>integer</classname> &amp;</type><parameter name="o"><paramtype><classname>integer</classname> &amp;&amp;</paramtype></parameter></copy-assignment>
<constructor><parameter name="start"><paramtype>value_type</paramtype><description><para>first integer of covered range. </para></description></parameter><parameter name="stop"><paramtype>value_type</paramtype><description><para>one past last integer of covered range. </para></description></parameter><parameter name="meta"><paramtype>metadata_type</paramtype><default>{}</default><description><para>description of the axis. </para></description></parameter><purpose>Construct over semi-open integer interval [start, stop). </purpose><description><para>
</para></description></constructor>
<constructor><parameter name="src"><paramtype>const <classname>integer</classname> &amp;</paramtype></parameter><parameter name="begin"><paramtype>index_type</paramtype></parameter><parameter name="end"><paramtype>index_type</paramtype></parameter><parameter name="merge"><paramtype>unsigned</paramtype></parameter><purpose>Constructor used by algorithm::reduce to shrink and rebin. </purpose></constructor>
<method-group name="public static functions">
<method name="options" cv="noexcept" specifiers="static"><type>constexpr unsigned</type><purpose>Returns the options. </purpose></method>
</method-group>
<method-group name="private member functions">
<method name="index_impl" cv="const noexcept"><type>index_type</type><parameter name=""><paramtype>std::false_type</paramtype></parameter><parameter name="x"><paramtype>int</paramtype></parameter></method>
<method name="index_impl" cv="const noexcept"><type>index_type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype>std::true_type</paramtype></parameter><parameter name="x"><paramtype>T</paramtype></parameter></method>
</method-group>
</class>











</namespace>

























</namespace>
</namespace>
</header>
<header name="boost/histogram/axis/interval_view.hpp">
<namespace name="boost">
<namespace name="histogram">
<namespace name="axis">
<class name="interval_view"><template>
      <template-type-parameter name="Axis"/>
    </template><purpose>Lightweight bin view. </purpose><description><para>Represents the current bin interval. </para></description><method-group name="public member functions">
<method name="lower" cv="const noexcept"><type>decltype(auto)</type><purpose>Return lower edge of bin. </purpose></method>
<method name="upper" cv="const noexcept"><type>decltype(auto)</type><purpose>Return upper edge of bin. </purpose></method>
<method name="center" cv="const noexcept"><type>decltype(auto)</type><purpose>Return center of bin. </purpose></method>
<method name="width" cv="const noexcept"><type>decltype(auto)</type><purpose>Return width of bin. </purpose></method>
<method name="operator==" cv="const noexcept"><type>bool</type><template>
          <template-type-parameter name="BinType"/>
        </template><parameter name="rhs"><paramtype>const BinType &amp;</paramtype></parameter></method>
<method name="operator!=" cv="const noexcept"><type>bool</type><template>
          <template-type-parameter name="BinType"/>
        </template><parameter name="rhs"><paramtype>const BinType &amp;</paramtype></parameter></method>
</method-group>
<constructor><parameter name="axis"><paramtype>const Axis &amp;</paramtype></parameter><parameter name="idx"><paramtype>int</paramtype></parameter></constructor>
<constructor cv="= delete"><parameter name="axis"><paramtype>Axis &amp;&amp;</paramtype></parameter><parameter name="idx"><paramtype>int</paramtype></parameter></constructor>
</class>











</namespace>

























</namespace>
</namespace>
</header>
<header name="boost/histogram/axis/iterator.hpp">
<namespace name="boost">
<namespace name="histogram">
<namespace name="axis">
<class name="iterator"><template>
      <template-type-parameter name="Axis"/>
    </template><method-group name="public member functions">
<method name="operator *" cv="const"><type>decltype(auto)</type><purpose>Return current bin object. </purpose></method>
</method-group>
<constructor><parameter name="axis"><paramtype>const Axis &amp;</paramtype></parameter><parameter name="idx"><paramtype>int</paramtype></parameter><purpose>Make iterator from axis and index. </purpose></constructor>
</class><class name="iterator_mixin"><template>
      <template-type-parameter name="Derived"/>
    </template><purpose>Uses CRTP to inject iterator logic into Derived. </purpose><typedef name="const_iterator"><type>iterator&lt; Derived &gt;</type></typedef>
<typedef name="const_reverse_iterator"><type>std::reverse_iterator&lt; const_iterator &gt;</type></typedef>
<method-group name="public member functions">
<method name="begin" cv="const noexcept"><type>const_iterator</type><purpose>Bin iterator to beginning of the axis (read-only). </purpose></method>
<method name="end" cv="const noexcept"><type>const_iterator</type><purpose>Bin iterator to the end of the axis (read-only). </purpose></method>
<method name="rbegin" cv="const noexcept"><type>const_reverse_iterator</type><purpose>Reverse bin iterator to the last entry of the axis (read-only). </purpose></method>
<method name="rend" cv="const noexcept"><type>const_reverse_iterator</type><purpose>Reverse bin iterator to the end (read-only). </purpose></method>
</method-group>
</class>











</namespace>

























</namespace>
</namespace>
</header>
<header name="boost/histogram/axis/option.hpp">
<para>Options for builtin axis types. </para><para>Options <computeroutput>circular</computeroutput> and <computeroutput>growth</computeroutput> are mutually exclusive. Options <computeroutput>circular</computeroutput> and <computeroutput>underflow</computeroutput> are mutually exclusive. </para><namespace name="boost">
<namespace name="histogram">
<namespace name="axis">
<namespace name="option">
<struct name="bit"><template>
      <template-nontype-parameter name="Pos"><type>unsigned</type><purpose><para>position of the bit in the set. </para></purpose></template-nontype-parameter>
    </template><inherit access="public">boost::histogram::axis::option::bitset&lt;(1&lt;&lt; Pos)&gt;</inherit><purpose>Single option flag. </purpose><description><para>
</para></description></struct><struct name="bitset"><template>
      <template-nontype-parameter name="Bits"><type>unsigned</type></template-nontype-parameter>
    </template><inherit access="public">std::integral_constant&lt; unsigned, Bits &gt;</inherit><purpose>Holder of axis options. </purpose><method-group name="public static functions">
<method name="test" specifiers="static"><type>constexpr auto</type><template>
          <template-nontype-parameter name="B"><type>unsigned</type></template-nontype-parameter>
        </template><parameter name=""><paramtype><classname>bitset</classname>&lt; B &gt;</paramtype></parameter><purpose>Returns true if all option flags in the argument are set and false otherwise. </purpose></method>
</method-group>
</struct><typedef name="none_t"><purpose>All options off. </purpose><type><classname>bitset</classname>&lt; 0 &gt;</type></typedef>
<typedef name="underflow_t"><purpose>Axis has an underflow bin. Mutually exclusive with <computeroutput>circular</computeroutput>. </purpose><type><classname>bit</classname>&lt; 0 &gt;</type></typedef>
<typedef name="overflow_t"><purpose>Axis has overflow bin. </purpose><type><classname>bit</classname>&lt; 1 &gt;</type></typedef>
<typedef name="circular_t"><purpose>Axis is circular. Mutually exclusive with <computeroutput>growth</computeroutput> and <computeroutput>underflow</computeroutput>. </purpose><type><classname>bit</classname>&lt; 2 &gt;</type></typedef>
<typedef name="growth_t"><purpose>Axis can grow. Mutually exclusive with <computeroutput>circular</computeroutput>. </purpose><type><classname>bit</classname>&lt; 3 &gt;</type></typedef>
<data-member name="none"><type>constexpr none_t</type><purpose>Instance of <computeroutput>none_t</computeroutput>. </purpose></data-member>
<data-member name="underflow"><type>constexpr underflow_t</type><purpose>Instance of <computeroutput>underflow_t</computeroutput>. </purpose></data-member>
<data-member name="overflow"><type>constexpr overflow_t</type><purpose>Instance of <computeroutput>overflow_t</computeroutput>. </purpose></data-member>
<data-member name="circular"><type>constexpr circular_t</type><purpose>Instance of <computeroutput>circular_t</computeroutput>. </purpose></data-member>
<data-member name="growth"><type>constexpr growth_t</type><purpose>Instance of <computeroutput>growth_t</computeroutput>. </purpose></data-member>
<function name="operator|"><type>constexpr auto</type><template>
          <template-nontype-parameter name="B1"><type>unsigned</type></template-nontype-parameter>
          <template-nontype-parameter name="B2"><type>unsigned</type></template-nontype-parameter>
        </template><parameter name=""><paramtype><classname>bitset</classname>&lt; B1 &gt;</paramtype></parameter><parameter name=""><paramtype><classname>bitset</classname>&lt; B2 &gt;</paramtype></parameter><purpose>Set union of the axis option arguments. </purpose></function>
<function name="operator&amp;"><type>constexpr auto</type><template>
          <template-nontype-parameter name="B1"><type>unsigned</type></template-nontype-parameter>
          <template-nontype-parameter name="B2"><type>unsigned</type></template-nontype-parameter>
        </template><parameter name=""><paramtype><classname>bitset</classname>&lt; B1 &gt;</paramtype></parameter><parameter name=""><paramtype><classname>bitset</classname>&lt; B2 &gt;</paramtype></parameter><purpose>Set intersection of the option arguments. </purpose></function>
<function name="operator-"><type>constexpr auto</type><template>
          <template-nontype-parameter name="B1"><type>unsigned</type></template-nontype-parameter>
          <template-nontype-parameter name="B2"><type>unsigned</type></template-nontype-parameter>
        </template><parameter name=""><paramtype><classname>bitset</classname>&lt; B1 &gt;</paramtype></parameter><parameter name=""><paramtype><classname>bitset</classname>&lt; B2 &gt;</paramtype></parameter><purpose>Set difference of the option arguments. </purpose></function>
</namespace>












</namespace>

























</namespace>
</namespace>
</header>
<header name="boost/histogram/axis/polymorphic_bin.hpp">
<namespace name="boost">
<namespace name="histogram">
<namespace name="axis">
<class name="polymorphic_bin"><template>
      <template-type-parameter name="RealType"/>
    </template><purpose>Holds the bin data of an <classname alt="boost::histogram::axis::variant">axis::variant</classname>. </purpose><description><para>The interface is a superset of the <classname alt="boost::histogram::axis::interval_view">axis::interval_view</classname> class. In addition, the object is implicitly convertible to the value type, returning the equivalent of a call to lower(). For discrete axes, lower() == upper(), and width() returns zero.</para><para>This is not a view like <classname alt="boost::histogram::axis::interval_view">axis::interval_view</classname> for two reasons.<itemizedlist>
<listitem><para>Sequential calls to lower() and upper() would have to each loop through the variant types. This is likely to be slower than filling all the data in one loop.</para>
</listitem><listitem><para><classname alt="boost::histogram::axis::polymorphic_bin">polymorphic_bin</classname> may be created from a temporary instance of <classname alt="boost::histogram::axis::variant">axis::variant</classname>, like in the call histogram::axis(0). Storing a reference to the axis would result in a dangling reference. Rather than specialing the code to handle this, it seems easier to just use a value instead of a view. </para>
</listitem></itemizedlist>
</para></description><method-group name="public member functions">
<method name="conversion-operator" cv="const noexcept"><type>const value_type &amp;</type><purpose>Implicitly convert to bin value (for axis with discrete values). </purpose></method>
<method name="lower" cv="const noexcept"><type>value_type</type><purpose>Return lower edge of bin. </purpose></method>
<method name="upper" cv="const noexcept"><type>value_type</type><purpose>Return upper edge of bin. </purpose></method>
<method name="center" cv="const noexcept"><type>value_type</type><purpose>Return center of bin. </purpose></method>
<method name="width" cv="const noexcept"><type>value_type</type><purpose>Return width of bin. </purpose></method>
<method name="operator==" cv="const noexcept"><type>bool</type><template>
          <template-type-parameter name="BinType"/>
        </template><parameter name="rhs"><paramtype>const BinType &amp;</paramtype></parameter></method>
<method name="operator!=" cv="const noexcept"><type>bool</type><template>
          <template-type-parameter name="BinType"/>
        </template><parameter name="rhs"><paramtype>const BinType &amp;</paramtype></parameter></method>
<method name="is_discrete" cv="const noexcept"><type>bool</type><purpose>Return true if bin is discrete. </purpose></method>
</method-group>
<constructor><parameter name="lower"><paramtype>value_type</paramtype></parameter><parameter name="upper"><paramtype>value_type</paramtype></parameter></constructor>
<method-group name="private member functions">
<method name="equal_impl" cv="const noexcept"><type>bool</type><parameter name=""><paramtype>std::true_type</paramtype></parameter><parameter name="rhs"><paramtype>const <classname>polymorphic_bin</classname> &amp;</paramtype></parameter></method>
<method name="equal_impl" cv="const noexcept"><type>bool</type><template>
          <template-type-parameter name="BinType"/>
        </template><parameter name=""><paramtype>std::true_type</paramtype></parameter><parameter name="rhs"><paramtype>const BinType &amp;</paramtype></parameter></method>
<method name="equal_impl" cv="const noexcept"><type>bool</type><template>
          <template-type-parameter name="BinType"/>
        </template><parameter name=""><paramtype>std::false_type</paramtype></parameter><parameter name="rhs"><paramtype>const BinType &amp;</paramtype></parameter></method>
</method-group>
</class>











</namespace>

























</namespace>
</namespace>
</header>
<header name="boost/histogram/axis/regular.hpp">
<namespace name="boost">
<namespace name="histogram">
<namespace name="axis">
<class name="circular"><template>
      <template-type-parameter name="Value"><default>double</default></template-type-parameter>
      <template-type-parameter name="MetaData"><default>use_default</default></template-type-parameter>
      <template-type-parameter name="Options"><default>use_default</default></template-type-parameter>
    </template><purpose>Regular axis with circular option already set. </purpose></class><class name="regular"><template>
      <template-type-parameter name="Value"><purpose><para>input value type, must be floating point. </para></purpose></template-type-parameter>
      <template-type-parameter name="Transform"><purpose><para>builtin or user-defined transform type. </para></purpose></template-type-parameter>
      <template-type-parameter name="MetaData"><purpose><para>type to store meta data. </para></purpose></template-type-parameter>
      <template-type-parameter name="Options"><purpose><para>see boost::histogram::axis::option (all values allowed). </para></purpose></template-type-parameter>
    </template><inherit access="public">boost::histogram::axis::iterator_mixin&lt; regular&lt; Value, Transform, MetaData, Options &gt; &gt;</inherit><purpose>Axis for equidistant intervals on the real line. </purpose><description><para>The most common binning strategy. Very fast. Binning is a O(1) operation.</para><para>
</para></description><method-group name="public member functions">
<method name="transform" cv="const noexcept"><type>const transform_type &amp;</type><purpose>Return instance of the transform type. </purpose></method>
<method name="index" cv="const noexcept"><type>index_type</type><parameter name="x"><paramtype>value_type</paramtype></parameter><purpose>Return index for value argument. </purpose></method>
<method name="update" cv="noexcept"><type>auto</type><parameter name="x"><paramtype>value_type</paramtype></parameter><purpose>Returns index and shift (if axis has grown) for the passed argument. </purpose></method>
<method name="value" cv="const noexcept"><type>value_type</type><parameter name="i"><paramtype>real_index_type</paramtype></parameter><purpose>Return value for fractional index argument. </purpose></method>
<method name="bin" cv="const noexcept"><type>decltype(auto)</type><parameter name="idx"><paramtype>index_type</paramtype></parameter><purpose>Return bin for index argument. </purpose></method>
<method name="size" cv="const noexcept"><type>index_type</type><purpose>Returns the number of bins, without over- or underflow. </purpose></method>
<method name="metadata" cv="noexcept"><type>metadata_type &amp;</type><purpose>Returns reference to metadata. </purpose></method>
<method name="metadata" cv="const noexcept"><type>const metadata_type &amp;</type><purpose>Returns reference to const metadata. </purpose></method>
<method name="operator==" cv="const noexcept"><type>bool</type><template>
          <template-type-parameter name="V"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="M"/>
          <template-type-parameter name="O"/>
        </template><parameter name="o"><paramtype>const <classname>regular</classname>&lt; V, T, M, O &gt; &amp;</paramtype></parameter></method>
<method name="operator!=" cv="const noexcept"><type>bool</type><template>
          <template-type-parameter name="V"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="M"/>
          <template-type-parameter name="O"/>
        </template><parameter name="o"><paramtype>const <classname>regular</classname>&lt; V, T, M, O &gt; &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name=""><paramtype>Archive &amp;</paramtype></parameter><parameter name=""><paramtype>unsigned</paramtype></parameter></method>
</method-group>
<constructor cv="= default"/>
<constructor cv="= default"><parameter name=""><paramtype>const <classname>regular</classname> &amp;</paramtype></parameter></constructor>
<copy-assignment cv="= default"><type><classname>regular</classname> &amp;</type><parameter name=""><paramtype>const <classname>regular</classname> &amp;</paramtype></parameter></copy-assignment>
<constructor cv="noexcept"><parameter name="o"><paramtype><classname>regular</classname> &amp;&amp;</paramtype></parameter></constructor>
<copy-assignment cv="noexcept"><type><classname>regular</classname> &amp;</type><parameter name="o"><paramtype><classname>regular</classname> &amp;&amp;</paramtype></parameter></copy-assignment>
<constructor><parameter name="trans"><paramtype>transform_type</paramtype><description><para>transform instance to use. </para></description></parameter><parameter name="n"><paramtype>unsigned</paramtype><description><para>number of bins. </para></description></parameter><parameter name="start"><paramtype>value_type</paramtype><description><para>low edge of first bin. </para></description></parameter><parameter name="stop"><paramtype>value_type</paramtype><description><para>high edge of last bin. </para></description></parameter><parameter name="meta"><paramtype>metadata_type</paramtype><default>{}</default><description><para>description of the axis (optional). </para></description></parameter><purpose>Construct n bins over real transformed range [start, stop). </purpose><description><para>
</para></description></constructor>
<constructor><parameter name="n"><paramtype>unsigned</paramtype><description><para>number of bins. </para></description></parameter><parameter name="start"><paramtype>value_type</paramtype><description><para>low edge of first bin. </para></description></parameter><parameter name="stop"><paramtype>value_type</paramtype><description><para>high edge of last bin. </para></description></parameter><parameter name="meta"><paramtype>metadata_type</paramtype><default>{}</default><description><para>description of the axis (optional). </para></description></parameter><purpose>Construct n bins over real range [start, stop). </purpose><description><para>
</para></description></constructor>
<constructor><template>
          <template-type-parameter name="T"/>
        </template><parameter name="trans"><paramtype>transform_type</paramtype><description><para>transform instance to use. </para></description></parameter><parameter name="step"><paramtype>const step_type&lt; T &gt; &amp;</paramtype><description><para>width of a single bin. </para></description></parameter><parameter name="start"><paramtype>value_type</paramtype><description><para>low edge of first bin. </para></description></parameter><parameter name="stop"><paramtype>value_type</paramtype><description><para>upper limit of high edge of last bin (see below). </para></description></parameter><parameter name="meta"><paramtype>metadata_type</paramtype><default>{}</default><description><para>description of the axis (optional).</para></description></parameter><purpose>Construct bins with the given step size over real transformed range [start, stop). </purpose><description><para>
The axis computes the number of bins as n = abs(stop - start) / step, rounded down. This means that stop is an upper limit to the actual value (start + n * step). </para></description></constructor>
<constructor><template>
          <template-type-parameter name="T"/>
        </template><parameter name="step"><paramtype>const step_type&lt; T &gt; &amp;</paramtype><description><para>width of a single bin. </para></description></parameter><parameter name="start"><paramtype>value_type</paramtype><description><para>low edge of first bin. </para></description></parameter><parameter name="stop"><paramtype>value_type</paramtype><description><para>upper limit of high edge of last bin (see below). </para></description></parameter><parameter name="meta"><paramtype>metadata_type</paramtype><default>{}</default><description><para>description of the axis (optional).</para></description></parameter><purpose>Construct bins with the given step size over real range [start, stop). </purpose><description><para>
The axis computes the number of bins as n = abs(stop - start) / step, rounded down. This means that stop is an upper limit to the actual value (start + n * step). </para></description></constructor>
<constructor><parameter name="src"><paramtype>const <classname>regular</classname> &amp;</paramtype></parameter><parameter name="begin"><paramtype>index_type</paramtype></parameter><parameter name="end"><paramtype>index_type</paramtype></parameter><parameter name="merge"><paramtype>unsigned</paramtype></parameter><purpose>Constructor used by algorithm::reduce to shrink and rebin (not for users). </purpose></constructor>
<method-group name="public static functions">
<method name="options" cv="noexcept" specifiers="static"><type>constexpr unsigned</type><purpose>Returns the options. </purpose></method>
</method-group>
</class><namespace name="transform">
<struct name="id"><purpose>Identity transform for equidistant bins. </purpose><method-group name="public static functions">
<method name="forward" cv="noexcept" specifiers="static"><type>T</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="x"><paramtype>T &amp;&amp;</paramtype></parameter><purpose>Pass-through. </purpose></method>
<method name="inverse" cv="noexcept" specifiers="static"><type>T</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="x"><paramtype>T &amp;&amp;</paramtype></parameter><purpose>Pass-through. </purpose></method>
</method-group>
</struct><struct name="log"><purpose>Log transform for equidistant bins in log-space. </purpose><method-group name="public static functions">
<method name="forward" specifiers="static"><type>T</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="x"><paramtype>T</paramtype></parameter><purpose>Returns log(x) of external value x. </purpose></method>
<method name="inverse" specifiers="static"><type>T</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="x"><paramtype>T</paramtype></parameter><purpose>Returns exp(x) for internal value x. </purpose></method>
</method-group>
</struct><struct name="pow"><purpose>Pow transform for equidistant bins in pow-space. </purpose><data-member name="power"><type>double</type><purpose>power index </purpose></data-member>
<method-group name="public member functions">
<method name="forward" cv="const"><type>auto</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="x"><paramtype>T</paramtype></parameter><purpose>Returns pow(x, power) of external value x. </purpose></method>
<method name="inverse" cv="const"><type>auto</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="x"><paramtype>T</paramtype></parameter><purpose>Returns pow(x, 1/power) of external value x. </purpose></method>
<method name="operator==" cv="const noexcept"><type>bool</type><parameter name="o"><paramtype>const <classname>pow</classname> &amp;</paramtype></parameter></method>
</method-group>
<constructor specifiers="explicit"><parameter name="p"><paramtype>double</paramtype></parameter><purpose>Make transform with index p. </purpose></constructor>
<constructor cv="= default"/>
</struct><struct name="sqrt"><purpose>Sqrt transform for equidistant bins in sqrt-space. </purpose><method-group name="public static functions">
<method name="forward" specifiers="static"><type>T</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="x"><paramtype>T</paramtype></parameter><purpose>Returns sqrt(x) of external value x. </purpose></method>
<method name="inverse" specifiers="static"><type>T</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="x"><paramtype>T</paramtype></parameter><purpose>Returns x^2 of internal value x. </purpose></method>
</method-group>
</struct></namespace>











<function name="step"><type>auto</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;&amp;</paramtype></parameter><purpose>Helper function to mark argument as step size. </purpose></function>
</namespace>

























</namespace>
</namespace>
</header>
<header name="boost/histogram/axis/traits.hpp">
<namespace name="boost">
<namespace name="histogram">
<namespace name="axis">
<namespace name="traits">
<struct name="is_reducible"><template>
      <template-type-parameter name="Axis"><purpose><para>axis type. </para></purpose></template-type-parameter>
    </template><purpose>Meta-function to detect whether an axis is reducible. </purpose><description><para>Doxygen does not render this well. This is a meta-function, it accepts an axis type and represents std::true_type or std::false_type, depending on whether the axis can be reduced with boost::histogram::algorithm::reduce().</para><para>
</para></description></struct><struct name="static_options"><template>
      <template-type-parameter name="Axis"><purpose><para>axis type </para></purpose></template-type-parameter>
    </template><purpose>Get static axis options for axis type. </purpose><description><para>Doxygen does not render this well. This is a meta-function, it accepts an axis type and represents its <classname alt="boost::histogram::axis::option::bitset">boost::histogram::axis::option::bitset</classname>.</para><para>If Axis::options() is valid and constexpr, <classname alt="boost::histogram::axis::traits::static_options">static_options</classname> is the corresponding option type. Otherwise, it is boost::histogram::axis::option::growth_t, if the axis has a method <computeroutput>update</computeroutput>, else boost::histogram::axis::option::none_t.</para><para>
</para></description></struct><function name="metadata"><type>decltype(auto)</type><template>
          <template-type-parameter name="Axis"/>
        </template><parameter name="axis"><paramtype>Axis &amp;&amp;</paramtype><description><para>any axis instance </para></description></parameter><purpose>Returns reference to metadata of an axis. </purpose><description><para>If the expression x.metadata() for an axis instance <computeroutput>x</computeroutput> (maybe const) is valid, return the result. Otherwise, return a reference to a static instance of <classname alt="boost::histogram::axis::null_type">boost::histogram::axis::null_type</classname>.</para><para>
</para></description></function>
<function name="options"><type>constexpr unsigned</type><template>
          <template-type-parameter name="Axis"/>
        </template><parameter name="axis"><paramtype>const Axis &amp;</paramtype><description><para>any axis instance </para></description></parameter><purpose>Returns axis options as unsigned integer. </purpose><description><para>If axis.options() is valid, return the result. Otherwise, return boost::histogram::axis::traits::static_options&lt;decltype(axis)&gt;::value.</para><para>
</para></description></function>
<function name="extent"><type>constexpr index_type</type><template>
          <template-type-parameter name="Axis"/>
        </template><parameter name="axis"><paramtype>const Axis &amp;</paramtype><description><para>any axis instance </para></description></parameter><purpose>Returns axis size plus any extra bins for under- and overflow. </purpose><description><para>
</para></description></function>
<function name="value"><type>decltype(auto)</type><template>
          <template-type-parameter name="Axis"/>
        </template><parameter name="axis"><paramtype>const Axis &amp;</paramtype><description><para>any axis instance </para></description></parameter><parameter name="index"><paramtype>real_index_type</paramtype><description><para>floating point axis index </para></description></parameter><purpose>Returns axis value for index. </purpose><description><para>If the axis has no <computeroutput>value</computeroutput> method, throw std::runtime_error. If the method exists and accepts a floating point index, pass the index and return the result. If the method exists but accepts only integer indices, cast the floating point index to int, pass this index and return the result.</para><para>
</para></description></function>
<function name="value_as"><type>Result</type><template>
          <template-type-parameter name="Result"><purpose><para>requested return type </para></purpose></template-type-parameter>
          <template-type-parameter name="Axis"><purpose><para>axis type </para></purpose></template-type-parameter>
        </template><parameter name="axis"><paramtype>const Axis &amp;</paramtype><description><para>any axis instance </para></description></parameter><parameter name="index"><paramtype>real_index_type</paramtype><description><para>floating point axis index </para></description></parameter><purpose>Returns axis value for index if it is convertible to target type or throws. </purpose><description><para>Like boost::histogram::axis::traits::value, but converts the result into the requested return type. If the conversion is not possible, throws std::runtime_error.</para><para>

</para></description></function>
<function name="index"><type>axis::index_type</type><template>
          <template-type-parameter name="Axis"/>
          <template-type-parameter name="U"/>
          <template-type-parameter name="_V"><default>std::decay_t&lt;detail::arg_type&lt;decltype(&amp;Axis::index)&gt;&gt;</default></template-type-parameter>
        </template><parameter name="axis"><paramtype>const Axis &amp;</paramtype><description><para>any axis instance </para></description></parameter><parameter name="value"><paramtype>const U &amp;</paramtype><description><para>argument to be passed to <computeroutput>index</computeroutput> method </para></description></parameter><purpose>Returns axis index for value. </purpose><description><para>Throws std::invalid_argument if the value argument is not implicitly convertible.</para><para>
</para></description></function>
<function name="index"><type>axis::index_type</type><template>
          <template-nontype-parameter name="Ts"><type>class...</type></template-nontype-parameter>
          <template-type-parameter name="U"/>
        </template><parameter name="axis"><paramtype>const <classname>variant</classname>&lt; Ts... &gt; &amp;</paramtype></parameter><parameter name="value"><paramtype>const U &amp;</paramtype></parameter></function>
<function name="update"><type>std::pair&lt; index_type, index_type &gt;</type><template>
          <template-type-parameter name="Axis"/>
          <template-type-parameter name="U"/>
          <template-type-parameter name="_V"><default>std::decay_t&lt;detail::arg_type&lt;decltype(&amp;Axis::index)&gt;&gt;</default></template-type-parameter>
        </template><parameter name="axis"><paramtype>Axis &amp;</paramtype><description><para>any axis instance </para></description></parameter><parameter name="value"><paramtype>const U &amp;</paramtype><description><para>argument to be passed to <computeroutput>update</computeroutput> or <computeroutput>index</computeroutput> method </para></description></parameter><purpose>Returns pair of axis index and shift for the value argument. </purpose><description><para>Throws <computeroutput>std::invalid_argument</computeroutput> if the value argument is not implicitly convertible to the argument expected by the <computeroutput>index</computeroutput> method. If the result of boost::histogram::axis::traits::static_options&lt;decltype(axis)&gt; has the growth flag set, call <computeroutput>update</computeroutput> method with the argument and return the result. Otherwise, call <computeroutput>index</computeroutput> and return the pair of the result and a zero shift.</para><para>
</para></description></function>
<function name="update"><type>std::pair&lt; index_type, index_type &gt;</type><template>
          <template-nontype-parameter name="Ts"><type>class...</type></template-nontype-parameter>
          <template-type-parameter name="U"/>
        </template><parameter name="axis"><paramtype><classname>variant</classname>&lt; Ts... &gt; &amp;</paramtype></parameter><parameter name="value"><paramtype>const U &amp;</paramtype></parameter></function>
<function name="width"><type>decltype(auto)</type><template>
          <template-type-parameter name="Axis"/>
        </template><parameter name="axis"><paramtype>const Axis &amp;</paramtype><description><para>any axis instance </para></description></parameter><parameter name="index"><paramtype>index_type</paramtype><description><para>bin index </para></description></parameter><purpose>Returns bin width at axis index. </purpose><description><para>If the axis has no <computeroutput>value</computeroutput> method, throw std::runtime_error. If the method exists and accepts a floating point index, return the result of <computeroutput>axis.value(index + 1) - axis.value(index)</computeroutput>. If the method exists but accepts only integer indices, return 0.</para><para>
</para></description></function>
<function name="width_as"><type>Result</type><template>
          <template-type-parameter name="Result"/>
          <template-type-parameter name="Axis"/>
        </template><parameter name="axis"><paramtype>const Axis &amp;</paramtype><description><para>any axis instance </para></description></parameter><parameter name="index"><paramtype>index_type</paramtype><description><para>bin index </para></description></parameter><purpose>Returns bin width at axis index. </purpose><description><para>Like boost::histogram::axis::traits::width, but converts the result into the requested return type. If the conversion is not possible, throw std::runtime_error.</para><para>
</para></description></function>
</namespace>












</namespace>

























</namespace>
</namespace>
</header>
<header name="boost/histogram/axis/variable.hpp">
<namespace name="boost">
<namespace name="histogram">
<namespace name="axis">
<class name="variable"><template>
      <template-type-parameter name="Value"><purpose><para>input value type, must be floating point. </para></purpose></template-type-parameter>
      <template-type-parameter name="MetaData"><purpose><para>type to store meta data. </para></purpose></template-type-parameter>
      <template-type-parameter name="Options"><purpose><para>see boost::histogram::axis::option (all values allowed). </para></purpose></template-type-parameter>
      <template-type-parameter name="Allocator"><purpose><para>allocator to use for dynamic memory management. </para></purpose></template-type-parameter>
    </template><inherit access="public">boost::histogram::axis::iterator_mixin&lt; variable&lt; Value, MetaData, Options, Allocator &gt; &gt;</inherit><purpose>Axis for non-equidistant bins on the real line. </purpose><description><para>Binning is a O(log(N)) operation. If speed matters and the problem domain allows it, prefer a regular axis, possibly with a transform.</para><para>
</para></description><method-group name="public member functions">
<method name="index" cv="const noexcept"><type>index_type</type><parameter name="x"><paramtype>value_type</paramtype></parameter><purpose>Return index for value argument. </purpose></method>
<method name="update" cv="noexcept"><type>auto</type><parameter name="x"><paramtype>value_type</paramtype></parameter></method>
<method name="value" cv="const noexcept"><type>value_type</type><parameter name="i"><paramtype>real_index_type</paramtype></parameter><purpose>Return value for fractional index argument. </purpose></method>
<method name="bin" cv="const noexcept"><type>auto</type><parameter name="idx"><paramtype>index_type</paramtype></parameter><purpose>Return bin for index argument. </purpose></method>
<method name="size" cv="const noexcept"><type>index_type</type><purpose>Returns the number of bins, without over- or underflow. </purpose></method>
<method name="metadata" cv="noexcept"><type>metadata_type &amp;</type><purpose>Returns reference to metadata. </purpose></method>
<method name="metadata" cv="const noexcept"><type>const metadata_type &amp;</type><purpose>Returns reference to const metadata. </purpose></method>
<method name="operator==" cv="const noexcept"><type>bool</type><template>
          <template-type-parameter name="V"/>
          <template-type-parameter name="M"/>
          <template-type-parameter name="O"/>
          <template-type-parameter name="A"/>
        </template><parameter name="o"><paramtype>const <classname>variable</classname>&lt; V, M, O, A &gt; &amp;</paramtype></parameter></method>
<method name="operator!=" cv="const noexcept"><type>bool</type><template>
          <template-type-parameter name="V"/>
          <template-type-parameter name="M"/>
          <template-type-parameter name="O"/>
          <template-type-parameter name="A"/>
        </template><parameter name="o"><paramtype>const <classname>variable</classname>&lt; V, M, O, A &gt; &amp;</paramtype></parameter></method>
<method name="get_allocator" cv="const"><type>auto</type><purpose>Return allocator instance. </purpose></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name=""><paramtype>Archive &amp;</paramtype></parameter><parameter name=""><paramtype>unsigned</paramtype></parameter></method>
</method-group>
<constructor specifiers="explicit"><parameter name="alloc"><paramtype>allocator_type</paramtype><default>{}</default></parameter></constructor>
<constructor cv="= default"><parameter name=""><paramtype>const <classname>variable</classname> &amp;</paramtype></parameter></constructor>
<copy-assignment cv="= default"><type><classname>variable</classname> &amp;</type><parameter name=""><paramtype>const <classname>variable</classname> &amp;</paramtype></parameter></copy-assignment>
<constructor cv="noexcept"><parameter name="o"><paramtype><classname>variable</classname> &amp;&amp;</paramtype></parameter></constructor>
<copy-assignment cv="noexcept"><type><classname>variable</classname> &amp;</type><parameter name="o"><paramtype><classname>variable</classname> &amp;&amp;</paramtype></parameter></copy-assignment>
<constructor><template>
          <template-type-parameter name="It"/>
          <template-type-parameter name=""><default>detail::requires_iterator&lt;It&gt;</default></template-type-parameter>
        </template><parameter name="begin"><paramtype>It</paramtype><description><para>begin of edge sequence. </para></description></parameter><parameter name="end"><paramtype>It</paramtype><description><para>end of edge sequence. </para></description></parameter><parameter name="meta"><paramtype>metadata_type</paramtype><default>{}</default><description><para>description of the axis. </para></description></parameter><parameter name="alloc"><paramtype>allocator_type</paramtype><default>{}</default><description><para>allocator instance to use. </para></description></parameter><purpose>Construct from iterator range of bin edges. </purpose><description><para>
</para></description></constructor>
<constructor><template>
          <template-type-parameter name="U"/>
          <template-type-parameter name=""><default>detail::requires_iterable&lt;U&gt;</default></template-type-parameter>
        </template><parameter name="iterable"><paramtype>const U &amp;</paramtype><description><para>iterable range of bin edges. </para></description></parameter><parameter name="meta"><paramtype>metadata_type</paramtype><default>{}</default><description><para>description of the axis. </para></description></parameter><parameter name="alloc"><paramtype>allocator_type</paramtype><default>{}</default><description><para>allocator instance to use. </para></description></parameter><purpose>Construct variable axis from iterable range of bin edges. </purpose><description><para>
</para></description></constructor>
<constructor><template>
          <template-type-parameter name="U"/>
        </template><parameter name="list"><paramtype>std::initializer_list&lt; U &gt;</paramtype><description><para><computeroutput>std::initializer_list</computeroutput> of bin edges. </para></description></parameter><parameter name="meta"><paramtype>metadata_type</paramtype><default>{}</default><description><para>description of the axis. </para></description></parameter><parameter name="alloc"><paramtype>allocator_type</paramtype><default>{}</default><description><para>allocator instance to use. </para></description></parameter><purpose>Construct variable axis from initializer list of bin edges. </purpose><description><para>
</para></description></constructor>
<constructor><parameter name="src"><paramtype>const <classname>variable</classname> &amp;</paramtype></parameter><parameter name="begin"><paramtype>index_type</paramtype></parameter><parameter name="end"><paramtype>index_type</paramtype></parameter><parameter name="merge"><paramtype>unsigned</paramtype></parameter><purpose>Constructor used by algorithm::reduce to shrink and rebin (not for users). </purpose></constructor>
<method-group name="public static functions">
<method name="options" cv="noexcept" specifiers="static"><type>constexpr unsigned</type><purpose>Returns the options. </purpose></method>
</method-group>
</class>











</namespace>

























</namespace>
</namespace>
</header>
<header name="boost/histogram/axis/variant.hpp">
<namespace name="boost">
<namespace name="histogram">
<namespace name="axis">
<class name="variant"><template>
      <template-nontype-parameter name="Ts"><type>class...</type></template-nontype-parameter>
    </template><inherit access="public">boost::histogram::axis::iterator_mixin&lt; variant&lt; Ts... &gt; &gt;</inherit><purpose>Polymorphic axis type. </purpose><method-group name="public member functions">
<method name="size" cv="const"><type>index_type</type><purpose>Return size of axis. </purpose></method>
<method name="options" cv="const"><type>unsigned</type><purpose>Return options of axis or option::none_t if axis has no options. </purpose></method>
<method name="metadata" cv="const"><type>const metadata_type &amp;</type><purpose>Return reference to const metadata or instance of <classname alt="boost::histogram::axis::null_type">null_type</classname> if axis has no metadata. </purpose></method>
<method name="metadata"><type>metadata_type &amp;</type><purpose>Return reference to metadata or instance of <classname alt="boost::histogram::axis::null_type">null_type</classname> if axis has no metadata. </purpose></method>
<method name="index" cv="const"><type>index_type</type><template>
          <template-type-parameter name="U"/>
        </template><parameter name="u"><paramtype>const U &amp;</paramtype></parameter><purpose>Return index for value argument. </purpose><description><para>Throws std::invalid_argument if axis has incompatible call signature. </para></description></method>
<method name="value" cv="const"><type>double</type><parameter name="idx"><paramtype>real_index_type</paramtype></parameter><purpose>Return value for index argument. </purpose><description><para>Only works for axes with value method that returns something convertible to double and will throw a runtime_error otherwise, see axis::traits::value(). </para></description></method>
<method name="bin" cv="const"><type>auto</type><parameter name="idx"><paramtype>index_type</paramtype></parameter><purpose>Return bin for index argument. </purpose><description><para>Only works for axes with value method that returns something convertible to double and will throw a runtime_error otherwise, see axis::traits::value(). </para></description></method>
<method name="operator==" cv="const"><type>bool</type><template>
          <template-nontype-parameter name="Us"><type>class...</type></template-nontype-parameter>
        </template><parameter name="u"><paramtype>const <classname>variant</classname>&lt; Us... &gt; &amp;</paramtype></parameter><purpose>Compare two variants. </purpose><description><para>Return true if the variants point to the same concrete axis type and the types compare equal. Otherwise return false. </para></description></method>
<method name="operator==" cv="const"><type>bool</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>const T &amp;</paramtype></parameter><purpose>Compare variant with a concrete axis type. </purpose><description><para>Return true if the variant point to the same concrete axis type and the types compare equal. Otherwise return false. </para></description></method>
<method name="operator!=" cv="const"><type>bool</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>const T &amp;</paramtype></parameter><purpose>The negation of operator==. </purpose></method>
</method-group>
<constructor cv="= default"/>
<constructor cv="= default"><parameter name=""><paramtype>const <classname>variant</classname> &amp;</paramtype></parameter></constructor>
<copy-assignment cv="= default"><type><classname>variant</classname> &amp;</type><parameter name=""><paramtype>const <classname>variant</classname> &amp;</paramtype></parameter></copy-assignment>
<constructor cv="= default"><parameter name=""><paramtype><classname>variant</classname> &amp;&amp;</paramtype></parameter></constructor>
<copy-assignment cv="= default"><type><classname>variant</classname> &amp;</type><parameter name=""><paramtype><classname>variant</classname> &amp;&amp;</paramtype></parameter></copy-assignment>
<constructor><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name=""><default>requires_bounded_type&lt;T&gt;</default></template-type-parameter>
        </template><parameter name="t"><paramtype>T &amp;&amp;</paramtype></parameter></constructor>
<copy-assignment><type><classname>variant</classname> &amp;</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name=""><default>requires_bounded_type&lt;T&gt;</default></template-type-parameter>
        </template><parameter name="t"><paramtype>T &amp;&amp;</paramtype></parameter></copy-assignment>
<constructor><template>
          <template-nontype-parameter name="Us"><type>class...</type></template-nontype-parameter>
        </template><parameter name="u"><paramtype>const <classname>variant</classname>&lt; Us... &gt; &amp;</paramtype></parameter></constructor>
<copy-assignment><type><classname>variant</classname> &amp;</type><template>
          <template-nontype-parameter name="Us"><type>class...</type></template-nontype-parameter>
        </template><parameter name="u"><paramtype>const <classname>variant</classname>&lt; Us... &gt; &amp;</paramtype></parameter></copy-assignment>
</class><class name="variant"><template>
    </template></class><function name="visit"><type>decltype(auto)</type><template>
          <template-type-parameter name="Visitor"/>
          <template-nontype-parameter name="Us"><type>class...</type></template-nontype-parameter>
        </template><parameter name="vis"><paramtype>Visitor &amp;&amp;</paramtype></parameter><parameter name="var"><paramtype><classname>variant</classname>&lt; Us... &gt; &amp;</paramtype></parameter><purpose>Apply visitor to variant (reference). </purpose></function>
<function name="visit"><type>decltype(auto)</type><template>
          <template-type-parameter name="Visitor"/>
          <template-nontype-parameter name="Us"><type>class...</type></template-nontype-parameter>
        </template><parameter name="vis"><paramtype>Visitor &amp;&amp;</paramtype></parameter><parameter name="var"><paramtype><classname>variant</classname>&lt; Us... &gt; &amp;&amp;</paramtype></parameter><purpose>Apply visitor to variant (movable reference). </purpose></function>
<function name="visit"><type>decltype(auto)</type><template>
          <template-type-parameter name="Visitor"/>
          <template-nontype-parameter name="Us"><type>class...</type></template-nontype-parameter>
        </template><parameter name="vis"><paramtype>Visitor &amp;&amp;</paramtype></parameter><parameter name="var"><paramtype>const <classname>variant</classname>&lt; Us... &gt; &amp;</paramtype></parameter><purpose>Apply visitor to variant (const reference). </purpose></function>
<function name="get_if"><type>T *</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Us"><type>class...</type></template-nontype-parameter>
        </template><parameter name="v"><paramtype><classname>variant</classname>&lt; Us... &gt; *</paramtype></parameter><purpose>Returns pointer to T in variant or null pointer if type does not match. </purpose></function>
<function name="get_if"><type>const T *</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Us"><type>class...</type></template-nontype-parameter>
        </template><parameter name="v"><paramtype>const <classname>variant</classname>&lt; Us... &gt; *</paramtype></parameter><purpose>Returns pointer to const T in variant or null pointer if type does not match. </purpose></function>
<function name="get"><type>decltype(auto)</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Us"><type>class...</type></template-nontype-parameter>
        </template><parameter name="v"><paramtype><classname>variant</classname>&lt; Us... &gt; &amp;</paramtype></parameter><purpose>Return reference to T, throws std::runtime_error if type does not match. </purpose></function>
<function name="get"><type>decltype(auto)</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Us"><type>class...</type></template-nontype-parameter>
        </template><parameter name="v"><paramtype><classname>variant</classname>&lt; Us... &gt; &amp;&amp;</paramtype></parameter><purpose>Return movable reference to T, throws unspecified exception if type does not match. </purpose></function>
<function name="get"><type>decltype(auto)</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Us"><type>class...</type></template-nontype-parameter>
        </template><parameter name="v"><paramtype>const <classname>variant</classname>&lt; Us... &gt; &amp;</paramtype></parameter><purpose>Return const reference to T, throws unspecified exception if type does not match. </purpose></function>
<function name="get"><type>decltype(auto)</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="u"><paramtype>U &amp;&amp;</paramtype></parameter></function>
<function name="get_if"><type>T *</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="u"><paramtype>U *</paramtype></parameter></function>
<function name="get_if"><type>const T *</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="u"><paramtype>const U *</paramtype></parameter></function>

</namespace>

























</namespace>
</namespace>
</header>
<header name="boost/histogram/fwd.hpp">
<para>Forward declarations, tag types and type aliases. </para><namespace name="boost">
<namespace name="histogram">
<namespace name="axis">
<struct name="null_type"><purpose>Empty metadata type. </purpose></struct><typedef name="index_type"><purpose>Integral type for axis indices. </purpose><type>int</type></typedef>
<typedef name="real_index_type"><purpose>Real type for axis indices. </purpose><type>double</type></typedef>












</namespace>
<typedef name="dense_storage"><purpose>Vector-like storage for fast zero-overhead access to cells. </purpose><type><classname>storage_adaptor</classname>&lt; std::vector&lt; T, A &gt; &gt;</type></typedef>
<typedef name="default_storage"><purpose>Default storage, optimized for unweighted histograms. </purpose><type><classname>unlimited_storage</classname>&lt;&gt;</type></typedef>
<typedef name="weight_storage"><purpose>Dense storage which tracks sums of weights and a variance estimate. </purpose><type>dense_storage&lt; <classname>accumulators::weighted_sum</classname>&lt;&gt; &gt;</type></typedef>
<typedef name="profile_storage"><purpose>Dense storage which tracks means of samples in each cell. </purpose><type>dense_storage&lt; <classname>accumulators::mean</classname>&lt;&gt; &gt;</type></typedef>
<typedef name="weighted_profile_storage"><purpose>Dense storage which tracks means of weighted samples in each cell. </purpose><type>dense_storage&lt; <classname>accumulators::weighted_mean</classname>&lt;&gt; &gt;</type></typedef>

























</namespace>
</namespace>
</header>
<header name="boost/histogram/indexed.hpp">
<namespace name="boost">
<namespace name="histogram">
<class name="indexed_range"><template>
      <template-type-parameter name="Histogram"/>
    </template><purpose>Input iterator range over histogram bins with multi-dimensional index. </purpose><description><para>The iterator returned by begin() can only be incremented. begin() may only be called once, calling it a second time returns the end() iterator. If several copies of the input iterators exist, the other copies become invalid if one of them is incremented. </para></description><class name="accessor"><purpose>Pointer-like class to access value and index of current cell. </purpose><description><para>Its methods provide access to the current indices and bins and it acts like a pointer to the cell value. To interoperate with the algorithms of the standard library, the accessor is implicitly convertible to a cell value. Assignments and comparisons are passed through to the cell. The accessor is coupled to its parent iterator. Moving the parent iterator forward also updates the linked accessor. Accessors are not copyable. They cannot be stored in containers, but range_iterators can be stored. </para></description><class name="index_view"><purpose>Array-like view into the current multi-dimensional index. </purpose><class name="const_iterator"><purpose>implementation detail </purpose><method-group name="public member functions">
<method name="operator *" cv="const noexcept"><type>const_reference</type></method>
</method-group>
<method-group name="private member functions">
</method-group>
<constructor specifiers="explicit" cv="noexcept"><parameter name="i"><paramtype>index_pointer</paramtype></parameter></constructor>
</class><typedef name="const_reference"><type>const axis::index_type &amp;</type></typedef>
<typedef name="reference"><purpose>deprecated </purpose><type>const_reference</type></typedef>
<method-group name="public member functions">
<method name="begin" cv="const noexcept"><type><classname>const_iterator</classname></type></method>
<method name="end" cv="const noexcept"><type><classname>const_iterator</classname></type></method>
<method name="size" cv="const noexcept"><type>std::size_t</type></method>
<method name="operator[]" cv="const noexcept"><type>const_reference</type><parameter name="d"><paramtype>unsigned</paramtype></parameter></method>
<method name="at" cv="const"><type>const_reference</type><parameter name="d"><paramtype>unsigned</paramtype></parameter></method>
</method-group>
<method-group name="private member functions">
</method-group>
<constructor><parameter name="b"><paramtype>index_pointer</paramtype></parameter><parameter name="e"><paramtype>index_pointer</paramtype></parameter><purpose>implementation detail </purpose></constructor>
</class><method-group name="public member functions">
<method name="get" cv="const noexcept"><type>value_reference</type><purpose>Returns the cell reference. </purpose></method>
<method name="operator *" cv="const noexcept"><type>value_reference</type><purpose>Returns the cell reference. </purpose></method>
<method name="operator-&gt;" cv="const noexcept"><type>value_iterator</type><purpose>Access fields and methods of the cell object. </purpose></method>
<method name="index" cv="const noexcept"><type>axis::index_type</type><parameter name="d"><paramtype>unsigned</paramtype><default>0</default><description><para>axis dimension. </para></description></parameter><purpose>Access current index. </purpose><description><para>
</para></description></method>
<method name="indices" cv="const noexcept"><type><classname>index_view</classname></type><purpose>Access indices as an iterable range. </purpose></method>
<method name="bin" cv="const"><type>decltype(auto)</type><template>
          <template-nontype-parameter name="N"><type>unsigned</type><default>0</default><purpose><para>axis dimension. </para></purpose></template-nontype-parameter>
        </template><parameter name=""><paramtype>std::integral_constant&lt; unsigned, N &gt;</paramtype><default>{}</default></parameter><purpose>Access current bin. </purpose><description><para>
</para></description></method>
<method name="bin" cv="const"><type>decltype(auto)</type><parameter name="d"><paramtype>unsigned</paramtype><description><para>axis dimension. </para></description></parameter><purpose>Access current bin. </purpose><description><para>
</para></description></method>
<method name="density" cv="const"><type>double</type><purpose>Computes density in current cell. </purpose><description><para>The density is computed as the cell value divided by the product of bin widths. Axes without bin widths, like <classname alt="boost::histogram::axis::category">axis::category</classname>, are treated as having unit bin with. </para></description></method>
<method name="operator&lt;" cv="noexcept"><type>bool</type><parameter name="o"><paramtype>const <classname>accessor</classname> &amp;</paramtype></parameter></method>
<method name="operator&gt;" cv="noexcept"><type>bool</type><parameter name="o"><paramtype>const <classname>accessor</classname> &amp;</paramtype></parameter></method>
<method name="operator==" cv="noexcept"><type>bool</type><parameter name="o"><paramtype>const <classname>accessor</classname> &amp;</paramtype></parameter></method>
<method name="operator!=" cv="noexcept"><type>bool</type><parameter name="o"><paramtype>const <classname>accessor</classname> &amp;</paramtype></parameter></method>
<method name="operator&lt;=" cv="noexcept"><type>bool</type><parameter name="o"><paramtype>const <classname>accessor</classname> &amp;</paramtype></parameter></method>
<method name="operator&gt;=" cv="noexcept"><type>bool</type><parameter name="o"><paramtype>const <classname>accessor</classname> &amp;</paramtype></parameter></method>
<method name="operator&lt;" cv="const noexcept"><type>bool</type><template>
          <template-type-parameter name="U"/>
        </template><parameter name="o"><paramtype>const U &amp;</paramtype></parameter></method>
<method name="operator&gt;" cv="const noexcept"><type>bool</type><template>
          <template-type-parameter name="U"/>
        </template><parameter name="o"><paramtype>const U &amp;</paramtype></parameter></method>
<method name="operator==" cv="const noexcept"><type>bool</type><template>
          <template-type-parameter name="U"/>
        </template><parameter name="o"><paramtype>const U &amp;</paramtype></parameter></method>
<method name="operator!=" cv="const noexcept"><type>bool</type><template>
          <template-type-parameter name="U"/>
        </template><parameter name="o"><paramtype>const U &amp;</paramtype></parameter></method>
<method name="operator&lt;=" cv="const noexcept"><type>bool</type><template>
          <template-type-parameter name="U"/>
        </template><parameter name="o"><paramtype>const U &amp;</paramtype></parameter></method>
<method name="operator&gt;=" cv="const noexcept"><type>bool</type><template>
          <template-type-parameter name="U"/>
        </template><parameter name="o"><paramtype>const U &amp;</paramtype></parameter></method>
<method name="conversion-operator" cv="const noexcept"><type>value_type</type></method>
</method-group>
<copy-assignment><type><classname>accessor</classname> &amp;</type><parameter name="o"><paramtype>const <classname>accessor</classname> &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>accessor</classname> &amp;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="x"><paramtype>const T &amp;</paramtype></parameter></copy-assignment>
<method-group name="private member functions">
</method-group>
<constructor cv="noexcept"><parameter name="i"><paramtype><classname>iterator</classname> &amp;</paramtype></parameter></constructor>
<constructor cv="= default"><parameter name=""><paramtype>const <classname>accessor</classname> &amp;</paramtype></parameter></constructor>
</class><class name="iterator"><purpose>implementation detail </purpose><struct name="index_data"><data-member name="idx"><type>axis::index_type</type></data-member>
<data-member name="begin"><type>axis::index_type</type></data-member>
<data-member name="end"><type>axis::index_type</type></data-member>
<data-member name="extent"><type>axis::index_type</type></data-member>
</struct><struct name="indices_t"><inherit access="public">std::array&lt; index_data, buffer_size &gt;</inherit><typedef name="base_type"><type>std::array&lt; index_data, buffer_size &gt;</type></typedef>
<data-member name="hist_"><type>histogram_type *</type></data-member>
<method-group name="public member functions">
<method name="end" cv="noexcept"><type>constexpr auto</type></method>
<method name="end" cv="const noexcept"><type>constexpr auto</type></method>
</method-group>
<constructor cv="noexcept"><parameter name="h"><paramtype>histogram_type *</paramtype></parameter></constructor>
</struct><struct name="pointer_proxy"><data-member name="ref_"><type><classname>reference</classname></type></data-member>
<method-group name="public member functions">
<method name="operator-&gt;" cv="noexcept"><type><classname>reference</classname> *</type></method>
</method-group>
</struct><typedef name="value_type"><type>typename indexed_range::value_type</type></typedef>
<typedef name="reference"><type><classname>accessor</classname></type></typedef>
<typedef name="pointer"><type>pointer_proxy</type></typedef>
<typedef name="difference_type"><type>std::ptrdiff_t</type></typedef>
<typedef name="iterator_category"><type>std::forward_iterator_tag</type></typedef>
<method-group name="public member functions">
<method name="operator *" cv="noexcept"><type><classname>reference</classname></type></method>
<method name="operator-&gt;" cv="noexcept"><type>pointer</type></method>
<method name="operator++"><type><classname>iterator</classname> &amp;</type></method>
<method name="operator++"><type><classname>iterator</classname></type><parameter name=""><paramtype>int</paramtype></parameter></method>
<method name="operator==" cv="const noexcept"><type>bool</type><parameter name="x"><paramtype>const <classname>iterator</classname> &amp;</paramtype></parameter></method>
<method name="operator!=" cv="const noexcept"><type>bool</type><parameter name="x"><paramtype>const <classname>iterator</classname> &amp;</paramtype></parameter></method>
</method-group>
<method-group name="private member functions">
</method-group>
<constructor><parameter name="h"><paramtype>histogram_type *</paramtype></parameter></constructor>
</class><typedef name="value_iterator"><type>decltype(std::declval&lt; histogram_type &gt;().begin())</type></typedef>
<typedef name="value_reference"><type>typename value_iterator::reference</type></typedef>
<typedef name="value_type"><type>typename value_iterator::value_type</type></typedef>
<typedef name="range_iterator"><purpose>deprecated </purpose><type><classname>iterator</classname></type></typedef>
<method-group name="public member functions">
<method name="begin" cv="noexcept"><type><classname>iterator</classname></type></method>
<method name="end" cv="noexcept"><type><classname>iterator</classname></type></method>
</method-group>
<constructor><parameter name="hist"><paramtype>histogram_type &amp;</paramtype></parameter><parameter name="cov"><paramtype>coverage</paramtype></parameter></constructor>
</class><enum name="coverage"><enumvalue name="inner"><description><para>iterate over inner bins, exclude underflow and overflow </para></description></enumvalue><enumvalue name="all"><description><para>iterate over all bins, including underflow and overflow </para></description></enumvalue><purpose>Coverage mode of the indexed range generator. </purpose><description><para>Defines options for the iteration strategy. </para></description></enum>















<function name="indexed"><type>auto</type><template>
          <template-type-parameter name="Histogram"/>
        </template><parameter name="hist"><paramtype>Histogram &amp;&amp;</paramtype><description><para>Reference to the histogram. </para></description></parameter><parameter name="cov"><paramtype>coverage</paramtype><default>coverage::inner</default><description><para>Iterate over all or only inner bins (optional, default: inner). </para></description></parameter><purpose>Generates an indexed range of <ulink url="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">forward iterators</ulink> over the histogram cells. </purpose><description><para>Use this in a range-based for loop:</para><para><programlisting language="c++">for (auto&amp;&amp; x : indexed(hist)) { ... }
</programlisting></para><para>This generates an optimized loop which is nearly always faster than a hand-written loop over the histogram cells. The iterators dereference to an <classname alt="boost::histogram::indexed_range::accessor">indexed_range::accessor</classname>, which has methods to query the current indices and bins and acts like a pointer to the cell value. The returned iterators are forward iterators. They can be stored in a container, but may not be used after the life-time of the histogram ends.</para><para>

</para></description><returns><para><classname alt="boost::histogram::indexed_range">indexed_range</classname></para>
</returns></function>









</namespace>
</namespace>
</header>
<header name="boost/histogram/literals.hpp">
<namespace name="boost">
<namespace name="histogram">
<namespace name="literals">
<function name="operator&quot;&quot;_c"><type>auto</type><template>
          <template-nontype-parameter name="digits"><type>char...</type></template-nontype-parameter>
        </template><purpose>Suffix operator to generate literal compile-time numbers, 0_c, 12_c, etc. </purpose></function>
</namespace>

























</namespace>
</namespace>
</header>
<header name="boost/histogram/make_histogram.hpp">
<para>Collection of factory functions to conveniently create histograms. </para><namespace name="boost">
<namespace name="histogram">






<function name="make_histogram_with"><type>auto</type><template>
          <template-type-parameter name="Storage"/>
          <template-type-parameter name="Axis"/>
          <template-nontype-parameter name="Axes"><type>class...</type></template-nontype-parameter>
          <template-type-parameter name=""><default>detail::requires_storage_or_adaptible&lt;Storage&gt;</default></template-type-parameter>
          <template-type-parameter name=""><default>detail::requires_axis&lt;Axis&gt;</default></template-type-parameter>
        </template><parameter name="storage"><paramtype>Storage &amp;&amp;</paramtype><description><para>Storage or container with standard interface (any vector, array, or map). </para></description></parameter><parameter name="axis"><paramtype>Axis &amp;&amp;</paramtype><description><para>First axis instance. </para></description></parameter><parameter name="axes"><paramtype>Axes &amp;&amp;...</paramtype><description><para>Other axis instances. </para></description></parameter><purpose>Make histogram from compile-time axis configuration and custom storage. </purpose><description><para>
</para></description></function>
<function name="make_histogram"><type>auto</type><template>
          <template-type-parameter name="Axis"/>
          <template-nontype-parameter name="Axes"><type>class...</type></template-nontype-parameter>
          <template-type-parameter name=""><default>detail::requires_axis&lt;Axis&gt;</default></template-type-parameter>
        </template><parameter name="axis"><paramtype>Axis &amp;&amp;</paramtype><description><para>First axis instance. </para></description></parameter><parameter name="axes"><paramtype>Axes &amp;&amp;...</paramtype><description><para>Other axis instances. </para></description></parameter><purpose>Make histogram from compile-time axis configuration and default storage. </purpose><description><para>
</para></description></function>
<function name="make_weighted_histogram"><type>auto</type><template>
          <template-type-parameter name="Axis"/>
          <template-nontype-parameter name="Axes"><type>class...</type></template-nontype-parameter>
          <template-type-parameter name=""><default>detail::requires_axis&lt;Axis&gt;</default></template-type-parameter>
        </template><parameter name="axis"><paramtype>Axis &amp;&amp;</paramtype><description><para>First axis instance. </para></description></parameter><parameter name="axes"><paramtype>Axes &amp;&amp;...</paramtype><description><para>Other axis instances. </para></description></parameter><purpose>Make histogram from compile-time axis configuration and weight-counting storage. </purpose><description><para>
</para></description></function>
<function name="make_histogram_with"><type>auto</type><template>
          <template-type-parameter name="Storage"/>
          <template-type-parameter name="Iterable"/>
          <template-type-parameter name=""><default>detail::requires_storage_or_adaptible&lt;Storage&gt;</default></template-type-parameter>
          <template-type-parameter name=""><default>detail::requires_sequence_of_any_axis&lt;Iterable&gt;</default></template-type-parameter>
        </template><parameter name="storage"><paramtype>Storage &amp;&amp;</paramtype><description><para>Storage or container with standard interface (any vector, array, or map). </para></description></parameter><parameter name="iterable"><paramtype>Iterable &amp;&amp;</paramtype><description><para>Iterable range of axis objects. </para></description></parameter><purpose>Make histogram from iterable range and custom storage. </purpose><description><para>
</para></description></function>
<function name="make_histogram"><type>auto</type><template>
          <template-type-parameter name="Iterable"/>
          <template-type-parameter name=""><default>detail::requires_sequence_of_any_axis&lt;Iterable&gt;</default></template-type-parameter>
        </template><parameter name="iterable"><paramtype>Iterable &amp;&amp;</paramtype><description><para>Iterable range of axis objects. </para></description></parameter><purpose>Make histogram from iterable range and default storage. </purpose><description><para>
</para></description></function>
<function name="make_weighted_histogram"><type>auto</type><template>
          <template-type-parameter name="Iterable"/>
          <template-type-parameter name=""><default>detail::requires_sequence_of_any_axis&lt;Iterable&gt;</default></template-type-parameter>
        </template><parameter name="iterable"><paramtype>Iterable &amp;&amp;</paramtype><description><para>Iterable range of axis objects. </para></description></parameter><purpose>Make histogram from iterable range and weight-counting storage. </purpose><description><para>
</para></description></function>
<function name="make_histogram_with"><type>auto</type><template>
          <template-type-parameter name="Storage"/>
          <template-type-parameter name="Iterator"/>
          <template-type-parameter name=""><default>detail::requires_storage_or_adaptible&lt;Storage&gt;</default></template-type-parameter>
          <template-type-parameter name=""><default>detail::requires_iterator&lt;Iterator&gt;</default></template-type-parameter>
        </template><parameter name="storage"><paramtype>Storage &amp;&amp;</paramtype><description><para>Storage or container with standard interface (any vector, array, or map). </para></description></parameter><parameter name="begin"><paramtype>Iterator</paramtype><description><para>Iterator to range of axis objects. </para></description></parameter><parameter name="end"><paramtype>Iterator</paramtype><description><para>Iterator to range of axis objects. </para></description></parameter><purpose>Make histogram from iterator interval and custom storage. </purpose><description><para>
</para></description></function>
<function name="make_histogram"><type>auto</type><template>
          <template-type-parameter name="Iterator"/>
          <template-type-parameter name=""><default>detail::requires_iterator&lt;Iterator&gt;</default></template-type-parameter>
        </template><parameter name="begin"><paramtype>Iterator</paramtype><description><para>Iterator to range of axis objects. </para></description></parameter><parameter name="end"><paramtype>Iterator</paramtype><description><para>Iterator to range of axis objects. </para></description></parameter><purpose>Make histogram from iterator interval and default storage. </purpose><description><para>
</para></description></function>
<function name="make_weighted_histogram"><type>auto</type><template>
          <template-type-parameter name="Iterator"/>
          <template-type-parameter name=""><default>detail::requires_iterator&lt;Iterator&gt;</default></template-type-parameter>
        </template><parameter name="begin"><paramtype>Iterator</paramtype><description><para>Iterator to range of axis objects. </para></description></parameter><parameter name="end"><paramtype>Iterator</paramtype><description><para>Iterator to range of axis objects. </para></description></parameter><purpose>Make histogram from iterator interval and weight-counting storage. </purpose><description><para>
</para></description></function>










</namespace>
</namespace>
</header>
<header name="boost/histogram/make_profile.hpp">
<para>Collection of factory functions to conveniently create profiles. </para><para>Profiles are histograms which accept an additional sample and compute the mean of the sample in each cell. </para><namespace name="boost">
<namespace name="histogram">
<function name="make_profile"><type>auto</type><template>
          <template-type-parameter name="Axis"/>
          <template-nontype-parameter name="Axes"><type>typename...</type></template-nontype-parameter>
          <template-type-parameter name=""><default>detail::requires_axis&lt;Axis&gt;</default></template-type-parameter>
        </template><parameter name="axis"><paramtype>Axis &amp;&amp;</paramtype><description><para>First axis instance. </para></description></parameter><parameter name="axes"><paramtype>Axes &amp;&amp;...</paramtype><description><para>Other axis instances. </para></description></parameter><purpose>Make profle from compile-time axis configuration. </purpose><description><para>
</para></description></function>
<function name="make_weighted_profile"><type>auto</type><template>
          <template-type-parameter name="Axis"/>
          <template-nontype-parameter name="Axes"><type>typename...</type></template-nontype-parameter>
          <template-type-parameter name=""><default>detail::requires_axis&lt;Axis&gt;</default></template-type-parameter>
        </template><parameter name="axis"><paramtype>Axis &amp;&amp;</paramtype><description><para>First axis instance. </para></description></parameter><parameter name="axes"><paramtype>Axes &amp;&amp;...</paramtype><description><para>Other axis instances. </para></description></parameter><purpose>Make profle from compile-time axis configuration which accepts weights. </purpose><description><para>
</para></description></function>
<function name="make_profile"><type>auto</type><template>
          <template-type-parameter name="Iterable"/>
          <template-type-parameter name=""><default>detail::requires_sequence_of_any_axis&lt;Iterable&gt;</default></template-type-parameter>
        </template><parameter name="iterable"><paramtype>Iterable &amp;&amp;</paramtype><description><para>Iterable range of axis objects. </para></description></parameter><purpose>Make profile from iterable range. </purpose><description><para>
</para></description></function>
<function name="make_weighted_profile"><type>auto</type><template>
          <template-type-parameter name="Iterable"/>
          <template-type-parameter name=""><default>detail::requires_sequence_of_any_axis&lt;Iterable&gt;</default></template-type-parameter>
        </template><parameter name="iterable"><paramtype>Iterable &amp;&amp;</paramtype><description><para>Iterable range of axis objects. </para></description></parameter><purpose>Make profile from iterable range which accepts weights. </purpose><description><para>
</para></description></function>
<function name="make_profile"><type>auto</type><template>
          <template-type-parameter name="Iterator"/>
          <template-type-parameter name=""><default>detail::requires_iterator&lt;Iterator&gt;</default></template-type-parameter>
        </template><parameter name="begin"><paramtype>Iterator</paramtype><description><para>Iterator to range of axis objects. </para></description></parameter><parameter name="end"><paramtype>Iterator</paramtype><description><para>Iterator to range of axis objects. </para></description></parameter><purpose>Make profile from iterator interval. </purpose><description><para>
</para></description></function>
<function name="make_weighted_profile"><type>auto</type><template>
          <template-type-parameter name="Iterator"/>
          <template-type-parameter name=""><default>detail::requires_iterator&lt;Iterator&gt;</default></template-type-parameter>
        </template><parameter name="begin"><paramtype>Iterator</paramtype><description><para>Iterator to range of axis objects. </para></description></parameter><parameter name="end"><paramtype>Iterator</paramtype><description><para>Iterator to range of axis objects. </para></description></parameter><purpose>Make profile from iterator interval which accepts weights. </purpose><description><para>
</para></description></function>



















</namespace>
</namespace>
</header>
<header name="boost/histogram/ostream.hpp">
<para>A simple streaming operator for the histogram type. </para><para>The text representation is rudimentary and not guaranteed to be stable between versions of Boost.Histogram. This header is not included by any other header and must be explicitly included to use the streaming operator.</para><para>To you use your own, simply include your own implementation instead of this header. </para></header>
<header name="boost/histogram/accumulators/ostream.hpp">
<para>Simple streaming operators for the builtin accumulator types. </para><para>The text representation is not guaranteed to be stable between versions of Boost.Histogram. This header is only included by <ulink url="histogram/reference.html#header.boost.histogram.ostream_hpp">boost/histogram/ostream.hpp</ulink>. To you use your own, include your own implementation instead of this header and do not include <ulink url="histogram/reference.html#header.boost.histogram.ostream_hpp">boost/histogram/ostream.hpp</ulink>. </para></header>
<header name="boost/histogram/axis/ostream.hpp">
<para>Simple streaming operators for the builtin axis types. </para><para>The text representation is not guaranteed to be stable between versions of Boost.Histogram. This header is only included by <ulink url="histogram/reference.html#header.boost.histogram.ostream_hpp">boost/histogram/ostream.hpp</ulink>. To you use your own, include your own implementation instead of this header and do not include <ulink url="histogram/reference.html#header.boost.histogram.ostream_hpp">boost/histogram/ostream.hpp</ulink>. </para></header>
<header name="boost/histogram/serialization.hpp">
<para>Implemenations of the serialization functions using <ulink url="https://www.boost.org/doc/libs/develop/libs/serialization/doc/index.html">Boost.Serialization</ulink>. </para></header>
<header name="boost/histogram/storage_adaptor.hpp">
<namespace name="boost">
<namespace name="histogram">
<class name="storage_adaptor"><template>
      <template-type-parameter name="T"/>
    </template><purpose>Turns any vector-like, array-like, and map-like container into a storage type. </purpose><method-group name="public member functions">
<method name="operator==" cv="const"><type>bool</type><template>
          <template-type-parameter name="U"/>
          <template-type-parameter name=""><default>detail::requires_iterable&lt;U&gt;</default></template-type-parameter>
        </template><parameter name="u"><paramtype>const U &amp;</paramtype></parameter></method>
</method-group>
<constructor cv="= default"><parameter name=""><paramtype><classname>storage_adaptor</classname> &amp;&amp;</paramtype></parameter></constructor>
<constructor cv="= default"><parameter name=""><paramtype>const <classname>storage_adaptor</classname> &amp;</paramtype></parameter></constructor>
<copy-assignment cv="= default"><type><classname>storage_adaptor</classname> &amp;</type><parameter name=""><paramtype><classname>storage_adaptor</classname> &amp;&amp;</paramtype></parameter></copy-assignment>
<copy-assignment cv="= default"><type><classname>storage_adaptor</classname> &amp;</type><parameter name=""><paramtype>const <classname>storage_adaptor</classname> &amp;</paramtype></parameter></copy-assignment>
<constructor><template>
          <template-nontype-parameter name="Ts"><type>class...</type></template-nontype-parameter>
        </template><parameter name="ts"><paramtype>Ts &amp;&amp;...</paramtype></parameter></constructor>
<copy-assignment><type><classname>storage_adaptor</classname> &amp;</type><template>
          <template-type-parameter name="U"/>
        </template><parameter name="u"><paramtype>U &amp;&amp;</paramtype></parameter></copy-assignment>
</class>
























</namespace>
</namespace>
</header>
<header name="boost/histogram/unlimited_storage.hpp">
<namespace name="boost">
<namespace name="histogram">
<class name="unlimited_storage"><template>
      <template-type-parameter name="Allocator"/>
    </template><purpose>Memory-efficient storage for integral counters which cannot overflow. </purpose><description><para>This storage provides a no-overflow-guarantee if the counters are incremented with integer weights. It maintains a contiguous array of elemental counters, one for each cell. If an operation is requested which would overflow a counter, the array is replaced with another of a wider integral type, then the operation is executed. The storage uses integers of 8, 16, 32, 64 bits, and then switches to a multiprecision integral type, similar to those in <ulink url="https://www.boost.org/doc/libs/develop/libs/multiprecision/doc/html/index.html">Boost.Multiprecision</ulink>.</para><para>A scaling operation or adding a floating point number triggers a conversion of the elemental counters into doubles, which voids the no-overflow-guarantee. </para></description><struct name="adder"><method-group name="public member functions">
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="U"/>
        </template><parameter name="tp"><paramtype>double *</paramtype></parameter><parameter name=""><paramtype>buffer_type &amp;</paramtype></parameter><parameter name="i"><paramtype>std::size_t</paramtype></parameter><parameter name="x"><paramtype>const U &amp;</paramtype></parameter></method>
<method name="operator()"><type>void</type><parameter name="tp"><paramtype>large_int *</paramtype></parameter><parameter name=""><paramtype>buffer_type &amp;</paramtype></parameter><parameter name="i"><paramtype>std::size_t</paramtype></parameter><parameter name="x"><paramtype>const large_int &amp;</paramtype></parameter></method>
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="tp"><paramtype>T *</paramtype></parameter><parameter name="b"><paramtype>buffer_type &amp;</paramtype></parameter><parameter name="i"><paramtype>std::size_t</paramtype></parameter><parameter name="x"><paramtype>const U &amp;</paramtype></parameter></method>
<method name="is_x_integral"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name=""><paramtype>std::false_type</paramtype></parameter><parameter name="tp"><paramtype>T *</paramtype></parameter><parameter name="b"><paramtype>buffer_type &amp;</paramtype></parameter><parameter name="i"><paramtype>std::size_t</paramtype></parameter><parameter name="x"><paramtype>const U &amp;</paramtype></parameter></method>
<method name="is_x_integral"><type>void</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype>std::false_type</paramtype></parameter><parameter name="tp"><paramtype>T *</paramtype></parameter><parameter name="b"><paramtype>buffer_type &amp;</paramtype></parameter><parameter name="i"><paramtype>std::size_t</paramtype></parameter><parameter name="x"><paramtype>const large_int &amp;</paramtype></parameter></method>
<method name="is_x_integral"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name=""><paramtype>std::true_type</paramtype></parameter><parameter name="tp"><paramtype>T *</paramtype></parameter><parameter name="b"><paramtype>buffer_type &amp;</paramtype></parameter><parameter name="i"><paramtype>std::size_t</paramtype></parameter><parameter name="x"><paramtype>const U &amp;</paramtype></parameter></method>
<method name="is_x_unsigned"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name=""><paramtype>std::false_type</paramtype></parameter><parameter name="tp"><paramtype>T *</paramtype></parameter><parameter name="b"><paramtype>buffer_type &amp;</paramtype></parameter><parameter name="i"><paramtype>std::size_t</paramtype></parameter><parameter name="x"><paramtype>const U &amp;</paramtype></parameter></method>
<method name="is_x_unsigned"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name=""><paramtype>std::true_type</paramtype></parameter><parameter name="tp"><paramtype>T *</paramtype></parameter><parameter name="b"><paramtype>buffer_type &amp;</paramtype></parameter><parameter name="i"><paramtype>std::size_t</paramtype></parameter><parameter name="x"><paramtype>const U &amp;</paramtype></parameter></method>
<method name="is_x_unsigned"><type>void</type><template>
          <template-type-parameter name="U"/>
        </template><parameter name=""><paramtype>std::true_type</paramtype></parameter><parameter name="tp"><paramtype>large_int *</paramtype></parameter><parameter name=""><paramtype>buffer_type &amp;</paramtype></parameter><parameter name="i"><paramtype>std::size_t</paramtype></parameter><parameter name="x"><paramtype>const U &amp;</paramtype></parameter></method>
</method-group>
</struct><struct name="buffer_type"><typedef name="types"><type>mp11::mp_list&lt; U8, U16, U32, U64, large_int, double &gt;</type></typedef>
<data-member name="alloc"><type>allocator_type</type></data-member>
<data-member name="size"><type>std::size_t</type></data-member>
<data-member name="type"><type>unsigned</type></data-member>
<data-member name="ptr" specifiers="mutable"><type>void *</type></data-member>
<method-group name="public static functions">
<method name="type_index" cv="noexcept" specifiers="static"><type>constexpr unsigned</type><template>
          <template-type-parameter name="T"/>
        </template></method>
</method-group>
<method-group name="public member functions">
<method name="visit" cv="const"><type>decltype(auto)</type><template>
          <template-type-parameter name="F"/>
          <template-nontype-parameter name="Ts"><type>class...</type></template-nontype-parameter>
        </template><parameter name="f"><paramtype>F &amp;&amp;</paramtype></parameter><parameter name="ts"><paramtype>Ts &amp;&amp;...</paramtype></parameter></method>
<method name="destroy" cv="noexcept"><type>void</type></method>
<method name="make"><type>void</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="n"><paramtype>std::size_t</paramtype></parameter></method>
<method name="make"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="n"><paramtype>std::size_t</paramtype></parameter><parameter name="iter"><paramtype>U</paramtype></parameter></method>
</method-group>
<constructor><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>{}</default></parameter></constructor>
<constructor cv="noexcept"><parameter name="o"><paramtype>buffer_type &amp;&amp;</paramtype></parameter></constructor>
<copy-assignment cv="noexcept"><type>buffer_type &amp;</type><parameter name="o"><paramtype>buffer_type &amp;&amp;</paramtype></parameter></copy-assignment>
<constructor><parameter name="x"><paramtype>const buffer_type &amp;</paramtype></parameter></constructor>
<copy-assignment><type>buffer_type &amp;</type><parameter name="o"><paramtype>const buffer_type &amp;</paramtype></parameter></copy-assignment>
<destructor/>
</struct><class name="const_reference"><purpose>implementation detail </purpose><method-group name="public member functions">
<method name="conversion-operator" cv="const noexcept"><type>double</type></method>
<method name="operator&lt;" cv="const noexcept"><type>bool</type><parameter name="o"><paramtype>const <classname>const_reference</classname> &amp;</paramtype></parameter></method>
<method name="operator==" cv="const noexcept"><type>bool</type><parameter name="o"><paramtype>const <classname>const_reference</classname> &amp;</paramtype></parameter></method>
<method name="operator&lt;" cv="const noexcept"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="U"/>
        </template><parameter name="o"><paramtype>const U &amp;</paramtype></parameter></method>
<method name="operator&gt;" cv="const noexcept"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="U"/>
        </template><parameter name="o"><paramtype>const U &amp;</paramtype></parameter></method>
<method name="operator==" cv="const noexcept"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="U"/>
        </template><parameter name="o"><paramtype>const U &amp;</paramtype></parameter></method>
</method-group>
<constructor cv="noexcept"><parameter name="b"><paramtype>buffer_type &amp;</paramtype></parameter><parameter name="i"><paramtype>std::size_t</paramtype></parameter></constructor>
<constructor><parameter name=""><paramtype>const <classname>const_reference</classname> &amp;</paramtype></parameter></constructor>
<copy-assignment cv="= delete"><type><classname>const_reference</classname> &amp;</type><parameter name=""><paramtype>const <classname>const_reference</classname> &amp;</paramtype></parameter></copy-assignment>
<copy-assignment cv="= delete"><type><classname>const_reference</classname> &amp;</type><parameter name=""><paramtype><classname>const_reference</classname> &amp;&amp;</paramtype></parameter></copy-assignment>
<method-group name="private member functions">
<method name="apply_binary" cv="const noexcept"><type>bool</type><template>
          <template-type-parameter name="Binary"/>
        </template><parameter name="x"><paramtype>const <classname>const_reference</classname> &amp;</paramtype></parameter></method>
<method name="apply_binary" cv="const noexcept"><type>bool</type><template>
          <template-type-parameter name="Binary"/>
          <template-type-parameter name="U"/>
        </template><parameter name="x"><paramtype>const U &amp;</paramtype></parameter></method>
</method-group>
</class><struct name="incrementor"><method-group name="public member functions">
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="tp"><paramtype>T *</paramtype></parameter><parameter name="b"><paramtype>buffer_type &amp;</paramtype></parameter><parameter name="i"><paramtype>std::size_t</paramtype></parameter></method>
<method name="operator()"><type>void</type><parameter name="tp"><paramtype>large_int *</paramtype></parameter><parameter name=""><paramtype>buffer_type &amp;</paramtype></parameter><parameter name="i"><paramtype>std::size_t</paramtype></parameter></method>
<method name="operator()"><type>void</type><parameter name="tp"><paramtype>double *</paramtype></parameter><parameter name=""><paramtype>buffer_type &amp;</paramtype></parameter><parameter name="i"><paramtype>std::size_t</paramtype></parameter></method>
</method-group>
</struct><class name="iterator_impl"><template>
      <template-type-parameter name="Value"/>
      <template-type-parameter name="Reference"/>
    </template><method-group name="public member functions">
<method name="operator *" cv="const noexcept"><type>Reference</type></method>
</method-group>
<constructor cv="= default"/>
<constructor><template>
          <template-type-parameter name="V"/>
          <template-type-parameter name="R"/>
        </template><parameter name="it"><paramtype>const iterator_impl&lt; V, R &gt; &amp;</paramtype></parameter></constructor>
<constructor cv="noexcept"><parameter name="b"><paramtype>buffer_type *</paramtype></parameter><parameter name="i"><paramtype>std::size_t</paramtype></parameter></constructor>
</class><struct name="multiplier"><method-group name="public member functions">
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="tp"><paramtype>T *</paramtype></parameter><parameter name="b"><paramtype>buffer_type &amp;</paramtype></parameter><parameter name="x"><paramtype>const double</paramtype></parameter></method>
<method name="operator()"><type>void</type><parameter name="tp"><paramtype>double *</paramtype></parameter><parameter name="b"><paramtype>buffer_type &amp;</paramtype></parameter><parameter name="x"><paramtype>const double</paramtype></parameter></method>
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="tp"><paramtype>T *</paramtype></parameter><parameter name="b"><paramtype>buffer_type &amp;</paramtype></parameter><parameter name="i"><paramtype>std::size_t</paramtype></parameter><parameter name="x"><paramtype>const double</paramtype></parameter></method>
<method name="operator()"><type>void</type><parameter name="tp"><paramtype>double *</paramtype></parameter><parameter name=""><paramtype>buffer_type &amp;</paramtype></parameter><parameter name="i"><paramtype>std::size_t</paramtype></parameter><parameter name="x"><paramtype>const double</paramtype></parameter></method>
</method-group>
</struct><class name="reference"><inherit access="public">boost::histogram::unlimited_storage&lt; Allocator &gt;::const_reference</inherit><purpose>implementation detail </purpose><method-group name="public member functions">
<method name="operator&lt;" cv="const noexcept"><type>bool</type><parameter name="o"><paramtype>const <classname>reference</classname> &amp;</paramtype></parameter></method>
<method name="operator==" cv="const noexcept"><type>bool</type><parameter name="o"><paramtype>const <classname>reference</classname> &amp;</paramtype></parameter></method>
<method name="operator&lt;" cv="const noexcept"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="U"/>
        </template><parameter name="o"><paramtype>const U &amp;</paramtype></parameter></method>
<method name="operator&gt;" cv="const noexcept"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="U"/>
        </template><parameter name="o"><paramtype>const U &amp;</paramtype></parameter></method>
<method name="operator==" cv="const noexcept"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="U"/>
        </template><parameter name="o"><paramtype>const U &amp;</paramtype></parameter></method>
<method name="operator+="><type><classname>reference</classname> &amp;</type><parameter name="x"><paramtype>const <classname>const_reference</classname> &amp;</paramtype></parameter></method>
<method name="operator+="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="U"/>
        </template><parameter name="x"><paramtype>const U &amp;</paramtype></parameter></method>
<method name="operator-="><type><classname>reference</classname> &amp;</type><parameter name="x"><paramtype>const double</paramtype></parameter></method>
<method name="operator *="><type><classname>reference</classname> &amp;</type><parameter name="x"><paramtype>const double</paramtype></parameter></method>
<method name="operator/="><type><classname>reference</classname> &amp;</type><parameter name="x"><paramtype>const double</paramtype></parameter></method>
<method name="operator++"><type><classname>reference</classname> &amp;</type></method>
</method-group>
<constructor cv="noexcept"><parameter name="b"><paramtype>buffer_type &amp;</paramtype></parameter><parameter name="i"><paramtype>std::size_t</paramtype></parameter></constructor>
<constructor><parameter name="x"><paramtype>const <classname>reference</classname> &amp;</paramtype></parameter></constructor>
<copy-assignment><type><classname>reference</classname> &amp;</type><parameter name="x"><paramtype>const <classname>reference</classname> &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>reference</classname> &amp;</type><parameter name="x"><paramtype>const <classname>const_reference</classname> &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="U"/>
        </template><parameter name="x"><paramtype>const U &amp;</paramtype></parameter></copy-assignment>
</class><typedef name="allocator_type"><type>Allocator</type></typedef>
<typedef name="value_type"><type>double</type></typedef>
<typedef name="large_int"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="const_iterator"><type>iterator_impl&lt; const value_type, <classname>const_reference</classname> &gt;</type></typedef>
<typedef name="iterator"><type>iterator_impl&lt; value_type, <classname>reference</classname> &gt;</type></typedef>
<data-member name="has_threading_support" specifiers="static"><type>constexpr bool</type></data-member>
<method-group name="public member functions">
<method name="get_allocator" cv="const"><type>allocator_type</type></method>
<method name="reset"><type>void</type><parameter name="n"><paramtype>std::size_t</paramtype></parameter></method>
<method name="size" cv="const noexcept"><type>std::size_t</type></method>
<method name="operator[]" cv="noexcept"><type><classname>reference</classname></type><parameter name="i"><paramtype>std::size_t</paramtype></parameter></method>
<method name="operator[]" cv="const noexcept"><type><classname>const_reference</classname></type><parameter name="i"><paramtype>std::size_t</paramtype></parameter></method>
<method name="operator==" cv="const noexcept"><type>bool</type><parameter name="x"><paramtype>const <classname>unlimited_storage</classname> &amp;</paramtype></parameter></method>
<method name="operator==" cv="const"><type>bool</type><template>
          <template-type-parameter name="Iterable"/>
        </template><parameter name="iterable"><paramtype>const Iterable &amp;</paramtype></parameter></method>
<method name="operator *="><type><classname>unlimited_storage</classname> &amp;</type><parameter name="x"><paramtype>const double</paramtype></parameter></method>
<method name="begin" cv="noexcept"><type>iterator</type></method>
<method name="end" cv="noexcept"><type>iterator</type></method>
<method name="begin" cv="const noexcept"><type>const_iterator</type></method>
<method name="end" cv="const noexcept"><type>const_iterator</type></method>
</method-group>
<constructor specifiers="explicit"><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>{}</default></parameter></constructor>
<constructor cv="= default"><parameter name=""><paramtype>const <classname>unlimited_storage</classname> &amp;</paramtype></parameter></constructor>
<copy-assignment cv="= default"><type><classname>unlimited_storage</classname> &amp;</type><parameter name=""><paramtype>const <classname>unlimited_storage</classname> &amp;</paramtype></parameter></copy-assignment>
<constructor cv="= default"><parameter name=""><paramtype><classname>unlimited_storage</classname> &amp;&amp;</paramtype></parameter></constructor>
<copy-assignment cv="= default"><type><classname>unlimited_storage</classname> &amp;</type><parameter name=""><paramtype><classname>unlimited_storage</classname> &amp;&amp;</paramtype></parameter></copy-assignment>
<constructor specifiers="explicit"><template>
          <template-type-parameter name="Iterable"/>
          <template-type-parameter name=""><default>detail::requires_iterable&lt;Iterable&gt;</default></template-type-parameter>
        </template><parameter name="s"><paramtype>const Iterable &amp;</paramtype></parameter></constructor>
<copy-assignment><type><classname>unlimited_storage</classname> &amp;</type><template>
          <template-type-parameter name="Iterable"/>
          <template-type-parameter name=""><default>detail::requires_iterable&lt;Iterable&gt;</default></template-type-parameter>
        </template><parameter name="s"><paramtype>const Iterable &amp;</paramtype></parameter></copy-assignment>
<constructor><template>
          <template-type-parameter name="T"/>
        </template><parameter name="s"><paramtype>std::size_t</paramtype></parameter><parameter name="p"><paramtype>const T *</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>{}</default></parameter><purpose>implementation detail; used by unit tests, not part of generic storage interface </purpose></constructor>
</class>
























</namespace>
</namespace>
</header>
<header name="boost/histogram/unsafe_access.hpp">
<namespace name="boost">
<namespace name="histogram">
<struct name="unsafe_access"><purpose>Unsafe read/write access to private data that potentially breaks consistency. </purpose><description><para>This struct enables access to private data of some classes. It is intended for library developers who need this to implement algorithms efficiently, for example, serialization. Users should not use this. If you are a user who absolutely needs this to get a specific effect, please submit an issue on Github. Perhaps the public interface is insufficient and should be extended for your use case.</para><para>Unlike the normal interface, the <classname alt="boost::histogram::unsafe_access">unsafe_access</classname> interface may change between versions. If your code relies on <classname alt="boost::histogram::unsafe_access">unsafe_access</classname>, it may or may not break when you update Boost. This is another reason to not use it unless you are ok with these conditions. </para></description><method-group name="public static functions">
<method name="axes" specifiers="static"><type>auto &amp;</type><template>
          <template-type-parameter name="Histogram"/>
        </template><parameter name="hist"><paramtype>Histogram &amp;</paramtype><description><para>histogram. </para></description></parameter><purpose>Get axes. </purpose><description><para>
</para></description></method>
<method name="axes" specifiers="static"><type>const auto &amp;</type><template>
          <template-type-parameter name="Histogram"/>
        </template><parameter name="hist"><paramtype>const Histogram &amp;</paramtype><description><para>histogram. </para></description></parameter><purpose>Get axes. </purpose><description><para>
</para></description></method>
<method name="axis" specifiers="static"><type>decltype(auto)</type><template>
          <template-type-parameter name="Histogram"/>
          <template-nontype-parameter name="I"><type>unsigned</type><default>0</default><purpose><para>axis index (optional, default: 0). </para></purpose></template-nontype-parameter>
        </template><parameter name="hist"><paramtype>Histogram &amp;</paramtype><description><para>histogram. </para></description></parameter><parameter name=""><paramtype>std::integral_constant&lt; unsigned, I &gt;</paramtype><default>{}</default></parameter><purpose>Get mutable axis reference with compile-time number. </purpose><description><para>

</para></description></method>
<method name="axis" specifiers="static"><type>decltype(auto)</type><template>
          <template-type-parameter name="Histogram"/>
        </template><parameter name="hist"><paramtype>Histogram &amp;</paramtype><description><para>histogram. </para></description></parameter><parameter name="i"><paramtype>unsigned</paramtype><description><para>axis index. </para></description></parameter><purpose>Get mutable axis reference with run-time number. </purpose><description><para>
</para></description></method>
<method name="storage" specifiers="static"><type>auto &amp;</type><template>
          <template-type-parameter name="Histogram"/>
        </template><parameter name="hist"><paramtype>Histogram &amp;</paramtype><description><para>histogram. </para></description></parameter><purpose>Get storage. </purpose><description><para>
</para></description></method>
<method name="storage" specifiers="static"><type>const auto &amp;</type><template>
          <template-type-parameter name="Histogram"/>
        </template><parameter name="hist"><paramtype>const Histogram &amp;</paramtype><description><para>histogram. </para></description></parameter><purpose>Get storage. </purpose><description><para>
</para></description></method>
<method name="unlimited_storage_buffer" specifiers="static"><type>constexpr auto &amp;</type><template>
          <template-type-parameter name="Allocator"/>
        </template><parameter name="storage"><paramtype><classname>unlimited_storage</classname>&lt; Allocator &gt; &amp;</paramtype><description><para>instance of <classname alt="boost::histogram::unlimited_storage">unlimited_storage</classname>. </para></description></parameter><purpose>Get buffer of <classname alt="boost::histogram::unlimited_storage">unlimited_storage</classname>. </purpose><description><para>
</para></description></method>
<method name="storage_adaptor_impl" specifiers="static"><type>constexpr auto &amp;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="storage"><paramtype><classname>storage_adaptor</classname>&lt; T &gt; &amp;</paramtype><description><para>instance of <classname alt="boost::histogram::storage_adaptor">storage_adaptor</classname>. </para></description></parameter><purpose>Get implementation of <classname alt="boost::histogram::storage_adaptor">storage_adaptor</classname>. </purpose><description><para>
</para></description></method>
</method-group>
</struct>
























</namespace>
</namespace>
</header>
</library-reference>