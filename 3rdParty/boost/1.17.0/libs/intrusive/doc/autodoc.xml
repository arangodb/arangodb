<?xml version="1.0" standalone="yes"?>
<library-reference><header name="boost/intrusive/any_hook.hpp">
<namespace name="boost">
<namespace name="intrusive">
<class name="any_base_hook"><template>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><inherit access="public">make_any_base_hook::type&lt; O1, O2, O3 &gt;</inherit><description><para>Derive a class from this hook in order to store objects of that class in an intrusive container.</para><para>The hook admits the following options: <computeroutput>tag&lt;&gt;</computeroutput>, <computeroutput>void_pointer&lt;&gt;</computeroutput> and <computeroutput>link_mode&lt;&gt;</computeroutput>.</para><para><computeroutput>tag&lt;&gt;</computeroutput> defines a tag to identify the node. The same tag value can be used in different classes, but if a class is derived from more than one <computeroutput><classname alt="boost::intrusive::any_base_hook">any_base_hook</classname></computeroutput>, then each <computeroutput><classname alt="boost::intrusive::any_base_hook">any_base_hook</classname></computeroutput> needs its unique tag.</para><para><computeroutput>link_mode&lt;&gt;</computeroutput> will specify the linking mode of the hook (<computeroutput>normal_link</computeroutput>, <computeroutput>safe_link</computeroutput>).</para><para><computeroutput>void_pointer&lt;&gt;</computeroutput> is the pointer type that will be used internally in the hook and the container configured to use this hook. </para></description><method-group name="public member functions">
<method name="is_linked" cv="const"><type>bool</type><description><para><emphasis role="bold">Precondition</emphasis>: <classname alt="boost::intrusive::link_mode">link_mode</classname> must be <computeroutput>safe_link</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: true, if the node belongs to a container, false otherwise. This function can be used to test whether <computeroutput>container::iterator_to</computeroutput> will return a valid iterator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></constructor>
<constructor><parameter name=""><paramtype>const <classname>any_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing a copy-constructor makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></constructor>
<copy-assignment><type><classname>any_base_hook</classname> &amp;</type><parameter name=""><paramtype>const <classname>any_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Empty function. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing an assignment operator makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>normal_link</computeroutput>, the destructor does nothing (ie. no code is generated). If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>safe_link</computeroutput> and the object is stored in a container an assertion is raised.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor>
</class><class name="any_member_hook"><template>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><inherit access="public">make_any_member_hook::type&lt; O1, O2, O3 &gt;</inherit><description><para>Store this hook in a class to be inserted in an intrusive container.</para><para>The hook admits the following options: <computeroutput>void_pointer&lt;&gt;</computeroutput> and <computeroutput>link_mode&lt;&gt;</computeroutput>.</para><para><computeroutput>link_mode&lt;&gt;</computeroutput> will specify the linking mode of the hook (<computeroutput>normal_link</computeroutput> or <computeroutput>safe_link</computeroutput>).</para><para><computeroutput>void_pointer&lt;&gt;</computeroutput> is the pointer type that will be used internally in the hook and the container configured to use this hook. </para></description><method-group name="public member functions">
<method name="is_linked" cv="const"><type>bool</type><description><para><emphasis role="bold">Precondition</emphasis>: <classname alt="boost::intrusive::link_mode">link_mode</classname> must be <computeroutput>safe_link</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: true, if the node belongs to a container, false otherwise. This function can be used to test whether <computeroutput>container::iterator_to</computeroutput> will return a valid iterator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></constructor>
<constructor><parameter name=""><paramtype>const <classname>any_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing a copy-constructor makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></constructor>
<copy-assignment><type><classname>any_member_hook</classname> &amp;</type><parameter name=""><paramtype>const <classname>any_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Empty function. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing an assignment operator makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>normal_link</computeroutput>, the destructor does nothing (ie. no code is generated). If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>safe_link</computeroutput> and the object is stored in a container an assertion is raised.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor>
</class><struct name="any_to_avl_set_hook"><template>
      <template-type-parameter name="BasicHook"/>
    </template><description><para>This option setter specifies that any hook should behave as an <classname alt="boost::intrusive::avl_set">avl_set</classname> hook </para></description></struct><struct name="any_to_bs_set_hook"><template>
      <template-type-parameter name="BasicHook"/>
    </template><description><para>This option setter specifies that any hook should behave as a <classname alt="boost::intrusive::bs_set">bs_set</classname> hook </para></description></struct><struct name="any_to_list_hook"><template>
      <template-type-parameter name="BasicHook"/>
    </template><description><para>This option setter specifies that any hook should behave as an list hook </para></description></struct><struct name="any_to_set_hook"><template>
      <template-type-parameter name="BasicHook"/>
    </template><description><para>This option setter specifies that any hook should behave as a set hook </para></description></struct><struct name="any_to_slist_hook"><template>
      <template-type-parameter name="BasicHook"/>
    </template><description><para>This option setter specifies that any hook should behave as an slist hook </para></description></struct><struct name="any_to_unordered_set_hook"><template>
      <template-type-parameter name="BasicHook"/>
    </template><description><para>This option setter specifies that any hook should behave as an unordered set hook </para></description></struct><struct name="make_any_base_hook"><template>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput><computeroutput><classname alt="boost::intrusive::any_base_hook">any_base_hook</classname></computeroutput> that</computeroutput> yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct><struct name="make_any_member_hook"><template>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput><computeroutput><classname alt="boost::intrusive::any_member_hook">any_member_hook</classname></computeroutput> that</computeroutput> yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct>



















































</namespace>
</namespace>
</header>
<header name="boost/intrusive/avl_set.hpp">
<namespace name="boost">
<namespace name="intrusive">
<class name="avl_multiset"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>The class template <classname alt="boost::intrusive::avl_multiset">avl_multiset</classname> is an intrusive container, that mimics most of the interface of std::_multiset as described in the C++ standard.</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput> and <computeroutput>compare&lt;&gt;</computeroutput>. </para></description><typedef name="value_type"><type>implementation_defined::value_type</type></typedef>
<typedef name="key_type"><type>implementation_defined::key_type</type></typedef>
<typedef name="key_of_value"><type>implementation_defined::key_of_value</type></typedef>
<typedef name="value_traits"><type>implementation_defined::value_traits</type></typedef>
<typedef name="pointer"><type>implementation_defined::pointer</type></typedef>
<typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef>
<typedef name="reference"><type>implementation_defined::reference</type></typedef>
<typedef name="const_reference"><type>implementation_defined::const_reference</type></typedef>
<typedef name="difference_type"><type>implementation_defined::difference_type</type></typedef>
<typedef name="size_type"><type>implementation_defined::size_type</type></typedef>
<typedef name="value_compare"><type>implementation_defined::value_compare</type></typedef>
<typedef name="key_compare"><type>implementation_defined::key_compare</type></typedef>
<typedef name="iterator"><type>implementation_defined::iterator</type></typedef>
<typedef name="const_iterator"><type>implementation_defined::const_iterator</type></typedef>
<typedef name="reverse_iterator"><type>implementation_defined::reverse_iterator</type></typedef>
<typedef name="const_reverse_iterator"><type>implementation_defined::const_reverse_iterator</type></typedef>
<typedef name="insert_commit_data"><type>implementation_defined::insert_commit_data</type></typedef>
<typedef name="node_traits"><type>implementation_defined::node_traits</type></typedef>
<typedef name="node"><type>implementation_defined::node</type></typedef>
<typedef name="node_ptr"><type>implementation_defined::node_ptr</type></typedef>
<typedef name="const_node_ptr"><type>implementation_defined::const_node_ptr</type></typedef>
<typedef name="node_algorithms"><type>implementation_defined::node_algorithms</type></typedef>
<data-member name="constant_time_size" specifiers="static"><type>const bool</type></data-member>
<method-group name="public member functions">
<method name="begin"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rbegin"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a iterator pointing to the root node of the container or end() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="croot" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the key_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If key_compare copy-constructor throws. </para></description></method>
<method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the value_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_compare copy-constructor throws. </para></description></method>
<method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this if constant-time size option is disabled. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="swap"><type>void</type><parameter name="other"><paramtype><classname>avl_multiset</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of two containers.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison functor's swap call throws. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>avl_multiset</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype><classname>avl_multiset</classname> &amp;&amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(reference) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: This version can modify the source container, useful to implement move semantics. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the container before the upper bound.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal key_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and "hint" must be a valid iterator.</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container, using "hint" as a hint to where it will be inserted. If "hint" is the upper_bound the insertion takes constant time (two comparisons in the worst case)</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the internal key_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Inserts a each element of a range into the container before the upper bound of the key of each element.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_before"><type>iterator</type><parameter name="pos"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, "pos" must be a valid iterator (or end) and must be the succesor of value once inserted according to the predicate</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container before "pos".</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if "pos" is not the successor of "value" container ordering invariant will be broken. This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_back"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no less than the greatest inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the last position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is less than the greatest inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_front"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no greater than the minimum inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the first position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is greater than the minimum inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="i"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp".</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk) and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="clear"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="clear_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements calling disposer(p) for each node to be erased. <emphasis role="bold">Complexity</emphasis>: Average complexity for is at most O(log(size() + N)), where N is the number of elements in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. Calls N times to disposer functor. </para></description></method>
<method name="count" cv="const"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given value</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given value.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="count" cv="const"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="lower_bound"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="find"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="find"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="lower_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="lower_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const key_type &amp;key</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="iterator_to"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="unlink_leftmost_without_rebalance"><type>pointer</type><description><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the container.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the container and the container can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the container. </para></description></method>
<method name="replace_node"><type>void</type><parameter name="replace_this"><paramtype>iterator</paramtype></parameter><parameter name="with_this"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: replace_this must be a valid iterator of *this and with_this must not be inserted in any container.</para><para><emphasis role="bold">Effects</emphasis>: Replaces replace_this in its position in the container with with_this. The container does not need to be rebalanced.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if with_this is not equivalent to *replace_this according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. </para></description></method>
<method name="remove_node"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: removes "value" from the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic time.</para><para><emphasis role="bold">Note</emphasis>: This static function is only usable with non-constant time size containers that have stateless comparison functors.</para><para>If the user calls this function with a constant time size container or stateful comparison functor a compilation error will be issued. </para></description></method>
<method name="merge"><type>void</type><template>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="source"><paramtype><classname>avl_multiset</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Extracts each element in source and insert it into a using the comparison object of *this.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="source"><paramtype><classname>avl_set</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Extracts each element in source and insert it into a using the comparison object of *this.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container with given comparison and traits.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype><default>key_compare()</default></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type. cmp must be a comparison function that induces a strict weak ordering.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container and inserts elements from [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if [b, e) is already sorted using comp and otherwise N * log N, where N is the distance between first and last.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor/operator() of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>avl_multiset</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a container moving resources from another container. Internal comparison object and value traits are move constructed and nodes belonging to x (except the node representing the "end") are linked to *this.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node's move constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the move constructor of the comparison objet throws. </para></description></constructor>
<copy-assignment><type><classname>avl_multiset</classname> &amp;</type><parameter name="x"><paramtype><classname>avl_multiset</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to swap </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the set are not deleted (i.e. no destructors are called), but the nodes according to the <classname alt="boost::intrusive::value_traits">value_traits</classname> template parameter are reinitialized and thus can be reused.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor>
<method-group name="public static functions">
<method name="container_from_end_iterator" specifiers="static"><type><classname>avl_multiset</classname> &amp;</type><parameter name="end_iterator"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_end_iterator" specifiers="static"><type>const <classname>avl_multiset</classname> &amp;</type><parameter name="end_iterator"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type><classname>avl_multiset</classname> &amp;</type><parameter name="it"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type>const <classname>avl_multiset</classname> &amp;</type><parameter name="it"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="init_node" specifiers="static"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value shall not be in a container.</para><para><emphasis role="bold">Effects</emphasis>: init_node puts the hook of a value in a well-known default state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: This function puts the hook in the well-known default state used by auto_unlink and safe hooks. </para></description></method>
</method-group>
</class><class name="avl_set"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>The class template <classname alt="boost::intrusive::avl_set">avl_set</classname> is an intrusive container, that mimics most of the interface of std::set as described in the C++ standard.</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput> and <computeroutput>compare&lt;&gt;</computeroutput>. </para></description><typedef name="value_type"><type>implementation_defined::value_type</type></typedef>
<typedef name="key_type"><type>implementation_defined::key_type</type></typedef>
<typedef name="key_of_value"><type>implementation_defined::key_of_value</type></typedef>
<typedef name="value_traits"><type>implementation_defined::value_traits</type></typedef>
<typedef name="pointer"><type>implementation_defined::pointer</type></typedef>
<typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef>
<typedef name="reference"><type>implementation_defined::reference</type></typedef>
<typedef name="const_reference"><type>implementation_defined::const_reference</type></typedef>
<typedef name="difference_type"><type>implementation_defined::difference_type</type></typedef>
<typedef name="size_type"><type>implementation_defined::size_type</type></typedef>
<typedef name="value_compare"><type>implementation_defined::value_compare</type></typedef>
<typedef name="key_compare"><type>implementation_defined::key_compare</type></typedef>
<typedef name="iterator"><type>implementation_defined::iterator</type></typedef>
<typedef name="const_iterator"><type>implementation_defined::const_iterator</type></typedef>
<typedef name="reverse_iterator"><type>implementation_defined::reverse_iterator</type></typedef>
<typedef name="const_reverse_iterator"><type>implementation_defined::const_reverse_iterator</type></typedef>
<typedef name="insert_commit_data"><type>implementation_defined::insert_commit_data</type></typedef>
<typedef name="node_traits"><type>implementation_defined::node_traits</type></typedef>
<typedef name="node"><type>implementation_defined::node</type></typedef>
<typedef name="node_ptr"><type>implementation_defined::node_ptr</type></typedef>
<typedef name="const_node_ptr"><type>implementation_defined::const_node_ptr</type></typedef>
<typedef name="node_algorithms"><type>implementation_defined::node_algorithms</type></typedef>
<data-member name="constant_time_size" specifiers="static"><type>const bool</type></data-member>
<method-group name="public member functions">
<method name="begin"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="avlegin"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="avlegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a iterator pointing to the root node of the container or end() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="croot" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the key_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If key_compare copy-constructor throws. </para></description></method>
<method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the value_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_compare copy-constructor throws. </para></description></method>
<method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this if constant-time size option is disabled. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="swap"><type>void</type><parameter name="other"><paramtype><classname>avl_set</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of two containers.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison functor's swap call throws. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>avl_set</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype><classname>avl_set</classname> &amp;&amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(reference) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: This version can modify the source container, useful to implement move semantics. </para></description></method>
<method name="insert"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the container if the value is not already present.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and "hint" must be a valid iterator</para><para><emphasis role="bold">Effects</emphasis>: Tries to insert x into the container, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time (two comparisons in the worst case) if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_check"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee. </para></description></method>
<method name="insert_check"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it's amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee. </para></description></method>
<method name="insert_check"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must be a comparison function that induces the same strict weak ordering as key_compare. The difference is that comp compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the container. </para></description></method>
<method name="insert_check"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must be a comparison function that induces the same strict weak ordering as key_compare. The difference is that comp compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it's amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the constructing that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that key to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This can give a total constant-time complexity to the insertion: check(O(1)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the container. </para></description></method>
<method name="insert"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Tries to insert each element of a range into the container.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_commit"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><parameter name="commit_data"><paramtype>const insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue of type value_type. commit_data must have been obtained from a previous call to "insert_check". No objects should have been inserted or erased from the container between the "insert_check" that filled "commit_data" and the call to "insert_commit".</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value in the container using the information obtained from the "commit_data" that a previous "insert_check" filled.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the newly inserted object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function has only sense if a "insert_check" has been previously executed to fill "commit_data". No value should be inserted or erased between the "insert_check" and "insert_commit" calls. </para></description></method>
<method name="insert_before"><type>iterator</type><parameter name="pos"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, "pos" must be a valid iterator (or end) and must be the succesor of value once inserted according to the predicate</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container before "pos".</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if "pos" is not the successor of "value" container ordering invariant will be broken. This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_back"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no less than the greatest inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the last position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is less than the greatest inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_front"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no greater than the minimum inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the first position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is greater than the minimum inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="i"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp".</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk) and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="clear"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="clear_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements calling disposer(p) for each node to be erased. <emphasis role="bold">Complexity</emphasis>: Average complexity for is at most O(log(size() + N)), where N is the number of elements in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. Calls N times to disposer functor. </para></description></method>
<method name="count" cv="const"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given value</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given value.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="count" cv="const"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="lower_bound"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="find"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="find"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="lower_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="lower_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="iterator_to"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="unlink_leftmost_without_rebalance"><type>pointer</type><description><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the container.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the container and the container can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the container. </para></description></method>
<method name="replace_node"><type>void</type><parameter name="replace_this"><paramtype>iterator</paramtype></parameter><parameter name="with_this"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: replace_this must be a valid iterator of *this and with_this must not be inserted in any container.</para><para><emphasis role="bold">Effects</emphasis>: Replaces replace_this in its position in the container with with_this. The container does not need to be rebalanced.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if with_this is not equivalent to *replace_this according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. </para></description></method>
<method name="remove_node"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: removes "value" from the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic time.</para><para><emphasis role="bold">Note</emphasis>: This static function is only usable with non-constant time size containers that have stateless comparison functors.</para><para>If the user calls this function with a constant time size container or stateful comparison functor a compilation error will be issued. </para></description></method>
<method name="merge"><type>void</type><template>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="source"><paramtype><classname>avl_set</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="source"><paramtype><classname>avl_multiset</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container with given comparison and traits.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype><default>key_compare()</default></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type. cmp must be a comparison function that induces a strict weak ordering.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container and inserts elements from [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if [b, e) is already sorted using comp and otherwise N * log N, where N is the distance between first and last.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor/operator() of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>avl_set</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a container moving resources from another container. Internal comparison object and value traits are move constructed and nodes belonging to x (except the node representing the "end") are linked to *this.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node's move constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the move constructor of the comparison objet throws. </para></description></constructor>
<copy-assignment><type><classname>avl_set</classname> &amp;</type><parameter name="x"><paramtype><classname>avl_set</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to swap </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the set are not deleted (i.e. no destructors are called), but the nodes according to the <classname alt="boost::intrusive::value_traits">value_traits</classname> template parameter are reinitialized and thus can be reused.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor>
<method-group name="public static functions">
<method name="container_from_end_iterator" specifiers="static"><type><classname>avl_set</classname> &amp;</type><parameter name="end_iterator"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_end_iterator" specifiers="static"><type>const <classname>avl_set</classname> &amp;</type><parameter name="end_iterator"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type><classname>avl_set</classname> &amp;</type><parameter name="it"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type>const <classname>avl_set</classname> &amp;</type><parameter name="it"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="init_node" specifiers="static"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value shall not be in a container.</para><para><emphasis role="bold">Effects</emphasis>: init_node puts the hook of a value in a well-known default state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: This function puts the hook in the well-known default state used by auto_unlink and safe hooks. </para></description></method>
</method-group>
</class><struct name="make_avl_multiset"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput><classname alt="boost::intrusive::avl_multiset">avl_multiset</classname></computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct><struct name="make_avl_set"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>set</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct>









































<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>avl_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>avl_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>avl_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>avl_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>avl_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>avl_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>avl_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>avl_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype><classname>avl_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>avl_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>avl_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>avl_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>avl_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>avl_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>avl_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>avl_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>avl_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>avl_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype><classname>avl_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>avl_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
</namespace>
</namespace>
</header>
<header name="boost/intrusive/avl_set_hook.hpp">
<namespace name="boost">
<namespace name="intrusive">
<class name="avl_set_base_hook"><template>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><inherit access="public">make_avl_set_base_hook::type&lt; O1, O2, O3, O4 &gt;</inherit><description><para>Derive a class from <classname alt="boost::intrusive::avl_set_base_hook">avl_set_base_hook</classname> in order to store objects in in an avl_set/avl_multiset. <classname alt="boost::intrusive::avl_set_base_hook">avl_set_base_hook</classname> holds the data necessary to maintain the avl_set/avl_multiset and provides an appropriate <classname alt="boost::intrusive::value_traits">value_traits</classname> class for avl_set/avl_multiset.</para><para>The hook admits the following options: <computeroutput>tag&lt;&gt;</computeroutput>, <computeroutput>void_pointer&lt;&gt;</computeroutput>, <computeroutput>link_mode&lt;&gt;</computeroutput> and <computeroutput>optimize_size&lt;&gt;</computeroutput>.</para><para><computeroutput>tag&lt;&gt;</computeroutput> defines a tag to identify the node. The same tag value can be used in different classes, but if a class is derived from more than one <computeroutput><classname alt="boost::intrusive::list_base_hook">list_base_hook</classname></computeroutput>, then each <computeroutput><classname alt="boost::intrusive::list_base_hook">list_base_hook</classname></computeroutput> needs its unique tag.</para><para><computeroutput>void_pointer&lt;&gt;</computeroutput> is the pointer type that will be used internally in the hook and the container configured to use this hook.</para><para><computeroutput>link_mode&lt;&gt;</computeroutput> will specify the linking mode of the hook (<computeroutput>normal_link</computeroutput>, <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput>).</para><para><computeroutput>optimize_size&lt;&gt;</computeroutput> will tell the hook to optimize the hook for size instead of speed. </para></description><method-group name="public member functions">
<method name="swap_nodes"><type>void</type><parameter name="other"><paramtype><classname>avl_set_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swapping two nodes swaps the position of the elements related to those nodes in one or two containers. That is, if the node this is part of the element e1, the node x is part of the element e2 and both elements are included in the containers s1 and s2, then after the swap-operation e1 is in s2 at the position of e2 and e2 is in s1 at the position of e1. If one element is not in a container, then after the swap-operation the other element is not in a container. Iterators to e1 and e2 related to those nodes are invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="is_linked" cv="const"><type>bool</type><description><para><emphasis role="bold">Precondition</emphasis>: <classname alt="boost::intrusive::link_mode">link_mode</classname> must be <computeroutput>safe_link</computeroutput> or <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: true, if the node belongs to a container, false otherwise. This function can be used to test whether <computeroutput>set::iterator_to</computeroutput> will return a valid iterator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method>
<method name="unlink"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the node if it's inserted in a container. This function is only allowed if <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></constructor>
<constructor><parameter name=""><paramtype>const <classname>avl_set_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing a copy-constructor makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></constructor>
<copy-assignment><type><classname>avl_set_base_hook</classname> &amp;</type><parameter name=""><paramtype>const <classname>avl_set_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Empty function. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing an assignment operator makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>normal_link</computeroutput>, the destructor does nothing (ie. no code is generated). If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>safe_link</computeroutput> and the object is stored in a set an assertion is raised. If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> and <computeroutput>is_linked()</computeroutput> is true, the node is unlinked.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor>
</class><class name="avl_set_member_hook"><template>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><inherit access="public">make_avl_set_member_hook::type&lt; O1, O2, O3, O4 &gt;</inherit><description><para>Put a public data member <classname alt="boost::intrusive::avl_set_member_hook">avl_set_member_hook</classname> in order to store objects of this class in an avl_set/avl_multiset. <classname alt="boost::intrusive::avl_set_member_hook">avl_set_member_hook</classname> holds the data necessary for maintaining the avl_set/avl_multiset and provides an appropriate <classname alt="boost::intrusive::value_traits">value_traits</classname> class for avl_set/avl_multiset.</para><para>The hook admits the following options: <computeroutput>void_pointer&lt;&gt;</computeroutput>, <computeroutput>link_mode&lt;&gt;</computeroutput> and <computeroutput>optimize_size&lt;&gt;</computeroutput>.</para><para><computeroutput>void_pointer&lt;&gt;</computeroutput> is the pointer type that will be used internally in the hook and the container configured to use this hook.</para><para><computeroutput>link_mode&lt;&gt;</computeroutput> will specify the linking mode of the hook (<computeroutput>normal_link</computeroutput>, <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput>).</para><para><computeroutput>optimize_size&lt;&gt;</computeroutput> will tell the hook to optimize the hook for size instead of speed. </para></description><method-group name="public member functions">
<method name="swap_nodes"><type>void</type><parameter name="other"><paramtype><classname>avl_set_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swapping two nodes swaps the position of the elements related to those nodes in one or two containers. That is, if the node this is part of the element e1, the node x is part of the element e2 and both elements are included in the containers s1 and s2, then after the swap-operation e1 is in s2 at the position of e2 and e2 is in s1 at the position of e1. If one element is not in a container, then after the swap-operation the other element is not in a container. Iterators to e1 and e2 related to those nodes are invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="is_linked" cv="const"><type>bool</type><description><para><emphasis role="bold">Precondition</emphasis>: <classname alt="boost::intrusive::link_mode">link_mode</classname> must be <computeroutput>safe_link</computeroutput> or <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: true, if the node belongs to a container, false otherwise. This function can be used to test whether <computeroutput>set::iterator_to</computeroutput> will return a valid iterator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method>
<method name="unlink"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the node if it's inserted in a container. This function is only allowed if <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></constructor>
<constructor><parameter name=""><paramtype>const <classname>avl_set_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing a copy-constructor makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></constructor>
<copy-assignment><type><classname>avl_set_member_hook</classname> &amp;</type><parameter name=""><paramtype>const <classname>avl_set_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Empty function. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing an assignment operator makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>normal_link</computeroutput>, the destructor does nothing (ie. no code is generated). If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>safe_link</computeroutput> and the object is stored in a set an assertion is raised. If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> and <computeroutput>is_linked()</computeroutput> is true, the node is unlinked.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor>
</class><struct name="make_avl_set_base_hook"><template>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput><classname alt="boost::intrusive::avl_set_base_hook">avl_set_base_hook</classname></computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct><struct name="make_avl_set_member_hook"><template>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput><classname alt="boost::intrusive::avl_set_member_hook">avl_set_member_hook</classname></computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct>



















































</namespace>
</namespace>
</header>
<header name="boost/intrusive/avltree.hpp">
<namespace name="boost">
<namespace name="intrusive">
<class name="avltree"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>The class template avltree is an intrusive AVL tree container, that is used to construct intrusive <classname alt="boost::intrusive::avl_set">avl_set</classname> and <classname alt="boost::intrusive::avl_multiset">avl_multiset</classname> containers. The no-throw guarantee holds only, if the key_compare object doesn't throw.</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput> and <computeroutput>compare&lt;&gt;</computeroutput>. </para></description><typedef name="value_traits"><type>ValueTraits</type></typedef>
<typedef name="pointer"><type>implementation_defined::pointer</type></typedef>
<typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef>
<typedef name="value_type"><type>implementation_defined::value_type</type></typedef>
<typedef name="key_type"><type>implementation_defined::key_type</type></typedef>
<typedef name="key_of_value"><type>implementation_defined::key_of_value</type></typedef>
<typedef name="reference"><type>implementation_defined::reference</type></typedef>
<typedef name="const_reference"><type>implementation_defined::const_reference</type></typedef>
<typedef name="difference_type"><type>implementation_defined::difference_type</type></typedef>
<typedef name="size_type"><type>implementation_defined::size_type</type></typedef>
<typedef name="value_compare"><type>implementation_defined::value_compare</type></typedef>
<typedef name="key_compare"><type>implementation_defined::key_compare</type></typedef>
<typedef name="iterator"><type>implementation_defined::iterator</type></typedef>
<typedef name="const_iterator"><type>implementation_defined::const_iterator</type></typedef>
<typedef name="reverse_iterator"><type>implementation_defined::reverse_iterator</type></typedef>
<typedef name="const_reverse_iterator"><type>implementation_defined::const_reverse_iterator</type></typedef>
<typedef name="node_traits"><type>implementation_defined::node_traits</type></typedef>
<typedef name="node"><type>implementation_defined::node</type></typedef>
<typedef name="node_ptr"><type>implementation_defined::node_ptr</type></typedef>
<typedef name="const_node_ptr"><type>implementation_defined::const_node_ptr</type></typedef>
<typedef name="node_algorithms"><type>implementation_defined::node_algorithms</type></typedef>
<typedef name="insert_commit_data"><type>implementation_defined::insert_commit_data</type></typedef>
<data-member name="constant_time_size" specifiers="static"><type>const bool</type></data-member>
<method-group name="public member functions">
<method name="begin"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rbegin"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a iterator pointing to the root node of the container or end() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="croot" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the key_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If key_compare copy-constructor throws. </para></description></method>
<method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the value_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_compare copy-constructor throws. </para></description></method>
<method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this if constant-time size option is disabled. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="swap"><type>void</type><parameter name="other"><paramtype><classname>avltree</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of two containers.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison functor's swap call throws. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>avltree</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype><classname>avltree</classname> &amp;&amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(reference) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: This version can modify the source container, useful to implement move semantics. </para></description></method>
<method name="insert_equal"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the container before the upper bound.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal key_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_equal"><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and "hint" must be a valid iterator.</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container, using "hint" as a hint to where it will be inserted. If "hint" is the upper_bound the insertion takes constant time (two comparisons in the worst case)</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the internal key_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_equal"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Inserts a each element of a range into the container before the upper bound of the key of each element.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_unique"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the container if the value is not already present.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_unique"><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and "hint" must be a valid iterator</para><para><emphasis role="bold">Effects</emphasis>: Tries to insert x into the container, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time (two comparisons in the worst case) if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_unique_check"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must be a comparison function that induces the same strict weak ordering as key_compare. The difference is that comp compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the container. </para></description></method>
<method name="insert_unique_check"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must be a comparison function that induces the same strict weak ordering as key_compare. The difference is that comp compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it's amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the constructing that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that key to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This can give a total constant-time complexity to the insertion: check(O(1)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the container. </para></description></method>
<method name="insert_unique_check"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee. </para></description></method>
<method name="insert_unique_check"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it's amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee. </para></description></method>
<method name="insert_unique_commit"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><parameter name="commit_data"><paramtype>const insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue of type value_type. commit_data must have been obtained from a previous call to "insert_check". No objects should have been inserted or erased from the container between the "insert_check" that filled "commit_data" and the call to "insert_commit".</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value in the container using the information obtained from the "commit_data" that a previous "insert_check" filled.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the newly inserted object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function has only sense if a "insert_check" has been previously executed to fill "commit_data". No value should be inserted or erased between the "insert_check" and "insert_commit" calls. </para></description></method>
<method name="insert_unique"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Tries to insert each element of a range into the container.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_before"><type>iterator</type><parameter name="pos"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, "pos" must be a valid iterator (or end) and must be the succesor of value once inserted according to the predicate</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container before "pos".</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if "pos" is not the successor of "value" container ordering invariant will be broken. This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_back"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no less than the greatest inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the last position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is less than the greatest inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_front"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no greater than the minimum inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the first position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is greater than the minimum inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="i"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp".</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk) and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="clear"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="clear_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements calling disposer(p) for each node to be erased. <emphasis role="bold">Complexity</emphasis>: Average complexity for is at most O(log(size() + N)), where N is the number of elements in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. Calls N times to disposer functor. </para></description></method>
<method name="count" cv="const"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given value</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given value.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="count" cv="const"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="lower_bound"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="find"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="find"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="lower"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="lower_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="iterator_to"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="unlink_leftmost_without_rebalance"><type>pointer</type><description><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the container.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the container and the container can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the container. </para></description></method>
<method name="replace_node"><type>void</type><parameter name="replace_this"><paramtype>iterator</paramtype></parameter><parameter name="with_this"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: replace_this must be a valid iterator of *this and with_this must not be inserted in any container.</para><para><emphasis role="bold">Effects</emphasis>: Replaces replace_this in its position in the container with with_this. The container does not need to be rebalanced.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if with_this is not equivalent to *replace_this according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. </para></description></method>
<method name="remove_node"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: removes "value" from the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic time.</para><para><emphasis role="bold">Note</emphasis>: This static function is only usable with non-constant time size containers that have stateless comparison functors.</para><para>If the user calls this function with a constant time size container or stateful comparison functor a compilation error will be issued. </para></description></method>
<method name="merge_unique"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name=""><paramtype><classname>avltree</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge_equal"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name=""><paramtype><classname>avltree</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Extracts each element in source and insert it into a using the comparison object of *this.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container with given comparison and traits.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="unique"><paramtype>bool</paramtype></parameter><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype><default>key_compare()</default></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type. cmp must be a comparison function that induces a strict weak ordering.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container and inserts elements from [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if [b, e) is already sorted using comp and otherwise N * log N, where N is the distance between first and last.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor/operator() of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>avltree</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a container moving resources from another container. Internal comparison object and value traits are move constructed and nodes belonging to x (except the node representing the "end") are linked to *this.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node's move constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the move constructor of the comparison objet throws. </para></description></constructor>
<copy-assignment><type><classname>avltree</classname> &amp;</type><parameter name="x"><paramtype><classname>avltree</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to swap </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the set are not deleted (i.e. no destructors are called), but the nodes according to the <classname alt="boost::intrusive::value_traits">value_traits</classname> template parameter are reinitialized and thus can be reused.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor>
<method-group name="public static functions">
<method name="container_from_end_iterator" specifiers="static"><type><classname>avltree</classname> &amp;</type><parameter name="end_iterator"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_end_iterator" specifiers="static"><type>const <classname>avltree</classname> &amp;</type><parameter name="end_iterator"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type><classname>avltree</classname> &amp;</type><parameter name="it"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type>const <classname>avltree</classname> &amp;</type><parameter name="it"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="init_node" specifiers="static"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value shall not be in a container.</para><para><emphasis role="bold">Effects</emphasis>: init_node puts the hook of a value in a well-known default state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: This function puts the hook in the well-known default state used by auto_unlink and safe hooks. </para></description></method>
</method-group>
</class><struct name="make_avltree"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>avltree</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct>



















































</namespace>
</namespace>
</header>
<header name="boost/intrusive/avltree_algorithms.hpp">
<namespace name="boost">
<namespace name="intrusive">
<class name="avltree_algorithms"><template>
      <template-type-parameter name="NodeTraits"/>
    </template><description><para><classname alt="boost::intrusive::avltree_algorithms">avltree_algorithms</classname> is configured with a NodeTraits class, which encapsulates the information about the node to be manipulated. NodeTraits must support the following interface:</para><para><emphasis role="bold">Typedefs</emphasis>:</para><para><computeroutput>node</computeroutput>: The type of the node that forms the binary search tree</para><para><computeroutput>node_ptr</computeroutput>: A pointer to a node</para><para><computeroutput>const_node_ptr</computeroutput>: A pointer to a const node</para><para><computeroutput>balance</computeroutput>: The type of the balance factor</para><para><emphasis role="bold">Static functions</emphasis>:</para><para><computeroutput>static node_ptr get_parent(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_parent(node_ptr n, node_ptr parent);</computeroutput></para><para><computeroutput>static node_ptr get_left(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_left(node_ptr n, node_ptr left);</computeroutput></para><para><computeroutput>static node_ptr get_right(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_right(node_ptr n, node_ptr right);</computeroutput></para><para><computeroutput>static balance get_balance(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_balance(node_ptr n, balance b);</computeroutput></para><para><computeroutput>static balance negative();</computeroutput></para><para><computeroutput>static balance zero();</computeroutput></para><para><computeroutput>static balance positive();</computeroutput> </para></description><typedef name="node"><type>NodeTraits::node</type></typedef>
<typedef name="node_traits"><type>NodeTraits</type></typedef>
<typedef name="node_ptr"><type>NodeTraits::node_ptr</type></typedef>
<typedef name="const_node_ptr"><type>NodeTraits::const_node_ptr</type></typedef>
<typedef name="balance"><type>NodeTraits::balance</type></typedef>
<typedef name="insert_commit_data"><description><para>This type is the information that will be filled by insert_unique_check </para></description><type>bstree_algo::insert_commit_data</type></typedef>
<method-group name="public static functions">
<method name="get_header" specifiers="static"><type>node_ptr</type><parameter name="n"><paramtype>const const_node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'node' is a node of the tree or a header node.</para><para><emphasis role="bold">Effects</emphasis>: Returns the header of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="begin_node" specifiers="static"><type>node_ptr</type><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'header' is the header node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Returns the first node of the tree, the header if the tree is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end_node" specifiers="static"><type>node_ptr</type><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'header' is the header node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Returns the header of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="swap_tree" specifiers="static"><type>void</type><parameter name="header1"><paramtype>node_ptr</paramtype></parameter><parameter name="header2"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header1 and header2 must be the header nodes of two trees.</para><para><emphasis role="bold">Effects</emphasis>: Swaps two trees. After the function header1 will contain links to the second tree and header2 will have links to the first tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="swap_nodes" specifiers="static"><type>void</type><parameter name="node1"><paramtype>node_ptr</paramtype></parameter><parameter name="node2"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node1 and node2 can't be header nodes of two trees.</para><para><emphasis role="bold">Effects</emphasis>: Swaps two nodes. After the function node1 will be inserted in the position node2 before the function. node2 will be inserted in the position node1 had before the function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if node1 and node2 are not equivalent according to the ordering rules.</para><para>Experimental function </para></description></method>
<method name="swap_nodes" specifiers="static"><type>void</type><parameter name="node1"><paramtype>node_ptr</paramtype></parameter><parameter name="header1"><paramtype>node_ptr</paramtype></parameter><parameter name="node2"><paramtype>node_ptr</paramtype></parameter><parameter name="header2"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node1 and node2 can't be header nodes of two trees with header header1 and header2.</para><para><emphasis role="bold">Effects</emphasis>: Swaps two nodes. After the function node1 will be inserted in the position node2 before the function. node2 will be inserted in the position node1 had before the function.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if node1 and node2 are not equivalent according to the ordering rules.</para><para>Experimental function </para></description></method>
<method name="replace_node" specifiers="static"><type>void</type><parameter name="node_to_be_replaced"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node_to_be_replaced must be inserted in a tree and new_node must not be inserted in a tree.</para><para><emphasis role="bold">Effects</emphasis>: Replaces node_to_be_replaced in its position in the tree with new_node. The tree does not need to be rebalanced</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if new_node is not equivalent to node_to_be_replaced according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing and comparison is needed. Experimental function </para></description></method>
<method name="replace_node" specifiers="static"><type>void</type><parameter name="node_to_be_replaced"><paramtype>node_ptr</paramtype></parameter><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node_to_be_replaced must be inserted in a tree with header "header" and new_node must not be inserted in a tree.</para><para><emphasis role="bold">Effects</emphasis>: Replaces node_to_be_replaced in its position in the tree with new_node. The tree does not need to be rebalanced</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if new_node is not equivalent to node_to_be_replaced according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. Experimental function </para></description></method>
<method name="unlink" specifiers="static"><type>void</type><parameter name="node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node is a tree node but not the header.</para><para><emphasis role="bold">Effects</emphasis>: Unlinks the node and rebalances the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="unlink_leftmost_without_rebalance" specifiers="static"><type>node_ptr</type><parameter name="header"><paramtype>const node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header is the header of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the tree, and updates the header link to the new leftmost node.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the tree and the tree can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the tree. </para></description></method>
<method name="unique" specifiers="static"><type>bool</type><parameter name="node"><paramtype>const const_node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'node' is a node of the tree or a node initialized by init(...) or init_node.</para><para><emphasis role="bold">Effects</emphasis>: Returns true if the node is initialized by init() or init_node().</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="size" specifiers="static"><type>std::size_t</type><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node is a node of the tree but it's not the header.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of nodes of the subtree.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="next_node" specifiers="static"><type>node_ptr</type><parameter name="node"><paramtype>const node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'node' is a node from the tree except the header.</para><para><emphasis role="bold">Effects</emphasis>: Returns the next node of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="prev_node" specifiers="static"><type>node_ptr</type><parameter name="node"><paramtype>const node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'node' is a node from the tree except the leftmost node.</para><para><emphasis role="bold">Effects</emphasis>: Returns the previous node of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="init" specifiers="static"><type>void</type><parameter name="node"><paramtype>const node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'node' must not be part of any tree.</para><para><emphasis role="bold">Effects</emphasis>: After the function unique(node) == true.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Nodes</emphasis>: If node is inserted in a tree, this function corrupts the tree. </para></description></method>
<method name="init_header" specifiers="static"><type>void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node must not be part of any tree.</para><para><emphasis role="bold">Effects</emphasis>: Initializes the header to represent an empty tree. unique(header) == true.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Nodes</emphasis>: If node is inserted in a tree, this function corrupts the tree. </para></description></method>
<method name="erase" specifiers="static"><type>node_ptr</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="z"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header must be the header of a tree, z a node of that tree and z != header.</para><para><emphasis role="bold">Effects</emphasis>: Erases node "z" from the tree with header "header".</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="transfer_unique" specifiers="static"><type>bool</type><template>
          <template-type-parameter name="NodePtrCompare"/>
        </template><parameter name="header1"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><parameter name="header2"><paramtype>node_ptr</paramtype></parameter><parameter name="z"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header1 and header2 must be the headers of trees tree1 and tree2 respectively, z a non-header node of tree1. NodePtrCompare is the comparison function of tree1..</para><para><emphasis role="bold">Effects</emphasis>: Transfers node "z" from tree1 to tree2 if tree1 does not contain a node that is equivalent to z.</para><para><emphasis role="bold">Returns</emphasis>: True if the node was trasferred, false otherwise.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison throws. </para></description></method>
<method name="transfer_equal" specifiers="static"><type>void</type><template>
          <template-type-parameter name="NodePtrCompare"/>
        </template><parameter name="header1"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><parameter name="header2"><paramtype>node_ptr</paramtype></parameter><parameter name="z"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header1 and header2 must be the headers of trees tree1 and tree2 respectively, z a non-header node of tree1. NodePtrCompare is the comparison function of tree1..</para><para><emphasis role="bold">Effects</emphasis>: Transfers node "z" from tree1 to tree2.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison throws. </para></description></method>
<method name="clone" specifiers="static"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="source_header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><parameter name="target_header"><paramtype>node_ptr</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "cloner" must be a function object taking a node_ptr and returning a new cloned node of it. "disposer" must take a node_ptr and shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: First empties target tree calling <computeroutput>void disposer::operator()(const node_ptr &amp;)</computeroutput> for every node of the tree except the header.</para><para>Then, duplicates the entire tree pointed by "source_header" cloning each source node with <computeroutput>node_ptr Cloner::operator()(const node_ptr &amp;)</computeroutput> to obtain the nodes of the target tree. If "cloner" throws, the cloned target nodes are disposed using <computeroutput>void disposer(const node_ptr &amp;)</computeroutput>.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of element of the source tree plus the number of elements of tree target tree when calling this function.</para><para><emphasis role="bold">Throws</emphasis>: If cloner functor throws. If this happens target nodes are disposed. </para></description></method>
<method name="clear_and_dispose" specifiers="static"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="header"><paramtype>const node_ptr &amp;</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "disposer" must be an object function taking a node_ptr parameter and shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Empties the target tree calling <computeroutput>void disposer::operator()(const node_ptr &amp;)</computeroutput> for every node of the tree except the header.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of element of the source tree plus the. number of elements of tree target tree when calling this function.</para><para><emphasis role="bold">Throws</emphasis>: If cloner functor throws. If this happens target nodes are disposed. </para></description></method>
<method name="lower_bound" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns a node_ptr to the first element that is not less than "key" according to "comp" or "header" if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="upper_bound" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns a node_ptr to the first element that is greater than "key" according to "comp" or "header" if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="find" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns a node_ptr to the first element that is equivalent to "key" according to "comp" or "header" if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="equal_range" specifiers="static"><type>std::pair&lt; node_ptr, node_ptr &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair of node_ptr delimiting a range containing all elements that are equivalent to "key" according to "comp" or an empty range that indicates the position where those elements would be if there are no equivalent elements.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="bounded_range" specifiers="static"><type>std::pair&lt; node_ptr, node_ptr &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs. 'lower_key' must not be greater than 'upper_key' according to 'comp'. If 'lower_key' == 'upper_key', ('left_closed' || 'right_closed') must be true.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change. </para></description></method>
<method name="count" specifiers="static"><type>std::size_t</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements with a key equivalent to "key" according to "comp".</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="insert_equal_upper_bound" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="NodePtrCompare"/>
        </template><parameter name="h"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "h" must be the header node of a tree. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares two node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree before the upper bound according to "comp".</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="insert_equal_lower_bound" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="NodePtrCompare"/>
        </template><parameter name="h"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "h" must be the header node of a tree. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares two node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree before the lower bound according to "comp".</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="insert_equal" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="NodePtrCompare"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="hint"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares two node_ptrs. "hint" is node from the "header"'s tree.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree, using "hint" as a hint to where it will be inserted. If "hint" is the upper_bound the insertion takes constant time (two comparisons in the worst case).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time if new_node is inserted immediately before "hint".</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="insert_before" specifiers="static"><type>node_ptr</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="pos"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. "pos" must be a valid iterator or header (end) node. "pos" must be an iterator pointing to the successor to "new_node" once inserted according to the order of already inserted nodes. This function does not check "pos" and this precondition must be guaranteed by the caller.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree before "pos".</para><para><emphasis role="bold">Complexity</emphasis>: Constant-time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: If "pos" is not the successor of the newly inserted "new_node" tree invariants might be broken. </para></description></method>
<method name="push_back" specifiers="static"><type>void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. "new_node" must be, according to the used ordering no less than the greatest inserted key.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree before "pos".</para><para><emphasis role="bold">Complexity</emphasis>: Constant-time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: If "new_node" is less than the greatest inserted key tree invariants are broken. This function is slightly faster than using "insert_before". </para></description></method>
<method name="push_front" specifiers="static"><type>void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. "new_node" must be, according to the used ordering, no greater than the lowest inserted key.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree before "pos".</para><para><emphasis role="bold">Complexity</emphasis>: Constant-time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: If "new_node" is greater than the lowest inserted key tree invariants are broken. This function is slightly faster than using "insert_before". </para></description></method>
<method name="insert_unique_check" specifiers="static"><type>std::pair&lt; node_ptr, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares KeyType with a node_ptr.</para><para><emphasis role="bold">Effects</emphasis>: Checks if there is an equivalent node to "key" in the tree according to "comp" and obtains the needed information to realize a constant-time node insertion if there is no equivalent node.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing a node_ptr to the already present node and false. If there is not equivalent key can be inserted returns true in the returned pair's boolean and fills "commit_data" that is meant to be used with the "insert_commit" function to achieve a constant-time insertion function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a node is expensive and the user does not want to have two equivalent nodes in the tree: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the node and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the node and use "insert_commit" to insert the node in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_unique_commit" only if no more objects are inserted or erased from the set. </para></description></method>
<method name="insert_unique_check" specifiers="static"><type>std::pair&lt; node_ptr, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><parameter name="hint"><paramtype>const node_ptr &amp;</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares KeyType with a node_ptr. "hint" is node from the "header"'s tree.</para><para><emphasis role="bold">Effects</emphasis>: Checks if there is an equivalent node to "key" in the tree according to "comp" using "hint" as a hint to where it should be inserted and obtains the needed information to realize a constant-time node insertion if there is no equivalent node. If "hint" is the upper_bound the function has constant time complexity (two comparisons in the worst case).</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing a node_ptr to the already present node and false. If there is not equivalent key can be inserted returns true in the returned pair's boolean and fills "commit_data" that is meant to be used with the "insert_commit" function to achieve a constant-time insertion function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic, but it is amortized constant time if new_node should be inserted immediately before "hint".</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a node is expensive and the user does not want to have two equivalent nodes in the tree: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the node and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the node and use "insert_commit" to insert the node in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_unique_commit" only if no more objects are inserted or erased from the set. </para></description></method>
<method name="insert_unique_commit" specifiers="static"><type>void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_value"><paramtype>node_ptr</paramtype></parameter><parameter name="commit_data"><paramtype>const insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. "commit_data" must have been obtained from a previous call to "insert_unique_check". No objects should have been inserted or erased from the set between the "insert_unique_check" that filled "commit_data" and the call to "insert_commit".</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node in the set using the information obtained from the "commit_data" that a previous "insert_check" filled.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function has only sense if a "insert_unique_check" has been previously executed to fill "commit_data". No value should be inserted or erased between the "insert_check" and "insert_commit" calls. </para></description></method>
<method name="is_header" specifiers="static"><type>bool</type><parameter name="p"><paramtype>const const_node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p is a node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Returns true if p is the header of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
</method-group>
</class>



















































</namespace>
</namespace>
</header>
<header name="boost/intrusive/bs_set.hpp">
<namespace name="boost">
<namespace name="intrusive">
<class name="bs_multiset"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>The class template <classname alt="boost::intrusive::bs_multiset">bs_multiset</classname> is an intrusive container, that mimics most of the interface of std::multiset as described in the C++ standard.</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput> and <computeroutput>compare&lt;&gt;</computeroutput>. </para></description><typedef name="value_type"><type>implementation_defined::value_type</type></typedef>
<typedef name="key_type"><type>implementation_defined::key_type</type></typedef>
<typedef name="value_traits"><type>implementation_defined::value_traits</type></typedef>
<typedef name="pointer"><type>implementation_defined::pointer</type></typedef>
<typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef>
<typedef name="reference"><type>implementation_defined::reference</type></typedef>
<typedef name="const_reference"><type>implementation_defined::const_reference</type></typedef>
<typedef name="difference_type"><type>implementation_defined::difference_type</type></typedef>
<typedef name="size_type"><type>implementation_defined::size_type</type></typedef>
<typedef name="value_compare"><type>implementation_defined::value_compare</type></typedef>
<typedef name="key_compare"><type>implementation_defined::key_compare</type></typedef>
<typedef name="iterator"><type>implementation_defined::iterator</type></typedef>
<typedef name="const_iterator"><type>implementation_defined::const_iterator</type></typedef>
<typedef name="reverse_iterator"><type>implementation_defined::reverse_iterator</type></typedef>
<typedef name="const_reverse_iterator"><type>implementation_defined::const_reverse_iterator</type></typedef>
<typedef name="insert_commit_data"><type>implementation_defined::insert_commit_data</type></typedef>
<typedef name="node_traits"><type>implementation_defined::node_traits</type></typedef>
<typedef name="node"><type>implementation_defined::node</type></typedef>
<typedef name="node_ptr"><type>implementation_defined::node_ptr</type></typedef>
<typedef name="const_node_ptr"><type>implementation_defined::const_node_ptr</type></typedef>
<typedef name="node_algorithms"><type>implementation_defined::node_algorithms</type></typedef>
<data-member name="constant_time_size" specifiers="static"><type>const bool</type></data-member>
<method-group name="public member functions">
<method name="begin"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rbegin"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a iterator pointing to the root node of the container or end() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="croot" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the key_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If key_compare copy-constructor throws. </para></description></method>
<method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the value_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_compare copy-constructor throws. </para></description></method>
<method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this if constant-time size option is disabled. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="swap"><type>void</type><parameter name="other"><paramtype><classname>bs_multiset</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of two containers.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison functor's swap call throws. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>bs_multiset</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype><classname>bs_multiset</classname> &amp;&amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(reference) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: This version can modify the source container, useful to implement move semantics. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the container before the upper bound.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal key_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and "hint" must be a valid iterator.</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container, using "hint" as a hint to where it will be inserted. If "hint" is the upper_bound the insertion takes constant time (two comparisons in the worst case)</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the internal key_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Inserts a each element of a range into the container before the upper bound of the key of each element.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_before"><type>iterator</type><parameter name="pos"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, "pos" must be a valid iterator (or end) and must be the succesor of value once inserted according to the predicate</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container before "pos".</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if "pos" is not the successor of "value" container ordering invariant will be broken. This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_back"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no less than the greatest inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the last position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is less than the greatest inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_front"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no greater than the minimum inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the first position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is greater than the minimum inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="i"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp".</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk) and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="clear"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="clear_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements calling disposer(p) for each node to be erased. <emphasis role="bold">Complexity</emphasis>: Average complexity for is at most O(log(size() + N)), where N is the number of elements in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. Calls N times to disposer functor. </para></description></method>
<method name="count" cv="const"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given value</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given value.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="count" cv="const"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="lower_bound"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="find"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="find"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="lower_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="lower_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="iterator_to"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="unlink_leftmost_without_rebalance"><type>pointer</type><description><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the container.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the container and the container can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the container. </para></description></method>
<method name="replace_node"><type>void</type><parameter name="replace_this"><paramtype>iterator</paramtype></parameter><parameter name="with_this"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: replace_this must be a valid iterator of *this and with_this must not be inserted in any container.</para><para><emphasis role="bold">Effects</emphasis>: Replaces replace_this in its position in the container with with_this. The container does not need to be rebalanced.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if with_this is not equivalent to *replace_this according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. </para></description></method>
<method name="remove_node"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: removes "value" from the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic time.</para><para><emphasis role="bold">Note</emphasis>: This static function is only usable with non-constant time size containers that have stateless comparison functors.</para><para>If the user calls this function with a constant time size container or stateful comparison functor a compilation error will be issued. </para></description></method>
<method name="merge"><type>void</type><template>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="source"><paramtype><classname>bs_multiset</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Extracts each element in source and insert it into a using the comparison object of *this.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="source"><paramtype><classname>bs_set</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Extracts each element in source and insert it into a using the comparison object of *this.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container with given comparison and traits.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype><default>key_compare()</default></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type. cmp must be a comparison function that induces a strict weak ordering.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container and inserts elements from [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if [b, e) is already sorted using comp and otherwise N * log N, where N is the distance between first and last.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor/operator() of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>bs_multiset</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a container moving resources from another container. Internal comparison object and value traits are move constructed and nodes belonging to x (except the node representing the "end") are linked to *this.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node's move constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the move constructor of the comparison objet throws. </para></description></constructor>
<copy-assignment><type><classname>bs_multiset</classname> &amp;</type><parameter name="x"><paramtype><classname>bs_multiset</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to swap </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the set are not deleted (i.e. no destructors are called), but the nodes according to the <classname alt="boost::intrusive::value_traits">value_traits</classname> template parameter are reinitialized and thus can be reused.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor>
<method-group name="public static functions">
<method name="container_from_end_iterator" specifiers="static"><type><classname>bs_multiset</classname> &amp;</type><parameter name="end_iterator"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_end_iterator" specifiers="static"><type>const <classname>bs_multiset</classname> &amp;</type><parameter name="end_iterator"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type><classname>bs_multiset</classname> &amp;</type><parameter name="it"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type>const <classname>bs_multiset</classname> &amp;</type><parameter name="it"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="init_node" specifiers="static"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value shall not be in a container.</para><para><emphasis role="bold">Effects</emphasis>: init_node puts the hook of a value in a well-known default state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: This function puts the hook in the well-known default state used by auto_unlink and safe hooks. </para></description></method>
</method-group>
</class><class name="bs_set"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>The class template <classname alt="boost::intrusive::bs_set">bs_set</classname> is an intrusive container, that mimics most of the interface of std::set as described in the C++ standard.</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput> and <computeroutput>compare&lt;&gt;</computeroutput>. </para></description><typedef name="value_type"><type>implementation_defined::value_type</type></typedef>
<typedef name="key_type"><type>implementation_defined::key_type</type></typedef>
<typedef name="value_traits"><type>implementation_defined::value_traits</type></typedef>
<typedef name="pointer"><type>implementation_defined::pointer</type></typedef>
<typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef>
<typedef name="reference"><type>implementation_defined::reference</type></typedef>
<typedef name="const_reference"><type>implementation_defined::const_reference</type></typedef>
<typedef name="difference_type"><type>implementation_defined::difference_type</type></typedef>
<typedef name="size_type"><type>implementation_defined::size_type</type></typedef>
<typedef name="value_compare"><type>implementation_defined::value_compare</type></typedef>
<typedef name="key_compare"><type>implementation_defined::key_compare</type></typedef>
<typedef name="iterator"><type>implementation_defined::iterator</type></typedef>
<typedef name="const_iterator"><type>implementation_defined::const_iterator</type></typedef>
<typedef name="reverse_iterator"><type>implementation_defined::reverse_iterator</type></typedef>
<typedef name="const_reverse_iterator"><type>implementation_defined::const_reverse_iterator</type></typedef>
<typedef name="insert_commit_data"><type>implementation_defined::insert_commit_data</type></typedef>
<typedef name="node_traits"><type>implementation_defined::node_traits</type></typedef>
<typedef name="node"><type>implementation_defined::node</type></typedef>
<typedef name="node_ptr"><type>implementation_defined::node_ptr</type></typedef>
<typedef name="const_node_ptr"><type>implementation_defined::const_node_ptr</type></typedef>
<typedef name="node_algorithms"><type>implementation_defined::node_algorithms</type></typedef>
<data-member name="constant_time_size" specifiers="static"><type>const bool</type></data-member>
<method-group name="public member functions">
<method name="begin"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rbegin"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a iterator pointing to the root node of the container or end() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="croot" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the key_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If key_compare copy-constructor throws. </para></description></method>
<method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the value_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_compare copy-constructor throws. </para></description></method>
<method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this if constant-time size option is disabled. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="swap"><type>void</type><parameter name="other"><paramtype><classname>bs_set</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of two containers.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison functor's swap call throws. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>bs_set</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype><classname>bs_set</classname> &amp;&amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(reference) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: This version can modify the source container, useful to implement move semantics. </para></description></method>
<method name="insert"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the container if the value is not already present.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and "hint" must be a valid iterator</para><para><emphasis role="bold">Effects</emphasis>: Tries to insert x into the container, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time (two comparisons in the worst case) if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_check"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee. </para></description></method>
<method name="insert_check"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it's amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee. </para></description></method>
<method name="insert_check"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must be a comparison function that induces the same strict weak ordering as key_compare. The difference is that comp compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the container. </para></description></method>
<method name="insert_check"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must be a comparison function that induces the same strict weak ordering as key_compare. The difference is that comp compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it's amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the constructing that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that key to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This can give a total constant-time complexity to the insertion: check(O(1)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the container. </para></description></method>
<method name="insert"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Tries to insert each element of a range into the container.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_commit"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><parameter name="commit_data"><paramtype>const insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue of type value_type. commit_data must have been obtained from a previous call to "insert_check". No objects should have been inserted or erased from the container between the "insert_check" that filled "commit_data" and the call to "insert_commit".</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value in the container using the information obtained from the "commit_data" that a previous "insert_check" filled.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the newly inserted object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function has only sense if a "insert_check" has been previously executed to fill "commit_data". No value should be inserted or erased between the "insert_check" and "insert_commit" calls. </para></description></method>
<method name="insert_before"><type>iterator</type><parameter name="pos"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, "pos" must be a valid iterator (or end) and must be the succesor of value once inserted according to the predicate</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container before "pos".</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if "pos" is not the successor of "value" container ordering invariant will be broken. This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_back"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no less than the greatest inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the last position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is less than the greatest inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_front"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no greater than the minimum inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the first position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is greater than the minimum inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="i"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp".</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk) and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="clear"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="clear_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements calling disposer(p) for each node to be erased. <emphasis role="bold">Complexity</emphasis>: Average complexity for is at most O(log(size() + N)), where N is the number of elements in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. Calls N times to disposer functor. </para></description></method>
<method name="count" cv="const"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given value</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given value.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="count" cv="const"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="lower_bound"><type>iterator</type><parameter name=""><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="find"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="find"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="lower_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="lower_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="iterator_to"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="unlink_leftmost_without_rebalance"><type>pointer</type><description><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the container.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the container and the container can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the container. </para></description></method>
<method name="replace_node"><type>void</type><parameter name="replace_this"><paramtype>iterator</paramtype></parameter><parameter name="with_this"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: replace_this must be a valid iterator of *this and with_this must not be inserted in any container.</para><para><emphasis role="bold">Effects</emphasis>: Replaces replace_this in its position in the container with with_this. The container does not need to be rebalanced.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if with_this is not equivalent to *replace_this according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. </para></description></method>
<method name="remove_node"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: removes "value" from the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic time.</para><para><emphasis role="bold">Note</emphasis>: This static function is only usable with non-constant time size containers that have stateless comparison functors.</para><para>If the user calls this function with a constant time size container or stateful comparison functor a compilation error will be issued. </para></description></method>
<method name="merge"><type>void</type><template>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="source"><paramtype><classname>bs_set</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="source"><paramtype><classname>bs_multiset</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container with given comparison and traits.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype><default>key_compare()</default></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type. cmp must be a comparison function that induces a strict weak ordering.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container and inserts elements from [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if [b, e) is already sorted using comp and otherwise N * log N, where N is the distance between first and last.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor/operator() of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>bs_set</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a container moving resources from another container. Internal comparison object and value traits are move constructed and nodes belonging to x (except the node representing the "end") are linked to *this.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node's move constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the move constructor of the comparison objet throws. </para></description></constructor>
<copy-assignment><type><classname>bs_set</classname> &amp;</type><parameter name="x"><paramtype><classname>bs_set</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to swap </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the set are not deleted (i.e. no destructors are called), but the nodes according to the <classname alt="boost::intrusive::value_traits">value_traits</classname> template parameter are reinitialized and thus can be reused.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor>
<method-group name="public static functions">
<method name="container_from_end_iterator" specifiers="static"><type><classname>bs_set</classname> &amp;</type><parameter name="end_iterator"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_end_iterator" specifiers="static"><type>const <classname>bs_set</classname> &amp;</type><parameter name="end_iterator"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type><classname>bs_set</classname> &amp;</type><parameter name="it"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type>const <classname>bs_set</classname> &amp;</type><parameter name="it"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="init_node" specifiers="static"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value shall not be in a container.</para><para><emphasis role="bold">Effects</emphasis>: init_node puts the hook of a value in a well-known default state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: This function puts the hook in the well-known default state used by auto_unlink and safe hooks. </para></description></method>
</method-group>
</class><struct name="make_bs_multiset"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput><classname alt="boost::intrusive::bs_multiset">bs_multiset</classname></computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct><struct name="make_bs_set"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput><classname alt="boost::intrusive::bs_set">bs_set</classname></computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct>































<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>bs_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>bs_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>bs_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>bs_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>bs_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>bs_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>bs_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>bs_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype><classname>bs_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>bs_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>bs_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>bs_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>bs_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>bs_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>bs_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>bs_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>bs_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>bs_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype><classname>bs_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>bs_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>










</namespace>
</namespace>
</header>
<header name="boost/intrusive/bs_set_hook.hpp">
<namespace name="boost">
<namespace name="intrusive">
<class name="bs_set_base_hook"><template>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><inherit access="public">make_bs_set_base_hook::type&lt; O1, O2, O3 &gt;</inherit><description><para>Derive a class from <classname alt="boost::intrusive::bs_set_base_hook">bs_set_base_hook</classname> in order to store objects in in a bs_set/bs_multiset. <classname alt="boost::intrusive::bs_set_base_hook">bs_set_base_hook</classname> holds the data necessary to maintain the bs_set/bs_multiset and provides an appropriate <classname alt="boost::intrusive::value_traits">value_traits</classname> class for bs_set/bs_multiset.</para><para>The hook admits the following options: <computeroutput>tag&lt;&gt;</computeroutput>, <computeroutput>void_pointer&lt;&gt;</computeroutput>, <computeroutput>link_mode&lt;&gt;</computeroutput>.</para><para><computeroutput>tag&lt;&gt;</computeroutput> defines a tag to identify the node. The same tag value can be used in different classes, but if a class is derived from more than one <computeroutput><classname alt="boost::intrusive::list_base_hook">list_base_hook</classname></computeroutput>, then each <computeroutput><classname alt="boost::intrusive::list_base_hook">list_base_hook</classname></computeroutput> needs its unique tag.</para><para><computeroutput>void_pointer&lt;&gt;</computeroutput> is the pointer type that will be used internally in the hook and the container configured to use this hook.</para><para><computeroutput>link_mode&lt;&gt;</computeroutput> will specify the linking mode of the hook (<computeroutput>normal_link</computeroutput>, <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput>). </para></description><method-group name="public member functions">
<method name="swap_nodes"><type>void</type><parameter name="other"><paramtype><classname>bs_set_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swapping two nodes swaps the position of the elements related to those nodes in one or two containers. That is, if the node this is part of the element e1, the node x is part of the element e2 and both elements are included in the containers s1 and s2, then after the swap-operation e1 is in s2 at the position of e2 and e2 is in s1 at the position of e1. If one element is not in a container, then after the swap-operation the other element is not in a container. Iterators to e1 and e2 related to those nodes are invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="is_linked" cv="const"><type>bool</type><description><para><emphasis role="bold">Precondition</emphasis>: <classname alt="boost::intrusive::link_mode">link_mode</classname> must be <computeroutput>safe_link</computeroutput> or <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: true, if the node belongs to a container, false otherwise. This function can be used to test whether <computeroutput>set::iterator_to</computeroutput> will return a valid iterator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method>
<method name="unlink"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the node if it's inserted in a container. This function is only allowed if <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></constructor>
<constructor><parameter name=""><paramtype>const <classname>bs_set_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing a copy-constructor makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></constructor>
<copy-assignment><type><classname>bs_set_base_hook</classname> &amp;</type><parameter name=""><paramtype>const <classname>bs_set_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Empty function. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing an assignment operator makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>normal_link</computeroutput>, the destructor does nothing (ie. no code is generated). If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>safe_link</computeroutput> and the object is stored in a set an assertion is raised. If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> and <computeroutput>is_linked()</computeroutput> is true, the node is unlinked.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor>
</class><class name="bs_set_member_hook"><template>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><inherit access="public">make_bs_set_member_hook::type&lt; O1, O2, O3 &gt;</inherit><description><para>Put a public data member <classname alt="boost::intrusive::bs_set_member_hook">bs_set_member_hook</classname> in order to store objects of this class in a bs_set/bs_multiset. <classname alt="boost::intrusive::bs_set_member_hook">bs_set_member_hook</classname> holds the data necessary for maintaining the bs_set/bs_multiset and provides an appropriate <classname alt="boost::intrusive::value_traits">value_traits</classname> class for bs_set/bs_multiset.</para><para>The hook admits the following options: <computeroutput>void_pointer&lt;&gt;</computeroutput>, <computeroutput>link_mode&lt;&gt;</computeroutput>.</para><para><computeroutput>void_pointer&lt;&gt;</computeroutput> is the pointer type that will be used internally in the hook and the container configured to use this hook.</para><para><computeroutput>link_mode&lt;&gt;</computeroutput> will specify the linking mode of the hook (<computeroutput>normal_link</computeroutput>, <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput>). </para></description><method-group name="public member functions">
<method name="swap_nodes"><type>void</type><parameter name="other"><paramtype><classname>bs_set_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swapping two nodes swaps the position of the elements related to those nodes in one or two containers. That is, if the node this is part of the element e1, the node x is part of the element e2 and both elements are included in the containers s1 and s2, then after the swap-operation e1 is in s2 at the position of e2 and e2 is in s1 at the position of e1. If one element is not in a container, then after the swap-operation the other element is not in a container. Iterators to e1 and e2 related to those nodes are invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="is_linked" cv="const"><type>bool</type><description><para><emphasis role="bold">Precondition</emphasis>: <classname alt="boost::intrusive::link_mode">link_mode</classname> must be <computeroutput>safe_link</computeroutput> or <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: true, if the node belongs to a container, false otherwise. This function can be used to test whether <computeroutput>set::iterator_to</computeroutput> will return a valid iterator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method>
<method name="unlink"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the node if it's inserted in a container. This function is only allowed if <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></constructor>
<constructor><parameter name=""><paramtype>const <classname>bs_set_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing a copy-constructor makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></constructor>
<copy-assignment><type><classname>bs_set_member_hook</classname> &amp;</type><parameter name=""><paramtype>const <classname>bs_set_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Empty function. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing an assignment operator makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>normal_link</computeroutput>, the destructor does nothing (ie. no code is generated). If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>safe_link</computeroutput> and the object is stored in a set an assertion is raised. If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> and <computeroutput>is_linked()</computeroutput> is true, the node is unlinked.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor>
</class><struct name="make_bs_set_base_hook"><template>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput><classname alt="boost::intrusive::bs_set_base_hook">bs_set_base_hook</classname></computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct><struct name="make_bs_set_member_hook"><template>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput><classname alt="boost::intrusive::bs_set_member_hook">bs_set_member_hook</classname></computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct>



















































</namespace>
</namespace>
</header>
<header name="boost/intrusive/bstree.hpp">
<namespace name="boost">
<namespace name="intrusive">
<class name="bstree"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><inherit access="public">bstbase&lt; ValueTraits, VoidOrKeyOfValue, VoidOrKeyComp, ConstantTimeSize, SizeType, AlgoType, HeaderHolder &gt;</inherit><description><para>The class template bstree is an unbalanced intrusive binary search tree container. The no-throw guarantee holds only, if the key_compare object doesn't throw.</para><para>The complexity guarantees only hold if the tree is balanced, logarithmic complexity would increase to linear if the tree is totally unbalanced.</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput> and <computeroutput>compare&lt;&gt;</computeroutput>. </para></description><typedef name="value_traits"><type>implementation_defined</type></typedef>
<typedef name="pointer"><type>implementation_defined</type></typedef>
<typedef name="const_pointer"><type>implementation_defined</type></typedef>
<typedef name="value_type"><type>implementation_defined</type></typedef>
<typedef name="key_type"><type>implementation_defined</type></typedef>
<typedef name="key_of_value"><type>implementation_defined</type></typedef>
<typedef name="reference"><type>implementation_defined</type></typedef>
<typedef name="const_reference"><type>implementation_defined</type></typedef>
<typedef name="difference_type"><type>implementation_defined</type></typedef>
<typedef name="size_type"><type>implementation_defined</type></typedef>
<typedef name="value_compare"><type>implementation_defined</type></typedef>
<typedef name="key_compare"><type>implementation_defined</type></typedef>
<typedef name="iterator"><type>implementation_defined</type></typedef>
<typedef name="const_iterator"><type>implementation_defined</type></typedef>
<typedef name="reverse_iterator"><type>implementation_defined</type></typedef>
<typedef name="const_reverse_iterator"><type>implementation_defined</type></typedef>
<typedef name="node_traits"><type>implementation_defined</type></typedef>
<typedef name="node"><type>implementation_defined</type></typedef>
<typedef name="node_ptr"><type>implementation_defined</type></typedef>
<typedef name="const_node_ptr"><type>implementation_defined</type></typedef>
<typedef name="node_algorithms"><type>implementation_defined</type></typedef>
<typedef name="insert_commit_data"><type>node_algorithms::insert_commit_data</type></typedef>
<data-member name="constant_time_size" specifiers="static"><type>const bool</type></data-member>
<data-member name="stateful_value_traits" specifiers="static"><type>const bool</type></data-member>
<method-group name="public member functions">
<method name="begin"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rbegin"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a iterator pointing to the root node of the container or end() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="croot" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the key_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If key_compare copy-constructor throws. </para></description></method>
<method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the value_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_compare copy-constructor throws. </para></description></method>
<method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this if constant-time size option is disabled. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="swap"><type>void</type><parameter name="other"><paramtype><classname>bstree</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of two containers.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison functor's swap call throws. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>bstree</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype><classname>bstree</classname> &amp;&amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(reference) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: This version can modify the source container, useful to implement move semantics. </para></description></method>
<method name="insert_equal"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the container before the upper bound.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal key_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_equal"><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and "hint" must be a valid iterator.</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container, using "hint" as a hint to where it will be inserted. If "hint" is the upper_bound the insertion takes constant time (two comparisons in the worst case)</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the internal key_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_equal"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Inserts a each element of a range into the container before the upper bound of the key of each element.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_unique"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the container if the value is not already present.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_unique"><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and "hint" must be a valid iterator</para><para><emphasis role="bold">Effects</emphasis>: Tries to insert x into the container, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time (two comparisons in the worst case) if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_unique"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Tries to insert each element of a range into the container.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_unique_check"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee. </para></description></method>
<method name="insert_unique_check"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it's amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee. </para></description></method>
<method name="insert_unique_check"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must be a comparison function that induces the same strict weak ordering as key_compare. The difference is that comp compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the container. </para></description></method>
<method name="insert_unique_check"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must be a comparison function that induces the same strict weak ordering as key_compare. The difference is that comp compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it's amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the constructing that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that key to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This can give a total constant-time complexity to the insertion: check(O(1)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the container. </para></description></method>
<method name="insert_unique_commit"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><parameter name="commit_data"><paramtype>const insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue of type value_type. commit_data must have been obtained from a previous call to "insert_check". No objects should have been inserted or erased from the container between the "insert_check" that filled "commit_data" and the call to "insert_commit".</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value in the container using the information obtained from the "commit_data" that a previous "insert_check" filled.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the newly inserted object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function has only sense if a "insert_check" has been previously executed to fill "commit_data". No value should be inserted or erased between the "insert_check" and "insert_commit" calls. </para></description></method>
<method name="insert_before"><type>iterator</type><parameter name="pos"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, "pos" must be a valid iterator (or end) and must be the succesor of value once inserted according to the predicate</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container before "pos".</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if "pos" is not the successor of "value" container ordering invariant will be broken. This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_back"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no less than the greatest inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the last position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is less than the greatest inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_front"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no greater than the minimum inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the first position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is greater than the minimum inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="i"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp".</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk) and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="clear"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="clear_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements calling disposer(p) for each node to be erased. <emphasis role="bold">Complexity</emphasis>: Average complexity for is at most O(log(size() + N)), where N is the number of elements in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. Calls N times to disposer functor. </para></description></method>
<method name="count" cv="const"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given value</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given value.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="count" cv="const"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="lower_bound"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="find"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="find"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="lower_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="upper_value"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="lower_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="iterator_to"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="unlink_leftmost_without_rebalance"><type>pointer</type><description><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the container.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the container and the container can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the container. </para></description></method>
<method name="replace_node"><type>void</type><parameter name="replace_this"><paramtype>iterator</paramtype></parameter><parameter name="with_this"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: replace_this must be a valid iterator of *this and with_this must not be inserted in any container.</para><para><emphasis role="bold">Effects</emphasis>: Replaces replace_this in its position in the container with with_this. The container does not need to be rebalanced.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if with_this is not equivalent to *replace_this according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. </para></description></method>
<method name="rebalance"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Rebalances the tree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear. </para></description></method>
<method name="rebalance_subtree"><type>iterator</type><parameter name="root"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: old_root is a node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Rebalances the subtree rooted at old_root.</para><para><emphasis role="bold">Returns</emphasis>: The new root of the subtree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements in the subtree. </para></description></method>
<method name="merge_unique"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name=""><paramtype><classname>bstree</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="while"><type/><parameter name=""><paramtype>it !</paramtype><default>itend</default></parameter></method>
<method name="merge_equal"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name=""><paramtype><classname>bstree</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Extracts each element in source and insert it into a using the comparison object of *this.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="while"><type/><parameter name=""><paramtype>it !</paramtype><default>itend</default></parameter></method>
<method name="check" cv="const"><type>void</type><template>
          <template-type-parameter name="ExtraChecker"/>
        </template><parameter name="extra_checker"><paramtype>ExtraChecker</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Asserts the integrity of the container with additional checks provided by the user.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time.</para><para><emphasis role="bold">Note</emphasis>: The method might not have effect when asserts are turned off (e.g., with NDEBUG). Experimental function, interface might change in future versions. </para></description></method>
<method name="check" cv="const"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Asserts the integrity of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time.</para><para><emphasis role="bold">Note</emphasis>: The method has no effect when asserts are turned off (e.g., with NDEBUG). Experimental function, interface might change in future versions. </para></description></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container with given comparison and traits.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="unique"><paramtype>bool</paramtype></parameter><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype><default>key_compare()</default></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type. cmp must be a comparison function that induces a strict weak ordering.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container and inserts elements from [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if [b, e) is already sorted using comp and otherwise N * log N, where N is the distance between first and last.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor/operator() of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>bstree</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a container moving resources from another container. Internal comparison object and value traits are move constructed and nodes belonging to x (except the node representing the "end") are linked to *this.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node's move constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the move constructor of the comparison objet throws. </para></description></constructor>
<copy-assignment><type><classname>bstree</classname> &amp;</type><parameter name="x"><paramtype><classname>bstree</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to swap </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the set are not deleted (i.e. no destructors are called), but the nodes according to the <classname alt="boost::intrusive::value_traits">value_traits</classname> template parameter are reinitialized and thus can be reused.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor>
<method-group name="public static functions">
<method name="container_from_end_iterator" specifiers="static"><type><classname>bstree</classname> &amp;</type><parameter name="end_iterator"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_end_iterator" specifiers="static"><type>const <classname>bstree</classname> &amp;</type><parameter name="end_iterator"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end const_iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type><classname>bstree</classname> &amp;</type><parameter name="it"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type>const <classname>bstree</classname> &amp;</type><parameter name="it"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid end const_iterator of container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="init_node" specifiers="static"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value shall not be in a container.</para><para><emphasis role="bold">Effects</emphasis>: init_node puts the hook of a value in a well-known default state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: This function puts the hook in the well-known default state used by auto_unlink and safe hooks. </para></description></method>
<method name="remove_node" specifiers="static"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: removes "value" from the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic time.</para><para><emphasis role="bold">Note</emphasis>: This static function is only usable with non-constant time size containers that have stateless comparison functors.</para><para>If the user calls this function with a constant time size container or stateful comparison functor a compilation error will be issued. </para></description></method>
</method-group>
</class><struct name="make_bstree"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>bstree</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct>



















































</namespace>
</namespace>
</header>
<header name="boost/intrusive/bstree_algorithms.hpp">
<namespace name="boost">
<namespace name="intrusive">
<class name="bstree_algorithms"><template>
      <template-type-parameter name="NodeTraits"/>
    </template><inherit access="public">bstree_algorithms_base&lt; NodeTraits &gt;</inherit><description><para>This is an implementation of a binary search tree. A node in the search tree has references to its children and its parent. This is to allow traversal of the whole tree from a given node making the implementation of iterator a pointer to a node. At the top of the tree a node is used specially. This node's parent pointer is pointing to the root of the tree. Its left pointer points to the leftmost node in the tree and the right pointer to the rightmost one. This node is used to represent the end-iterator.                                      +---------+
header------------------------------&gt;|         |
                                     |         |
            +----------(left)--------|         |--------(right)---------+
            |                        +---------+                        |
            |                             |                             |
            |                             | (parent)                    |
            |                             |                             |
            |                             |                             |
            |                        +---------+                        |
 root of tree ..|......................&gt; | | | | | D | | | | | | | +----<mdash/>+------<mdash/>+----<mdash/>+ | <informaltable><tgroup cols="3"><tbody><row>
<entry><emphasis role="bold"/></entry><entry><emphasis role="bold"/></entry><entry><emphasis role="bold"/></entry></row>
<row>
<entry/><entry/><entry/></row>
<row>
<entry/><entry/><entry/></row>
<row>
<entry/><entry/><entry/></row>
</tbody></tgroup></informaltable>
| +------<mdash/>+ +------<mdash/>+ | | | | | | | | | B | | F | | | | | | | | | +–+------<mdash/>+–+ +–+------<mdash/>+–+ | <informaltable><tgroup cols="5"><tbody><row>
<entry><emphasis role="bold"/></entry><entry><emphasis role="bold"/></entry><entry><emphasis role="bold"/></entry><entry><emphasis role="bold"/></entry><entry><emphasis role="bold"/></entry></row>
<row>
<entry/><entry/><entry/><entry/><entry/></row>
</tbody></tgroup></informaltable>
| +<mdash/>+--<mdash/>+ +--<mdash/>+<mdash/>+ +<mdash/>+--<mdash/>+ +--<mdash/>+<mdash/>+ | +--&gt;| | | | | | | |&lt;–+ | A | | C | | E | | G | | | | | | | | | +------<mdash/>+ +------<mdash/>+ +------<mdash/>+ +------<mdash/>+</para><para><classname alt="boost::intrusive::bstree_algorithms">bstree_algorithms</classname> is configured with a NodeTraits class, which encapsulates the information about the node to be manipulated. NodeTraits must support the following interface:</para><para><emphasis role="bold">Typedefs</emphasis>:</para><para><computeroutput>node</computeroutput>: The type of the node that forms the binary search tree</para><para><computeroutput>node_ptr</computeroutput>: A pointer to a node</para><para><computeroutput>const_node_ptr</computeroutput>: A pointer to a const node</para><para><emphasis role="bold">Static functions</emphasis>:</para><para><computeroutput>static node_ptr get_parent(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_parent(node_ptr n, node_ptr parent);</computeroutput></para><para><computeroutput>static node_ptr get_left(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_left(node_ptr n, node_ptr left);</computeroutput></para><para><computeroutput>static node_ptr get_right(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_right(node_ptr n, node_ptr right);</computeroutput> </para></description><typedef name="node"><type>NodeTraits::node</type></typedef>
<typedef name="node_traits"><type>NodeTraits</type></typedef>
<typedef name="node_ptr"><type>NodeTraits::node_ptr</type></typedef>
<typedef name="const_node_ptr"><type>NodeTraits::const_node_ptr</type></typedef>
<typedef name="insert_commit_data"><type>insert_commit_data_t&lt; node_ptr &gt;</type></typedef>
<typedef name="data_for_rebalance"><type>data_for_rebalance_t&lt; node_ptr &gt;</type></typedef>
<method-group name="public static functions">
<method name="begin_node" specifiers="static"><type>node_ptr</type><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'header' is the header node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Returns the first node of the tree, the header if the tree is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end_node" specifiers="static"><type>node_ptr</type><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'header' is the header node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Returns the header of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root_node" specifiers="static"><type>node_ptr</type><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'header' is the header node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Returns the root of the tree if any, header otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="unique" specifiers="static"><type>bool</type><parameter name="node"><paramtype>const const_node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'node' is a node of the tree or a node initialized by init(...) or init_node.</para><para><emphasis role="bold">Effects</emphasis>: Returns true if the node is initialized by init() or init_node().</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="get_header" specifiers="static"><type>node_ptr</type><parameter name="node"><paramtype>const const_node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'node' is a node of the tree or a header node.</para><para><emphasis role="bold">Effects</emphasis>: Returns the header of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="swap_nodes" specifiers="static"><type>void</type><parameter name="node1"><paramtype>node_ptr</paramtype></parameter><parameter name="node2"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node1 and node2 can't be header nodes of two trees.</para><para><emphasis role="bold">Effects</emphasis>: Swaps two nodes. After the function node1 will be inserted in the position node2 before the function. node2 will be inserted in the position node1 had before the function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if node1 and node2 are not equivalent according to the ordering rules.</para><para>Experimental function </para></description></method>
<method name="swap_nodes" specifiers="static"><type>void</type><parameter name="node1"><paramtype>node_ptr</paramtype></parameter><parameter name="header1"><paramtype>node_ptr</paramtype></parameter><parameter name="node2"><paramtype>node_ptr</paramtype></parameter><parameter name="header2"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node1 and node2 can't be header nodes of two trees with header header1 and header2.</para><para><emphasis role="bold">Effects</emphasis>: Swaps two nodes. After the function node1 will be inserted in the position node2 before the function. node2 will be inserted in the position node1 had before the function.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if node1 and node2 are not equivalent according to the ordering rules.</para><para>Experimental function </para></description></method>
<method name="replace_node" specifiers="static"><type>void</type><parameter name="node_to_be_replaced"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node_to_be_replaced must be inserted in a tree and new_node must not be inserted in a tree.</para><para><emphasis role="bold">Effects</emphasis>: Replaces node_to_be_replaced in its position in the tree with new_node. The tree does not need to be rebalanced</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if new_node is not equivalent to node_to_be_replaced according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing and comparison is needed. Experimental function </para></description></method>
<method name="replace_node" specifiers="static"><type>void</type><parameter name="node_to_be_replaced"><paramtype>node_ptr</paramtype></parameter><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node_to_be_replaced must be inserted in a tree with header "header" and new_node must not be inserted in a tree.</para><para><emphasis role="bold">Effects</emphasis>: Replaces node_to_be_replaced in its position in the tree with new_node. The tree does not need to be rebalanced</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if new_node is not equivalent to node_to_be_replaced according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. Experimental function </para></description></method>
<method name="next_node" specifiers="static"><type>node_ptr</type><parameter name="node"><paramtype>const node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'node' is a node from the tree except the header.</para><para><emphasis role="bold">Effects</emphasis>: Returns the next node of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="prev_node" specifiers="static"><type>node_ptr</type><parameter name="node"><paramtype>const node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'node' is a node from the tree except the leftmost node.</para><para><emphasis role="bold">Effects</emphasis>: Returns the previous node of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="minimum" specifiers="static"><type>node_ptr</type><parameter name="node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'node' is a node of a tree but not the header.</para><para><emphasis role="bold">Effects</emphasis>: Returns the minimum node of the subtree starting at p.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the size of the subtree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="maximum" specifiers="static"><type>node_ptr</type><parameter name="node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'node' is a node of a tree but not the header.</para><para><emphasis role="bold">Effects</emphasis>: Returns the maximum node of the subtree starting at p.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the size of the subtree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="init" specifiers="static"><type>void</type><parameter name="node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'node' must not be part of any tree.</para><para><emphasis role="bold">Effects</emphasis>: After the function unique(node) == true.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Nodes</emphasis>: If node is inserted in a tree, this function corrupts the tree. </para></description></method>
<method name="inited" specifiers="static"><type>bool</type><parameter name="node"><paramtype>const const_node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if node is in the same state as if called init(node)</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="init_header" specifiers="static"><type>void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node must not be part of any tree.</para><para><emphasis role="bold">Effects</emphasis>: Initializes the header to represent an empty tree. unique(header) == true.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Nodes</emphasis>: If node is inserted in a tree, this function corrupts the tree. </para></description></method>
<method name="clear_and_dispose" specifiers="static"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="header"><paramtype>const node_ptr &amp;</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "disposer" must be an object function taking a node_ptr parameter and shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Empties the target tree calling <computeroutput>void disposer::operator()(const node_ptr &amp;)</computeroutput> for every node of the tree except the header.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of element of the source tree plus the. number of elements of tree target tree when calling this function.</para><para><emphasis role="bold">Throws</emphasis>: If cloner functor throws. If this happens target nodes are disposed. </para></description></method>
<method name="unlink_leftmost_without_rebalance" specifiers="static"><type>node_ptr</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header is the header of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the tree, and updates the header link to the new leftmost node.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the tree and the tree can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the tree. </para></description></method>
<method name="size" specifiers="static"><type>std::size_t</type><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node is a node of the tree but it's not the header.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of nodes of the subtree.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="swap_tree" specifiers="static"><type>void</type><parameter name="header1"><paramtype>node_ptr</paramtype></parameter><parameter name="header2"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header1 and header2 must be the header nodes of two trees.</para><para><emphasis role="bold">Effects</emphasis>: Swaps two trees. After the function header1 will contain links to the second tree and header2 will have links to the first tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="is_header" specifiers="static"><type>bool</type><parameter name="p"><paramtype>const const_node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p is a node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Returns true if p is the header of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="find" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns a node_ptr to the first element that is equivalent to "key" according to "comp" or "header" if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="bounded_range" specifiers="static"><type>std::pair&lt; node_ptr, node_ptr &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs. 'lower_key' must not be greater than 'upper_key' according to 'comp'. If 'lower_key' == 'upper_key', ('left_closed' || 'right_closed') must be true.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change. </para></description></method>
<method name="count" specifiers="static"><type>std::size_t</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements with a key equivalent to "key" according to "comp".</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="equal_range" specifiers="static"><type>std::pair&lt; node_ptr, node_ptr &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair of node_ptr delimiting a range containing all elements that are equivalent to "key" according to "comp" or an empty range that indicates the position where those elements would be if there are no equivalent elements.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="lower_bound_range" specifiers="static"><type>std::pair&lt; node_ptr, node_ptr &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair of node_ptr delimiting a range containing the first element that is equivalent to "key" according to "comp" or an empty range that indicates the position where that element would be if there are no equivalent elements.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="lower_bound" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns a node_ptr to the first element that is not less than "key" according to "comp" or "header" if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="upper_bound" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns a node_ptr to the first element that is greater than "key" according to "comp" or "header" if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="insert_unique_commit" specifiers="static"><type>void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_value"><paramtype>node_ptr</paramtype></parameter><parameter name="commit_data"><paramtype>const insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. "commit_data" must have been obtained from a previous call to "insert_unique_check". No objects should have been inserted or erased from the set between the "insert_unique_check" that filled "commit_data" and the call to "insert_commit".</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node in the set using the information obtained from the "commit_data" that a previous "insert_check" filled.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function has only sense if a "insert_unique_check" has been previously executed to fill "commit_data". No value should be inserted or erased between the "insert_check" and "insert_commit" calls. </para></description></method>
<method name="insert_unique_check" specifiers="static"><type>std::pair&lt; node_ptr, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares KeyType with a node_ptr.</para><para><emphasis role="bold">Effects</emphasis>: Checks if there is an equivalent node to "key" in the tree according to "comp" and obtains the needed information to realize a constant-time node insertion if there is no equivalent node.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing a node_ptr to the already present node and false. If there is not equivalent key can be inserted returns true in the returned pair's boolean and fills "commit_data" that is meant to be used with the "insert_commit" function to achieve a constant-time insertion function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a node is expensive and the user does not want to have two equivalent nodes in the tree: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the node and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the node and use "insert_commit" to insert the node in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_unique_commit" only if no more objects are inserted or erased from the set. </para></description></method>
<method name="insert_unique_check" specifiers="static"><type>std::pair&lt; node_ptr, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><parameter name="hint"><paramtype>const node_ptr &amp;</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares KeyType with a node_ptr. "hint" is node from the "header"'s tree.</para><para><emphasis role="bold">Effects</emphasis>: Checks if there is an equivalent node to "key" in the tree according to "comp" using "hint" as a hint to where it should be inserted and obtains the needed information to realize a constant-time node insertion if there is no equivalent node. If "hint" is the upper_bound the function has constant time complexity (two comparisons in the worst case).</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing a node_ptr to the already present node and false. If there is not equivalent key can be inserted returns true in the returned pair's boolean and fills "commit_data" that is meant to be used with the "insert_commit" function to achieve a constant-time insertion function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic, but it is amortized constant time if new_node should be inserted immediately before "hint".</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a node is expensive and the user does not want to have two equivalent nodes in the tree: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the node and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the node and use "insert_commit" to insert the node in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_unique_commit" only if no more objects are inserted or erased from the set. </para></description></method>
<method name="insert_equal" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="NodePtrCompare"/>
        </template><parameter name="h"><paramtype>node_ptr</paramtype></parameter><parameter name="hint"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares two node_ptrs. "hint" is node from the "header"'s tree.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree, using "hint" as a hint to where it will be inserted. If "hint" is the upper_bound the insertion takes constant time (two comparisons in the worst case).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time if new_node is inserted immediately before "hint".</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="insert_equal_upper_bound" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="NodePtrCompare"/>
        </template><parameter name="h"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "h" must be the header node of a tree. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares two node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree before the upper bound according to "comp".</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="insert_equal_lower_bound" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="NodePtrCompare"/>
        </template><parameter name="h"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "h" must be the header node of a tree. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares two node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree before the lower bound according to "comp".</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="insert_before" specifiers="static"><type>node_ptr</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="pos"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. "pos" must be a valid iterator or header (end) node. "pos" must be an iterator pointing to the successor to "new_node" once inserted according to the order of already inserted nodes. This function does not check "pos" and this precondition must be guaranteed by the caller.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree before "pos".</para><para><emphasis role="bold">Complexity</emphasis>: Constant-time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: If "pos" is not the successor of the newly inserted "new_node" tree invariants might be broken. </para></description></method>
<method name="push_back" specifiers="static"><type>void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. "new_node" must be, according to the used ordering no less than the greatest inserted key.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree before "pos".</para><para><emphasis role="bold">Complexity</emphasis>: Constant-time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: If "new_node" is less than the greatest inserted key tree invariants are broken. This function is slightly faster than using "insert_before". </para></description></method>
<method name="push_front" specifiers="static"><type>void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. "new_node" must be, according to the used ordering, no greater than the lowest inserted key.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree before "pos".</para><para><emphasis role="bold">Complexity</emphasis>: Constant-time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: If "new_node" is greater than the lowest inserted key tree invariants are broken. This function is slightly faster than using "insert_before". </para></description></method>
<method name="depth" specifiers="static"><type>std::size_t</type><parameter name="node"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'node' can't be a header node.</para><para><emphasis role="bold">Effects</emphasis>: Calculates the depth of a node: the depth of a node is the length (number of edges) of the path from the root to that node. (The root node is at depth 0.)</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of nodes in the tree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="clone" specifiers="static"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="source_header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><parameter name="target_header"><paramtype>node_ptr</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "cloner" must be a function object taking a node_ptr and returning a new cloned node of it. "disposer" must take a node_ptr and shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: First empties target tree calling <computeroutput>void disposer::operator()(const node_ptr &amp;)</computeroutput> for every node of the tree except the header.</para><para>Then, duplicates the entire tree pointed by "source_header" cloning each source node with <computeroutput>node_ptr Cloner::operator()(const node_ptr &amp;)</computeroutput> to obtain the nodes of the target tree. If "cloner" throws, the cloned target nodes are disposed using <computeroutput>void disposer(const node_ptr &amp;)</computeroutput>.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of element of the source tree plus the number of elements of tree target tree when calling this function.</para><para><emphasis role="bold">Throws</emphasis>: If cloner functor throws. If this happens target nodes are disposed. </para></description></method>
<method name="erase" specifiers="static"><type>void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="z"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header must be the header of a tree, z a node of that tree and z != header.</para><para><emphasis role="bold">Effects</emphasis>: Erases node "z" from the tree with header "header".</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="transfer_unique" specifiers="static"><type>bool</type><template>
          <template-type-parameter name="NodePtrCompare"/>
        </template><parameter name="header1"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><parameter name="header2"><paramtype>node_ptr</paramtype></parameter><parameter name="z"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header1 and header2 must be the headers of trees tree1 and tree2 respectively, z a non-header node of tree1. NodePtrCompare is the comparison function of tree1..</para><para><emphasis role="bold">Effects</emphasis>: Transfers node "z" from tree1 to tree2 if tree1 does not contain a node that is equivalent to z.</para><para><emphasis role="bold">Returns</emphasis>: True if the node was trasferred, false otherwise.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison throws. </para></description></method>
<method name="transfer_equal" specifiers="static"><type>void</type><template>
          <template-type-parameter name="NodePtrCompare"/>
        </template><parameter name="header1"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><parameter name="header2"><paramtype>node_ptr</paramtype></parameter><parameter name="z"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header1 and header2 must be the headers of trees tree1 and tree2 respectively, z a non-header node of tree1. NodePtrCompare is the comparison function of tree1..</para><para><emphasis role="bold">Effects</emphasis>: Transfers node "z" from tree1 to tree2.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison throws. </para></description></method>
<method name="unlink" specifiers="static"><type>void</type><parameter name="node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node is a tree node but not the header.</para><para><emphasis role="bold">Effects</emphasis>: Unlinks the node and rebalances the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rebalance" specifiers="static"><type>void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header must be the header of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Rebalances the tree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear. </para></description></method>
<method name="rebalance_subtree" specifiers="static"><type>node_ptr</type><parameter name="old_root"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: old_root is a node of a tree. It shall not be null.</para><para><emphasis role="bold">Effects</emphasis>: Rebalances the subtree rooted at old_root.</para><para><emphasis role="bold">Returns</emphasis>: The new root of the subtree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear. </para></description></method>
<method name="check" specifiers="static"><type>void</type><template>
          <template-type-parameter name="Checker"/>
        </template><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><parameter name="checker"><paramtype>Checker</paramtype></parameter><parameter name="checker_return"><paramtype>typename Checker::return_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Asserts the integrity of the container with additional checks provided by the user.</para><para><emphasis role="bold">Requires</emphasis>: header must be the header of a tree.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time.</para><para><emphasis role="bold">Note</emphasis>: The method might not have effect when asserts are turned off (e.g., with NDEBUG). Experimental function, interface might change in future versions. </para></description></method>
</method-group>
<method-group name="protected static functions">
<method name="transfer_unique" specifiers="static"><type>bool</type><template>
          <template-type-parameter name="NodePtrCompare"/>
        </template><parameter name="header1"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><parameter name="header2"><paramtype>node_ptr</paramtype></parameter><parameter name="z"><paramtype>node_ptr</paramtype></parameter><parameter name="info"><paramtype>data_for_rebalance &amp;</paramtype></parameter></method>
<method name="transfer_equal" specifiers="static"><type>void</type><template>
          <template-type-parameter name="NodePtrCompare"/>
        </template><parameter name="header1"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><parameter name="header2"><paramtype>node_ptr</paramtype></parameter><parameter name="z"><paramtype>node_ptr</paramtype></parameter><parameter name="info"><paramtype>data_for_rebalance &amp;</paramtype></parameter></method>
<method name="erase" specifiers="static"><type>void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="z"><paramtype>node_ptr</paramtype></parameter><parameter name="info"><paramtype>data_for_rebalance &amp;</paramtype></parameter></method>
<method name="subtree_size" specifiers="static"><type>std::size_t</type><parameter name="subtree"><paramtype>const const_node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node is a node of the tree but it's not the header.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of nodes of the subtree.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="is_left_child" specifiers="static"><type>bool</type><parameter name="p"><paramtype>const node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p is a node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Returns true if p is a left child.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="is_right_child" specifiers="static"><type>bool</type><parameter name="p"><paramtype>const node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p is a node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Returns true if p is a right child.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="insert_before_check" specifiers="static"><type>void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="pos"><paramtype>node_ptr</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter></method>
<method name="push_back_check" specifiers="static"><type>void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter></method>
<method name="push_front_check" specifiers="static"><type>void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter></method>
<method name="insert_equal_check" specifiers="static"><type>void</type><template>
          <template-type-parameter name="NodePtrCompare"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="hint"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter></method>
<method name="insert_equal_upper_bound_check" specifiers="static"><type>void</type><template>
          <template-type-parameter name="NodePtrCompare"/>
        </template><parameter name="h"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><parameter name="pdepth"><paramtype>std::size_t *</paramtype><default>0</default></parameter></method>
<method name="insert_equal_lower_bound_check" specifiers="static"><type>void</type><template>
          <template-type-parameter name="NodePtrCompare"/>
        </template><parameter name="h"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><parameter name="pdepth"><paramtype>std::size_t *</paramtype><default>0</default></parameter></method>
<method name="insert_commit" specifiers="static"><type>void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="commit_data"><paramtype>const insert_commit_data &amp;</paramtype></parameter></method>
<method name="set_child" specifiers="static"><type>void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_child"><paramtype>node_ptr</paramtype></parameter><parameter name="new_parent"><paramtype>node_ptr</paramtype></parameter><parameter name="link_left"><paramtype>const bool</paramtype></parameter></method>
<method name="rotate_left_no_parent_fix" specifiers="static"><type>void</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><parameter name="p_right"><paramtype>node_ptr</paramtype></parameter></method>
<method name="rotate_left" specifiers="static"><type>void</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><parameter name="p_right"><paramtype>node_ptr</paramtype></parameter><parameter name="p_parent"><paramtype>node_ptr</paramtype></parameter><parameter name="header"><paramtype>node_ptr</paramtype></parameter></method>
<method name="rotate_right_no_parent_fix" specifiers="static"><type>void</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><parameter name="p_left"><paramtype>node_ptr</paramtype></parameter></method>
<method name="rotate_right" specifiers="static"><type>void</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><parameter name="p_left"><paramtype>node_ptr</paramtype></parameter><parameter name="p_parent"><paramtype>node_ptr</paramtype></parameter><parameter name="header"><paramtype>node_ptr</paramtype></parameter></method>
</method-group>
<method-group name="private static functions">
<method name="subtree_to_vine" specifiers="static"><type>void</type><parameter name="vine_tail"><paramtype>node_ptr</paramtype></parameter><parameter name="size"><paramtype>std::size_t &amp;</paramtype></parameter></method>
<method name="compress_subtree" specifiers="static"><type>void</type><parameter name="scanner"><paramtype>node_ptr</paramtype></parameter><parameter name="count"><paramtype>std::size_t</paramtype></parameter></method>
<method name="vine_to_subtree" specifiers="static"><type>void</type><parameter name="super_root"><paramtype>node_ptr</paramtype></parameter><parameter name="count"><paramtype>std::size_t</paramtype></parameter></method>
<method name="get_root" specifiers="static"><type>node_ptr</type><parameter name="node"><paramtype>const node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "n" must be a node inserted in a tree.</para><para><emphasis role="bold">Effects</emphasis>: Returns a pointer to the header node of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="clone_subtree" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="source_parent"><paramtype>const const_node_ptr &amp;</paramtype></parameter><parameter name="target_parent"><paramtype>node_ptr</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><parameter name="leftmost_out"><paramtype>node_ptr &amp;</paramtype></parameter><parameter name="rightmost_out"><paramtype>node_ptr &amp;</paramtype></parameter></method>
<method name="dispose_subtree" specifiers="static"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="x"><paramtype>node_ptr</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter></method>
<method name="lower_bound_loop" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="x"><paramtype>node_ptr</paramtype></parameter><parameter name="y"><paramtype>node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter></method>
<method name="upper_bound_loop" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="x"><paramtype>node_ptr</paramtype></parameter><parameter name="y"><paramtype>node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter></method>
<method name="check_subtree" specifiers="static"><type>void</type><template>
          <template-type-parameter name="Checker"/>
        </template><parameter name="node"><paramtype>const const_node_ptr &amp;</paramtype></parameter><parameter name="checker"><paramtype>Checker</paramtype></parameter><parameter name="check_return"><paramtype>typename Checker::return_type &amp;</paramtype></parameter></method>
</method-group>
</class>



















































</namespace>
</namespace>
</header>
<header name="boost/intrusive/circular_list_algorithms.hpp">
<namespace name="boost">
<namespace name="intrusive">
<class name="circular_list_algorithms"><template>
      <template-type-parameter name="NodeTraits"/>
    </template><description><para><classname alt="boost::intrusive::circular_list_algorithms">circular_list_algorithms</classname> provides basic algorithms to manipulate nodes forming a circular doubly linked list. An empty circular list is formed by a node whose pointers point to itself.</para><para><classname alt="boost::intrusive::circular_list_algorithms">circular_list_algorithms</classname> is configured with a NodeTraits class, which encapsulates the information about the node to be manipulated. NodeTraits must support the following interface:</para><para><emphasis role="bold">Typedefs</emphasis>:</para><para><computeroutput>node</computeroutput>: The type of the node that forms the circular list</para><para><computeroutput>node_ptr</computeroutput>: A pointer to a node</para><para><computeroutput>const_node_ptr</computeroutput>: A pointer to a const node</para><para><emphasis role="bold">Static functions</emphasis>:</para><para><computeroutput>static node_ptr get_previous(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_previous(node_ptr n, node_ptr prev);</computeroutput></para><para><computeroutput>static node_ptr get_next(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_next(node_ptr n, node_ptr next);</computeroutput> </para></description><struct name="stable_partition_info"><data-member name="num_1st_partition"><type>std::size_t</type></data-member>
<data-member name="num_2nd_partition"><type>std::size_t</type></data-member>
<data-member name="beg_2st_partition"><type>node_ptr</type></data-member>
</struct><typedef name="node"><type>NodeTraits::node</type></typedef>
<typedef name="node_ptr"><type>NodeTraits::node_ptr</type></typedef>
<typedef name="const_node_ptr"><type>NodeTraits::const_node_ptr</type></typedef>
<typedef name="node_traits"><type>NodeTraits</type></typedef>
<method-group name="public static functions">
<method name="init" specifiers="static"><type>void</type><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an non-used list element, so that inited(this_node) == true</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="inited" specifiers="static"><type>bool</type><parameter name="this_node"><paramtype>const const_node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true is "this_node" is in a non-used state as if it was initialized by the "init" function.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="init_header" specifiers="static"><type>void</type><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty list, making this_node the only node of the circular list: <computeroutput>NodeTraits::get_next(this_node) == NodeTraits::get_previous(this_node) == this_node</computeroutput>.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="unique" specifiers="static"><type>bool</type><parameter name="this_node"><paramtype>const const_node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this_node must be in a circular list or be an empty circular list.</para><para><emphasis role="bold">Effects</emphasis>: Returns true is "this_node" is the only node of a circular list: <computeroutput>return NodeTraits::get_next(this_node) == this_node</computeroutput></para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="count" specifiers="static"><type>std::size_t</type><parameter name="this_node"><paramtype>const const_node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this_node must be in a circular list or be an empty circular list.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of nodes in a circular list. If the circular list is empty, returns 1.</para><para><emphasis role="bold">Complexity</emphasis>: Linear</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="unlink" specifiers="static"><type>node_ptr</type><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this_node must be in a circular list or be an empty circular list.</para><para><emphasis role="bold">Effects</emphasis>: Unlinks the node from the circular list.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="unlink" specifiers="static"><type>void</type><parameter name="b"><paramtype>node_ptr</paramtype></parameter><parameter name="e"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: b and e must be nodes of the same circular list or an empty range.</para><para><emphasis role="bold">Effects</emphasis>: Unlinks the node [b, e) from the circular list.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="link_before" specifiers="static"><type>void</type><parameter name="nxt_node"><paramtype>node_ptr</paramtype></parameter><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: nxt_node must be a node of a circular list.</para><para><emphasis role="bold">Effects</emphasis>: Links this_node before nxt_node in the circular list.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="link_after" specifiers="static"><type>void</type><parameter name="prev_node"><paramtype>node_ptr</paramtype></parameter><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev_node must be a node of a circular list.</para><para><emphasis role="bold">Effects</emphasis>: Links this_node after prev_node in the circular list.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="swap_nodes" specifiers="static"><type>void</type><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><parameter name="other_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this_node and other_node must be nodes inserted in circular lists or be empty circular lists.</para><para><emphasis role="bold">Effects</emphasis>: Swaps the position of the nodes: this_node is inserted in other_nodes position in the second circular list and the other_node is inserted in this_node's position in the first circular list.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="transfer" specifiers="static"><type>void</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><parameter name="b"><paramtype>node_ptr</paramtype></parameter><parameter name="e"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: b and e must be nodes of the same circular list or an empty range. and p must be a node of a different circular list or may not be an iterator in <emphasis role="bold">Effects</emphasis>: Removes the nodes from [b, e) range from their circular list and inserts them before p in p's circular list.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="transfer" specifiers="static"><type>void</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><parameter name="i"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: i must a node of a circular list and p must be a node of a different circular list.</para><para><emphasis role="bold">Effects</emphasis>: Removes the node i from its circular list and inserts it before p in p's circular list. If p == i or p == NodeTraits::get_next(i), this function is a null operation.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="reverse" specifiers="static"><type>void</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Reverses the order of elements in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear time. </para></description></method>
<method name="move_backwards" specifiers="static"><type>void</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><parameter name="n"><paramtype>std::size_t</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Moves the node p n positions towards the end of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of moved positions. </para></description></method>
<method name="move_forward" specifiers="static"><type>void</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><parameter name="n"><paramtype>std::size_t</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Moves the node p n positions towards the beginning of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of moved positions. </para></description></method>
<method name="distance" specifiers="static"><type>std::size_t</type><parameter name="f"><paramtype>const const_node_ptr &amp;</paramtype></parameter><parameter name="l"><paramtype>const const_node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: f and l must be in a circular list.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of nodes in the range [f, l).</para><para><emphasis role="bold">Complexity</emphasis>: Linear</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="stable_partition" specifiers="static"><type>void</type><template>
          <template-type-parameter name="Pred"/>
        </template><parameter name="beg"><paramtype>node_ptr</paramtype></parameter><parameter name="end"><paramtype>node_ptr</paramtype></parameter><parameter name="pred"><paramtype>Pred</paramtype></parameter><parameter name="info"><paramtype>stable_partition_info &amp;</paramtype></parameter></method>
</method-group>
<method-group name="private static functions">
<method name="swap_prev" specifiers="static"><type>void</type><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><parameter name="other_node"><paramtype>node_ptr</paramtype></parameter></method>
<method name="swap_next" specifiers="static"><type>void</type><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><parameter name="other_node"><paramtype>node_ptr</paramtype></parameter></method>
</method-group>
</class>



















































</namespace>
</namespace>
</header>
<header name="boost/intrusive/circular_slist_algorithms.hpp">
<namespace name="boost">
<namespace name="intrusive">
<class name="circular_slist_algorithms"><template>
      <template-type-parameter name="NodeTraits"/>
    </template><description><para><classname alt="boost::intrusive::circular_slist_algorithms">circular_slist_algorithms</classname> provides basic algorithms to manipulate nodes forming a circular singly linked list. An empty circular list is formed by a node whose pointer to the next node points to itself.</para><para><classname alt="boost::intrusive::circular_slist_algorithms">circular_slist_algorithms</classname> is configured with a NodeTraits class, which encapsulates the information about the node to be manipulated. NodeTraits must support the following interface:</para><para><emphasis role="bold">Typedefs</emphasis>:</para><para><computeroutput>node</computeroutput>: The type of the node that forms the circular list</para><para><computeroutput>node_ptr</computeroutput>: A pointer to a node</para><para><computeroutput>const_node_ptr</computeroutput>: A pointer to a const node</para><para><emphasis role="bold">Static functions</emphasis>:</para><para><computeroutput>static node_ptr get_next(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_next(node_ptr n, node_ptr next);</computeroutput> </para></description><typedef name="node"><type>NodeTraits::node</type></typedef>
<typedef name="node_ptr"><type>NodeTraits::node_ptr</type></typedef>
<typedef name="const_node_ptr"><type>NodeTraits::const_node_ptr</type></typedef>
<typedef name="node_traits"><type>NodeTraits</type></typedef>
<method-group name="public static functions">
<method name="init" specifiers="static"><type>void</type><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an non-used list element, putting the next pointer to null: <computeroutput>NodeTraits::get_next(this_node) == node_ptr()</computeroutput></para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="unique" specifiers="static"><type>bool</type><parameter name="this_node"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this_node must be in a circular list or be an empty circular list.</para><para><emphasis role="bold">Effects</emphasis>: Returns true is "this_node" is the only node of a circular list: or it's a not inserted node: <computeroutput>return node_ptr() == NodeTraits::get_next(this_node) || NodeTraits::get_next(this_node) == this_node</computeroutput></para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="inited" specifiers="static"><type>bool</type><parameter name="this_node"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true is "this_node" has the same state as if it was inited using "init(node_ptr)"</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="unlink_after" specifiers="static"><type>void</type><parameter name="prev_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev_node must be in a circular list or be an empty circular list.</para><para><emphasis role="bold">Effects</emphasis>: Unlinks the next node of prev_node from the circular list.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="unlink_after" specifiers="static"><type>void</type><parameter name="prev_node"><paramtype>node_ptr</paramtype></parameter><parameter name="last_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev_node and last_node must be in a circular list or be an empty circular list.</para><para><emphasis role="bold">Effects</emphasis>: Unlinks the range (prev_node, last_node) from the circular list.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="link_after" specifiers="static"><type>void</type><parameter name="prev_node"><paramtype>node_ptr</paramtype></parameter><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev_node must be a node of a circular list.</para><para><emphasis role="bold">Effects</emphasis>: Links this_node after prev_node in the circular list.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="transfer_after" specifiers="static"><type>void</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><parameter name="b"><paramtype>node_ptr</paramtype></parameter><parameter name="e"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: b and e must be nodes of the same circular list or an empty range. and p must be a node of a different circular list.</para><para><emphasis role="bold">Effects</emphasis>: Removes the nodes from (b, e] range from their circular list and inserts them after p in p's circular list.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="init_header" specifiers="static"><type>void</type><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty list, making this_node the only node of the circular list: <computeroutput>NodeTraits::get_next(this_node) == this_node</computeroutput>.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="get_previous_node" specifiers="static"><type>node_ptr</type><parameter name="prev_init_node"><paramtype>const node_ptr &amp;</paramtype></parameter><parameter name="this_node"><paramtype>const node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this_node and prev_init_node must be in the same circular list.</para><para><emphasis role="bold">Effects</emphasis>: Returns the previous node of this_node in the circular list starting. the search from prev_init_node. The first node checked for equality is NodeTraits::get_next(prev_init_node).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements between prev_init_node and this_node.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="get_previous_node" specifiers="static"><type>node_ptr</type><parameter name="this_node"><paramtype>const node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this_node must be in a circular list or be an empty circular list.</para><para><emphasis role="bold">Effects</emphasis>: Returns the previous node of this_node in the circular list.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the circular list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="get_previous_previous_node" specifiers="static"><type>node_ptr</type><parameter name="this_node"><paramtype>const node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this_node must be in a circular list or be an empty circular list.</para><para><emphasis role="bold">Effects</emphasis>: Returns the previous node of the previous node of this_node in the circular list.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the circular list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="get_previous_previous_node" specifiers="static"><type>node_ptr</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><parameter name="this_node"><paramtype>const node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this_node and p must be in the same circular list.</para><para><emphasis role="bold">Effects</emphasis>: Returns the previous node of the previous node of this_node in the circular list starting. the search from p. The first node checked for equality is NodeTraits::get_next((NodeTraits::get_next(p)).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the circular list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="count" specifiers="static"><type>std::size_t</type><parameter name="this_node"><paramtype>const const_node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this_node must be in a circular list or be an empty circular list.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of nodes in a circular list. If the circular list is empty, returns 1.</para><para><emphasis role="bold">Complexity</emphasis>: Linear</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="unlink" specifiers="static"><type>void</type><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this_node must be in a circular list, be an empty circular list or be inited.</para><para><emphasis role="bold">Effects</emphasis>: Unlinks the node from the circular list.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the circular list</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="link_before" specifiers="static"><type>void</type><parameter name="nxt_node"><paramtype>node_ptr</paramtype></parameter><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: nxt_node must be a node of a circular list.</para><para><emphasis role="bold">Effects</emphasis>: Links this_node before nxt_node in the circular list.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the circular list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="swap_nodes" specifiers="static"><type>void</type><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><parameter name="other_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this_node and other_node must be nodes inserted in circular lists or be empty circular lists.</para><para><emphasis role="bold">Effects</emphasis>: Swaps the position of the nodes: this_node is inserted in other_nodes position in the second circular list and the other_node is inserted in this_node's position in the first circular list.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to number of elements of both lists</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="reverse" specifiers="static"><type>void</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Reverses the order of elements in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear to the contained elements. </para></description></method>
<method name="move_backwards" specifiers="static"><type>node_ptr</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><parameter name="n"><paramtype>std::size_t</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Moves the node p n positions towards the end of the list.</para><para><emphasis role="bold">Returns</emphasis>: The previous node of p after the function if there has been any movement, Null if n leads to no movement.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements plus the number moved positions. </para></description></method>
<method name="move_forward" specifiers="static"><type>node_ptr</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><parameter name="n"><paramtype>std::size_t</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Moves the node p n positions towards the beginning of the list.</para><para><emphasis role="bold">Returns</emphasis>: The previous node of p after the function if there has been any movement, Null if n leads equals to no movement.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements plus the number moved positions. </para></description></method>
</method-group>
</class>



















































</namespace>
</namespace>
</header>
<header name="boost/intrusive/derivation_value_traits.hpp">
<namespace name="boost">
<namespace name="intrusive">
<struct name="derivation_value_traits"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="NodeTraits"/>
      <template-nontype-parameter name="LinkMode"><type>link_mode_type</type><default>safe_link</default></template-nontype-parameter>
    </template><description><para>This value traits template is used to create value traits from user defined node traits where value_traits::value_type will derive from node_traits::node </para></description><typedef name="node_traits"><type>NodeTraits</type></typedef>
<typedef name="value_type"><type>T</type></typedef>
<typedef name="node"><type>node_traits::node</type></typedef>
<typedef name="node_ptr"><type>node_traits::node_ptr</type></typedef>
<typedef name="const_node_ptr"><type>node_traits::const_node_ptr</type></typedef>
<typedef name="pointer"><type><classname>pointer_traits</classname>&lt; node_ptr &gt;::template rebind_pointer&lt; value_type &gt;::type</type></typedef>
<typedef name="const_pointer"><type><classname>pointer_traits</classname>&lt; node_ptr &gt;::template rebind_pointer&lt; const value_type &gt;::type</type></typedef>
<typedef name="reference"><type><classname>boost::intrusive::pointer_traits</classname>&lt; pointer &gt;::reference</type></typedef>
<typedef name="const_reference"><type><classname>boost::intrusive::pointer_traits</classname>&lt; const_pointer &gt;::reference</type></typedef>
<data-member name="link_mode" specifiers="static"><type>const link_mode_type</type></data-member>
<method-group name="public static functions">
<method name="to_node_ptr" specifiers="static"><type>node_ptr</type><parameter name="value"><paramtype>reference</paramtype></parameter></method>
<method name="to_node_ptr" specifiers="static"><type>const_node_ptr</type><parameter name="value"><paramtype>const_reference</paramtype></parameter></method>
<method name="to_value_ptr" specifiers="static"><type>pointer</type><parameter name="n"><paramtype>const node_ptr &amp;</paramtype></parameter></method>
<method name="to_value_ptr" specifiers="static"><type>const_pointer</type><parameter name="n"><paramtype>const const_node_ptr &amp;</paramtype></parameter></method>
</method-group>
</struct>



















































</namespace>
</namespace>
</header>
<header name="boost/intrusive/hashtable.hpp">
<namespace name="boost">
<namespace name="intrusive">
<class name="hashtable"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><inherit access="private">hashtable_size_traits_wrapper&lt; hashdata_internal&lt; ValueTraits, VoidOrKeyOfValue, VoidOrKeyHash, VoidOrKeyEqual, BucketTraits, SizeType, BoolFlags &amp;(hash_bool_flags::incremental_pos|hash_bool_flags::cache_begin_pos) &gt;, SizeType,(BoolFlags &amp;hash_bool_flags::constant_time_size_pos) !=0 &gt;</inherit><description><para>The class template hashtable is an intrusive hash table container, that is used to construct intrusive <classname alt="boost::intrusive::unordered_set">unordered_set</classname> and <classname alt="boost::intrusive::unordered_multiset">unordered_multiset</classname> containers. The no-throw guarantee holds only, if the VoidOrKeyEqual object and Hasher don't throw.</para><para>hashtable is a semi-intrusive container: each object to be stored in the container must contain a proper hook, but the container also needs additional auxiliary memory to work: hashtable needs a pointer to an array of type <computeroutput>bucket_type</computeroutput> to be passed in the constructor. This bucket array must have at least the same lifetime as the container. This makes the use of hashtable more complicated than purely intrusive containers. <computeroutput>bucket_type</computeroutput> is default-constructible, copyable and assignable</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput>, <computeroutput>hash&lt;&gt;</computeroutput> and <computeroutput>equal&lt;&gt;</computeroutput> <computeroutput>bucket_traits&lt;&gt;</computeroutput>, power_2_buckets&lt;&gt;, cache_begin&lt;&gt; and incremental&lt;&gt;.</para><para>hashtable only provides forward iterators but it provides 4 iterator types: iterator and const_iterator to navigate through the whole container and local_iterator and const_local_iterator to navigate through the values stored in a single bucket. Local iterators are faster and smaller.</para><para>It's not recommended to use non constant-time size hashtables because several key functions, like "empty()", become non-constant time functions. Non constant_time size hashtables are mainly provided to support auto-unlink hooks.</para><para>hashtables, does not make automatic rehashings nor offers functions related to a load factor. Rehashing can be explicitly requested and the user must provide a new bucket array that will be used from that moment.</para><para>Since no automatic rehashing is done, iterators are never invalidated when inserting or erasing elements. Iterators are only invalidated when rehashing. </para></description><typedef name="value_traits"><type>ValueTraits</type></typedef>
<typedef name="pointer"><type>value_traits::pointer</type></typedef>
<typedef name="const_pointer"><type>value_traits::const_pointer</type></typedef>
<typedef name="value_type"><type>value_traits::value_type</type></typedef>
<typedef name="key_type"><type>hash_types_base::key_type</type></typedef>
<typedef name="key_of_value"><type>hash_types_base::key_of_value</type></typedef>
<typedef name="reference"><type><classname>pointer_traits</classname>&lt; pointer &gt;::reference</type></typedef>
<typedef name="const_reference"><type><classname>pointer_traits</classname>&lt; const_pointer &gt;::reference</type></typedef>
<typedef name="difference_type"><type><classname>pointer_traits</classname>&lt; pointer &gt;::difference_type</type></typedef>
<typedef name="size_type"><type>SizeType</type></typedef>
<typedef name="key_equal"><type>internal_type::key_equal</type></typedef>
<typedef name="hasher"><type>internal_type::hasher</type></typedef>
<typedef name="bucket_type"><type>bucket_impl&lt; <classname>slist</classname> &gt;</type></typedef>
<typedef name="bucket_ptr"><type>internal_type::bucket_ptr</type></typedef>
<typedef name="siterator"><type>slist::iterator</type></typedef>
<typedef name="const_siterator"><type>slist::const_iterator</type></typedef>
<typedef name="iterator"><type>internal_type::iterator</type></typedef>
<typedef name="const_iterator"><type>internal_type::const_iterator</type></typedef>
<typedef name="local_iterator"><type>internal_type::local_iterator</type></typedef>
<typedef name="const_local_iterator"><type>internal_type::const_local_iterator</type></typedef>
<typedef name="node_traits"><type>value_traits::node_traits</type></typedef>
<typedef name="node"><type>node_traits::node</type></typedef>
<typedef name="node_ptr"><type><classname>pointer_traits</classname>&lt; pointer &gt;::template rebind_pointer&lt; node &gt;::type</type></typedef>
<typedef name="const_node_ptr"><type><classname>pointer_traits</classname>&lt; pointer &gt;::template rebind_pointer&lt; const node &gt;::type</type></typedef>
<typedef name="node_reference"><type><classname>pointer_traits</classname>&lt; node_ptr &gt;::reference</type></typedef>
<typedef name="const_node_reference"><type><classname>pointer_traits</classname>&lt; const_node_ptr &gt;::reference</type></typedef>
<typedef name="node_algorithms"><type>slist::node_algorithms</type></typedef>
<typedef name="insert_commit_data"><type><emphasis>unspecified</emphasis></type></typedef>
<data-member name="stateful_value_traits" specifiers="static"><type>const bool</type></data-member>
<data-member name="store_hash" specifiers="static"><type>const bool</type></data-member>
<data-member name="unique_keys" specifiers="static"><type>const bool</type></data-member>
<data-member name="constant_time_size" specifiers="static"><type>const bool</type></data-member>
<data-member name="cache_begin" specifiers="static"><type>const bool</type></data-member>
<data-member name="compare_hash" specifiers="static"><type>const bool</type></data-member>
<data-member name="incremental" specifiers="static"><type>const bool</type></data-member>
<data-member name="power_2_buckets" specifiers="static"><type>const bool</type></data-member>
<data-member name="optimize_multikey" specifiers="static"><type>const bool</type></data-member>
<method-group name="public member functions">
<method name="begin"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. Worst case (empty <classname alt="boost::intrusive::unordered_set">unordered_set</classname>): O(this-&gt;bucket_count())</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. Worst case (empty <classname alt="boost::intrusive::unordered_set">unordered_set</classname>): O(this-&gt;bucket_count())</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. Worst case (empty <classname alt="boost::intrusive::unordered_set">unordered_set</classname>): O(this-&gt;bucket_count())</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="hash_function" cv="const"><type>hasher</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the hasher object used by the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If hasher copy-constructor throws. </para></description></method>
<method name="key_eq" cv="const"><type>key_equal</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the key_equal object used by the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If key_equal copy-constructor throws. </para></description></method>
<method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: if constant-time size and <classname alt="boost::intrusive::cache_begin">cache_begin</classname> options are disabled, average constant time (worst case, with empty() == true: O(this-&gt;bucket_count()). Otherwise constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this if <classname alt="boost::intrusive::constant_time_size">constant_time_size</classname> is false. Constant-time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="swap"><type>void</type><parameter name="other"><paramtype><classname>hashtable</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: the hasher and the equality function unqualified swap call should not throw.</para><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of two unordered_sets. Swaps also the contained bucket array and equality and hasher functors.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the swap() call for the comparison or hash functors found using ADL throw. Basic guarantee. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>hashtable</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw Cloner should yield to nodes that compare equal and produce the same hash than the original node.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this. The hash function and the equality predicate are copied from the source.</para><para>If <classname alt="boost::intrusive::store_hash">store_hash</classname> option is true, this method does not use the hash function.</para><para>If any operation throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner or hasher throw or hash or equality predicate copying throws. Basic guarantee. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype><classname>hashtable</classname> &amp;&amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw Cloner should yield to nodes that compare equal and produce the same hash than the original node.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(reference) and inserts them on *this. The hash function and the equality predicate are copied from the source.</para><para>If <classname alt="boost::intrusive::store_hash">store_hash</classname> option is true, this method does not use the hash function.</para><para>If any operation throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner or hasher throw or hash or equality predicate copying throws. Basic guarantee. </para></description></method>
<method name="insert_equal"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value into the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the inserted value.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_equal"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Equivalent to this-&gt;insert_equal(t) for each element in [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(N), where N is distance(b, e). Worst case O(N*this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_unique"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Tries to inserts value into the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>.</para><para><emphasis role="bold">Returns</emphasis>: If the value is not already present inserts it and returns a pair containing the iterator to the new value and true. If there is an equivalent value returns a pair containing an iterator to the already present value and false.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_unique"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Equivalent to this-&gt;insert_unique(t) for each element in [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(N), where N is distance(b, e). Worst case O(N*this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_unique_check"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyEqual</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"equal_func" must be a equality function that induces the same equality as key_equal. The difference is that "equal_func" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>, using a user provided key instead of the value itself.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hash_func or equal_func throw. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the hash or the equality is much cheaper to construct than the value_type and this function offers the possibility to use that the part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time.</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>.</para><para>After a successful rehashing insert_commit_data remains valid. </para></description></method>
<method name="insert_unique_check"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>, using a user provided key instead of the value itself.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hasher or key_compare throw. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the hash or the equality is much cheaper to construct than the value_type and this function offers the possibility to use that the part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time.</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>.</para><para>After a successful rehashing insert_commit_data remains valid. </para></description></method>
<method name="insert_unique_commit"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><parameter name="commit_data"><paramtype>const insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue of type value_type. commit_data must have been obtained from a previous call to "insert_check". No objects should have been inserted or erased from the <classname alt="boost::intrusive::unordered_set">unordered_set</classname> between the "insert_check" that filled "commit_data" and the call to "insert_commit".</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value in the <classname alt="boost::intrusive::unordered_set">unordered_set</classname> using the information obtained from the "commit_data" that a previous "insert_check" filled.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the newly inserted object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function has only sense if a "insert_check" has been previously executed to fill "commit_data". No value should be inserted or erased between the "insert_check" and "insert_commit" calls.</para><para>After a successful rehashing insert_commit_data remains valid. </para></description></method>
<method name="erase"><type>void</type><parameter name="i"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased element. No destructors are called. </para></description></method>
<method name="erase"><type>void</type><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(distance(b, e)), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyEqual</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"equal_func" must be a equality function that induces the same equality as key_equal. The difference is that "equal_func" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements that have the same hash and compare equal with the given key.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hash_func or equal_func throw. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(distance(b, e)), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyEqual"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyEqual</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "equal_func". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hash_func or equal_func throw. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="clear"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="clear_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="count" cv="const"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given value</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. </para></description></method>
<method name="count" cv="const"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyEqual</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"equal_func" must be a equality function that induces the same equality as key_equal. The difference is that "equal_func" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hash_func or equal throw. </para></description></method>
<method name="find"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element is equal to "value" or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. </para></description></method>
<method name="find"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyEqual</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"equal_func" must be a equality function that induces the same equality as key_equal. The difference is that "equal_func" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is "key" according to the given hash and equality functor or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hash_func or equal_func throw.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a const_iterator to the first element whose key is "key" or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyEqual</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"equal_func" must be a equality function that induces the same equality as key_equal. The difference is that "equal_func" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is "key" according to the given hasher and equality functor or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hash_func or equal_func throw.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns a range containing all elements with values equivalent to value. Returns std::make_pair(this-&gt;end(), this-&gt;end()) if no such elements exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyEqual</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"equal_func" must be a equality function that induces the same equality as key_equal. The difference is that "equal_func" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Returns a range containing all elements with equivalent keys. Returns std::make_pair(this-&gt;end(), this-&gt;end()) if no such elements exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(key, hash_func, equal_func)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hash_func or the equal_func throw.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns a range containing all elements with values equivalent to value. Returns std::make_pair(this-&gt;end(), this-&gt;end()) if no such elements exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyEqual</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"equal_func" must be a equality function that induces the same equality as key_equal. The difference is that "equal_func" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Returns a range containing all elements with equivalent keys. Returns std::make_pair(this-&gt;end(), this-&gt;end()) if no such elements exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(key, hash_func, equal_func)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the hasher or equal_func throw.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method>
<method name="iterator_to"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a <classname alt="boost::intrusive::unordered_set">unordered_set</classname> of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator belonging to the <classname alt="boost::intrusive::unordered_set">unordered_set</classname> that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the internal hash function throws. </para></description></method>
<method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a <classname alt="boost::intrusive::unordered_set">unordered_set</classname> of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator belonging to the <classname alt="boost::intrusive::unordered_set">unordered_set</classname> that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the internal hash function throws. </para></description></method>
<method name="local_iterator_to"><type>local_iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a <classname alt="boost::intrusive::unordered_set">unordered_set</classname> of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid local_iterator belonging to the <classname alt="boost::intrusive::unordered_set">unordered_set</classname> that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="local_iterator_to" cv="const"><type>const_local_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a <classname alt="boost::intrusive::unordered_set">unordered_set</classname> of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_local_iterator belonging to the <classname alt="boost::intrusive::unordered_set">unordered_set</classname> that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="bucket_count" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of buckets passed in the constructor or the last rehash function.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="bucket_size" cv="const"><type>size_type</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements in the nth bucket.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="bucket" cv="const"><type>size_type</type><parameter name="k"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the index of the bucket in which elements with keys equivalent to k would be found, if any such element existed.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the hash functor throws.</para><para><emphasis role="bold">Note</emphasis>: the return value is in the range [0, this-&gt;bucket_count()). </para></description></method>
<method name="bucket" cv="const"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
        </template><parameter name="k"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para><emphasis role="bold">Effects</emphasis>: Returns the index of the bucket in which elements with keys equivalent to k would be found, if any such element existed.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If hash_func throws.</para><para><emphasis role="bold">Note</emphasis>: the return value is in the range [0, this-&gt;bucket_count()). </para></description></method>
<method name="bucket_pointer" cv="const"><type>bucket_ptr</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the bucket array pointer passed in the constructor or the last rehash function.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="begin"><type>local_iterator</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a local_iterator pointing to the beginning of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method>
<method name="begin" cv="const"><type>const_local_iterator</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_local_iterator pointing to the beginning of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method>
<method name="cbegin" cv="const"><type>const_local_iterator</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_local_iterator pointing to the beginning of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method>
<method name="end"><type>local_iterator</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a local_iterator pointing to the end of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method>
<method name="end" cv="const"><type>const_local_iterator</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_local_iterator pointing to the end of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method>
<method name="cend" cv="const"><type>const_local_iterator</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_local_iterator pointing to the end of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method>
<method name="rehash"><type>void</type><parameter name="new_bucket_traits"><paramtype>const <classname>bucket_traits</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: new_bucket_traits can hold a pointer to a new bucket array or the same as the old bucket array with a different length. new_size is the length of the the array pointed by new_buckets. If new_bucket_traits.bucket_begin() == this-&gt;bucket_pointer() new_bucket_traits.bucket_count() can be bigger or smaller than this-&gt;bucket_count(). 'new_bucket_traits' copy constructor should not throw.</para><para><emphasis role="bold">Effects</emphasis>: If <computeroutput>new_bucket_traits.bucket_begin() == this-&gt;bucket_pointer()</computeroutput> is false, unlinks values from the old bucket and inserts then in the new one according to the hash value of values.</para><para>If <computeroutput>new_bucket_traits.bucket_begin() == this-&gt;bucket_pointer()</computeroutput> is true, the implementations avoids moving values as much as possible.</para><para>Bucket traits hold by *this is assigned from new_bucket_traits. If the container is configured as incremental&lt;&gt;, the split bucket is set to the new bucket_count().</para><para>If <classname alt="boost::intrusive::store_hash">store_hash</classname> option is true, this method does not use the hash function. If false, the implementation tries to minimize calls to the hash function (e.g. once for equivalent values if optimize_multikey&lt;true&gt; is true).</para><para>If rehash is successful updates the internal <classname alt="boost::intrusive::bucket_traits">bucket_traits</classname> with new_bucket_traits.</para><para><emphasis role="bold">Complexity</emphasis>: Average case linear in this-&gt;size(), worst case quadratic.</para><para><emphasis role="bold">Throws</emphasis>: If the hasher functor throws. Basic guarantee. </para></description></method>
<method name="full_rehash"><type>void</type><description><para><emphasis role="bold">Note</emphasis>: This function is used when keys from inserted elements are changed (e.g. a language change when key is a string) but uniqueness and hash properties are preserved so a fast full rehash recovers invariants for *this without extracting and reinserting all elements again.</para><para><emphasis role="bold">Requires</emphasis>: Calls produced to the hash function should not alter the value uniqueness properties of already inserted elements. If hasher(key1) == hasher(key2) was true when elements were inserted, it shall be true during calls produced in the execution of this function.</para><para>key_equal is not called inside this function so it is assumed that key_equal(value1, value2) should produce the same results as before for inserted elements.</para><para><emphasis role="bold">Effects</emphasis>: Reprocesses all values hold by *this, recalculating their hash values and redistributing them though the buckets.</para><para>If <classname alt="boost::intrusive::store_hash">store_hash</classname> option is true, this method uses the hash function and updates the stored hash value.</para><para><emphasis role="bold">Complexity</emphasis>: Average case linear in this-&gt;size(), worst case quadratic.</para><para><emphasis role="bold">Throws</emphasis>: If the hasher functor throws. Basic guarantee. </para></description></method>
<method name="incremental_rehash"><type>bool</type><parameter name="grow"><paramtype>bool</paramtype><default>true</default></parameter><description><para><emphasis role="bold">Requires</emphasis>:</para><para><emphasis role="bold">Effects</emphasis>:</para><para><emphasis role="bold">Complexity</emphasis>:</para><para><emphasis role="bold">Throws</emphasis>:</para><para><emphasis role="bold">Note</emphasis>: this method is only available if incremental&lt;true&gt; option is activated. </para></description><description><para>grow </para></description></method>
<method name="incremental_rehash"><type>bool</type><parameter name="new_bucket_traits"><paramtype>const <classname>bucket_traits</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If new_bucket_traits.bucket_count() is not this-&gt;bucket_count()/2 or this-&gt;bucket_count()*2, or this-&gt;split_bucket() != new_bucket_traits.bucket_count() returns false and does nothing.</para><para>Otherwise, copy assigns new_bucket_traits to the internal <classname alt="boost::intrusive::bucket_traits">bucket_traits</classname> and transfers all the objects from old buckets to the new ones.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to size().</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Note</emphasis>: this method is only available if incremental&lt;true&gt; option is activated. </para></description></method>
<method name="split_count" cv="const"><type>size_type</type><description><para><emphasis role="bold">Requires</emphasis>: incremental&lt;&gt; option must be set</para><para><emphasis role="bold">Effects</emphasis>: returns the current split count</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing </para></description></method>
</method-group>
<constructor specifiers="explicit"><parameter name="b_traits"><paramtype>const <classname>bucket_traits</classname> &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>const hasher &amp;</paramtype><default>hasher()</default></parameter><parameter name="equal_func"><paramtype>const key_equal &amp;</paramtype><default>key_equal()</default></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: buckets must not be being used by any other resource.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::intrusive::unordered_set">unordered_set</classname>, storing a reference to the bucket array and copies of the key_hasher and equal_func functors.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor or invocation of hash_func or equal_func throws.</para><para><emphasis role="bold">Notes</emphasis>: buckets array must be disposed only after *this is disposed. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="unique"><paramtype>bool</paramtype></parameter><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="b_traits"><paramtype>const <classname>bucket_traits</classname> &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>const hasher &amp;</paramtype><default>hasher()</default></parameter><parameter name="equal_func"><paramtype>const key_equal &amp;</paramtype><default>key_equal()</default></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: buckets must not be being used by any other resource and dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container and inserts elements from [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: If N is distance(b, e): Average case is O(N) (with a good hash function and with buckets_len &gt;= N),worst case O(N^2).</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor or invocation of hasher or key_equal throws.</para><para><emphasis role="bold">Notes</emphasis>: buckets array must be disposed only after *this is disposed. </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>hashtable</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a container moving resources from another container. Internal value traits, bucket traits, hasher and comparison are move constructed and nodes belonging to x are linked to *this.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node's move constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the move constructor of value traits, bucket traits, hasher or comparison throws. </para></description></constructor>
<copy-assignment><type><classname>hashtable</classname> &amp;</type><parameter name="x"><paramtype><classname>hashtable</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to swap. </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the <classname alt="boost::intrusive::unordered_set">unordered_set</classname> are not deleted (i.e. no destructors are called).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>, if it's a safe-mode or auto-unlink value. Otherwise constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor>
<method-group name="public static functions">
<method name="s_local_iterator_to" specifiers="static"><type>local_iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a <classname alt="boost::intrusive::unordered_set">unordered_set</classname> of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid local_iterator belonging to the <classname alt="boost::intrusive::unordered_set">unordered_set</classname> that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="s_local_iterator_to" specifiers="static"><type>const_local_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a <classname alt="boost::intrusive::unordered_set">unordered_set</classname> of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_local_iterator belonging to the <classname alt="boost::intrusive::unordered_set">unordered_set</classname> that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="suggested_upper_bucket_count" specifiers="static"><type>size_type</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the nearest new bucket count optimized for the container that is bigger or equal than n. This suggestion can be used to create bucket arrays with a size that will usually improve container's performance. If such value does not exist, the higher possible value is returned.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="suggested_lower_bucket_count" specifiers="static"><type>size_type</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the nearest new bucket count optimized for the container that is smaller or equal than n. This suggestion can be used to create bucket arrays with a size that will usually improve container's performance. If such value does not exist, the lowest possible value is returned.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
</method-group>
</class><struct name="make_hashtable"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>hashtable</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct>



















































</namespace>
</namespace>
</header>
<header name="boost/intrusive/intrusive_fwd.hpp">
<para>This header file forward declares most Intrusive classes.</para><para>It forward declares the following containers and hooks:<itemizedlist>
<listitem><para><classname alt="boost::intrusive::slist">boost::intrusive::slist</classname> / <classname alt="boost::intrusive::slist_base_hook">boost::intrusive::slist_base_hook</classname> / <classname alt="boost::intrusive::slist_member_hook">boost::intrusive::slist_member_hook</classname></para>
</listitem><listitem><para><classname alt="boost::intrusive::list">boost::intrusive::list</classname> / <classname alt="boost::intrusive::list_base_hook">boost::intrusive::list_base_hook</classname> / <classname alt="boost::intrusive::list_member_hook">boost::intrusive::list_member_hook</classname></para>
</listitem><listitem><para><classname alt="boost::intrusive::bstree">boost::intrusive::bstree</classname> / <classname alt="boost::intrusive::bs_set">boost::intrusive::bs_set</classname> / <classname alt="boost::intrusive::bs_multiset">boost::intrusive::bs_multiset</classname> / <classname alt="boost::intrusive::bs_set_base_hook">boost::intrusive::bs_set_base_hook</classname> / <classname alt="boost::intrusive::bs_set_member_hook">boost::intrusive::bs_set_member_hook</classname></para>
</listitem><listitem><para><classname alt="boost::intrusive::rbtree">boost::intrusive::rbtree</classname> / <classname alt="boost::intrusive::set">boost::intrusive::set</classname> / <classname alt="boost::intrusive::multiset">boost::intrusive::multiset</classname> / <classname alt="boost::intrusive::set_base_hook">boost::intrusive::set_base_hook</classname> / <classname alt="boost::intrusive::set_member_hook">boost::intrusive::set_member_hook</classname></para>
</listitem><listitem><para><classname alt="boost::intrusive::avltree">boost::intrusive::avltree</classname> / <classname alt="boost::intrusive::avl_set">boost::intrusive::avl_set</classname> / <classname alt="boost::intrusive::avl_multiset">boost::intrusive::avl_multiset</classname> / <classname alt="boost::intrusive::avl_set_base_hook">boost::intrusive::avl_set_base_hook</classname> / <classname alt="boost::intrusive::avl_set_member_hook">boost::intrusive::avl_set_member_hook</classname></para>
</listitem><listitem><para><classname alt="boost::intrusive::splaytree">boost::intrusive::splaytree</classname> / <classname alt="boost::intrusive::splay_set">boost::intrusive::splay_set</classname> / <classname alt="boost::intrusive::splay_multiset">boost::intrusive::splay_multiset</classname></para>
</listitem><listitem><para><classname alt="boost::intrusive::sgtree">boost::intrusive::sgtree</classname> / <classname alt="boost::intrusive::sg_set">boost::intrusive::sg_set</classname> / <classname alt="boost::intrusive::sg_multiset">boost::intrusive::sg_multiset</classname></para>
</listitem><listitem><para><classname alt="boost::intrusive::treap">boost::intrusive::treap</classname> / <classname alt="boost::intrusive::treap_set">boost::intrusive::treap_set</classname> / <classname alt="boost::intrusive::treap_multiset">boost::intrusive::treap_multiset</classname></para>
</listitem><listitem><para><classname alt="boost::intrusive::hashtable">boost::intrusive::hashtable</classname> / <classname alt="boost::intrusive::unordered_set">boost::intrusive::unordered_set</classname> / <classname alt="boost::intrusive::unordered_multiset">boost::intrusive::unordered_multiset</classname> / <classname alt="boost::intrusive::unordered_set_base_hook">boost::intrusive::unordered_set_base_hook</classname> / <classname alt="boost::intrusive::unordered_set_member_hook">boost::intrusive::unordered_set_member_hook</classname> /</para>
</listitem><listitem><para><classname alt="boost::intrusive::any_base_hook">boost::intrusive::any_base_hook</classname> / <classname alt="boost::intrusive::any_member_hook">boost::intrusive::any_member_hook</classname></para>
</listitem></itemizedlist>
</para><para>It forward declares the following container or hook options:<itemizedlist>
<listitem><para><classname alt="boost::intrusive::constant_time_size">boost::intrusive::constant_time_size</classname> / <classname alt="boost::intrusive::size_type">boost::intrusive::size_type</classname> / <classname alt="boost::intrusive::compare">boost::intrusive::compare</classname> / <classname alt="boost::intrusive::equal">boost::intrusive::equal</classname></para>
</listitem><listitem><para><classname alt="boost::intrusive::floating_point">boost::intrusive::floating_point</classname> / <classname alt="boost::intrusive::priority">boost::intrusive::priority</classname> / <classname alt="boost::intrusive::hash">boost::intrusive::hash</classname></para>
</listitem><listitem><para><classname alt="boost::intrusive::value_traits">boost::intrusive::value_traits</classname> / <classname alt="boost::intrusive::member_hook">boost::intrusive::member_hook</classname> / <classname alt="boost::intrusive::function_hook">boost::intrusive::function_hook</classname> / <classname alt="boost::intrusive::base_hook">boost::intrusive::base_hook</classname></para>
</listitem><listitem><para><classname alt="boost::intrusive::void_pointer">boost::intrusive::void_pointer</classname> / <classname alt="boost::intrusive::tag">boost::intrusive::tag</classname> / <classname alt="boost::intrusive::link_mode">boost::intrusive::link_mode</classname></para>
</listitem><listitem><para><classname alt="boost::intrusive::optimize_size">boost::intrusive::optimize_size</classname> / <classname alt="boost::intrusive::linear">boost::intrusive::linear</classname> / <classname alt="boost::intrusive::cache_last">boost::intrusive::cache_last</classname></para>
</listitem><listitem><para><classname alt="boost::intrusive::bucket_traits">boost::intrusive::bucket_traits</classname> / <classname alt="boost::intrusive::store_hash">boost::intrusive::store_hash</classname> / <classname alt="boost::intrusive::optimize_multikey">boost::intrusive::optimize_multikey</classname></para>
</listitem><listitem><para><classname alt="boost::intrusive::power_2_buckets">boost::intrusive::power_2_buckets</classname> / <classname alt="boost::intrusive::cache_begin">boost::intrusive::cache_begin</classname> / <classname alt="boost::intrusive::compare_hash">boost::intrusive::compare_hash</classname> / <classname alt="boost::intrusive::incremental">boost::intrusive::incremental</classname></para>
</listitem></itemizedlist>
</para><para>It forward declares the following value traits utilities:<itemizedlist>
<listitem><para><classname alt="boost::intrusive::value_traits">boost::intrusive::value_traits</classname> / <classname alt="boost::intrusive::derivation_value_traits">boost::intrusive::derivation_value_traits</classname> / <classname alt="boost::intrusive::trivial_value_traits">boost::intrusive::trivial_value_traits</classname></para>
</listitem></itemizedlist>
</para><para>Finally it forward declares the following general purpose utilities:<itemizedlist>
<listitem><para><classname alt="boost::intrusive::pointer_plus_bits">boost::intrusive::pointer_plus_bits</classname> / boost::intrusive::priority_compare. </para>
</listitem></itemizedlist>
</para></header>
<header name="boost/intrusive/linear_slist_algorithms.hpp">
<namespace name="boost">
<namespace name="intrusive">
<class name="linear_slist_algorithms"><template>
      <template-type-parameter name="NodeTraits"/>
    </template><description><para><classname alt="boost::intrusive::linear_slist_algorithms">linear_slist_algorithms</classname> provides basic algorithms to manipulate nodes forming a linear singly linked list.</para><para><classname alt="boost::intrusive::linear_slist_algorithms">linear_slist_algorithms</classname> is configured with a NodeTraits class, which encapsulates the information about the node to be manipulated. NodeTraits must support the following interface:</para><para><emphasis role="bold">Typedefs</emphasis>:</para><para><computeroutput>node</computeroutput>: The type of the node that forms the linear list</para><para><computeroutput>node_ptr</computeroutput>: A pointer to a node</para><para><computeroutput>const_node_ptr</computeroutput>: A pointer to a const node</para><para><emphasis role="bold">Static functions</emphasis>:</para><para><computeroutput>static node_ptr get_next(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_next(node_ptr n, node_ptr next);</computeroutput> </para></description><typedef name="node"><type>NodeTraits::node</type></typedef>
<typedef name="node_ptr"><type>NodeTraits::node_ptr</type></typedef>
<typedef name="const_node_ptr"><type>NodeTraits::const_node_ptr</type></typedef>
<typedef name="node_traits"><type>NodeTraits</type></typedef>
<method-group name="public static functions">
<method name="init" specifiers="static"><type>void</type><parameter name="this_node"><paramtype>const node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an non-used list element, putting the next pointer to null: <computeroutput>NodeTraits::get_next(this_node) == node_ptr()</computeroutput></para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="unique" specifiers="static"><type>bool</type><parameter name="this_node"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this_node must be in a circular list or be an empty circular list.</para><para><emphasis role="bold">Effects</emphasis>: Returns true is "this_node" is the only node of a circular list: or it's a not inserted node: <computeroutput>return node_ptr() == NodeTraits::get_next(this_node) || NodeTraits::get_next(this_node) == this_node</computeroutput></para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="inited" specifiers="static"><type>bool</type><parameter name="this_node"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true is "this_node" has the same state as if it was inited using "init(node_ptr)"</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="unlink_after" specifiers="static"><type>void</type><parameter name="prev_node"><paramtype>const node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev_node must be in a circular list or be an empty circular list.</para><para><emphasis role="bold">Effects</emphasis>: Unlinks the next node of prev_node from the circular list.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="unlink_after" specifiers="static"><type>void</type><parameter name="prev_node"><paramtype>const node_ptr &amp;</paramtype></parameter><parameter name="last_node"><paramtype>const node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev_node and last_node must be in a circular list or be an empty circular list.</para><para><emphasis role="bold">Effects</emphasis>: Unlinks the range (prev_node, last_node) from the linear list.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="link_after" specifiers="static"><type>void</type><parameter name="prev_node"><paramtype>const node_ptr &amp;</paramtype></parameter><parameter name="this_node"><paramtype>const node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev_node must be a node of a linear list.</para><para><emphasis role="bold">Effects</emphasis>: Links this_node after prev_node in the linear list.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="transfer_after" specifiers="static"><type>void</type><parameter name="p"><paramtype>const node_ptr &amp;</paramtype></parameter><parameter name="b"><paramtype>const node_ptr &amp;</paramtype></parameter><parameter name="e"><paramtype>const node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: b and e must be nodes of the same linear list or an empty range. and p must be a node of a different linear list.</para><para><emphasis role="bold">Effects</emphasis>: Removes the nodes from (b, e] range from their linear list and inserts them after p in p's linear list.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="init_header" specifiers="static"><type>void</type><parameter name="this_node"><paramtype>const node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty list, making this_node the only node of the circular list: <computeroutput>NodeTraits::get_next(this_node) == this_node</computeroutput>.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="get_previous_node" specifiers="static"><type>node_ptr</type><parameter name="prev_init_node"><paramtype>const node_ptr &amp;</paramtype></parameter><parameter name="this_node"><paramtype>const node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this_node and prev_init_node must be in the same linear list.</para><para><emphasis role="bold">Effects</emphasis>: Returns the previous node of this_node in the linear list starting. the search from prev_init_node. The first node checked for equality is NodeTraits::get_next(prev_init_node).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements between prev_init_node and this_node.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="count" specifiers="static"><type>std::size_t</type><parameter name="this_node"><paramtype>const const_node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this_node must be in a linear list or be an empty linear list.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of nodes in a linear list. If the linear list is empty, returns 1.</para><para><emphasis role="bold">Complexity</emphasis>: Linear</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="swap_trailing_nodes" specifiers="static"><type>void</type><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><parameter name="other_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this_node and other_node must be nodes inserted in linear lists or be empty linear lists.</para><para><emphasis role="bold">Effects</emphasis>: Moves all the nodes previously chained after this_node after other_node and vice-versa.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="reverse" specifiers="static"><type>node_ptr</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Reverses the order of elements in the list.</para><para><emphasis role="bold">Returns</emphasis>: The new first node of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear to the contained elements. </para></description></method>
<method name="move_first_n_backwards" specifiers="static"><type>std::pair&lt; node_ptr, node_ptr &gt;</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><parameter name="n"><paramtype>std::size_t</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Moves the first n nodes starting at p to the end of the list.</para><para><emphasis role="bold">Returns</emphasis>: A pair containing the new first and last node of the list or if there has been any movement, a null pair if n leads to no movement.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements plus the number moved positions. </para></description></method>
<method name="move_first_n_forward" specifiers="static"><type>std::pair&lt; node_ptr, node_ptr &gt;</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><parameter name="n"><paramtype>std::size_t</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Moves the first n nodes starting at p to the beginning of the list.</para><para><emphasis role="bold">Returns</emphasis>: A pair containing the new first and last node of the list or if there has been any movement, a null pair if n leads to no movement.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements plus the number moved positions. </para></description></method>
</method-group>
</class>



















































</namespace>
</namespace>
</header>
<header name="boost/intrusive/link_mode.hpp">
<namespace name="boost">
<namespace name="intrusive">
<enum name="link_mode_type"><enumvalue name="normal_link"><description><para>If this linking policy is specified in a <classname alt="boost::intrusive::value_traits">value_traits</classname> class as the <classname alt="boost::intrusive::link_mode">link_mode</classname>, containers configured with such <classname alt="boost::intrusive::value_traits">value_traits</classname> won't set the hooks of the erased values to a default state. Containers also won't check that the hooks of the new values are default initialized. </para></description></enumvalue><enumvalue name="safe_link"><description><para>If this linking policy is specified in a <classname alt="boost::intrusive::value_traits">value_traits</classname> class as the <classname alt="boost::intrusive::link_mode">link_mode</classname>, containers configured with such <classname alt="boost::intrusive::value_traits">value_traits</classname> will set the hooks of the erased values to a default state. Containers also will check that the hooks of the new values are default initialized. </para></description></enumvalue><enumvalue name="auto_unlink"><description><para>Same as "safe_link" but the user type is an auto-unlink type, so the containers with constant-time size features won't be compatible with <classname alt="boost::intrusive::value_traits">value_traits</classname> configured with this policy. Containers also know that the a value can be silently erased from the container without using any function provided by the containers. </para></description></enumvalue><description><para>This enumeration defines the type of <classname alt="boost::intrusive::value_traits">value_traits</classname> that can be defined for Boost.Intrusive containers </para></description></enum>




















































</namespace>
</namespace>
</header>
<header name="boost/intrusive/list.hpp">
<namespace name="boost">
<namespace name="intrusive">
<class name="list"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>The class template list is an intrusive container that mimics most of the interface of std::list as described in the C++ standard.</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput> and <computeroutput>size_type&lt;&gt;</computeroutput>. </para></description><typedef name="value_traits"><type>ValueTraits</type></typedef>
<typedef name="pointer"><type>value_traits::pointer</type></typedef>
<typedef name="const_pointer"><type>value_traits::const_pointer</type></typedef>
<typedef name="value_type"><type><classname>pointer_traits</classname>&lt; pointer &gt;::element_type</type></typedef>
<typedef name="reference"><type><classname>pointer_traits</classname>&lt; pointer &gt;::reference</type></typedef>
<typedef name="const_reference"><type><classname>pointer_traits</classname>&lt; const_pointer &gt;::reference</type></typedef>
<typedef name="difference_type"><type><classname>pointer_traits</classname>&lt; pointer &gt;::difference_type</type></typedef>
<typedef name="size_type"><type>SizeType</type></typedef>
<typedef name="iterator"><type>list_iterator&lt; value_traits, false &gt;</type></typedef>
<typedef name="const_iterator"><type>list_iterator&lt; value_traits, true &gt;</type></typedef>
<typedef name="reverse_iterator"><type>boost::intrusive::reverse_iterator&lt; iterator &gt;</type></typedef>
<typedef name="const_reverse_iterator"><type>boost::intrusive::reverse_iterator&lt; const_iterator &gt;</type></typedef>
<typedef name="node_traits"><type>value_traits::node_traits</type></typedef>
<typedef name="node"><type>node_traits::node</type></typedef>
<typedef name="node_ptr"><type>node_traits::node_ptr</type></typedef>
<typedef name="const_node_ptr"><type>node_traits::const_node_ptr</type></typedef>
<typedef name="node_algorithms"><type><classname>circular_list_algorithms</classname>&lt; node_traits &gt;</type></typedef>
<typedef name="header_holder_type"><type><emphasis>unspecified</emphasis></type></typedef>
<data-member name="constant_time_size" specifiers="static"><type>const bool</type></data-member>
<data-member name="stateful_value_traits" specifiers="static"><type>const bool</type></data-member>
<data-member name="has_container_from_iterator" specifiers="static"><type>const bool</type></data-member>
<method-group name="public member functions">
<method name="push_back"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue.</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value in the back of the list. No copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method>
<method name="push_front"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue.</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value in the front of the list. No copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method>
<method name="pop_back"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases the last element of the list. No destructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased element. </para></description></method>
<method name="pop_back_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the last element of the list. No destructors are called. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased element. </para></description></method>
<method name="pop_front"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases the first element of the list. No destructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased element. </para></description></method>
<method name="pop_front_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the first element of the list. No destructors are called. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased element. </para></description></method>
<method name="front"><type>reference</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the first element of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="front" cv="const"><type>const_reference</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reference to the first element of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="back"><type>reference</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the last element of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="back" cv="const"><type>const_reference</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reference to the last element of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="begin"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element contained in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="end"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the end of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a constant iterator to the end of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rbegin"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="crbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rend"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="crend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of the elements contained in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements contained in the list. if constant-time size option is disabled. Constant time otherwise.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method>
<method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the list contains no elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method>
<method name="swap"><type>void</type><parameter name="other"><paramtype><classname>list</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the elements of x and *this.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method>
<method name="shift_backwards"><type>void</type><parameter name="n"><paramtype>size_type</paramtype><default>1</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Moves backwards all the elements, so that the first element becomes the second, the second becomes the third... the last element becomes the first one.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of shifts.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method>
<method name="shift_forward"><type>void</type><parameter name="n"><paramtype>size_type</paramtype><default>1</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Moves forward all the elements, so that the second element becomes the first, the third becomes the second... the first element becomes the last one.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of shifts.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="i"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed by i of the list. No destructors are called.</para><para><emphasis role="bold">Returns</emphasis>: the first element remaining beyond the removed element, or end() if no such element exists.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased element. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: b and e must be valid iterators to elements in *this.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element range pointed by b and e No destructors are called.</para><para><emphasis role="bold">Returns</emphasis>: the first element remaining beyond the removed elements, or end() if no such element exists.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of erased elements if it's a safe-mode or auto-unlink value, or constant-time size is enabled. Constant-time otherwise.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: b and e must be valid iterators to elements in *this. n must be distance(b, e).</para><para><emphasis role="bold">Effects</emphasis>: Erases the element range pointed by b and e No destructors are called.</para><para><emphasis role="bold">Returns</emphasis>: the first element remaining beyond the removed elements, or end() if no such element exists.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of erased elements if it's a safe-mode or auto-unlink value is enabled. Constant-time otherwise.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed by i of the list. No destructors are called. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Returns</emphasis>: the first element remaining beyond the removed element, or end() if no such element exists.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased element. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element range pointed by b and e No destructors are called. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: the first element remaining beyond the removed elements, or end() if no such element exists.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements erased.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="clear"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the container. No destructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements of the list. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. </para></description></method>
<method name="clear_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the container. No destructors are called. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements of the list.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>list</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws. Basic guarantee. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype><classname>list</classname> &amp;&amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(reference) and inserts them on *this.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws. Basic guarantee. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value before the position pointed by p.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the inserted element.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time. No copy constructors are called.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method>
<method name="insert"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type and p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Inserts the range pointed by b and e before the position p. No copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements inserted.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method>
<method name="assign"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Clears the list and inserts the range pointed by b and e. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements inserted plus linear to the elements contained in the list if it's a safe-mode or auto-unlink value. Linear to the number of elements inserted in the list otherwise.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. </para></description></method>
<method name="dispose_and_assign"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Clears the list and inserts the range pointed by b and e. No destructors or copy constructors are called. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements inserted plus linear to the elements contained in the list.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. </para></description></method>
<method name="splice"><type>void</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><classname>list</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Transfers all the elements of list x to this list, before the the element pointed by p. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method>
<method name="splice"><type>void</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><classname>list</classname> &amp;</paramtype></parameter><parameter name="new_ele"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this. new_ele must point to an element contained in list x.</para><para><emphasis role="bold">Effects</emphasis>: Transfers the value pointed by new_ele, from list x to this list, before the element pointed by p. No destructors or copy constructors are called. If p == new_ele or p == ++new_ele, this function is a null operation.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method>
<method name="splice"><type>void</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><classname>list</classname> &amp;</paramtype></parameter><parameter name="f"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this. f and e must point to elements contained in list x.</para><para><emphasis role="bold">Effects</emphasis>: Transfers the range pointed by f and e from list x to this list, before the element pointed by p. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements transferred if constant-time size option is enabled. Constant-time otherwise.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method>
<method name="splice"><type>void</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><classname>list</classname> &amp;</paramtype></parameter><parameter name="f"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this. f and e must point to elements contained in list x. n == distance(f, e)</para><para><emphasis role="bold">Effects</emphasis>: Transfers the range pointed by f and e from list x to this list, before the element pointed by p. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method>
<method name="sort"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: This function sorts the list *this according to std::less&lt;value_type&gt;. The sort is stable, that is, the relative order of equivalent elements is preserved.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or std::less&lt;value_type&gt; throws. Basic guarantee.</para><para><emphasis role="bold">Notes</emphasis>: Iterators and references are not invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: The number of comparisons is approximately N log N, where N is the list's size. </para></description></method>
<method name="sort"><type>void</type><template>
          <template-type-parameter name="Predicate"/>
        </template><parameter name="p"><paramtype>Predicate</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a comparison function that induces a strict weak ordering</para><para><emphasis role="bold">Effects</emphasis>: This function sorts the list *this according to p. The sort is stable, that is, the relative order of equivalent elements is preserved.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the predicate throws. Basic guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This won't throw if list_base_hook&lt;&gt; or <classname alt="boost::intrusive::list_member_hook">list_member_hook</classname> are used. Iterators and references are not invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: The number of comparisons is approximately N log N, where N is the list's size. </para></description></method>
<method name="merge"><type>void</type><parameter name="x"><paramtype><classname>list</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: This function removes all of x's elements and inserts them in order into *this according to std::less&lt;value_type&gt;. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x.</para><para><emphasis role="bold">Throws</emphasis>: If std::less&lt;value_type&gt; throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear time: it performs at most size() + x.size() - 1 comparisons.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="Predicate"/>
        </template><parameter name="x"><paramtype><classname>list</classname> &amp;</paramtype></parameter><parameter name="p"><paramtype>Predicate</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a comparison function that induces a strict weak ordering and both *this and x must be sorted according to that ordering The lists x and *this must be distinct.</para><para><emphasis role="bold">Effects</emphasis>: This function removes all of x's elements and inserts them in order into *this. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x.</para><para><emphasis role="bold">Throws</emphasis>: If the predicate throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear time: it performs at most size() + x.size() - 1 comparisons.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated. </para></description></method>
<method name="reverse"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Reverses the order of elements in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear time.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated </para></description></method>
<method name="remove"><type>void</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Removes all the elements that compare equal to value. No destructors are called.</para><para><emphasis role="bold">Throws</emphasis>: If std::equal_to&lt;value_type&gt; throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time. It performs exactly size() comparisons for equality.</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method>
<method name="remove_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="value"><paramtype>const_reference</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Removes all the elements that compare equal to value. Disposer::operator()(pointer) is called for every removed element.</para><para><emphasis role="bold">Throws</emphasis>: If std::equal_to&lt;value_type&gt; throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time. It performs exactly size() comparisons for equality.</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method>
<method name="remove_if"><type>void</type><template>
          <template-type-parameter name="Pred"/>
        </template><parameter name="pred"><paramtype>Pred</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Removes all the elements for which a specified predicate is satisfied. No destructors are called.</para><para><emphasis role="bold">Throws</emphasis>: If pred throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time. It performs exactly size() calls to the predicate.</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method>
<method name="remove_and_dispose_if"><type>void</type><template>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="pred"><paramtype>Pred</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Removes all the elements for which a specified predicate is satisfied. Disposer::operator()(pointer) is called for every removed element.</para><para><emphasis role="bold">Throws</emphasis>: If pred throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time. It performs exactly size() comparisons for equality.</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method>
<method name="unique"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes adjacent duplicate elements or adjacent elements that are equal from the list. No destructors are called.</para><para><emphasis role="bold">Throws</emphasis>: If std::equal_to&lt;value_type throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time (size()-1 comparisons calls to pred()).</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method>
<method name="unique"><type>void</type><template>
          <template-type-parameter name="BinaryPredicate"/>
        </template><parameter name="pred"><paramtype>BinaryPredicate</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Removes adjacent duplicate elements or adjacent elements that satisfy some binary predicate from the list. No destructors are called.</para><para><emphasis role="bold">Throws</emphasis>: If pred throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time (size()-1 comparisons equality comparisons).</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method>
<method name="unique_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Removes adjacent duplicate elements or adjacent elements that are equal from the list. Disposer::operator()(pointer) is called for every removed element.</para><para><emphasis role="bold">Throws</emphasis>: If std::equal_to&lt;value_type throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time (size()-1) comparisons equality comparisons.</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method>
<method name="unique_and_dispose"><type>void</type><template>
          <template-type-parameter name="BinaryPredicate"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="pred"><paramtype>BinaryPredicate</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Removes adjacent duplicate elements or adjacent elements that satisfy some binary predicate from the list. Disposer::operator()(pointer) is called for every removed element.</para><para><emphasis role="bold">Throws</emphasis>: If pred throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time (size()-1) comparisons equality comparisons.</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method>
<method name="iterator_to"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be a reference to a value inserted in a list.</para><para><emphasis role="bold">Effects</emphasis>: This function returns a const_iterator pointing to the element</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated. </para></description></method>
<method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be a const reference to a value inserted in a list.</para><para><emphasis role="bold">Effects</emphasis>: This function returns an iterator pointing to the element.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated. </para></description></method>
<method name="check" cv="const"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Asserts the integrity of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time.</para><para><emphasis role="bold">Note</emphasis>: The method has no effect when asserts are turned off (e.g., with NDEBUG). Experimental function, interface might change in future versions. </para></description></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: constructs an empty list.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks). </para></description></constructor>
<constructor specifiers="explicit"><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: constructs an empty list.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks). </para></description></constructor>
<constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Constructs a list equal to the range [first,last).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in distance(b, e). No copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks). </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>list</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a container moving resources from another container. Internal value traits are move constructed and nodes belonging to x (except the node representing the "end") are linked to *this.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node's move constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the move constructor of value traits throws. </para></description></constructor>
<copy-assignment><type><classname>list</classname> &amp;</type><parameter name="x"><paramtype><classname>list</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to swap </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: If it's not a safe-mode or an auto-unlink value_type the destructor does nothing (ie. no code is generated). Otherwise it detaches all elements from this. In this case the objects in the list are not deleted (i.e. no destructors are called), but the hooks according to the ValueTraits template parameter are set to their default value.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the list, if it's a safe-mode or auto-unlink value . Otherwise constant. </para></description></destructor>
<method-group name="public static functions">
<method name="container_from_end_iterator" specifiers="static"><type><classname>list</classname> &amp;</type><parameter name="end_iterator"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of list.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the list associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_end_iterator" specifiers="static"><type>const <classname>list</classname> &amp;</type><parameter name="end_iterator"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end const_iterator of list.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the list associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be a reference to a value inserted in a list.</para><para><emphasis role="bold">Effects</emphasis>: This function returns a const_iterator pointing to the element</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated. This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be a const reference to a value inserted in a list.</para><para><emphasis role="bold">Effects</emphasis>: This function returns an iterator pointing to the element.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated. This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
</method-group>
</class><struct name="make_list"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>list</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct>



















































</namespace>
</namespace>
</header>
<header name="boost/intrusive/list_hook.hpp">
<namespace name="boost">
<namespace name="intrusive">
<class name="list_base_hook"><template>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><inherit access="public">make_list_base_hook::type&lt; O1, O2, O3 &gt;</inherit><description><para>Derive a class from this hook in order to store objects of that class in an list.</para><para>The hook admits the following options: <computeroutput>tag&lt;&gt;</computeroutput>, <computeroutput>void_pointer&lt;&gt;</computeroutput> and <computeroutput>link_mode&lt;&gt;</computeroutput>.</para><para><computeroutput>tag&lt;&gt;</computeroutput> defines a tag to identify the node. The same tag value can be used in different classes, but if a class is derived from more than one <computeroutput><classname alt="boost::intrusive::list_base_hook">list_base_hook</classname></computeroutput>, then each <computeroutput><classname alt="boost::intrusive::list_base_hook">list_base_hook</classname></computeroutput> needs its unique tag.</para><para><computeroutput>link_mode&lt;&gt;</computeroutput> will specify the linking mode of the hook (<computeroutput>normal_link</computeroutput>, <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput>).</para><para><computeroutput>void_pointer&lt;&gt;</computeroutput> is the pointer type that will be used internally in the hook and the container configured to use this hook. </para></description><method-group name="public member functions">
<method name="swap_nodes"><type>void</type><parameter name="other"><paramtype><classname>list_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swapping two nodes swaps the position of the elements related to those nodes in one or two containers. That is, if the node this is part of the element e1, the node x is part of the element e2 and both elements are included in the containers s1 and s2, then after the swap-operation e1 is in s2 at the position of e2 and e2 is in s1 at the position of e1. If one element is not in a container, then after the swap-operation the other element is not in a container. Iterators to e1 and e2 related to those nodes are invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="is_linked" cv="const"><type>bool</type><description><para><emphasis role="bold">Precondition</emphasis>: <classname alt="boost::intrusive::link_mode">link_mode</classname> must be <computeroutput>safe_link</computeroutput> or <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: true, if the node belongs to a container, false otherwise. This function can be used to test whether <computeroutput>list::iterator_to</computeroutput> will return a valid iterator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method>
<method name="unlink"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the node if it's inserted in a container. This function is only allowed if <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></constructor>
<constructor><parameter name=""><paramtype>const <classname>list_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing a copy-constructor makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></constructor>
<copy-assignment><type><classname>list_base_hook</classname> &amp;</type><parameter name=""><paramtype>const <classname>list_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Empty function. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing an assignment operator makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>normal_link</computeroutput>, the destructor does nothing (ie. no code is generated). If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>safe_link</computeroutput> and the object is stored in an list an assertion is raised. If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> and <computeroutput>is_linked()</computeroutput> is true, the node is unlinked.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor>
</class><class name="list_member_hook"><template>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><inherit access="public">make_list_member_hook::type&lt; O1, O2, O3 &gt;</inherit><description><para>Store this hook in a class to be inserted in an list.</para><para>The hook admits the following options: <computeroutput>void_pointer&lt;&gt;</computeroutput> and <computeroutput>link_mode&lt;&gt;</computeroutput>.</para><para><computeroutput>link_mode&lt;&gt;</computeroutput> will specify the linking mode of the hook (<computeroutput>normal_link</computeroutput>, <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput>).</para><para><computeroutput>void_pointer&lt;&gt;</computeroutput> is the pointer type that will be used internally in the hook and the container configured to use this hook. </para></description><method-group name="public member functions">
<method name="swap_nodes"><type>void</type><parameter name="other"><paramtype><classname>list_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swapping two nodes swaps the position of the elements related to those nodes in one or two containers. That is, if the node this is part of the element e1, the node x is part of the element e2 and both elements are included in the containers s1 and s2, then after the swap-operation e1 is in s2 at the position of e2 and e2 is in s1 at the position of e1. If one element is not in a container, then after the swap-operation the other element is not in a container. Iterators to e1 and e2 related to those nodes are invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="is_linked" cv="const"><type>bool</type><description><para><emphasis role="bold">Precondition</emphasis>: <classname alt="boost::intrusive::link_mode">link_mode</classname> must be <computeroutput>safe_link</computeroutput> or <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: true, if the node belongs to a container, false otherwise. This function can be used to test whether <computeroutput>list::iterator_to</computeroutput> will return a valid iterator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method>
<method name="unlink"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the node if it's inserted in a container. This function is only allowed if <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></constructor>
<constructor><parameter name=""><paramtype>const <classname>list_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing a copy-constructor makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></constructor>
<copy-assignment><type><classname>list_member_hook</classname> &amp;</type><parameter name=""><paramtype>const <classname>list_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Empty function. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing an assignment operator makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>normal_link</computeroutput>, the destructor does nothing (ie. no code is generated). If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>safe_link</computeroutput> and the object is stored in an list an assertion is raised. If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> and <computeroutput>is_linked()</computeroutput> is true, the node is unlinked.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor>
</class><struct name="make_list_base_hook"><template>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput><computeroutput><classname alt="boost::intrusive::list_base_hook">list_base_hook</classname></computeroutput> that</computeroutput> yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct><struct name="make_list_member_hook"><template>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput><computeroutput><classname alt="boost::intrusive::list_member_hook">list_member_hook</classname></computeroutput> that</computeroutput> yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct>



















































</namespace>
</namespace>
</header>
<header name="boost/intrusive/member_value_traits.hpp">
<namespace name="boost">
<namespace name="intrusive">
<struct name="member_value_traits"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="NodeTraits"/>
      <template-nontype-parameter name="PtrToMember"><type>typename NodeTraits::node T::*</type></template-nontype-parameter>
      <template-nontype-parameter name="LinkMode"><type>link_mode_type</type><default>safe_link</default></template-nontype-parameter>
    </template><description><para>This value traits template is used to create value traits from user defined node traits where value_traits::value_type will store a node_traits::node </para></description><typedef name="node_traits"><type>NodeTraits</type></typedef>
<typedef name="value_type"><type>T</type></typedef>
<typedef name="node"><type>node_traits::node</type></typedef>
<typedef name="node_ptr"><type>node_traits::node_ptr</type></typedef>
<typedef name="const_node_ptr"><type>node_traits::const_node_ptr</type></typedef>
<typedef name="node_ptr_traits"><type><classname>pointer_traits</classname>&lt; node_ptr &gt;</type></typedef>
<typedef name="pointer"><type><classname>pointer_traits</classname>&lt; node_ptr &gt;::template rebind_pointer&lt; T &gt;::type</type></typedef>
<typedef name="const_pointer"><type><classname>pointer_traits</classname>&lt; node_ptr &gt;::template rebind_pointer&lt; const T &gt;::type</type></typedef>
<typedef name="reference"><type>value_type &amp;</type></typedef>
<typedef name="const_reference"><type>const value_type &amp;</type></typedef>
<data-member name="link_mode" specifiers="static"><type>const link_mode_type</type></data-member>
<method-group name="public static functions">
<method name="to_node_ptr" specifiers="static"><type>node_ptr</type><parameter name="value"><paramtype>reference</paramtype></parameter></method>
<method name="to_node_ptr" specifiers="static"><type>const_node_ptr</type><parameter name="value"><paramtype>const_reference</paramtype></parameter></method>
<method name="to_value_ptr" specifiers="static"><type>pointer</type><parameter name="n"><paramtype>const node_ptr &amp;</paramtype></parameter></method>
<method name="to_value_ptr" specifiers="static"><type>const_pointer</type><parameter name="n"><paramtype>const const_node_ptr &amp;</paramtype></parameter></method>
</method-group>
</struct>



















































</namespace>
</namespace>
</header>
<header name="boost/intrusive/options.hpp">
<namespace name="boost">
<namespace name="intrusive">
<struct name="base_hook"><template>
      <template-type-parameter name="BaseHook"/>
    </template><description><para>This option setter specifies that the container must use the specified base hook </para></description></struct><struct name="bucket_traits"><template>
      <template-type-parameter name="BucketTraits"/>
    </template><description><para>This option setter specifies the bucket traits class for unordered associative containers. When this option is specified, instead of using the default bucket traits, a user defined holder will be defined </para></description></struct><struct name="cache_begin"><template>
      <template-nontype-parameter name="Enabled"><type>bool</type></template-nontype-parameter>
    </template><description><para>This option setter specifies if the container will cache a pointer to the first non-empty bucket so that begin() is always constant-time. This is specially helpful when we can have containers with a few elements but with big bucket arrays (that is, hashtables with low load factors). </para></description></struct><struct name="cache_last"><template>
      <template-nontype-parameter name="Enabled"><type>bool</type></template-nontype-parameter>
    </template><description><para>If true, slist also stores a pointer to the last element of the singly linked list. This allows O(1) swap and splice_after(iterator, slist &amp;) for circular slists and makes possible new functions like push_back(reference) and back(). </para></description></struct><struct name="compare"><template>
      <template-type-parameter name="Compare"/>
    </template><description><para>This option setter specifies the strict weak ordering comparison functor for the value type </para></description></struct><struct name="compare_hash"><template>
      <template-nontype-parameter name="Enabled"><type>bool</type></template-nontype-parameter>
    </template><description><para>This option setter specifies if the container will compare the hash value before comparing objects. This option can't be specified if store_hash&lt;&gt; is not true. This is specially helpful when we have containers with a high load factor. and the comparison function is much more expensive that comparing already stored hash values. </para></description></struct><struct name="constant_time_size"><template>
      <template-nontype-parameter name="Enabled"><type>bool</type></template-nontype-parameter>
    </template><description><para>This option setter specifies if the intrusive container stores its size as a member to obtain constant-time size() member. </para></description></struct><struct name="equal"><template>
      <template-type-parameter name="Equal"/>
    </template><description><para>This option setter specifies the equality functor for the value type </para></description></struct><struct name="floating_point"><template>
      <template-nontype-parameter name="Enabled"><type>bool</type></template-nontype-parameter>
    </template><description><para>This option setter for scapegoat containers specifies if the intrusive scapegoat container should use a non-variable alpha value that does not need floating-point operations.</para><para>If activated, the fixed alpha value is 1/sqrt(2). This option also saves some space in the container since the alpha value and some additional data does not need to be stored in the container.</para><para>If the user only needs an alpha value near 1/sqrt(2), this option also improves performance since avoids logarithm and division operations when rebalancing the tree. </para></description></struct><struct name="function_hook"><template>
      <template-type-parameter name="Functor"/>
    </template><description><para>This option setter specifies the function object that will be used to convert between values to be inserted in a container and the hook to be used for that purpose. </para></description></struct><struct name="hash"><template>
      <template-type-parameter name="Hash"/>
    </template><description><para>This option setter specifies the hash functor for the value type </para></description></struct><struct name="header_holder_type"><template>
      <template-type-parameter name="HeaderHolder"/>
    </template><purpose>This option setter specifies a container header holder type. </purpose></struct><struct name="incremental"><template>
      <template-nontype-parameter name="Enabled"><type>bool</type></template-nontype-parameter>
    </template><description><para>This option setter specifies if the hash container will use incremental hashing. With incremental hashing the cost of hash table expansion is spread out across each hash table insertion operation, as opposed to be incurred all at once. Therefore linear hashing is well suited for interactive applications or real-time appplications where the worst-case insertion time of non-incremental hash containers (rehashing the whole bucket array) is not admisible. </para></description></struct><struct name="key_of_value"><template>
      <template-type-parameter name="KeyOfValue"/>
    </template><description><para>This option setter specifies a function object that specifies the type of the key of an associative container and an operator to obtain it from a value type.</para><para>This function object must the define a <computeroutput>type</computeroutput> member typedef and a member with signature <computeroutput>type [const&amp;] operator()(const value_type &amp;) const</computeroutput> that will return the key from a value_type of an associative container </para></description></struct><struct name="linear"><template>
      <template-nontype-parameter name="Enabled"><type>bool</type></template-nontype-parameter>
    </template><description><para>This option setter specifies if the slist container should use a linear implementation instead of a circular one. </para></description></struct><struct name="link_mode"><template>
      <template-nontype-parameter name="LinkType"><type>link_mode_type</type></template-nontype-parameter>
    </template><description><para>This option setter specifies the link mode (normal_link, safe_link or auto_unlink) </para></description></struct><struct name="member_hook"><template>
      <template-type-parameter name="Parent"/>
      <template-type-parameter name="MemberHook"/>
      <template-nontype-parameter name="PtrToMember"><type>MemberHook Parent::*</type></template-nontype-parameter>
    </template><description><para>This option setter specifies the member hook the container must use. </para></description></struct><struct name="optimize_multikey"><template>
      <template-nontype-parameter name="Enabled"><type>bool</type></template-nontype-parameter>
    </template><description><para>This option setter specifies if the unordered hook should offer room to store another link to another node with the same key. Storing this link will speed up lookups and insertions on <classname alt="boost::intrusive::unordered_multiset">unordered_multiset</classname> containers with a great number of elements with the same key. </para></description></struct><struct name="optimize_size"><template>
      <template-nontype-parameter name="Enabled"><type>bool</type></template-nontype-parameter>
    </template><description><para>This option setter specifies if the hook should be optimized for size instead of for speed. </para></description></struct><struct name="power_2_buckets"><template>
      <template-nontype-parameter name="Enabled"><type>bool</type></template-nontype-parameter>
    </template><description><para>This option setter specifies if the bucket array will be always power of two. This allows using masks instead of the default modulo operation to determine the bucket number from the hash value, leading to better performance. In debug mode, if power of two buckets mode is activated, the bucket length will be checked with assertions. </para></description></struct><struct name="priority"><template>
      <template-type-parameter name="Priority"/>
    </template><description><para>This option setter specifies the priority comparison functor for the value type </para></description></struct><struct name="priority_of_value"><template>
      <template-type-parameter name="PrioOfValue"/>
    </template><description><para>This option setter specifies a function object that specifies the type of the priority of a treap container and an operator to obtain it from a value type.</para><para>This function object must the define a <computeroutput>type</computeroutput> member typedef and a member with signature <computeroutput>type [const&amp;] operator()(const value_type &amp;) const</computeroutput> that will return the priority from a value_type of a treap container </para></description></struct><struct name="size_type"><template>
      <template-type-parameter name="SizeType"/>
    </template><description><para>This option setter specifies the type that the container will use to store its size. </para></description></struct><struct name="store_hash"><template>
      <template-nontype-parameter name="Enabled"><type>bool</type></template-nontype-parameter>
    </template><description><para>This option setter specifies if the unordered hook should offer room to store the hash value. Storing the hash in the hook will speed up rehashing processes in applications where rehashing is frequent, rehashing might throw or the value is heavy to hash. </para></description></struct><struct name="tag"><template>
      <template-type-parameter name="Tag"/>
    </template><description><para>This option setter specifies the type of the tag of a base hook. A type cannot have two base hooks of the same type, so a tag can be used to differentiate two base hooks with otherwise same type </para></description></struct><struct name="value_traits"><template>
      <template-type-parameter name="ValueTraits"/>
    </template><description><para>This option setter specifies the relationship between the type to be managed by the container (the value type) and the node to be used in the node algorithms. It also specifies the linking policy. </para></description></struct><struct name="void_pointer"><template>
      <template-type-parameter name="VoidPointer"/>
    </template><description><para>This option setter specifies the type of a void pointer. This will instruct the hook to use this type of pointer instead of the default one </para></description></struct>



















































</namespace>
</namespace>
</header>
<header name="boost/intrusive/pack_options.hpp">
<namespace name="boost">
<namespace name="intrusive">
<struct name="pack_options"><template>
      <template-type-parameter name="DefaultOptions"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>This class is a utility that takes:<itemizedlist>
<listitem><para>a default options class defining initial static constant and typedefs</para>
</listitem><listitem><para>several options defined with BOOST_INTRUSIVE_OPTION_CONSTANT and BOOST_INTRUSIVE_OPTION_TYPE</para>
</listitem></itemizedlist>
</para><para>and packs them together in a new type that defines all options as member typedefs or static constant values. Given options of form:</para><para><programlisting language="c++">BOOST_INTRUSIVE_OPTION_TYPE(my_pointer, VoidPointer, VoidPointer, my_pointer_type)
BOOST_INTRUSIVE_OPTION_CONSTANT(incremental, bool, Enabled, is_incremental)
</programlisting></para><para>the following expression</para><para><programlisting language="c++">struct default_options
{
  typedef long      int_type;
  static const int  int_constant = -1;
};

pack_options&lt; default_options, my_pointer&lt;void*&gt;, incremental&lt;true&gt; &gt;::type
</programlisting></para><para>will create a type that will contain the following typedefs/constants</para><para><programlisting language="c++">struct unspecified_type
{
   //Default options
   typedef long      int_type;
   static const int  int_constant  = -1;

   //Packed options (will ovewrite any default option)
   typedef void*     my_pointer_type;
   static const bool is_incremental = true;
};
</programlisting></para><para>If an option is specified in the default options argument and later redefined as an option, the last definition will prevail. </para></description><typedef name="type"><type>unspecified_type</type></typedef>
</struct>



















































</namespace>
</namespace>
<macro name="BOOST_INTRUSIVE_OPTION_TYPE" kind="functionlike"><macro-parameter name="OPTION_NAME"/><macro-parameter name="TYPE"/><macro-parameter name="TYPEDEF_EXPR"/><macro-parameter name="TYPEDEF_NAME"/><description><para>Defines an option class of name OPTION_NAME that can be used to specify a type of type TYPE...</para><para><programlisting language="c++">struct OPTION_NAME&lt;class TYPE&gt;
{  unspecified_content  };
</programlisting></para><para>...that after being combined with <computeroutput><classname alt="boost::intrusive::pack_options">boost::intrusive::pack_options</classname></computeroutput>, will typedef TYPE as a typedef of name TYPEDEF_NAME. Example:</para><para><programlisting language="c++">//[includes and namespaces omitted for brevity]

//This macro will create the following class:
//    template&lt;class VoidPointer&gt;
//    struct my_pointer
//    { unspecified_content };
BOOST_INTRUSIVE_OPTION_TYPE(my_pointer, VoidPointer, boost::remove_pointer&lt;VoidPointer&gt;::type, my_pointer_type)

struct empty_default{};

typedef pack_options&lt; empty_default, typename my_pointer&lt;void*&gt; &gt;::type::my_pointer_type type;

BOOST_STATIC_ASSERT(( boost::is_same&lt;type, void&gt;::value ));
</programlisting> </para></description></macro>
<macro name="BOOST_INTRUSIVE_OPTION_CONSTANT" kind="functionlike"><macro-parameter name="OPTION_NAME"/><macro-parameter name="TYPE"/><macro-parameter name="VALUE"/><macro-parameter name="CONSTANT_NAME"/><description><para>Defines an option class of name OPTION_NAME that can be used to specify a constant of type TYPE with value VALUE...</para><para><programlisting language="c++">struct OPTION_NAME&lt;TYPE VALUE&gt;
{  unspecified_content  };
</programlisting></para><para>...that after being combined with <computeroutput><classname alt="boost::intrusive::pack_options">boost::intrusive::pack_options</classname></computeroutput>, will contain a CONSTANT_NAME static constant of value VALUE. Example:</para><para><programlisting language="c++">//[includes and namespaces omitted for brevity]

//This macro will create the following class:
//    template&lt;bool Enabled&gt;
//    struct incremental
//    { unspecified_content };
BOOST_INTRUSIVE_OPTION_CONSTANT(incremental, bool, Enabled, is_incremental)

struct empty_default{};

const bool is_incremental = pack_options&lt; empty_default, incremental&lt;true&gt; &gt;::type::is_incremental;

BOOST_STATIC_ASSERT(( is_incremental == true ));
</programlisting> </para></description></macro>
</header>
<header name="boost/intrusive/parent_from_member.hpp">
<namespace name="boost">
<namespace name="intrusive">






























<function name="get_parent_from_member"><type>Parent *</type><template>
          <template-type-parameter name="Parent"/>
          <template-type-parameter name="Member"/>
        </template><parameter name="member"><paramtype>Member *</paramtype></parameter><parameter name="ptr_to_member"><paramtype>const Member Parent::*</paramtype></parameter><description><para>Given a pointer to a member and its corresponding pointer to data member, this function returns the pointer of the parent containing that member. Note: this function does not work with pointer to members that rely on virtual inheritance. </para></description></function>
<function name="get_parent_from_member"><type>const Parent *</type><template>
          <template-type-parameter name="Parent"/>
          <template-type-parameter name="Member"/>
        </template><parameter name="member"><paramtype>const Member *</paramtype></parameter><parameter name="ptr_to_member"><paramtype>const Member Parent::*</paramtype></parameter><description><para>Given a const pointer to a member and its corresponding const pointer to data member, this function returns the const pointer of the parent containing that member. Note: this function does not work with pointer to members that rely on virtual inheritance. </para></description></function>




















</namespace>
</namespace>
</header>
<header name="boost/intrusive/pointer_plus_bits.hpp">
<namespace name="boost">
<namespace name="intrusive">
<struct name="max_pointer_plus_bits"><template>
      <template-type-parameter name="VoidPointer"/>
      <template-nontype-parameter name="Alignment"><type>std::size_t</type></template-nontype-parameter>
    </template><description><para>This trait class is used to know if a pointer can embed extra bits of information if it's going to be used to point to objects with an alignment of "Alignment" bytes. </para></description><data-member name="value" specifiers="static"><type>const std::size_t</type></data-member>
</struct><struct-specialization name="max_pointer_plus_bits"><template>
      <template-nontype-parameter name="Alignment"><type>std::size_t</type></template-nontype-parameter>
    </template><specialization><template-arg>void *</template-arg><template-arg>Alignment</template-arg></specialization><description><para>This is a specialization for raw pointers. Raw pointers can embed extra bits in the lower bits if the alignment is multiple of 2pow(NumBits). </para></description><data-member name="value" specifiers="static"><type>const std::size_t</type></data-member>
</struct-specialization><struct name="pointer_plus_bits"><template>
      <template-type-parameter name="Pointer"/>
      <template-nontype-parameter name="NumBits"><type>std::size_t</type></template-nontype-parameter>
    </template><description><para>This is class that is supposed to have static methods to embed extra bits of information in a pointer. This is a declaration and there is no default implementation, because operations to embed the bits change with every pointer type.</para><para>An implementation that detects that a pointer type whose has_pointer_plus_bits&lt;&gt;::value is non-zero can make use of these operations to embed the bits in the pointer. </para></description></struct><struct-specialization name="pointer_plus_bits"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="NumBits"><type>std::size_t</type></template-nontype-parameter>
    </template><specialization><template-arg>T *</template-arg><template-arg>NumBits</template-arg></specialization><description><para>This is the specialization to embed extra bits of information in a raw pointer. The extra bits are stored in the lower bits of the pointer. </para></description><typedef name="pointer"><type>T *</type></typedef>
<data-member name="Mask" specifiers="static"><type>const uintptr_t</type></data-member>
<method-group name="public static functions">
<method name="get_pointer" specifiers="static"><type>pointer</type><parameter name="n"><paramtype>pointer</paramtype></parameter></method>
<method name="set_pointer" specifiers="static"><type>void</type><parameter name="n"><paramtype>pointer &amp;</paramtype></parameter><parameter name="p"><paramtype>pointer</paramtype></parameter></method>
<method name="get_bits" specifiers="static"><type>std::size_t</type><parameter name="n"><paramtype>pointer</paramtype></parameter></method>
<method name="set_bits" specifiers="static"><type>void</type><parameter name="n"><paramtype>pointer &amp;</paramtype></parameter><parameter name="c"><paramtype>std::size_t</paramtype></parameter></method>
</method-group>
</struct-specialization>



















































</namespace>
</namespace>
</header>
<header name="boost/intrusive/pointer_rebind.hpp">
<namespace name="boost">
<namespace name="intrusive">
<struct name="pointer_has_rebind"><template>
      <template-type-parameter name="Ptr"/>
      <template-type-parameter name="U"/>
    </template><struct name="any"><template>
      <template-type-parameter name="V"/>
    </template><method-group name="public member functions">
</method-group>
<constructor><parameter name=""><paramtype>const V &amp;</paramtype></parameter></constructor>
</struct><data-member name="value" specifiers="static"><type>const bool</type></data-member>
<method-group name="public static functions">
<method name="test" specifiers="static"><type>char</type><template>
          <template-type-parameter name="X"/>
        </template><parameter name=""><paramtype>int</paramtype></parameter><parameter name=""><paramtype>typename X::template rebind&lt; U &gt; *</paramtype></parameter></method>
<method name="test" specifiers="static"><type>int</type><template>
          <template-type-parameter name="X"/>
        </template><parameter name=""><paramtype>any&lt; int &gt;</paramtype></parameter><parameter name=""><paramtype>void *</paramtype></parameter></method>
</method-group>
</struct><struct name="pointer_has_rebind_other"><template>
      <template-type-parameter name="Ptr"/>
      <template-type-parameter name="U"/>
    </template><struct name="any"><template>
      <template-type-parameter name="V"/>
    </template><method-group name="public member functions">
</method-group>
<constructor><parameter name=""><paramtype>const V &amp;</paramtype></parameter></constructor>
</struct><data-member name="value" specifiers="static"><type>const bool</type></data-member>
<method-group name="public static functions">
<method name="test" specifiers="static"><type>char</type><template>
          <template-type-parameter name="X"/>
        </template><parameter name=""><paramtype>int</paramtype></parameter><parameter name=""><paramtype>typename X::template rebind&lt; U &gt;::other *</paramtype></parameter></method>
<method name="test" specifiers="static"><type>int</type><template>
          <template-type-parameter name="X"/>
        </template><parameter name=""><paramtype>any&lt; int &gt;</paramtype></parameter><parameter name=""><paramtype>void *</paramtype></parameter></method>
</method-group>
</struct><struct name="pointer_rebind"><template>
      <template-type-parameter name="Ptr"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::intrusive::pointer_rebinder&lt; Ptr, U, pointer_rebind_mode&lt; Ptr, U &gt;::mode &gt;</inherit><purpose>defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) </purpose></struct><struct-specialization name="pointer_rebind"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><specialization><template-arg>T *</template-arg><template-arg>U</template-arg></specialization><typedef name="type"><type>U *</type></typedef>
</struct-specialization><struct name="pointer_rebind_mode"><template>
      <template-type-parameter name="Ptr"/>
      <template-type-parameter name="U"/>
    </template><data-member name="rebind" specifiers="static"><type>const unsigned int</type></data-member>
<data-member name="rebind_other" specifiers="static"><type>const unsigned int</type></data-member>
<data-member name="mode" specifiers="static"><type>const unsigned int</type></data-member>
</struct><struct name="pointer_rebinder"><template>
      <template-type-parameter name="Ptr"/>
      <template-type-parameter name="U"/>
      <template-nontype-parameter name="RebindMode"><type>unsigned int</type></template-nontype-parameter>
    </template></struct><struct-specialization name="pointer_rebinder"><template>
      <template-type-parameter name="Ptr"/>
      <template-type-parameter name="U"/>
    </template><specialization><template-arg>Ptr</template-arg><template-arg>U</template-arg><template-arg>1u</template-arg></specialization><typedef name="type"><type>Ptr::template rebind&lt; U &gt;</type></typedef>
</struct-specialization><struct-specialization name="pointer_rebinder"><template>
      <template-type-parameter name="Ptr"/>
      <template-type-parameter name="U"/>
    </template><specialization><template-arg>Ptr</template-arg><template-arg>U</template-arg><template-arg>2u</template-arg></specialization><typedef name="type"><type>Ptr::template rebind&lt; U &gt;::other</type></typedef>
</struct-specialization><struct-specialization name="pointer_rebinder"><template>
      <template-nontype-parameter name="Ptr"><type>template&lt; class &gt; class</type></template-nontype-parameter>
      <template-type-parameter name="A"/>
      <template-type-parameter name="U"/>
    </template><specialization><template-arg>Ptr&lt; A &gt;</template-arg><template-arg>U</template-arg><template-arg>0u</template-arg></specialization><typedef name="type"><type>Ptr&lt; U &gt;</type></typedef>
</struct-specialization><struct-specialization name="pointer_rebinder"><template>
      <template-nontype-parameter name="Ptr"><type>template&lt; class, class... &gt; class</type></template-nontype-parameter>
      <template-type-parameter name="A"/>
      <template-nontype-parameter name="An"><type>class...</type></template-nontype-parameter>
      <template-type-parameter name="U"/>
    </template><specialization><template-arg>Ptr&lt; A</template-arg><template-arg>An... &gt;</template-arg><template-arg>U</template-arg><template-arg>0u</template-arg></specialization><typedef name="type"><type>Ptr&lt; U, An... &gt;</type></typedef>
</struct-specialization>



















































</namespace>
</namespace>
</header>
<header name="boost/intrusive/pointer_traits.hpp">
<namespace name="boost">
<namespace name="intrusive">
<struct name="pointer_traits"><template>
      <template-type-parameter name="Ptr"/>
    </template><description><para><classname alt="boost::intrusive::pointer_traits">pointer_traits</classname> is the implementation of C++11 std::pointer_traits class with some extensions like castings.</para><para><classname alt="boost::intrusive::pointer_traits">pointer_traits</classname> supplies a uniform interface to certain attributes of pointer-like types.</para><para><emphasis role="bold">Note</emphasis>: When defining a custom family of pointers or references to be used with BI library, make sure the public static conversion functions accessed through the <computeroutput><classname alt="boost::intrusive::pointer_traits">pointer_traits</classname></computeroutput> interface (<computeroutput>*_cast_from</computeroutput> and <computeroutput>pointer_to</computeroutput>) can properly convert between const and nonconst referred member types <emphasis role="bold">without the use of implicit constructor calls</emphasis>. It is suggested these conversions be implemented as function templates, where the template argument is the type of the object being converted from. </para></description><typedef name="pointer"><description><para>The pointer type queried by this <classname alt="boost::intrusive::pointer_traits">pointer_traits</classname> instantiation </para></description><type>Ptr</type></typedef>
<typedef name="element_type"><description><para>Ptr::element_type if such a type exists; otherwise, T if Ptr is a class template instantiation of the form SomePointer&lt;T, Args&gt;, where Args is zero or more type arguments ; otherwise , the specialization is ill-formed. </para></description><type>unspecified_type</type></typedef>
<typedef name="difference_type"><description><para>Ptr::difference_type if such a type exists; otherwise, std::ptrdiff_t. </para></description><type>unspecified_type</type></typedef>
<typedef name="rebind"><description><para>Ptr::rebind&lt;U&gt; if such a type exists; otherwise, SomePointer&lt;U, Args&gt; if Ptr is a class template instantiation of the form SomePointer&lt;T, Args&gt;, where Args is zero or more type arguments ; otherwise, the instantiation of rebind is ill-formed.</para><para>For portable code for C++03 and C++11, <programlisting>typename rebind_pointer&lt;U&gt;::type</programlisting> shall be used instead of rebind<underline> to obtain a pointer to U. </underline></para></description><type>unspecified</type></typedef>
<typedef name="reference"><description><para>Ptr::reference if such a type exists (non-standard extension); otherwise, element_type &amp; </para></description><type>unspecified_type</type></typedef>
<method-group name="public static functions">
<method name="pointer_to" specifiers="static"><type>pointer</type><parameter name="r"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Remark</emphasis>: If element_type is (possibly cv-qualified) void, r type is unspecified; otherwise, it is element_type &amp;.</para><para><emphasis role="bold">Returns</emphasis>: A dereferenceable pointer to r obtained by calling Ptr::pointer_to(reference). Non-standard extension: If such function does not exist, returns pointer(addressof(r));</para><para><emphasis role="bold">Note</emphasis>: For non-conforming compilers only the existence of a member function called <computeroutput>pointer_to</computeroutput> is checked. </para></description></method>
<method name="static_cast_from" specifiers="static"><type>pointer</type><template>
          <template-type-parameter name="UPtr"/>
        </template><parameter name="uptr"><paramtype>const UPtr &amp;</paramtype></parameter><description><para><emphasis role="bold">Remark</emphasis>: Non-standard extension.</para><para><emphasis role="bold">Returns</emphasis>: A dereferenceable pointer to r obtained by calling the static template function Ptr::static_cast_from(UPpr/const UPpr &amp;). If such function does not exist, returns pointer_to(static_cast&lt;element_type&amp;&gt;(*uptr))</para><para><emphasis role="bold">Note</emphasis>: For non-conforming compilers only the existence of a member function called <computeroutput>static_cast_from</computeroutput> is checked. </para></description></method>
<method name="const_cast_from" specifiers="static"><type>pointer</type><template>
          <template-type-parameter name="UPtr"/>
        </template><parameter name="uptr"><paramtype>const UPtr &amp;</paramtype></parameter><description><para><emphasis role="bold">Remark</emphasis>: Non-standard extension.</para><para><emphasis role="bold">Returns</emphasis>: A dereferenceable pointer to r obtained by calling the static template function Ptr::const_cast_from&lt;UPtr&gt;(UPpr/const UPpr &amp;). If such function does not exist, returns pointer_to(const_cast&lt;element_type&amp;&gt;(*uptr))</para><para><emphasis role="bold">Note</emphasis>: For non-conforming compilers only the existence of a member function called <computeroutput>const_cast_from</computeroutput> is checked. </para></description></method>
<method name="dynamic_cast_from" specifiers="static"><type>pointer</type><template>
          <template-type-parameter name="UPtr"/>
        </template><parameter name="uptr"><paramtype>const UPtr &amp;</paramtype></parameter><description><para><emphasis role="bold">Remark</emphasis>: Non-standard extension.</para><para><emphasis role="bold">Returns</emphasis>: A dereferenceable pointer to r obtained by calling the static template function Ptr::dynamic_cast_from&lt;UPtr&gt;(UPpr/const UPpr &amp;). If such function does not exist, returns pointer_to(<emphasis>dynamic_cast&lt;element_type</emphasis>&gt;(&amp;*uptr))</para><para><emphasis role="bold">Note</emphasis>: For non-conforming compilers only the existence of a member function called <computeroutput>dynamic_cast_from</computeroutput> is checked. </para></description></method>
</method-group>
</struct><struct-specialization name="pointer_traits"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T *</template-arg></specialization><description><para>Specialization of <classname alt="boost::intrusive::pointer_traits">pointer_traits</classname> for raw pointers </para></description><struct name="rebind_pointer"><template>
      <template-type-parameter name="U"/>
    </template><typedef name="type"><type>U *</type></typedef>
</struct><typedef name="element_type"><type>T</type></typedef>
<typedef name="pointer"><type>T *</type></typedef>
<typedef name="difference_type"><type>std::ptrdiff_t</type></typedef>
<typedef name="reference"><type>T &amp;</type></typedef>
<typedef name="rebind"><description><programlisting>U *</programlisting><para>For portable code for C++03 and C++11, <programlisting>typename rebind_pointer&lt;U&gt;::type</programlisting> shall be used instead of rebind<underline> to obtain a pointer to U. </underline></para></description><type>U *</type></typedef>
<method-group name="public static functions">
<method name="pointer_to" specifiers="static"><type>pointer</type><parameter name="r"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: addressof(r) </para></description></method>
<method name="static_cast_from" specifiers="static"><type>pointer</type><template>
          <template-type-parameter name="U"/>
        </template><parameter name="uptr"><paramtype>U *</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: static_cast&lt;pointer&gt;(uptr) </para></description></method>
<method name="const_cast_from" specifiers="static"><type>pointer</type><template>
          <template-type-parameter name="U"/>
        </template><parameter name="uptr"><paramtype>U *</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: const_cast&lt;pointer&gt;(uptr) </para></description></method>
<method name="dynamic_cast_from" specifiers="static"><type>pointer</type><template>
          <template-type-parameter name="U"/>
        </template><parameter name="uptr"><paramtype>U *</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: dynamic_cast&lt;pointer&gt;(uptr) </para></description></method>
</method-group>
</struct-specialization>



















































</namespace>
</namespace>
</header>
<header name="boost/intrusive/priority_compare.hpp">
<namespace name="boost">
<namespace name="intrusive">
<struct name="priority_compare"><template>
      <template-type-parameter name="T"><default>void</default></template-type-parameter>
    </template><typedef name="first_argument_type"><type>T</type></typedef>
<typedef name="second_argument_type"><type>T</type></typedef>
<typedef name="result_type"><type>bool</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>bool</type><parameter name="val"><paramtype>const T &amp;</paramtype></parameter><parameter name="val2"><paramtype>const T &amp;</paramtype></parameter></method>
</method-group>
</struct><struct-specialization name="priority_compare"><template>
    </template><specialization><template-arg>void</template-arg></specialization><method-group name="public member functions">
<method name="operator()" cv="const"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="t"><paramtype>const T &amp;</paramtype></parameter><parameter name="u"><paramtype>const U &amp;</paramtype></parameter></method>
</method-group>
</struct-specialization>



















































</namespace>
</namespace>
</header>
<header name="boost/intrusive/rbtree.hpp">
<namespace name="boost">
<namespace name="intrusive">
<struct name="make_rbtree"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>rbtree</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct><class name="rbtree"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>The class template rbtree is an intrusive red-black tree container, that is used to construct intrusive set and multiset containers. The no-throw guarantee holds only, if the key_compare object doesn't throw.</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput> and <computeroutput>compare&lt;&gt;</computeroutput>. </para></description><typedef name="value_traits"><type>ValueTraits</type></typedef>
<typedef name="pointer"><type>implementation_defined::pointer</type></typedef>
<typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef>
<typedef name="value_type"><type>implementation_defined::value_type</type></typedef>
<typedef name="key_type"><type>implementation_defined::key_type</type></typedef>
<typedef name="key_of_value"><type>implementation_defined::key_of_value</type></typedef>
<typedef name="reference"><type>implementation_defined::reference</type></typedef>
<typedef name="const_reference"><type>implementation_defined::const_reference</type></typedef>
<typedef name="difference_type"><type>implementation_defined::difference_type</type></typedef>
<typedef name="size_type"><type>implementation_defined::size_type</type></typedef>
<typedef name="value_compare"><type>implementation_defined::value_compare</type></typedef>
<typedef name="key_compare"><type>implementation_defined::key_compare</type></typedef>
<typedef name="iterator"><type>implementation_defined::iterator</type></typedef>
<typedef name="const_iterator"><type>implementation_defined::const_iterator</type></typedef>
<typedef name="reverse_iterator"><type>implementation_defined::reverse_iterator</type></typedef>
<typedef name="const_reverse_iterator"><type>implementation_defined::const_reverse_iterator</type></typedef>
<typedef name="node_traits"><type>implementation_defined::node_traits</type></typedef>
<typedef name="node"><type>implementation_defined::node</type></typedef>
<typedef name="node_ptr"><type>implementation_defined::node_ptr</type></typedef>
<typedef name="const_node_ptr"><type>implementation_defined::const_node_ptr</type></typedef>
<typedef name="node_algorithms"><type>implementation_defined::node_algorithms</type></typedef>
<typedef name="insert_commit_data"><type>implementation_defined::insert_commit_data</type></typedef>
<data-member name="constant_time_size" specifiers="static"><type>const bool</type></data-member>
<method-group name="public member functions">
<method name="begin"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rbegin"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a iterator pointing to the root node of the container or end() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="croot" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the key_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If key_compare copy-constructor throws. </para></description></method>
<method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the value_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_compare copy-constructor throws. </para></description></method>
<method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this if constant-time size option is disabled. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="swap"><type>void</type><parameter name="other"><paramtype><classname>rbtree</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of two containers.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison functor's swap call throws. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>rbtree</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype><classname>rbtree</classname> &amp;&amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(reference) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: This version can modify the source container, useful to implement move semantics. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype><classname>rbtree</classname> &amp;&amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(reference) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: This version can modify the source container, useful to implement move semantics. </para></description></method>
<method name="insert_equal"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the container before the upper bound.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal key_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_equal"><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and "hint" must be a valid iterator.</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container, using "hint" as a hint to where it will be inserted. If "hint" is the upper_bound the insertion takes constant time (two comparisons in the worst case)</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the internal key_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_equal"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Inserts a each element of a range into the container before the upper bound of the key of each element.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_unique"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the container if the value is not already present.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_unique"><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and "hint" must be a valid iterator</para><para><emphasis role="bold">Effects</emphasis>: Tries to insert x into the container, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time (two comparisons in the worst case) if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_unique_check"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must be a comparison function that induces the same strict weak ordering as key_compare. The difference is that comp compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the container. </para></description></method>
<method name="insert_unique_check"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must be a comparison function that induces the same strict weak ordering as key_compare. The difference is that comp compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it's amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the constructing that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that key to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This can give a total constant-time complexity to the insertion: check(O(1)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the container. </para></description></method>
<method name="insert_unique_check"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee. </para></description></method>
<method name="insert_unique_check"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it's amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee. </para></description></method>
<method name="insert_unique_commit"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><parameter name="commit_data"><paramtype>const insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue of type value_type. commit_data must have been obtained from a previous call to "insert_check". No objects should have been inserted or erased from the container between the "insert_check" that filled "commit_data" and the call to "insert_commit".</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value in the container using the information obtained from the "commit_data" that a previous "insert_check" filled.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the newly inserted object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function has only sense if a "insert_check" has been previously executed to fill "commit_data". No value should be inserted or erased between the "insert_check" and "insert_commit" calls. </para></description></method>
<method name="insert_unique"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Tries to insert each element of a range into the container.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_before"><type>iterator</type><parameter name="pos"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, "pos" must be a valid iterator (or end) and must be the succesor of value once inserted according to the predicate</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container before "pos".</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if "pos" is not the successor of "value" container ordering invariant will be broken. This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_back"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no less than the greatest inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the last position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is less than the greatest inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_front"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no greater than the minimum inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the first position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is greater than the minimum inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="i"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp".</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk) and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="clear"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="clear_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements calling disposer(p) for each node to be erased. <emphasis role="bold">Complexity</emphasis>: Average complexity for is at most O(log(size() + N)), where N is the number of elements in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. Calls N times to disposer functor. </para></description></method>
<method name="count" cv="const"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given value</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given value.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="count" cv="const"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="lower_bound"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="find"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="find"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="lower"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="lower_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="iterator_to"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="unlink_leftmost_without_rebalance"><type>pointer</type><description><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the container.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the container and the container can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the container. </para></description></method>
<method name="replace_node"><type>void</type><parameter name="replace_this"><paramtype>iterator</paramtype></parameter><parameter name="with_this"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: replace_this must be a valid iterator of *this and with_this must not be inserted in any container.</para><para><emphasis role="bold">Effects</emphasis>: Replaces replace_this in its position in the container with with_this. The container does not need to be rebalanced.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if with_this is not equivalent to *replace_this according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. </para></description></method>
<method name="remove_node"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: removes "value" from the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic time.</para><para><emphasis role="bold">Note</emphasis>: This static function is only usable with non-constant time size containers that have stateless comparison functors.</para><para>If the user calls this function with a constant time size container or stateful comparison functor a compilation error will be issued. </para></description></method>
<method name="merge_unique"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name=""><paramtype><classname>rbtree</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge_equal"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name=""><paramtype><classname>rbtree</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Extracts each element in source and insert it into a using the comparison object of *this.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container with given comparison and traits.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="unique"><paramtype>bool</paramtype></parameter><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype><default>key_compare()</default></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type. cmp must be a comparison function that induces a strict weak ordering.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container and inserts elements from [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if [b, e) is already sorted using comp and otherwise N * log N, where N is the distance between first and last.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor/operator() of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>rbtree</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a container moving resources from another container. Internal comparison object and value traits are move constructed and nodes belonging to x (except the node representing the "end") are linked to *this.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node's move constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the move constructor of the comparison objet throws. </para></description></constructor>
<copy-assignment><type><classname>rbtree</classname> &amp;</type><parameter name="x"><paramtype><classname>rbtree</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to swap </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the set are not deleted (i.e. no destructors are called), but the nodes according to the <classname alt="boost::intrusive::value_traits">value_traits</classname> template parameter are reinitialized and thus can be reused.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor>
<method-group name="public static functions">
<method name="container_from_end_iterator" specifiers="static"><type><classname>rbtree</classname> &amp;</type><parameter name="end_iterator"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_end_iterator" specifiers="static"><type>const <classname>rbtree</classname> &amp;</type><parameter name="end_iterator"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type><classname>rbtree</classname> &amp;</type><parameter name="it"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type>const <classname>rbtree</classname> &amp;</type><parameter name="it"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="init_node" specifiers="static"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value shall not be in a container.</para><para><emphasis role="bold">Effects</emphasis>: init_node puts the hook of a value in a well-known default state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: This function puts the hook in the well-known default state used by auto_unlink and safe hooks. </para></description></method>
</method-group>
</class>



















































</namespace>
</namespace>
</header>
<header name="boost/intrusive/rbtree_algorithms.hpp">
<namespace name="boost">
<namespace name="intrusive">
<class name="rbtree_algorithms"><template>
      <template-type-parameter name="NodeTraits"/>
    </template><description><para><classname alt="boost::intrusive::rbtree_algorithms">rbtree_algorithms</classname> provides basic algorithms to manipulate nodes forming a red-black tree. The insertion and deletion algorithms are based on those in Cormen, Leiserson, and Rivest, Introduction to Algorithms (MIT Press, 1990), except that</para><para>(1) the header node is maintained with links not only to the root but also to the leftmost node of the tree, to enable constant time begin(), and to the rightmost node of the tree, to enable linear time performance when used with the generic set algorithms (set_union, etc.);</para><para>(2) when a node being deleted has two children its successor node is relinked into its place, rather than copied, so that the only pointers invalidated are those referring to the deleted node.</para><para><classname alt="boost::intrusive::rbtree_algorithms">rbtree_algorithms</classname> is configured with a NodeTraits class, which encapsulates the information about the node to be manipulated. NodeTraits must support the following interface:</para><para><emphasis role="bold">Typedefs</emphasis>:</para><para><computeroutput>node</computeroutput>: The type of the node that forms the binary search tree</para><para><computeroutput>node_ptr</computeroutput>: A pointer to a node</para><para><computeroutput>const_node_ptr</computeroutput>: A pointer to a const node</para><para><computeroutput>color</computeroutput>: The type that can store the color of a node</para><para><emphasis role="bold">Static functions</emphasis>:</para><para><computeroutput>static node_ptr get_parent(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_parent(node_ptr n, node_ptr parent);</computeroutput></para><para><computeroutput>static node_ptr get_left(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_left(node_ptr n, node_ptr left);</computeroutput></para><para><computeroutput>static node_ptr get_right(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_right(node_ptr n, node_ptr right);</computeroutput></para><para><computeroutput>static color get_color(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_color(node_ptr n, color c);</computeroutput></para><para><computeroutput>static color black();</computeroutput></para><para><computeroutput>static color red();</computeroutput> </para></description><typedef name="node_traits"><type>NodeTraits</type></typedef>
<typedef name="node"><type>NodeTraits::node</type></typedef>
<typedef name="node_ptr"><type>NodeTraits::node_ptr</type></typedef>
<typedef name="const_node_ptr"><type>NodeTraits::const_node_ptr</type></typedef>
<typedef name="color"><type>NodeTraits::color</type></typedef>
<typedef name="insert_commit_data"><description><para>This type is the information that will be filled by insert_unique_check </para></description><type>bstree_algo::insert_commit_data</type></typedef>
<method-group name="public static functions">
<method name="get_header" specifiers="static"><type>node_ptr</type><parameter name="n"><paramtype>const const_node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'node' is a node of the tree or a header node.</para><para><emphasis role="bold">Effects</emphasis>: Returns the header of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="begin_node" specifiers="static"><type>node_ptr</type><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'header' is the header node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Returns the first node of the tree, the header if the tree is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end_node" specifiers="static"><type>node_ptr</type><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'header' is the header node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Returns the header of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="swap_tree" specifiers="static"><type>void</type><parameter name="header1"><paramtype>node_ptr</paramtype></parameter><parameter name="header2"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header1 and header2 must be the header nodes of two trees.</para><para><emphasis role="bold">Effects</emphasis>: Swaps two trees. After the function header1 will contain links to the second tree and header2 will have links to the first tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="swap_nodes" specifiers="static"><type>void</type><parameter name="node1"><paramtype>node_ptr</paramtype></parameter><parameter name="node2"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node1 and node2 can't be header nodes of two trees.</para><para><emphasis role="bold">Effects</emphasis>: Swaps two nodes. After the function node1 will be inserted in the position node2 before the function. node2 will be inserted in the position node1 had before the function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if node1 and node2 are not equivalent according to the ordering rules.</para><para>Experimental function </para></description></method>
<method name="swap_nodes" specifiers="static"><type>void</type><parameter name="node1"><paramtype>node_ptr</paramtype></parameter><parameter name="header1"><paramtype>node_ptr</paramtype></parameter><parameter name="node2"><paramtype>node_ptr</paramtype></parameter><parameter name="header2"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node1 and node2 can't be header nodes of two trees with header header1 and header2.</para><para><emphasis role="bold">Effects</emphasis>: Swaps two nodes. After the function node1 will be inserted in the position node2 before the function. node2 will be inserted in the position node1 had before the function.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if node1 and node2 are not equivalent according to the ordering rules.</para><para>Experimental function </para></description></method>
<method name="replace_node" specifiers="static"><type>void</type><parameter name="node_to_be_replaced"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node_to_be_replaced must be inserted in a tree and new_node must not be inserted in a tree.</para><para><emphasis role="bold">Effects</emphasis>: Replaces node_to_be_replaced in its position in the tree with new_node. The tree does not need to be rebalanced</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if new_node is not equivalent to node_to_be_replaced according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing and comparison is needed. Experimental function </para></description></method>
<method name="replace_node" specifiers="static"><type>void</type><parameter name="node_to_be_replaced"><paramtype>node_ptr</paramtype></parameter><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node_to_be_replaced must be inserted in a tree with header "header" and new_node must not be inserted in a tree.</para><para><emphasis role="bold">Effects</emphasis>: Replaces node_to_be_replaced in its position in the tree with new_node. The tree does not need to be rebalanced</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if new_node is not equivalent to node_to_be_replaced according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. Experimental function </para></description></method>
<method name="unlink" specifiers="static"><type>void</type><parameter name="node"><paramtype>const node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node is a tree node but not the header.</para><para><emphasis role="bold">Effects</emphasis>: Unlinks the node and rebalances the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="unlink_leftmost_without_rebalance" specifiers="static"><type>node_ptr</type><parameter name="header"><paramtype>const node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header is the header of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the tree, and updates the header link to the new leftmost node.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the tree and the tree can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the tree. </para></description></method>
<method name="unique" specifiers="static"><type>bool</type><parameter name="node"><paramtype>const const_node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'node' is a node of the tree or a node initialized by init(...) or init_node.</para><para><emphasis role="bold">Effects</emphasis>: Returns true if the node is initialized by init() or init_node().</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="size" specifiers="static"><type>std::size_t</type><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node is a node of the tree but it's not the header.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of nodes of the subtree.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="next_node" specifiers="static"><type>node_ptr</type><parameter name="node"><paramtype>const node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'node' is a node from the tree except the header.</para><para><emphasis role="bold">Effects</emphasis>: Returns the next node of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="prev_node" specifiers="static"><type>node_ptr</type><parameter name="node"><paramtype>const node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'node' is a node from the tree except the leftmost node.</para><para><emphasis role="bold">Effects</emphasis>: Returns the previous node of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="init" specifiers="static"><type>void</type><parameter name="node"><paramtype>const node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'node' must not be part of any tree.</para><para><emphasis role="bold">Effects</emphasis>: After the function unique(node) == true.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Nodes</emphasis>: If node is inserted in a tree, this function corrupts the tree. </para></description></method>
<method name="init_header" specifiers="static"><type>void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node must not be part of any tree.</para><para><emphasis role="bold">Effects</emphasis>: Initializes the header to represent an empty tree. unique(header) == true.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Nodes</emphasis>: If node is inserted in a tree, this function corrupts the tree. </para></description></method>
<method name="erase" specifiers="static"><type>node_ptr</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="z"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header must be the header of a tree, z a node of that tree and z != header.</para><para><emphasis role="bold">Effects</emphasis>: Erases node "z" from the tree with header "header".</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="transfer_unique" specifiers="static"><type>bool</type><template>
          <template-type-parameter name="NodePtrCompare"/>
        </template><parameter name="header1"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><parameter name="header2"><paramtype>node_ptr</paramtype></parameter><parameter name="z"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header1 and header2 must be the headers of trees tree1 and tree2 respectively, z a non-header node of tree1. NodePtrCompare is the comparison function of tree1..</para><para><emphasis role="bold">Effects</emphasis>: Transfers node "z" from tree1 to tree2 if tree1 does not contain a node that is equivalent to z.</para><para><emphasis role="bold">Returns</emphasis>: True if the node was trasferred, false otherwise.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison throws. </para></description></method>
<method name="transfer_equal" specifiers="static"><type>void</type><template>
          <template-type-parameter name="NodePtrCompare"/>
        </template><parameter name="header1"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><parameter name="header2"><paramtype>node_ptr</paramtype></parameter><parameter name="z"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header1 and header2 must be the headers of trees tree1 and tree2 respectively, z a non-header node of tree1. NodePtrCompare is the comparison function of tree1..</para><para><emphasis role="bold">Effects</emphasis>: Transfers node "z" from tree1 to tree2.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison throws. </para></description></method>
<method name="clone" specifiers="static"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="source_header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="target_header"><paramtype>node_ptr</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "cloner" must be a function object taking a node_ptr and returning a new cloned node of it. "disposer" must take a node_ptr and shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: First empties target tree calling <computeroutput>void disposer::operator()(const node_ptr &amp;)</computeroutput> for every node of the tree except the header.</para><para>Then, duplicates the entire tree pointed by "source_header" cloning each source node with <computeroutput>node_ptr Cloner::operator()(const node_ptr &amp;)</computeroutput> to obtain the nodes of the target tree. If "cloner" throws, the cloned target nodes are disposed using <computeroutput>void disposer(const node_ptr &amp;)</computeroutput>.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of element of the source tree plus the number of elements of tree target tree when calling this function.</para><para><emphasis role="bold">Throws</emphasis>: If cloner functor throws. If this happens target nodes are disposed. </para></description></method>
<method name="clear_and_dispose" specifiers="static"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="header"><paramtype>const node_ptr &amp;</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "disposer" must be an object function taking a node_ptr parameter and shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Empties the target tree calling <computeroutput>void disposer::operator()(const node_ptr &amp;)</computeroutput> for every node of the tree except the header.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of element of the source tree plus the. number of elements of tree target tree when calling this function.</para><para><emphasis role="bold">Throws</emphasis>: If cloner functor throws. If this happens target nodes are disposed. </para></description></method>
<method name="lower_bound" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns a node_ptr to the first element that is not less than "key" according to "comp" or "header" if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="upper_bound" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns a node_ptr to the first element that is greater than "key" according to "comp" or "header" if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="find" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns a node_ptr to the first element that is equivalent to "key" according to "comp" or "header" if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="equal_range" specifiers="static"><type>std::pair&lt; node_ptr, node_ptr &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair of node_ptr delimiting a range containing all elements that are equivalent to "key" according to "comp" or an empty range that indicates the position where those elements would be if there are no equivalent elements.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="bounded_range" specifiers="static"><type>std::pair&lt; node_ptr, node_ptr &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs. 'lower_key' must not be greater than 'upper_key' according to 'comp'. If 'lower_key' == 'upper_key', ('left_closed' || 'right_closed') must be true.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change. </para></description></method>
<method name="count" specifiers="static"><type>std::size_t</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements with a key equivalent to "key" according to "comp".</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="insert_equal_upper_bound" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="NodePtrCompare"/>
        </template><parameter name="h"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "h" must be the header node of a tree. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares two node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree before the upper bound according to "comp".</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="insert_equal_lower_bound" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="NodePtrCompare"/>
        </template><parameter name="h"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "h" must be the header node of a tree. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares two node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree before the lower bound according to "comp".</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="insert_equal" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="NodePtrCompare"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="hint"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares two node_ptrs. "hint" is node from the "header"'s tree.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree, using "hint" as a hint to where it will be inserted. If "hint" is the upper_bound the insertion takes constant time (two comparisons in the worst case).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time if new_node is inserted immediately before "hint".</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="insert_before" specifiers="static"><type>node_ptr</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="pos"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. "pos" must be a valid iterator or header (end) node. "pos" must be an iterator pointing to the successor to "new_node" once inserted according to the order of already inserted nodes. This function does not check "pos" and this precondition must be guaranteed by the caller.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree before "pos".</para><para><emphasis role="bold">Complexity</emphasis>: Constant-time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: If "pos" is not the successor of the newly inserted "new_node" tree invariants might be broken. </para></description></method>
<method name="push_back" specifiers="static"><type>void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. "new_node" must be, according to the used ordering no less than the greatest inserted key.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree before "pos".</para><para><emphasis role="bold">Complexity</emphasis>: Constant-time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: If "new_node" is less than the greatest inserted key tree invariants are broken. This function is slightly faster than using "insert_before". </para></description></method>
<method name="push_front" specifiers="static"><type>void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. "new_node" must be, according to the used ordering, no greater than the lowest inserted key.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree before "pos".</para><para><emphasis role="bold">Complexity</emphasis>: Constant-time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: If "new_node" is greater than the lowest inserted key tree invariants are broken. This function is slightly faster than using "insert_before". </para></description></method>
<method name="insert_unique_check" specifiers="static"><type>std::pair&lt; node_ptr, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares KeyType with a node_ptr.</para><para><emphasis role="bold">Effects</emphasis>: Checks if there is an equivalent node to "key" in the tree according to "comp" and obtains the needed information to realize a constant-time node insertion if there is no equivalent node.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing a node_ptr to the already present node and false. If there is not equivalent key can be inserted returns true in the returned pair's boolean and fills "commit_data" that is meant to be used with the "insert_commit" function to achieve a constant-time insertion function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a node is expensive and the user does not want to have two equivalent nodes in the tree: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the node and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the node and use "insert_commit" to insert the node in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_unique_commit" only if no more objects are inserted or erased from the set. </para></description></method>
<method name="insert_unique_check" specifiers="static"><type>std::pair&lt; node_ptr, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="hint"><paramtype>node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares KeyType with a node_ptr. "hint" is node from the "header"'s tree.</para><para><emphasis role="bold">Effects</emphasis>: Checks if there is an equivalent node to "key" in the tree according to "comp" using "hint" as a hint to where it should be inserted and obtains the needed information to realize a constant-time node insertion if there is no equivalent node. If "hint" is the upper_bound the function has constant time complexity (two comparisons in the worst case).</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing a node_ptr to the already present node and false. If there is not equivalent key can be inserted returns true in the returned pair's boolean and fills "commit_data" that is meant to be used with the "insert_commit" function to achieve a constant-time insertion function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic, but it is amortized constant time if new_node should be inserted immediately before "hint".</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a node is expensive and the user does not want to have two equivalent nodes in the tree: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the node and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the node and use "insert_commit" to insert the node in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_unique_commit" only if no more objects are inserted or erased from the set. </para></description></method>
<method name="insert_unique_commit" specifiers="static"><type>void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_value"><paramtype>node_ptr</paramtype></parameter><parameter name="commit_data"><paramtype>const insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. "commit_data" must have been obtained from a previous call to "insert_unique_check". No objects should have been inserted or erased from the set between the "insert_unique_check" that filled "commit_data" and the call to "insert_commit".</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node in the set using the information obtained from the "commit_data" that a previous "insert_check" filled.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function has only sense if a "insert_unique_check" has been previously executed to fill "commit_data". No value should be inserted or erased between the "insert_check" and "insert_commit" calls. </para></description></method>
<method name="is_header" specifiers="static"><type>bool</type><parameter name="p"><paramtype>const const_node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p is a node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Returns true if p is the header of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
</method-group>
</class>



















































</namespace>
</namespace>
</header>
<header name="boost/intrusive/set.hpp">
<namespace name="boost">
<namespace name="intrusive">
<struct name="make_multiset"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>multiset</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct><struct name="make_set"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>set</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct><class name="multiset"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>The class template multiset is an intrusive container, that mimics most of the interface of std::multiset as described in the C++ standard.</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput> and <computeroutput>compare&lt;&gt;</computeroutput>. </para></description><typedef name="value_type"><type>implementation_defined::value_type</type></typedef>
<typedef name="key_type"><type>implementation_defined::key_type</type></typedef>
<typedef name="key_of_value"><type>implementation_defined::key_of_value</type></typedef>
<typedef name="value_traits"><type>implementation_defined::value_traits</type></typedef>
<typedef name="pointer"><type>implementation_defined::pointer</type></typedef>
<typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef>
<typedef name="reference"><type>implementation_defined::reference</type></typedef>
<typedef name="const_reference"><type>implementation_defined::const_reference</type></typedef>
<typedef name="difference_type"><type>implementation_defined::difference_type</type></typedef>
<typedef name="size_type"><type>implementation_defined::size_type</type></typedef>
<typedef name="value_compare"><type>implementation_defined::value_compare</type></typedef>
<typedef name="key_compare"><type>implementation_defined::key_compare</type></typedef>
<typedef name="iterator"><type>implementation_defined::iterator</type></typedef>
<typedef name="const_iterator"><type>implementation_defined::const_iterator</type></typedef>
<typedef name="reverse_iterator"><type>implementation_defined::reverse_iterator</type></typedef>
<typedef name="const_reverse_iterator"><type>implementation_defined::const_reverse_iterator</type></typedef>
<typedef name="insert_commit_data"><type>implementation_defined::insert_commit_data</type></typedef>
<typedef name="node_traits"><type>implementation_defined::node_traits</type></typedef>
<typedef name="node"><type>implementation_defined::node</type></typedef>
<typedef name="node_ptr"><type>implementation_defined::node_ptr</type></typedef>
<typedef name="const_node_ptr"><type>implementation_defined::const_node_ptr</type></typedef>
<typedef name="node_algorithms"><type>implementation_defined::node_algorithms</type></typedef>
<data-member name="constant_time_size" specifiers="static"><type>const bool</type></data-member>
<method-group name="public member functions">
<method name="begin"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rbegin"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a iterator pointing to the root node of the container or end() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="croot" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the key_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If key_compare copy-constructor throws. </para></description></method>
<method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the value_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_compare copy-constructor throws. </para></description></method>
<method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this if constant-time size option is disabled. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="swap"><type>void</type><parameter name="other"><paramtype><classname>multiset</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of two containers.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison functor's swap call throws. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>multiset</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype><classname>multiset</classname> &amp;&amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(reference) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: This version can modify the source container, useful to implement move semantics. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the container before the upper bound.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal key_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and "hint" must be a valid iterator.</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container, using "hint" as a hint to where it will be inserted. If "hint" is the upper_bound the insertion takes constant time (two comparisons in the worst case)</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the internal key_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Inserts a each element of a range into the container before the upper bound of the key of each element.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_before"><type>iterator</type><parameter name="pos"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, "pos" must be a valid iterator (or end) and must be the succesor of value once inserted according to the predicate</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container before "pos".</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if "pos" is not the successor of "value" container ordering invariant will be broken. This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_back"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no less than the greatest inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the last position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is less than the greatest inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_front"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no greater than the minimum inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the first position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is greater than the minimum inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="i"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp".</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk) and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="clear"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="clear_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements calling disposer(p) for each node to be erased. <emphasis role="bold">Complexity</emphasis>: Average complexity for is at most O(log(size() + N)), where N is the number of elements in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. Calls N times to disposer functor. </para></description></method>
<method name="count" cv="const"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given value</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given value.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="count" cv="const"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="lower_bound"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="find"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="find"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="lower_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="lower_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="iterator_to"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="unlink_leftmost_without_rebalance"><type>pointer</type><description><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the container.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the container and the container can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the container. </para></description></method>
<method name="replace_node"><type>void</type><parameter name="replace_this"><paramtype>iterator</paramtype></parameter><parameter name="with_this"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: replace_this must be a valid iterator of *this and with_this must not be inserted in any container.</para><para><emphasis role="bold">Effects</emphasis>: Replaces replace_this in its position in the container with with_this. The container does not need to be rebalanced.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if with_this is not equivalent to *replace_this according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. </para></description></method>
<method name="remove_node"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: removes "value" from the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic time.</para><para><emphasis role="bold">Note</emphasis>: This static function is only usable with non-constant time size containers that have stateless comparison functors.</para><para>If the user calls this function with a constant time size container or stateful comparison functor a compilation error will be issued. </para></description></method>
<method name="merge"><type>void</type><template>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="source"><paramtype><classname>multiset</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Extracts each element in source and insert it into a using the comparison object of *this.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="source"><paramtype><classname>set</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Extracts each element in source and insert it into a using the comparison object of *this.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container with given comparison and traits.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype><default>key_compare()</default></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type. cmp must be a comparison function that induces a strict weak ordering.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container and inserts elements from [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if [b, e) is already sorted using comp and otherwise N * log N, where N is the distance between first and last.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor/operator() of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>multiset</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a container moving resources from another container. Internal comparison object and value traits are move constructed and nodes belonging to x (except the node representing the "end") are linked to *this.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node's move constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the move constructor of the comparison objet throws. </para></description></constructor>
<copy-assignment><type><classname>multiset</classname> &amp;</type><parameter name="x"><paramtype><classname>multiset</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to swap </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the set are not deleted (i.e. no destructors are called), but the nodes according to the <classname alt="boost::intrusive::value_traits">value_traits</classname> template parameter are reinitialized and thus can be reused.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor>
<method-group name="public static functions">
<method name="container_from_end_iterator" specifiers="static"><type><classname>multiset</classname> &amp;</type><parameter name="end_iterator"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_end_iterator" specifiers="static"><type>const <classname>multiset</classname> &amp;</type><parameter name="end_iterator"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type><classname>multiset</classname> &amp;</type><parameter name="it"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type>const <classname>multiset</classname> &amp;</type><parameter name="it"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="init_node" specifiers="static"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value shall not be in a container.</para><para><emphasis role="bold">Effects</emphasis>: init_node puts the hook of a value in a well-known default state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: This function puts the hook in the well-known default state used by auto_unlink and safe hooks. </para></description></method>
</method-group>
</class><class name="set"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>The class template set is an intrusive container, that mimics most of the interface of std::set as described in the C++ standard.</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput> and <computeroutput>compare&lt;&gt;</computeroutput>. </para></description><typedef name="value_type"><type>implementation_defined::value_type</type></typedef>
<typedef name="key_type"><type>implementation_defined::key_type</type></typedef>
<typedef name="key_of_value"><type>implementation_defined::key_of_value</type></typedef>
<typedef name="value_traits"><type>implementation_defined::value_traits</type></typedef>
<typedef name="pointer"><type>implementation_defined::pointer</type></typedef>
<typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef>
<typedef name="reference"><type>implementation_defined::reference</type></typedef>
<typedef name="const_reference"><type>implementation_defined::const_reference</type></typedef>
<typedef name="difference_type"><type>implementation_defined::difference_type</type></typedef>
<typedef name="size_type"><type>implementation_defined::size_type</type></typedef>
<typedef name="value_compare"><type>implementation_defined::value_compare</type></typedef>
<typedef name="key_compare"><type>implementation_defined::key_compare</type></typedef>
<typedef name="iterator"><type>implementation_defined::iterator</type></typedef>
<typedef name="const_iterator"><type>implementation_defined::const_iterator</type></typedef>
<typedef name="reverse_iterator"><type>implementation_defined::reverse_iterator</type></typedef>
<typedef name="const_reverse_iterator"><type>implementation_defined::const_reverse_iterator</type></typedef>
<typedef name="insert_commit_data"><type>implementation_defined::insert_commit_data</type></typedef>
<typedef name="node_traits"><type>implementation_defined::node_traits</type></typedef>
<typedef name="node"><type>implementation_defined::node</type></typedef>
<typedef name="node_ptr"><type>implementation_defined::node_ptr</type></typedef>
<typedef name="const_node_ptr"><type>implementation_defined::const_node_ptr</type></typedef>
<typedef name="node_algorithms"><type>implementation_defined::node_algorithms</type></typedef>
<data-member name="constant_time_size" specifiers="static"><type>const bool</type></data-member>
<method-group name="public member functions">
<method name="begin"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rbegin"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a iterator pointing to the root node of the container or end() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="croot" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the key_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If key_compare copy-constructor throws. </para></description></method>
<method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the value_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_compare copy-constructor throws. </para></description></method>
<method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this if constant-time size option is disabled. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="swap"><type>void</type><parameter name="other"><paramtype><classname>set</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of two containers.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison functor's swap call throws. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>set</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype><classname>set</classname> &amp;&amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(reference) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: This version can modify the source container, useful to implement move semantics. </para></description></method>
<method name="insert"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the container if the value is not already present.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and "hint" must be a valid iterator</para><para><emphasis role="bold">Effects</emphasis>: Tries to insert x into the container, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time (two comparisons in the worst case) if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_check"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee. </para></description></method>
<method name="insert_check"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it's amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee. </para></description></method>
<method name="insert_check"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must be a comparison function that induces the same strict weak ordering as key_compare. The difference is that comp compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the container. </para></description></method>
<method name="insert_check"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must be a comparison function that induces the same strict weak ordering as key_compare. The difference is that comp compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it's amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the constructing that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that key to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This can give a total constant-time complexity to the insertion: check(O(1)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the container. </para></description></method>
<method name="insert"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Tries to insert each element of a range into the container.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_commit"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><parameter name="commit_data"><paramtype>const insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue of type value_type. commit_data must have been obtained from a previous call to "insert_check". No objects should have been inserted or erased from the container between the "insert_check" that filled "commit_data" and the call to "insert_commit".</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value in the container using the information obtained from the "commit_data" that a previous "insert_check" filled.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the newly inserted object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function has only sense if a "insert_check" has been previously executed to fill "commit_data". No value should be inserted or erased between the "insert_check" and "insert_commit" calls. </para></description></method>
<method name="insert_before"><type>iterator</type><parameter name="pos"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, "pos" must be a valid iterator (or end) and must be the succesor of value once inserted according to the predicate</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container before "pos".</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if "pos" is not the successor of "value" container ordering invariant will be broken. This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_back"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no less than the greatest inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the last position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is less than the greatest inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_front"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no greater than the minimum inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the first position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is greater than the minimum inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="i"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp".</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk) and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="clear"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="clear_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements calling disposer(p) for each node to be erased. <emphasis role="bold">Complexity</emphasis>: Average complexity for is at most O(log(size() + N)), where N is the number of elements in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. Calls N times to disposer functor. </para></description></method>
<method name="count" cv="const"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given value</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given value.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="count" cv="const"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="lower_bound"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="find"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="find"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="lower_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="lower_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="iterator_to"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="unlink_leftmost_without_rebalance"><type>pointer</type><description><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the container.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the container and the container can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the container. </para></description></method>
<method name="replace_node"><type>void</type><parameter name="replace_this"><paramtype>iterator</paramtype></parameter><parameter name="with_this"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: replace_this must be a valid iterator of *this and with_this must not be inserted in any container.</para><para><emphasis role="bold">Effects</emphasis>: Replaces replace_this in its position in the container with with_this. The container does not need to be rebalanced.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if with_this is not equivalent to *replace_this according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. </para></description></method>
<method name="remove_node"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: removes "value" from the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic time.</para><para><emphasis role="bold">Note</emphasis>: This static function is only usable with non-constant time size containers that have stateless comparison functors.</para><para>If the user calls this function with a constant time size container or stateful comparison functor a compilation error will be issued. </para></description></method>
<method name="merge"><type>void</type><template>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="source"><paramtype><classname>set</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="source"><paramtype><classname>multiset</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container with given comparison and traits.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype><default>key_compare()</default></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type. cmp must be a comparison function that induces a strict weak ordering.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container and inserts elements from [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if [b, e) is already sorted using comp and otherwise N * log N, where N is the distance between first and last.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor/operator() of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>set</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a container moving resources from another container. Internal comparison object and value traits are move constructed and nodes belonging to x (except the node representing the "end") are linked to *this.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node's move constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the move constructor of the comparison objet throws. </para></description></constructor>
<copy-assignment><type><classname>set</classname> &amp;</type><parameter name="x"><paramtype><classname>set</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to swap </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the set are not deleted (i.e. no destructors are called), but the nodes according to the <classname alt="boost::intrusive::value_traits">value_traits</classname> template parameter are reinitialized and thus can be reused.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor>
<method-group name="public static functions">
<method name="container_from_end_iterator" specifiers="static"><type><classname>set</classname> &amp;</type><parameter name="end_iterator"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_end_iterator" specifiers="static"><type>const <classname>set</classname> &amp;</type><parameter name="end_iterator"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type><classname>set</classname> &amp;</type><parameter name="it"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type>const <classname>set</classname> &amp;</type><parameter name="it"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="init_node" specifiers="static"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value shall not be in a container.</para><para><emphasis role="bold">Effects</emphasis>: init_node puts the hook of a value in a well-known default state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: This function puts the hook in the well-known default state used by auto_unlink and safe hooks. </para></description></method>
</method-group>
</class>



















<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype><classname>set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype><classname>multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>






















</namespace>
</namespace>
</header>
<header name="boost/intrusive/set_hook.hpp">
<namespace name="boost">
<namespace name="intrusive">
<struct name="make_set_base_hook"><template>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput><classname alt="boost::intrusive::set_base_hook">set_base_hook</classname></computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct><struct name="make_set_member_hook"><template>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput><classname alt="boost::intrusive::set_member_hook">set_member_hook</classname></computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct><class name="set_base_hook"><template>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><inherit access="public">make_set_base_hook::type&lt; O1, O2, O3, O4 &gt;</inherit><description><para>Derive a class from <classname alt="boost::intrusive::set_base_hook">set_base_hook</classname> in order to store objects in in a set/multiset. <classname alt="boost::intrusive::set_base_hook">set_base_hook</classname> holds the data necessary to maintain the set/multiset and provides an appropriate <classname alt="boost::intrusive::value_traits">value_traits</classname> class for set/multiset.</para><para>The hook admits the following options: <computeroutput>tag&lt;&gt;</computeroutput>, <computeroutput>void_pointer&lt;&gt;</computeroutput>, <computeroutput>link_mode&lt;&gt;</computeroutput> and <computeroutput>optimize_size&lt;&gt;</computeroutput>.</para><para><computeroutput>tag&lt;&gt;</computeroutput> defines a tag to identify the node. The same tag value can be used in different classes, but if a class is derived from more than one <computeroutput><classname alt="boost::intrusive::list_base_hook">list_base_hook</classname></computeroutput>, then each <computeroutput><classname alt="boost::intrusive::list_base_hook">list_base_hook</classname></computeroutput> needs its unique tag.</para><para><computeroutput>void_pointer&lt;&gt;</computeroutput> is the pointer type that will be used internally in the hook and the container configured to use this hook.</para><para><computeroutput>link_mode&lt;&gt;</computeroutput> will specify the linking mode of the hook (<computeroutput>normal_link</computeroutput>, <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput>).</para><para><computeroutput>optimize_size&lt;&gt;</computeroutput> will tell the hook to optimize the hook for size instead of speed. </para></description><method-group name="public member functions">
<method name="swap_nodes"><type>void</type><parameter name="other"><paramtype><classname>set_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swapping two nodes swaps the position of the elements related to those nodes in one or two containers. That is, if the node this is part of the element e1, the node x is part of the element e2 and both elements are included in the containers s1 and s2, then after the swap-operation e1 is in s2 at the position of e2 and e2 is in s1 at the position of e1. If one element is not in a container, then after the swap-operation the other element is not in a container. Iterators to e1 and e2 related to those nodes are invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="is_linked" cv="const"><type>bool</type><description><para><emphasis role="bold">Precondition</emphasis>: <classname alt="boost::intrusive::link_mode">link_mode</classname> must be <computeroutput>safe_link</computeroutput> or <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: true, if the node belongs to a container, false otherwise. This function can be used to test whether <computeroutput>set::iterator_to</computeroutput> will return a valid iterator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method>
<method name="unlink"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the node if it's inserted in a container. This function is only allowed if <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></constructor>
<constructor><parameter name=""><paramtype>const <classname>set_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing a copy-constructor makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></constructor>
<copy-assignment><type><classname>set_base_hook</classname> &amp;</type><parameter name=""><paramtype>const <classname>set_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Empty function. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing an assignment operator makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>normal_link</computeroutput>, the destructor does nothing (ie. no code is generated). If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>safe_link</computeroutput> and the object is stored in a set an assertion is raised. If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> and <computeroutput>is_linked()</computeroutput> is true, the node is unlinked.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor>
</class><class name="set_member_hook"><template>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><inherit access="public">make_set_member_hook::type&lt; O1, O2, O3, O4 &gt;</inherit><description><para>Put a public data member <classname alt="boost::intrusive::set_member_hook">set_member_hook</classname> in order to store objects of this class in a set/multiset. <classname alt="boost::intrusive::set_member_hook">set_member_hook</classname> holds the data necessary for maintaining the set/multiset and provides an appropriate <classname alt="boost::intrusive::value_traits">value_traits</classname> class for set/multiset.</para><para>The hook admits the following options: <computeroutput>void_pointer&lt;&gt;</computeroutput>, <computeroutput>link_mode&lt;&gt;</computeroutput> and <computeroutput>optimize_size&lt;&gt;</computeroutput>.</para><para><computeroutput>void_pointer&lt;&gt;</computeroutput> is the pointer type that will be used internally in the hook and the container configured to use this hook.</para><para><computeroutput>link_mode&lt;&gt;</computeroutput> will specify the linking mode of the hook (<computeroutput>normal_link</computeroutput>, <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput>).</para><para><computeroutput>optimize_size&lt;&gt;</computeroutput> will tell the hook to optimize the hook for size instead of speed. </para></description><method-group name="public member functions">
<method name="swap_nodes"><type>void</type><parameter name="other"><paramtype><classname>set_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swapping two nodes swaps the position of the elements related to those nodes in one or two containers. That is, if the node this is part of the element e1, the node x is part of the element e2 and both elements are included in the containers s1 and s2, then after the swap-operation e1 is in s2 at the position of e2 and e2 is in s1 at the position of e1. If one element is not in a container, then after the swap-operation the other element is not in a container. Iterators to e1 and e2 related to those nodes are invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="is_linked" cv="const"><type>bool</type><description><para><emphasis role="bold">Precondition</emphasis>: <classname alt="boost::intrusive::link_mode">link_mode</classname> must be <computeroutput>safe_link</computeroutput> or <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: true, if the node belongs to a container, false otherwise. This function can be used to test whether <computeroutput>set::iterator_to</computeroutput> will return a valid iterator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method>
<method name="unlink"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the node if it's inserted in a container. This function is only allowed if <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></constructor>
<constructor><parameter name=""><paramtype>const <classname>set_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing a copy-constructor makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></constructor>
<copy-assignment><type><classname>set_member_hook</classname> &amp;</type><parameter name=""><paramtype>const <classname>set_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Empty function. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing an assignment operator makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>normal_link</computeroutput>, the destructor does nothing (ie. no code is generated). If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>safe_link</computeroutput> and the object is stored in a set an assertion is raised. If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> and <computeroutput>is_linked()</computeroutput> is true, the node is unlinked.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor>
</class>



















































</namespace>
</namespace>
</header>
<header name="boost/intrusive/sg_set.hpp">
<namespace name="boost">
<namespace name="intrusive">
<struct name="make_sg_multiset"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput><classname alt="boost::intrusive::sg_multiset">sg_multiset</classname></computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct><struct name="make_sg_set"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput><classname alt="boost::intrusive::sg_set">sg_set</classname></computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct><class name="sg_multiset"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>The class template <classname alt="boost::intrusive::sg_multiset">sg_multiset</classname> is an intrusive container, that mimics most of the interface of std::sg_multiset as described in the C++ standard.</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>floating_point&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput> and <computeroutput>compare&lt;&gt;</computeroutput>. </para></description><typedef name="value_type"><type>implementation_defined::value_type</type></typedef>
<typedef name="key_type"><type>implementation_defined::key_type</type></typedef>
<typedef name="key_of_value"><type>implementation_defined::key_of_value</type></typedef>
<typedef name="value_traits"><type>implementation_defined::value_traits</type></typedef>
<typedef name="pointer"><type>implementation_defined::pointer</type></typedef>
<typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef>
<typedef name="reference"><type>implementation_defined::reference</type></typedef>
<typedef name="const_reference"><type>implementation_defined::const_reference</type></typedef>
<typedef name="difference_type"><type>implementation_defined::difference_type</type></typedef>
<typedef name="size_type"><type>implementation_defined::size_type</type></typedef>
<typedef name="value_compare"><type>implementation_defined::value_compare</type></typedef>
<typedef name="key_compare"><type>implementation_defined::key_compare</type></typedef>
<typedef name="iterator"><type>implementation_defined::iterator</type></typedef>
<typedef name="const_iterator"><type>implementation_defined::const_iterator</type></typedef>
<typedef name="reverse_iterator"><type>implementation_defined::reverse_iterator</type></typedef>
<typedef name="const_reverse_iterator"><type>implementation_defined::const_reverse_iterator</type></typedef>
<typedef name="insert_commit_data"><type>implementation_defined::insert_commit_data</type></typedef>
<typedef name="node_traits"><type>implementation_defined::node_traits</type></typedef>
<typedef name="node"><type>implementation_defined::node</type></typedef>
<typedef name="node_ptr"><type>implementation_defined::node_ptr</type></typedef>
<typedef name="const_node_ptr"><type>implementation_defined::const_node_ptr</type></typedef>
<typedef name="node_algorithms"><type>implementation_defined::node_algorithms</type></typedef>
<data-member name="constant_time_size" specifiers="static"><type>const bool</type></data-member>
<method-group name="public member functions">
<method name="begin"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rbegin"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a iterator pointing to the root node of the container or end() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="croot" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the key_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If key_compare copy-constructor throws. </para></description></method>
<method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the value_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_compare copy-constructor throws. </para></description></method>
<method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this if constant-time size option is disabled. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="swap"><type>void</type><parameter name="other"><paramtype><classname>sg_multiset</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of two containers.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison functor's swap call throws. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>sg_multiset</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee. Additional notes: it also copies the alpha factor from the source container. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype><classname>sg_multiset</classname> &amp;&amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(reference) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: This version can modify the source container, useful to implement move semantics. Additional notes: it also copies the alpha factor from the source container. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the container before the upper bound.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal key_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and "hint" must be a valid iterator.</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container, using "hint" as a hint to where it will be inserted. If "hint" is the upper_bound the insertion takes constant time (two comparisons in the worst case)</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the internal key_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Inserts a each element of a range into the container before the upper bound of the key of each element.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_before"><type>iterator</type><parameter name="pos"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, "pos" must be a valid iterator (or end) and must be the succesor of value once inserted according to the predicate</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container before "pos".</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if "pos" is not the successor of "value" container ordering invariant will be broken. This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_back"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no less than the greatest inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the last position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is less than the greatest inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_front"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no greater than the minimum inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the first position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is greater than the minimum inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="i"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp".</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk) and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="clear"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="clear_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements calling disposer(p) for each node to be erased. <emphasis role="bold">Complexity</emphasis>: Average complexity for is at most O(log(size() + N)), where N is the number of elements in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. Calls N times to disposer functor. </para></description></method>
<method name="count" cv="const"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given value</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given value.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="count" cv="const"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="lower_bound"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="find"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="find"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="lower_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="lower_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="iterator_to"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="unlink_leftmost_without_rebalance"><type>pointer</type><description><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the container.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the container and the container can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the container. </para></description></method>
<method name="replace_node"><type>void</type><parameter name="replace_this"><paramtype>iterator</paramtype></parameter><parameter name="with_this"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: replace_this must be a valid iterator of *this and with_this must not be inserted in any container.</para><para><emphasis role="bold">Effects</emphasis>: Replaces replace_this in its position in the container with with_this. The container does not need to be rebalanced.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if with_this is not equivalent to *replace_this according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. </para></description></method>
<method name="remove_node"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: removes "value" from the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic time.</para><para><emphasis role="bold">Note</emphasis>: This static function is only usable with non-constant time size containers that have stateless comparison functors.</para><para>If the user calls this function with a constant time size container or stateful comparison functor a compilation error will be issued. </para></description></method>
<method name="rebalance"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Rebalances the tree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear. </para></description></method>
<method name="rebalance_subtree"><type>iterator</type><parameter name="root"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: old_root is a node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Rebalances the subtree rooted at old_root.</para><para><emphasis role="bold">Returns</emphasis>: The new root of the subtree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements in the subtree. </para></description></method>
<method name="balance_factor" cv="const"><type>float</type><description><para><emphasis role="bold">Returns</emphasis>: The balance factor (alpha) used in this tree</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="balance_factor"><type>void</type><parameter name="new_alpha"><paramtype>float</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: new_alpha must be a value between 0.5 and 1.0</para><para><emphasis role="bold">Effects</emphasis>: Establishes a new balance factor (alpha) and rebalances the tree if the new balance factor is stricter (less) than the old factor.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements in the subtree. </para></description></method>
<method name="merge"><type>void</type><template>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="source"><paramtype><classname>sg_multiset</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="source"><paramtype><classname>sg_set</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container with given comparison and traits.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype><default>key_compare()</default></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type. cmp must be a comparison function that induces a strict weak ordering.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container and inserts elements from [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if [b, e) is already sorted using comp and otherwise N * log N, where N is the distance between first and last.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor/operator() of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>sg_multiset</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a container moving resources from another container. Internal comparison object and value traits are move constructed and nodes belonging to x (except the node representing the "end") are linked to *this.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node's move constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the move constructor of the comparison objet throws. </para></description></constructor>
<copy-assignment><type><classname>sg_multiset</classname> &amp;</type><parameter name="x"><paramtype><classname>sg_multiset</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to swap </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the set are not deleted (i.e. no destructors are called), but the nodes according to the <classname alt="boost::intrusive::value_traits">value_traits</classname> template parameter are reinitialized and thus can be reused.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor>
<method-group name="public static functions">
<method name="container_from_end_iterator" specifiers="static"><type><classname>sg_multiset</classname> &amp;</type><parameter name="end_iterator"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_end_iterator" specifiers="static"><type>const <classname>sg_multiset</classname> &amp;</type><parameter name="end_iterator"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type><classname>sg_multiset</classname> &amp;</type><parameter name="it"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type>const <classname>sg_multiset</classname> &amp;</type><parameter name="it"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="init_node" specifiers="static"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value shall not be in a container.</para><para><emphasis role="bold">Effects</emphasis>: init_node puts the hook of a value in a well-known default state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: This function puts the hook in the well-known default state used by auto_unlink and safe hooks. </para></description></method>
</method-group>
</class><class name="sg_set"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>The class template <classname alt="boost::intrusive::sg_set">sg_set</classname> is an intrusive container, that mimics most of the interface of std::sg_set as described in the C++ standard.</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>floating_point&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput> and <computeroutput>compare&lt;&gt;</computeroutput>. </para></description><typedef name="value_type"><type>implementation_defined::value_type</type></typedef>
<typedef name="key_type"><type>implementation_defined::key_type</type></typedef>
<typedef name="key_of_value"><type>implementation_defined::key_of_value</type></typedef>
<typedef name="value_traits"><type>implementation_defined::value_traits</type></typedef>
<typedef name="pointer"><type>implementation_defined::pointer</type></typedef>
<typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef>
<typedef name="reference"><type>implementation_defined::reference</type></typedef>
<typedef name="const_reference"><type>implementation_defined::const_reference</type></typedef>
<typedef name="difference_type"><type>implementation_defined::difference_type</type></typedef>
<typedef name="size_type"><type>implementation_defined::size_type</type></typedef>
<typedef name="value_compare"><type>implementation_defined::value_compare</type></typedef>
<typedef name="key_compare"><type>implementation_defined::key_compare</type></typedef>
<typedef name="iterator"><type>implementation_defined::iterator</type></typedef>
<typedef name="const_iterator"><type>implementation_defined::const_iterator</type></typedef>
<typedef name="reverse_iterator"><type>implementation_defined::reverse_iterator</type></typedef>
<typedef name="const_reverse_iterator"><type>implementation_defined::const_reverse_iterator</type></typedef>
<typedef name="insert_commit_data"><type>implementation_defined::insert_commit_data</type></typedef>
<typedef name="node_traits"><type>implementation_defined::node_traits</type></typedef>
<typedef name="node"><type>implementation_defined::node</type></typedef>
<typedef name="node_ptr"><type>implementation_defined::node_ptr</type></typedef>
<typedef name="const_node_ptr"><type>implementation_defined::const_node_ptr</type></typedef>
<typedef name="node_algorithms"><type>implementation_defined::node_algorithms</type></typedef>
<data-member name="constant_time_size" specifiers="static"><type>const bool</type></data-member>
<method-group name="public member functions">
<method name="begin"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rbegin"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a iterator pointing to the root node of the container or end() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="croot" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the key_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If key_compare copy-constructor throws. </para></description></method>
<method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the value_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_compare copy-constructor throws. </para></description></method>
<method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this if constant-time size option is disabled. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="swap"><type>void</type><parameter name="other"><paramtype><classname>sg_set</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of two containers.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison functor's swap call throws. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>sg_set</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee. Additional notes: it also copies the alpha factor from the source container. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype><classname>sg_set</classname> &amp;&amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(reference) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: This version can modify the source container, useful to implement move semantics. Additional notes: it also copies the alpha factor from the source container. </para></description></method>
<method name="insert"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the container if the value is not already present.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and "hint" must be a valid iterator</para><para><emphasis role="bold">Effects</emphasis>: Tries to insert x into the container, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time (two comparisons in the worst case) if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_check"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee. </para></description></method>
<method name="insert_check"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it's amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee. </para></description></method>
<method name="insert_check"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must be a comparison function that induces the same strict weak ordering as key_compare. The difference is that comp compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the container. </para></description></method>
<method name="insert_check"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must be a comparison function that induces the same strict weak ordering as key_compare. The difference is that comp compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it's amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the constructing that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that key to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This can give a total constant-time complexity to the insertion: check(O(1)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the container. </para></description></method>
<method name="insert"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Tries to insert each element of a range into the container.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_commit"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><parameter name="commit_data"><paramtype>const insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue of type value_type. commit_data must have been obtained from a previous call to "insert_check". No objects should have been inserted or erased from the container between the "insert_check" that filled "commit_data" and the call to "insert_commit".</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value in the container using the information obtained from the "commit_data" that a previous "insert_check" filled.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the newly inserted object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function has only sense if a "insert_check" has been previously executed to fill "commit_data". No value should be inserted or erased between the "insert_check" and "insert_commit" calls. </para></description></method>
<method name="insert_before"><type>iterator</type><parameter name="pos"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, "pos" must be a valid iterator (or end) and must be the succesor of value once inserted according to the predicate</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container before "pos".</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if "pos" is not the successor of "value" container ordering invariant will be broken. This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_back"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no less than the greatest inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the last position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is less than the greatest inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_front"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no greater than the minimum inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the first position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is greater than the minimum inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="i"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp".</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk) and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="clear"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="clear_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements calling disposer(p) for each node to be erased. <emphasis role="bold">Complexity</emphasis>: Average complexity for is at most O(log(size() + N)), where N is the number of elements in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. Calls N times to disposer functor. </para></description></method>
<method name="count" cv="const"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given value</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given value.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="count" cv="const"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="lower_bound"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="find"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="find"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="lower_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="lower_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="iterator_to"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="unlink_leftmost_without_rebalance"><type>pointer</type><description><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the container.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the container and the container can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the container. </para></description></method>
<method name="replace_node"><type>void</type><parameter name="replace_this"><paramtype>iterator</paramtype></parameter><parameter name="with_this"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: replace_this must be a valid iterator of *this and with_this must not be inserted in any container.</para><para><emphasis role="bold">Effects</emphasis>: Replaces replace_this in its position in the container with with_this. The container does not need to be rebalanced.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if with_this is not equivalent to *replace_this according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. </para></description></method>
<method name="remove_node"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: removes "value" from the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic time.</para><para><emphasis role="bold">Note</emphasis>: This static function is only usable with non-constant time size containers that have stateless comparison functors.</para><para>If the user calls this function with a constant time size container or stateful comparison functor a compilation error will be issued. </para></description></method>
<method name="rebalance"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Rebalances the tree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear. </para></description></method>
<method name="rebalance_subtree"><type>iterator</type><parameter name="root"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: old_root is a node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Rebalances the subtree rooted at old_root.</para><para><emphasis role="bold">Returns</emphasis>: The new root of the subtree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements in the subtree. </para></description></method>
<method name="balance_factor" cv="const"><type>float</type><description><para><emphasis role="bold">Returns</emphasis>: The balance factor (alpha) used in this tree</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="balance_factor"><type>void</type><parameter name="new_alpha"><paramtype>float</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: new_alpha must be a value between 0.5 and 1.0</para><para><emphasis role="bold">Effects</emphasis>: Establishes a new balance factor (alpha) and rebalances the tree if the new balance factor is stricter (less) than the old factor.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements in the subtree. </para></description></method>
<method name="merge"><type>void</type><template>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="source"><paramtype><classname>sg_set</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="source"><paramtype><classname>sg_multiset</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container with given comparison and traits.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype><default>key_compare()</default></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type. cmp must be a comparison function that induces a strict weak ordering.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container and inserts elements from [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if [b, e) is already sorted using comp and otherwise N * log N, where N is the distance between first and last.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor/operator() of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>sg_set</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a container moving resources from another container. Internal comparison object and value traits are move constructed and nodes belonging to x (except the node representing the "end") are linked to *this.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node's move constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the move constructor of the comparison objet throws. </para></description></constructor>
<copy-assignment><type><classname>sg_set</classname> &amp;</type><parameter name="x"><paramtype><classname>sg_set</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to swap </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the set are not deleted (i.e. no destructors are called), but the nodes according to the <classname alt="boost::intrusive::value_traits">value_traits</classname> template parameter are reinitialized and thus can be reused.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor>
<method-group name="public static functions">
<method name="container_from_end_iterator" specifiers="static"><type><classname>sg_set</classname> &amp;</type><parameter name="end_iterator"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_end_iterator" specifiers="static"><type>const <classname>sg_set</classname> &amp;</type><parameter name="end_iterator"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type><classname>sg_set</classname> &amp;</type><parameter name="it"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type>const <classname>sg_set</classname> &amp;</type><parameter name="it"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="init_node" specifiers="static"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value shall not be in a container.</para><para><emphasis role="bold">Effects</emphasis>: init_node puts the hook of a value in a well-known default state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: This function puts the hook in the well-known default state used by auto_unlink and safe hooks. </para></description></method>
</method-group>
</class>









<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>sg_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>sg_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>sg_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>sg_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>sg_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>sg_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>sg_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>sg_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype><classname>sg_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>sg_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>sg_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>sg_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>sg_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>sg_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>sg_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>sg_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>sg_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>sg_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype><classname>sg_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>sg_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
































</namespace>
</namespace>
</header>
<header name="boost/intrusive/sgtree.hpp">
<namespace name="boost">
<namespace name="intrusive">
<struct name="make_sgtree"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>sgtree</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct><class name="sgtree"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>The class template sgtree is an intrusive scapegoat tree container, that is used to construct intrusive <classname alt="boost::intrusive::sg_set">sg_set</classname> and <classname alt="boost::intrusive::sg_multiset">sg_multiset</classname> containers. The no-throw guarantee holds only, if the value_compare object doesn't throw.</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>floating_point&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput> and <computeroutput>compare&lt;&gt;</computeroutput>. </para></description><typedef name="value_traits"><type>ValueTraits</type></typedef>
<typedef name="pointer"><type>implementation_defined::pointer</type></typedef>
<typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef>
<typedef name="value_type"><type>implementation_defined::value_type</type></typedef>
<typedef name="key_type"><type>implementation_defined::key_type</type></typedef>
<typedef name="key_of_value"><type>implementation_defined::key_of_value</type></typedef>
<typedef name="reference"><type>implementation_defined::reference</type></typedef>
<typedef name="const_reference"><type>implementation_defined::const_reference</type></typedef>
<typedef name="difference_type"><type>implementation_defined::difference_type</type></typedef>
<typedef name="size_type"><type>implementation_defined::size_type</type></typedef>
<typedef name="value_compare"><type>implementation_defined::value_compare</type></typedef>
<typedef name="key_compare"><type>implementation_defined::key_compare</type></typedef>
<typedef name="iterator"><type>implementation_defined::iterator</type></typedef>
<typedef name="const_iterator"><type>implementation_defined::const_iterator</type></typedef>
<typedef name="reverse_iterator"><type>implementation_defined::reverse_iterator</type></typedef>
<typedef name="const_reverse_iterator"><type>implementation_defined::const_reverse_iterator</type></typedef>
<typedef name="node_traits"><type>implementation_defined::node_traits</type></typedef>
<typedef name="node"><type>implementation_defined::node</type></typedef>
<typedef name="node_ptr"><type>implementation_defined::node_ptr</type></typedef>
<typedef name="const_node_ptr"><type>implementation_defined::const_node_ptr</type></typedef>
<typedef name="node_algorithms"><type>implementation_defined</type></typedef>
<typedef name="insert_commit_data"><type>implementation_defined</type></typedef>
<data-member name="constant_time_size" specifiers="static"><type>const bool</type></data-member>
<data-member name="floating_point" specifiers="static"><type>const bool</type></data-member>
<data-member name="stateful_value_traits" specifiers="static"><type>const bool</type></data-member>
<method-group name="public member functions">
<method name="begin"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rbegin"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a iterator pointing to the root node of the container or end() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="croot" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the key_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If key_compare copy-constructor throws. </para></description></method>
<method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the value_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_compare copy-constructor throws. </para></description></method>
<method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this if constant-time size option is disabled. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="swap"><type>void</type><parameter name="other"><paramtype><classname>sgtree</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of two containers.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison functor's swap call throws. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>sgtree</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee. Additional notes: it also copies the alpha factor from the source container. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype><classname>sgtree</classname> &amp;&amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(reference) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: This version can modify the source container, useful to implement move semantics. Additional notes: it also copies the alpha factor from the source container. </para></description></method>
<method name="insert_equal"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the container before the upper bound.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal key_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_equal"><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and "hint" must be a valid iterator.</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container, using "hint" as a hint to where it will be inserted. If "hint" is the upper_bound the insertion takes constant time (two comparisons in the worst case)</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the internal key_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_equal"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Inserts a each element of a range into the container before the upper bound of the key of each element.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_unique"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the container if the value is not already present.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_unique"><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and "hint" must be a valid iterator</para><para><emphasis role="bold">Effects</emphasis>: Tries to insert x into the container, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time (two comparisons in the worst case) if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_unique_check"><type>std::pair&lt; iterator BOOST_INTRUSIVE_I bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must be a comparison function that induces the same strict weak ordering as key_compare. The difference is that comp compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the container. </para></description></method>
<method name="insert_unique_check"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must be a comparison function that induces the same strict weak ordering as key_compare. The difference is that comp compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it's amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the constructing that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that key to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This can give a total constant-time complexity to the insertion: check(O(1)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the container. </para></description></method>
<method name="insert_unique_check"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee. </para></description></method>
<method name="insert_unique_check"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it's amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee. </para></description></method>
<method name="insert_unique_commit"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><parameter name="commit_data"><paramtype>const insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue of type value_type. commit_data must have been obtained from a previous call to "insert_check". No objects should have been inserted or erased from the container between the "insert_check" that filled "commit_data" and the call to "insert_commit".</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value in the container using the information obtained from the "commit_data" that a previous "insert_check" filled.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the newly inserted object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function has only sense if a "insert_check" has been previously executed to fill "commit_data". No value should be inserted or erased between the "insert_check" and "insert_commit" calls. </para></description></method>
<method name="insert_unique"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Tries to insert each element of a range into the container.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_before"><type>iterator</type><parameter name="pos"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, "pos" must be a valid iterator (or end) and must be the succesor of value once inserted according to the predicate</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container before "pos".</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if "pos" is not the successor of "value" container ordering invariant will be broken. This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_back"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no less than the greatest inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the last position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is less than the greatest inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_front"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no greater than the minimum inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the first position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is greater than the minimum inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="i"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp".</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk) and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="clear"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="clear_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements calling disposer(p) for each node to be erased. <emphasis role="bold">Complexity</emphasis>: Average complexity for is at most O(log(size() + N)), where N is the number of elements in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. Calls N times to disposer functor. </para></description></method>
<method name="merge_unique"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name=""><paramtype><classname>sgtree</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="while"><type/><parameter name=""><paramtype>it !</paramtype><default>itend</default></parameter></method>
<method name="merge_equal"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name=""><paramtype><classname>sgtree</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Extracts each element in source and insert it into a using the comparison object of *this.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="while"><type/><parameter name=""><paramtype>it !</paramtype><default>itend</default></parameter></method>
<method name="count" cv="const"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given value</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given value.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="count" cv="const"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="lower_bound"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="find"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="find"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="lower_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="lower_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="iterator_to"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="unlink_leftmost_without_rebalance"><type>pointer</type><description><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the container.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the container and the container can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the container. </para></description></method>
<method name="replace_node"><type>void</type><parameter name="replace_this"><paramtype>iterator</paramtype></parameter><parameter name="with_this"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: replace_this must be a valid iterator of *this and with_this must not be inserted in any container.</para><para><emphasis role="bold">Effects</emphasis>: Replaces replace_this in its position in the container with with_this. The container does not need to be rebalanced.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if with_this is not equivalent to *replace_this according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. </para></description></method>
<method name="remove_node"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: removes "value" from the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic time.</para><para><emphasis role="bold">Note</emphasis>: This static function is only usable with non-constant time size containers that have stateless comparison functors.</para><para>If the user calls this function with a constant time size container or stateful comparison functor a compilation error will be issued. </para></description></method>
<method name="rebalance"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Rebalances the tree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear. </para></description></method>
<method name="rebalance_subtree"><type>iterator</type><parameter name="root"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: old_root is a node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Rebalances the subtree rooted at old_root.</para><para><emphasis role="bold">Returns</emphasis>: The new root of the subtree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements in the subtree. </para></description></method>
<method name="balance_factor" cv="const"><type>float</type><description><para><emphasis role="bold">Returns</emphasis>: The balance factor (alpha) used in this tree</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="balance_factor"><type>void</type><parameter name="new_alpha"><paramtype>float</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: new_alpha must be a value between 0.5 and 1.0</para><para><emphasis role="bold">Effects</emphasis>: Establishes a new balance factor (alpha) and rebalances the tree if the new balance factor is stricter (less) than the old factor.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements in the subtree. </para></description></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container with given comparison and traits.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="unique"><paramtype>bool</paramtype></parameter><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype><default>key_compare()</default></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type. cmp must be a comparison function that induces a strict weak ordering.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container and inserts elements from [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if [b, e) is already sorted using comp and otherwise N * log N, where N is the distance between first and last.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor/operator() of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>sgtree</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a container moving resources from another container. Internal comparison object and value traits are move constructed and nodes belonging to x (except the node representing the "end") are linked to *this.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node's move constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the move constructor of the comparison objet throws. </para></description></constructor>
<copy-assignment><type><classname>sgtree</classname> &amp;</type><parameter name="x"><paramtype><classname>sgtree</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to swap </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the set are not deleted (i.e. no destructors are called), but the nodes according to the <classname alt="boost::intrusive::value_traits">value_traits</classname> template parameter are reinitialized and thus can be reused.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor>
<method-group name="public static functions">
<method name="container_from_end_iterator" specifiers="static"><type><classname>sgtree</classname> &amp;</type><parameter name="end_iterator"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_end_iterator" specifiers="static"><type>const <classname>sgtree</classname> &amp;</type><parameter name="end_iterator"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type><classname>sgtree</classname> &amp;</type><parameter name="it"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type>const <classname>sgtree</classname> &amp;</type><parameter name="it"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="init_node" specifiers="static"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value shall not be in a container.</para><para><emphasis role="bold">Effects</emphasis>: init_node puts the hook of a value in a well-known default state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: This function puts the hook in the well-known default state used by auto_unlink and safe hooks. </para></description></method>
</method-group>
</class>



















































</namespace>
</namespace>
</header>
<header name="boost/intrusive/sgtree_algorithms.hpp">
<namespace name="boost">
<namespace name="intrusive">
<class name="sgtree_algorithms"><template>
      <template-type-parameter name="NodeTraits"/>
    </template><description><para><classname alt="boost::intrusive::sgtree_algorithms">sgtree_algorithms</classname> is configured with a NodeTraits class, which encapsulates the information about the node to be manipulated. NodeTraits must support the following interface:</para><para><emphasis role="bold">Typedefs</emphasis>:</para><para><computeroutput>node</computeroutput>: The type of the node that forms the binary search tree</para><para><computeroutput>node_ptr</computeroutput>: A pointer to a node</para><para><computeroutput>const_node_ptr</computeroutput>: A pointer to a const node</para><para><emphasis role="bold">Static functions</emphasis>:</para><para><computeroutput>static node_ptr get_parent(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_parent(node_ptr n, node_ptr parent);</computeroutput></para><para><computeroutput>static node_ptr get_left(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_left(node_ptr n, node_ptr left);</computeroutput></para><para><computeroutput>static node_ptr get_right(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_right(node_ptr n, node_ptr right);</computeroutput> </para></description><struct name="insert_commit_data"><inherit access="public">insert_commit_data</inherit><description><para>This type is the information that will be filled by insert_unique_check </para></description><data-member name="depth"><type>std::size_t</type></data-member>
</struct><typedef name="node"><type>NodeTraits::node</type></typedef>
<typedef name="node_traits"><type>NodeTraits</type></typedef>
<typedef name="node_ptr"><type>NodeTraits::node_ptr</type></typedef>
<typedef name="const_node_ptr"><type>NodeTraits::const_node_ptr</type></typedef>
<method-group name="public static functions">
<method name="get_header" specifiers="static"><type>node_ptr</type><parameter name="n"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'node' is a node of the tree or a header node.</para><para><emphasis role="bold">Effects</emphasis>: Returns the header of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="begin_node" specifiers="static"><type>node_ptr</type><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'header' is the header node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Returns the first node of the tree, the header if the tree is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end_node" specifiers="static"><type>node_ptr</type><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'header' is the header node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Returns the header of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="swap_tree" specifiers="static"><type>void</type><parameter name="header1"><paramtype>node_ptr</paramtype></parameter><parameter name="header2"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header1 and header2 must be the header nodes of two trees.</para><para><emphasis role="bold">Effects</emphasis>: Swaps two trees. After the function header1 will contain links to the second tree and header2 will have links to the first tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="swap_nodes" specifiers="static"><type>void</type><parameter name="node1"><paramtype>node_ptr</paramtype></parameter><parameter name="node2"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node1 and node2 can't be header nodes of two trees.</para><para><emphasis role="bold">Effects</emphasis>: Swaps two nodes. After the function node1 will be inserted in the position node2 before the function. node2 will be inserted in the position node1 had before the function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if node1 and node2 are not equivalent according to the ordering rules.</para><para>Experimental function </para></description></method>
<method name="swap_nodes" specifiers="static"><type>void</type><parameter name="node1"><paramtype>node_ptr</paramtype></parameter><parameter name="header1"><paramtype>node_ptr</paramtype></parameter><parameter name="node2"><paramtype>node_ptr</paramtype></parameter><parameter name="header2"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node1 and node2 can't be header nodes of two trees with header header1 and header2.</para><para><emphasis role="bold">Effects</emphasis>: Swaps two nodes. After the function node1 will be inserted in the position node2 before the function. node2 will be inserted in the position node1 had before the function.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if node1 and node2 are not equivalent according to the ordering rules.</para><para>Experimental function </para></description></method>
<method name="replace_node" specifiers="static"><type>void</type><parameter name="node_to_be_replaced"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node_to_be_replaced must be inserted in a tree and new_node must not be inserted in a tree.</para><para><emphasis role="bold">Effects</emphasis>: Replaces node_to_be_replaced in its position in the tree with new_node. The tree does not need to be rebalanced</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if new_node is not equivalent to node_to_be_replaced according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing and comparison is needed. Experimental function </para></description></method>
<method name="replace_node" specifiers="static"><type>void</type><parameter name="node_to_be_replaced"><paramtype>node_ptr</paramtype></parameter><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node_to_be_replaced must be inserted in a tree with header "header" and new_node must not be inserted in a tree.</para><para><emphasis role="bold">Effects</emphasis>: Replaces node_to_be_replaced in its position in the tree with new_node. The tree does not need to be rebalanced</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if new_node is not equivalent to node_to_be_replaced according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. Experimental function </para></description></method>
<method name="unlink_leftmost_without_rebalance" specifiers="static"><type>node_ptr</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><purpose>static void unlink(node_ptr node); </purpose><description><para><emphasis role="bold">Requires</emphasis>: header is the header of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the tree, and updates the header link to the new leftmost node.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the tree and the tree can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the tree. </para></description></method>
<method name="unique" specifiers="static"><type>bool</type><parameter name="node"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'node' is a node of the tree or a node initialized by init(...) or init_node.</para><para><emphasis role="bold">Effects</emphasis>: Returns true if the node is initialized by init() or init_node().</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="size" specifiers="static"><type>std::size_t</type><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node is a node of the tree but it's not the header.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of nodes of the subtree.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="next_node" specifiers="static"><type>node_ptr</type><parameter name="node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'node' is a node from the tree except the header.</para><para><emphasis role="bold">Effects</emphasis>: Returns the next node of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="prev_node" specifiers="static"><type>node_ptr</type><parameter name="node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'node' is a node from the tree except the leftmost node.</para><para><emphasis role="bold">Effects</emphasis>: Returns the previous node of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="init" specifiers="static"><type>void</type><parameter name="node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'node' must not be part of any tree.</para><para><emphasis role="bold">Effects</emphasis>: After the function unique(node) == true.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Nodes</emphasis>: If node is inserted in a tree, this function corrupts the tree. </para></description></method>
<method name="init_header" specifiers="static"><type>void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node must not be part of any tree.</para><para><emphasis role="bold">Effects</emphasis>: Initializes the header to represent an empty tree. unique(header) == true.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Nodes</emphasis>: If node is inserted in a tree, this function corrupts the tree. </para></description></method>
<method name="erase" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="AlphaByMaxSize"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="z"><paramtype>node_ptr</paramtype></parameter><parameter name="tree_size"><paramtype>std::size_t</paramtype></parameter><parameter name="max_tree_size"><paramtype>std::size_t &amp;</paramtype></parameter><parameter name="alpha_by_maxsize"><paramtype>AlphaByMaxSize</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header must be the header of a tree, z a node of that tree and z != header.</para><para><emphasis role="bold">Effects</emphasis>: Erases node "z" from the tree with header "header".</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="clone" specifiers="static"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="source_header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="target_header"><paramtype>node_ptr</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "cloner" must be a function object taking a node_ptr and returning a new cloned node of it. "disposer" must take a node_ptr and shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: First empties target tree calling <computeroutput>void disposer::operator()(const node_ptr &amp;)</computeroutput> for every node of the tree except the header.</para><para>Then, duplicates the entire tree pointed by "source_header" cloning each source node with <computeroutput>node_ptr Cloner::operator()(const node_ptr &amp;)</computeroutput> to obtain the nodes of the target tree. If "cloner" throws, the cloned target nodes are disposed using <computeroutput>void disposer(const node_ptr &amp;)</computeroutput>.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of element of the source tree plus the number of elements of tree target tree when calling this function.</para><para><emphasis role="bold">Throws</emphasis>: If cloner functor throws. If this happens target nodes are disposed. </para></description></method>
<method name="clear_and_dispose" specifiers="static"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "disposer" must be an object function taking a node_ptr parameter and shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Empties the target tree calling <computeroutput>void disposer::operator()(const node_ptr &amp;)</computeroutput> for every node of the tree except the header.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of element of the source tree plus the. number of elements of tree target tree when calling this function.</para><para><emphasis role="bold">Throws</emphasis>: If cloner functor throws. If this happens target nodes are disposed. </para></description></method>
<method name="lower_bound" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns a node_ptr to the first element that is not less than "key" according to "comp" or "header" if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="upper_bound" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns a node_ptr to the first element that is greater than "key" according to "comp" or "header" if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="find" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns a node_ptr to the first element that is equivalent to "key" according to "comp" or "header" if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="equal_range" specifiers="static"><type>std::pair&lt; node_ptr, node_ptr &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair of node_ptr delimiting a range containing all elements that are equivalent to "key" according to "comp" or an empty range that indicates the position where those elements would be if there are no equivalent elements.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="bounded_range" specifiers="static"><type>std::pair&lt; node_ptr, node_ptr &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs. 'lower_key' must not be greater than 'upper_key' according to 'comp'. If 'lower_key' == 'upper_key', ('left_closed' || 'right_closed') must be true.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change. </para></description></method>
<method name="count" specifiers="static"><type>std::size_t</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements with a key equivalent to "key" according to "comp".</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="insert_equal_upper_bound" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="NodePtrCompare"/>
          <template-type-parameter name="H_Alpha"/>
        </template><parameter name="h"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><parameter name="tree_size"><paramtype>std::size_t</paramtype></parameter><parameter name="h_alpha"><paramtype>H_Alpha</paramtype></parameter><parameter name="max_tree_size"><paramtype>std::size_t &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "h" must be the header node of a tree. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares two node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree before the upper bound according to "comp".</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="insert_equal_lower_bound" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="NodePtrCompare"/>
          <template-type-parameter name="H_Alpha"/>
        </template><parameter name="h"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><parameter name="tree_size"><paramtype>std::size_t</paramtype></parameter><parameter name="h_alpha"><paramtype>H_Alpha</paramtype></parameter><parameter name="max_tree_size"><paramtype>std::size_t &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "h" must be the header node of a tree. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares two node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree before the lower bound according to "comp".</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="insert_equal" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="NodePtrCompare"/>
          <template-type-parameter name="H_Alpha"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="hint"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><parameter name="tree_size"><paramtype>std::size_t</paramtype></parameter><parameter name="h_alpha"><paramtype>H_Alpha</paramtype></parameter><parameter name="max_tree_size"><paramtype>std::size_t &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares two node_ptrs. "hint" is node from the "header"'s tree.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree, using "hint" as a hint to where it will be inserted. If "hint" is the upper_bound the insertion takes constant time (two comparisons in the worst case).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time if new_node is inserted immediately before "hint".</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="insert_before" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="H_Alpha"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="pos"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="tree_size"><paramtype>std::size_t</paramtype></parameter><parameter name="h_alpha"><paramtype>H_Alpha</paramtype></parameter><parameter name="max_tree_size"><paramtype>std::size_t &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. "pos" must be a valid iterator or header (end) node. "pos" must be an iterator pointing to the successor to "new_node" once inserted according to the order of already inserted nodes. This function does not check "pos" and this precondition must be guaranteed by the caller.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree before "pos".</para><para><emphasis role="bold">Complexity</emphasis>: Constant-time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: If "pos" is not the successor of the newly inserted "new_node" tree invariants might be broken. </para></description></method>
<method name="push_back" specifiers="static"><type>void</type><template>
          <template-type-parameter name="H_Alpha"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="tree_size"><paramtype>std::size_t</paramtype></parameter><parameter name="h_alpha"><paramtype>H_Alpha</paramtype></parameter><parameter name="max_tree_size"><paramtype>std::size_t &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. "new_node" must be, according to the used ordering no less than the greatest inserted key.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree before "pos".</para><para><emphasis role="bold">Complexity</emphasis>: Constant-time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: If "new_node" is less than the greatest inserted key tree invariants are broken. This function is slightly faster than using "insert_before". </para></description></method>
<method name="push_front" specifiers="static"><type>void</type><template>
          <template-type-parameter name="H_Alpha"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="tree_size"><paramtype>std::size_t</paramtype></parameter><parameter name="h_alpha"><paramtype>H_Alpha</paramtype></parameter><parameter name="max_tree_size"><paramtype>std::size_t &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. "new_node" must be, according to the used ordering, no greater than the lowest inserted key.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree before "pos".</para><para><emphasis role="bold">Complexity</emphasis>: Constant-time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: If "new_node" is greater than the lowest inserted key tree invariants are broken. This function is slightly faster than using "insert_before". </para></description></method>
<method name="insert_unique_check" specifiers="static"><type>std::pair&lt; node_ptr, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><parameter name="commit_data"><paramtype><classname>insert_commit_data</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares KeyType with a node_ptr.</para><para><emphasis role="bold">Effects</emphasis>: Checks if there is an equivalent node to "key" in the tree according to "comp" and obtains the needed information to realize a constant-time node insertion if there is no equivalent node.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing a node_ptr to the already present node and false. If there is not equivalent key can be inserted returns true in the returned pair's boolean and fills "commit_data" that is meant to be used with the "insert_commit" function to achieve a constant-time insertion function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a node is expensive and the user does not want to have two equivalent nodes in the tree: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the node and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the node and use "insert_commit" to insert the node in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_unique_commit" only if no more objects are inserted or erased from the set. </para></description></method>
<method name="insert_unique_check" specifiers="static"><type>std::pair&lt; node_ptr, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="hint"><paramtype>node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><parameter name="commit_data"><paramtype><classname>insert_commit_data</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares KeyType with a node_ptr. "hint" is node from the "header"'s tree.</para><para><emphasis role="bold">Effects</emphasis>: Checks if there is an equivalent node to "key" in the tree according to "comp" using "hint" as a hint to where it should be inserted and obtains the needed information to realize a constant-time node insertion if there is no equivalent node. If "hint" is the upper_bound the function has constant time complexity (two comparisons in the worst case).</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing a node_ptr to the already present node and false. If there is not equivalent key can be inserted returns true in the returned pair's boolean and fills "commit_data" that is meant to be used with the "insert_commit" function to achieve a constant-time insertion function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic, but it is amortized constant time if new_node should be inserted immediately before "hint".</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a node is expensive and the user does not want to have two equivalent nodes in the tree: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the node and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the node and use "insert_commit" to insert the node in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_unique_commit" only if no more objects are inserted or erased from the set. </para></description></method>
<method name="insert_unique_commit" specifiers="static"><type>void</type><template>
          <template-type-parameter name="H_Alpha"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_value"><paramtype>node_ptr</paramtype></parameter><parameter name="commit_data"><paramtype>const <classname>insert_commit_data</classname> &amp;</paramtype></parameter><parameter name="tree_size"><paramtype>std::size_t</paramtype></parameter><parameter name="h_alpha"><paramtype>H_Alpha</paramtype></parameter><parameter name="max_tree_size"><paramtype>std::size_t &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. "commit_data" must have been obtained from a previous call to "insert_unique_check". No objects should have been inserted or erased from the set between the "insert_unique_check" that filled "commit_data" and the call to "insert_commit".</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node in the set using the information obtained from the "commit_data" that a previous "insert_check" filled.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function has only sense if a "insert_unique_check" has been previously executed to fill "commit_data". No value should be inserted or erased between the "insert_check" and "insert_commit" calls. </para></description></method>
<method name="transfer_unique" specifiers="static"><type>bool</type><template>
          <template-type-parameter name="NodePtrCompare"/>
          <template-type-parameter name="H_Alpha"/>
          <template-type-parameter name="AlphaByMaxSize"/>
        </template><parameter name="header1"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><parameter name="tree1_size"><paramtype>std::size_t</paramtype></parameter><parameter name="max_tree1_size"><paramtype>std::size_t &amp;</paramtype></parameter><parameter name="header2"><paramtype>node_ptr</paramtype></parameter><parameter name="z"><paramtype>node_ptr</paramtype></parameter><parameter name="tree2_size"><paramtype>std::size_t</paramtype></parameter><parameter name="max_tree2_size"><paramtype>std::size_t &amp;</paramtype></parameter><parameter name="h_alpha"><paramtype>H_Alpha</paramtype></parameter><parameter name="alpha_by_maxsize"><paramtype>AlphaByMaxSize</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header1 and header2 must be the headers of trees tree1 and tree2 respectively, z a non-header node of tree1. NodePtrCompare is the comparison function of tree1..</para><para><emphasis role="bold">Effects</emphasis>: Transfers node "z" from tree1 to tree2 if tree1 does not contain a node that is equivalent to z.</para><para><emphasis role="bold">Returns</emphasis>: True if the node was trasferred, false otherwise.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison throws. </para></description></method>
<method name="transfer_equal" specifiers="static"><type>void</type><template>
          <template-type-parameter name="NodePtrCompare"/>
          <template-type-parameter name="H_Alpha"/>
          <template-type-parameter name="AlphaByMaxSize"/>
        </template><parameter name="header1"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><parameter name="tree1_size"><paramtype>std::size_t</paramtype></parameter><parameter name="max_tree1_size"><paramtype>std::size_t &amp;</paramtype></parameter><parameter name="header2"><paramtype>node_ptr</paramtype></parameter><parameter name="z"><paramtype>node_ptr</paramtype></parameter><parameter name="tree2_size"><paramtype>std::size_t</paramtype></parameter><parameter name="max_tree2_size"><paramtype>std::size_t &amp;</paramtype></parameter><parameter name="h_alpha"><paramtype>H_Alpha</paramtype></parameter><parameter name="alpha_by_maxsize"><paramtype>AlphaByMaxSize</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header1 and header2 must be the headers of trees tree1 and tree2 respectively, z a non-header node of tree1. NodePtrCompare is the comparison function of tree1..</para><para><emphasis role="bold">Effects</emphasis>: Transfers node "z" from tree1 to tree2.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison throws. </para></description></method>
<method name="is_header" specifiers="static"><type>bool</type><parameter name="p"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p is a node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Returns true if p is the header of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rebalance" specifiers="static"><type>void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p is a node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Returns true if p is the header of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
</method-group>
</class>



















































</namespace>
</namespace>
</header>
<header name="boost/intrusive/slist.hpp">
<namespace name="boost">
<namespace name="intrusive">
<struct name="make_slist"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>slist</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct><class name="slist"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>The class template slist is an intrusive container, that encapsulates a singly-linked list. You can use such a list to squeeze the last bit of performance from your application. Unfortunately, the little gains come with some huge drawbacks. A lot of member functions can't be implemented as efficiently as for standard containers. To overcome this limitation some other member functions with rather unusual semantics have to be introduced.</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput>, <computeroutput>linear&lt;&gt;</computeroutput> and <computeroutput>cache_last&lt;&gt;</computeroutput>.</para><para>The iterators of slist are forward iterators. slist provides a static function called "previous" to compute the previous iterator of a given iterator. This function has linear complexity. To improve the usability esp. with the '*_after' functions, ++end() == begin() and previous(begin()) == end() are defined. An new special function "before_begin()" is defined, which returns an iterator that points one less the beginning of the list: ++before_begin() == begin() </para></description><typedef name="value_traits"><type>ValueTraits</type></typedef>
<typedef name="pointer"><type>value_traits::pointer</type></typedef>
<typedef name="const_pointer"><type>value_traits::const_pointer</type></typedef>
<typedef name="value_type"><type><classname>pointer_traits</classname>&lt; pointer &gt;::element_type</type></typedef>
<typedef name="reference"><type><classname>pointer_traits</classname>&lt; pointer &gt;::reference</type></typedef>
<typedef name="const_reference"><type><classname>pointer_traits</classname>&lt; const_pointer &gt;::reference</type></typedef>
<typedef name="difference_type"><type><classname>pointer_traits</classname>&lt; pointer &gt;::difference_type</type></typedef>
<typedef name="size_type"><type>SizeType</type></typedef>
<typedef name="iterator"><type>slist_iterator&lt; value_traits, false &gt;</type></typedef>
<typedef name="const_iterator"><type>slist_iterator&lt; value_traits, true &gt;</type></typedef>
<typedef name="node_traits"><type>value_traits::node_traits</type></typedef>
<typedef name="node"><type>node_traits::node</type></typedef>
<typedef name="node_ptr"><type>node_traits::node_ptr</type></typedef>
<typedef name="const_node_ptr"><type>node_traits::const_node_ptr</type></typedef>
<typedef name="header_holder_type"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="node_algorithms"><type><emphasis>unspecified</emphasis></type></typedef>
<data-member name="constant_time_size" specifiers="static"><type>const bool</type></data-member>
<data-member name="stateful_value_traits" specifiers="static"><type>const bool</type></data-member>
<data-member name="linear" specifiers="static"><type>const bool</type></data-member>
<data-member name="cache_last" specifiers="static"><type>const bool</type></data-member>
<data-member name="has_container_from_iterator" specifiers="static"><type>const bool</type></data-member>
<method-group name="public member functions">
<method name="clear"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements of the list. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. </para></description></method>
<method name="clear_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the container Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements of the list.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="push_front"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue.</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value in the front of the list. No copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method>
<method name="push_back"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue.</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value in the back of the list. No copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. This function is only available is cache_last&lt;&gt; is true. </para></description></method>
<method name="pop_front"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases the first element of the list. No destructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased element. </para></description></method>
<method name="pop_front_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the first element of the list. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased element. </para></description></method>
<method name="front"><type>reference</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the first element of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="front" cv="const"><type>const_reference</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reference to the first element of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="back"><type>reference</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the last element of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. This function is only available is cache_last&lt;&gt; is true. </para></description></method>
<method name="back" cv="const"><type>const_reference</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reference to the last element of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. This function is only available is cache_last&lt;&gt; is true. </para></description></method>
<method name="begin"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element contained in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="end"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the end of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="before_begin"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator that points to a position before the first element. Equivalent to "end()"</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="before_begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator that points to a position before the first element. Equivalent to "end()"</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="cbefore_begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator that points to a position before the first element. Equivalent to "end()"</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="last"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the last element contained in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: This function is present only if cached_last&lt;&gt; option is true. </para></description></method>
<method name="last" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the last element contained in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: This function is present only if cached_last&lt;&gt; option is true. </para></description></method>
<method name="clast" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the last element contained in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: This function is present only if cached_last&lt;&gt; option is true. </para></description></method>
<method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of the elements contained in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements contained in the list. if <classname alt="boost::intrusive::constant_time_size">constant_time_size</classname> is false. Constant time otherwise.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method>
<method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the list contains no elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method>
<method name="swap"><type>void</type><parameter name="other"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the elements of x and *this.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements of both lists. Constant-time if linear&lt;&gt; and/or cache_last&lt;&gt; options are used.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method>
<method name="shift_backwards"><type>void</type><parameter name="n"><paramtype>size_type</paramtype><default>1</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Moves backwards all the elements, so that the first element becomes the second, the second becomes the third... the last element becomes the first one.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements plus the number shifts.</para><para><emphasis role="bold">Note</emphasis>: Iterators Does not affect the validity of iterators and references. </para></description></method>
<method name="shift_forward"><type>void</type><parameter name="n"><paramtype>size_type</paramtype><default>1</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Moves forward all the elements, so that the second element becomes the first, the third becomes the second... the first element becomes the last one.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements plus the number shifts.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>slist</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype><classname>slist</classname> &amp;&amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(reference) and inserts them on *this.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws. </para></description></method>
<method name="insert_after"><type>iterator</type><parameter name="prev_p"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and prev_p must point to an element contained by the list or to end().</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value after the position pointed by prev_p. No copy constructor is called.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the inserted element.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method>
<method name="insert_after"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="prev_p"><paramtype>const_iterator</paramtype></parameter><parameter name="f"><paramtype>Iterator</paramtype></parameter><parameter name="l"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type and prev_p must point to an element contained by the list or to the end node.</para><para><emphasis role="bold">Effects</emphasis>: Inserts the [f, l) after the position prev_p.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements inserted.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and p must point to an element contained by the list or to end().</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value before the position pointed by p. No copy constructor is called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements before p. Constant-time if cache_last&lt;&gt; is true and p == end().</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method>
<method name="insert"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type and p must point to an element contained by the list or to the end node.</para><para><emphasis role="bold">Effects</emphasis>: Inserts the pointed by b and e before the position p. No copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements inserted plus linear to the elements before b. Linear to the number of elements to insert if cache_last&lt;&gt; option is true and p == end().</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method>
<method name="erase_after"><type>iterator</type><parameter name="prev"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element after the element pointed by prev of the list. No destructors are called.</para><para><emphasis role="bold">Returns</emphasis>: the first element remaining beyond the removed elements, or end() if no such element exists.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased element. </para></description></method>
<method name="erase_after"><type>iterator</type><parameter name="before_f"><paramtype>const_iterator</paramtype></parameter><parameter name="l"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range (before_f, l) from the list. No destructors are called.</para><para><emphasis role="bold">Returns</emphasis>: the first element remaining beyond the removed elements, or end() if no such element exists.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of erased elements if it's a safe-mode , auto-unlink value or constant-time size is activated. Constant time otherwise.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased element. </para></description></method>
<method name="erase_after"><type>iterator</type><parameter name="before_f"><paramtype>const_iterator</paramtype></parameter><parameter name="l"><paramtype>const_iterator</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range (before_f, l) from the list. n must be distance(before_f, l) - 1. No destructors are called.</para><para><emphasis role="bold">Returns</emphasis>: the first element remaining beyond the removed elements, or end() if no such element exists.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: constant-time if <classname alt="boost::intrusive::link_mode">link_mode</classname> is normal_link. Linear to the elements (l - before_f) otherwise.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased element. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="i"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed by i of the list. No destructors are called.</para><para><emphasis role="bold">Returns</emphasis>: the first element remaining beyond the removed element, or end() if no such element exists.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements before i.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased element. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="f"><paramtype>const_iterator</paramtype></parameter><parameter name="l"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: f and l must be valid iterator to elements in *this.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed by b and e. No destructors are called.</para><para><emphasis role="bold">Returns</emphasis>: the first element remaining beyond the removed elements, or end() if no such element exists.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements before l.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="f"><paramtype>const_iterator</paramtype></parameter><parameter name="l"><paramtype>const_iterator</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range [f, l) from the list. n must be distance(f, l). No destructors are called.</para><para><emphasis role="bold">Returns</emphasis>: the first element remaining beyond the removed elements, or end() if no such element exists.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: linear to the elements before f if <classname alt="boost::intrusive::link_mode">link_mode</classname> is normal_link and <classname alt="boost::intrusive::constant_time_size">constant_time_size</classname> is activated. Linear to the elements before l otherwise.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased element. </para></description></method>
<method name="erase_after_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="prev"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element after the element pointed by prev of the list. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Returns</emphasis>: the first element remaining beyond the removed elements, or end() if no such element exists.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased element. </para></description></method>
<method name="erase_after_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="before_f"><paramtype>const_iterator</paramtype></parameter><parameter name="l"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range (before_f, l) from the list. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: the first element remaining beyond the removed elements, or end() if no such element exists.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements (l - before_f + 1).</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased element. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed by i of the list. No destructors are called. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Returns</emphasis>: the first element remaining beyond the removed element, or end() if no such element exists.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements before i.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased element. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="f"><paramtype>const_iterator</paramtype></parameter><parameter name="l"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: f and l must be valid iterator to elements in *this. Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed by b and e. No destructors are called. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: the first element remaining beyond the removed elements, or end() if no such element exists.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of erased elements plus linear to the elements before f.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. </para></description></method>
<method name="assign"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Clears the list and inserts the range pointed by b and e. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements inserted plus linear to the elements contained in the list if it's a safe-mode or auto-unlink value. Linear to the number of elements inserted in the list otherwise.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. </para></description></method>
<method name="dispose_and_assign"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Clears the list and inserts the range pointed by b and e. No destructors or copy constructors are called. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements inserted plus linear to the elements contained in the list.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. </para></description></method>
<method name="splice_after"><type>void</type><parameter name="prev"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><parameter name="l"><paramtype>const_iterator *</paramtype><default>0</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev must point to an element contained by this list or to the before_begin() element</para><para><emphasis role="bold">Effects</emphasis>: Transfers all the elements of list x to this list, after the the element pointed by prev. No destructors or copy constructors are called.</para><para><emphasis role="bold">Returns</emphasis>: Nothing.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: In general, linear to the elements contained in x. Constant-time if cache_last&lt;&gt; option is true and also constant-time if linear&lt;&gt; option is true "this" is empty and "l" is not used.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated.</para><para><emphasis role="bold">Additional note</emphasis>: If the optional parameter "l" is provided, it will be assigned to the last spliced element or prev if x is empty. This iterator can be used as new "prev" iterator for a new splice_after call. that will splice new values after the previously spliced values. </para></description></method>
<method name="splice_after"><type>void</type><parameter name="prev_pos"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><parameter name="prev_ele"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev must point to an element contained by this list or to the before_begin() element. prev_ele must point to an element contained in list x or must be x.before_begin().</para><para><emphasis role="bold">Effects</emphasis>: Transfers the element after prev_ele, from list x to this list, after the element pointed by prev. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method>
<method name="splice_after"><type>void</type><parameter name="prev_pos"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><parameter name="before_f"><paramtype>const_iterator</paramtype></parameter><parameter name="before_l"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev_pos must be a dereferenceable iterator in *this or be before_begin(), and before_f and before_l belong to x and ++before_f != x.end() &amp;&amp; before_l != x.end().</para><para><emphasis role="bold">Effects</emphasis>: Transfers the range (before_f, before_l] from list x to this list, after the element pointed by prev_pos. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements transferred if <classname alt="boost::intrusive::constant_time_size">constant_time_size</classname> is true. Constant-time otherwise.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method>
<method name="splice_after"><type>void</type><parameter name="prev_pos"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><parameter name="before_f"><paramtype>const_iterator</paramtype></parameter><parameter name="before_l"><paramtype>const_iterator</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev_pos must be a dereferenceable iterator in *this or be before_begin(), and before_f and before_l belong to x and ++before_f != x.end() &amp;&amp; before_l != x.end() and n == distance(before_f, before_l).</para><para><emphasis role="bold">Effects</emphasis>: Transfers the range (before_f, before_l] from list x to this list, after the element pointed by p. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method>
<method name="splice"><type>void</type><parameter name="it"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><parameter name="l"><paramtype>const_iterator *</paramtype><default>0</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: it is an iterator to an element in *this.</para><para><emphasis role="bold">Effects</emphasis>: Transfers all the elements of list x to this list, before the the element pointed by it. No destructors or copy constructors are called.</para><para><emphasis role="bold">Returns</emphasis>: Nothing.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements contained in x plus linear to the elements before it. Linear to the elements before it if cache_last&lt;&gt; option is true. Constant-time if cache_last&lt;&gt; option is true and it == end().</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated.</para><para><emphasis role="bold">Additional note</emphasis>: If the optional parameter "l" is provided, it will be assigned to the last spliced element or prev if x is empty. This iterator can be used as new "prev" iterator for a new splice_after call. that will splice new values after the previously spliced values. </para></description></method>
<method name="splice"><type>void</type><parameter name="pos"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><parameter name="elem"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: it p must be a valid iterator of *this. elem must point to an element contained in list x.</para><para><emphasis role="bold">Effects</emphasis>: Transfers the element elem, from list x to this list, before the element pointed by pos. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements before pos and before elem. Linear to the elements before elem if cache_last&lt;&gt; option is true and pos == end().</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method>
<method name="splice"><type>void</type><parameter name="pos"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><parameter name="f"><paramtype>const_iterator</paramtype></parameter><parameter name="l"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: pos must be a dereferenceable iterator in *this and f and f belong to x and f and f a valid range on x.</para><para><emphasis role="bold">Effects</emphasis>: Transfers the range [f, l) from list x to this list, before the element pointed by pos. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the sum of elements before pos, f, and l plus linear to the number of elements transferred if <classname alt="boost::intrusive::constant_time_size">constant_time_size</classname> is true. Linear to the sum of elements before f, and l plus linear to the number of elements transferred if <classname alt="boost::intrusive::constant_time_size">constant_time_size</classname> is true if cache_last&lt;&gt; is true and pos == end()</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method>
<method name="splice"><type>void</type><parameter name="pos"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><parameter name="f"><paramtype>const_iterator</paramtype></parameter><parameter name="l"><paramtype>const_iterator</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: pos must be a dereferenceable iterator in *this and f and l belong to x and f and l a valid range on x. n == distance(f, l).</para><para><emphasis role="bold">Effects</emphasis>: Transfers the range [f, l) from list x to this list, before the element pointed by pos. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the sum of elements before pos, f, and l. Linear to the sum of elements before f and l if cache_last&lt;&gt; is true and pos == end().</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method>
<method name="sort"><type>void</type><template>
          <template-type-parameter name="Predicate"/>
        </template><parameter name="p"><paramtype>Predicate</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: This function sorts the list *this according to std::less&lt;value_type&gt;. The sort is stable, that is, the relative order of equivalent elements is preserved.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the predicate throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: The number of comparisons is approximately N log N, where N is the list's size.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated </para></description></method>
<method name="sort"><type>void</type><description><para><emphasis role="bold">Requires</emphasis>: p must be a comparison function that induces a strict weak ordering and both *this and x must be sorted according to that ordering The lists x and *this must be distinct.</para><para><emphasis role="bold">Effects</emphasis>: This function removes all of x's elements and inserts them in order into *this. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or std::less&lt;value_type&gt; throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear time: it performs at most size() + x.size() - 1 comparisons.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated. </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="Predicate"/>
        </template><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><parameter name="p"><paramtype>Predicate</paramtype></parameter><parameter name="l"><paramtype>const_iterator *</paramtype><default>0</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a comparison function that induces a strict weak ordering and both *this and x must be sorted according to that ordering The lists x and *this must be distinct.</para><para><emphasis role="bold">Effects</emphasis>: This function removes all of x's elements and inserts them in order into *this. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x.</para><para><emphasis role="bold">Returns</emphasis>: Nothing.</para><para><emphasis role="bold">Throws</emphasis>: If the predicate throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear time: it performs at most size() + x.size() - 1 comparisons.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated.</para><para><emphasis role="bold">Additional note</emphasis>: If optional "l" argument is passed, it is assigned to an iterator to the last transferred value or end() is x is empty. </para></description></method>
<method name="merge"><type>void</type><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: This function removes all of x's elements and inserts them in order into *this according to std::less&lt;value_type&gt;. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x.</para><para><emphasis role="bold">Throws</emphasis>: if std::less&lt;value_type&gt; throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear time: it performs at most size() + x.size() - 1 comparisons.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated </para></description></method>
<method name="reverse"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Reverses the order of elements in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear to the contained elements.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated </para></description></method>
<method name="remove"><type>void</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Removes all the elements that compare equal to value. No destructors are called.</para><para><emphasis role="bold">Throws</emphasis>: If std::equal_to&lt;value_type&gt; throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time. It performs exactly size() comparisons for equality.</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. This function is linear time: it performs exactly size() comparisons for equality. </para></description></method>
<method name="remove_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="value"><paramtype>const_reference</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Removes all the elements that compare equal to value. Disposer::operator()(pointer) is called for every removed element.</para><para><emphasis role="bold">Throws</emphasis>: If std::equal_to&lt;value_type&gt; throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time. It performs exactly size() comparisons for equality.</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method>
<method name="remove_if"><type>void</type><template>
          <template-type-parameter name="Pred"/>
        </template><parameter name="pred"><paramtype>Pred</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Removes all the elements for which a specified predicate is satisfied. No destructors are called.</para><para><emphasis role="bold">Throws</emphasis>: If pred throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time. It performs exactly size() calls to the predicate.</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method>
<method name="remove_and_dispose_if"><type>void</type><template>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="pred"><paramtype>Pred</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Removes all the elements for which a specified predicate is satisfied. Disposer::operator()(pointer) is called for every removed element.</para><para><emphasis role="bold">Throws</emphasis>: If pred throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time. It performs exactly size() comparisons for equality.</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method>
<method name="unique"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes adjacent duplicate elements or adjacent elements that are equal from the list. No destructors are called.</para><para><emphasis role="bold">Throws</emphasis>: If std::equal_to&lt;value_type&gt; throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time (size()-1) comparisons calls to pred()).</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method>
<method name="unique"><type>void</type><template>
          <template-type-parameter name="BinaryPredicate"/>
        </template><parameter name="pred"><paramtype>BinaryPredicate</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Removes adjacent duplicate elements or adjacent elements that satisfy some binary predicate from the list. No destructors are called.</para><para><emphasis role="bold">Throws</emphasis>: If the predicate throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time (size()-1) comparisons equality comparisons.</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method>
<method name="unique_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Removes adjacent duplicate elements or adjacent elements that satisfy some binary predicate from the list. Disposer::operator()(pointer) is called for every removed element.</para><para><emphasis role="bold">Throws</emphasis>: If std::equal_to&lt;value_type&gt; throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time (size()-1) comparisons equality comparisons.</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method>
<method name="unique_and_dispose"><type>void</type><template>
          <template-type-parameter name="BinaryPredicate"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="pred"><paramtype>BinaryPredicate</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Removes adjacent duplicate elements or adjacent elements that satisfy some binary predicate from the list. Disposer::operator()(pointer) is called for every removed element.</para><para><emphasis role="bold">Throws</emphasis>: If the predicate throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time (size()-1) comparisons equality comparisons.</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method>
<method name="iterator_to"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be a reference to a value inserted in a list.</para><para><emphasis role="bold">Effects</emphasis>: This function returns a const_iterator pointing to the element</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated. </para></description></method>
<method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be a const reference to a value inserted in a list.</para><para><emphasis role="bold">Effects</emphasis>: This function returns an iterator pointing to the element.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated. </para></description></method>
<method name="previous"><type>iterator</type><parameter name="i"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: The iterator to the element before i in the list. Returns the end-iterator, if either i is the begin-iterator or the list is empty.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements before i. Constant if cache_last&lt;&gt; is true and i == end(). </para></description></method>
<method name="previous" cv="const"><type>const_iterator</type><parameter name="i"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: The const_iterator to the element before i in the list. Returns the end-const_iterator, if either i is the begin-const_iterator or the list is empty.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements before i. Constant if cache_last&lt;&gt; is true and i == end(). </para></description></method>
<method name="previous"><type>iterator</type><parameter name="prev_from"><paramtype>const_iterator</paramtype></parameter><parameter name="i"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: The iterator to the element before i in the list, starting the search on element after prev_from. Returns the end-iterator, if either i is the begin-iterator or the list is empty.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements before i. Constant if cache_last&lt;&gt; is true and i == end(). </para></description></method>
<method name="previous" cv="const"><type>const_iterator</type><parameter name="prev_from"><paramtype>const_iterator</paramtype></parameter><parameter name="i"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: The const_iterator to the element before i in the list, starting the search on element after prev_from. Returns the end-const_iterator, if either i is the begin-const_iterator or the list is empty.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements before i. Constant if cache_last&lt;&gt; is true and i == end(). </para></description></method>
<method name="check" cv="const"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Asserts the integrity of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time.</para><para><emphasis role="bold">Note</emphasis>: The method has no effect when asserts are turned off (e.g., with NDEBUG). Experimental function, interface might change in future versions. </para></description></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: constructs an empty list.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks). </para></description></constructor>
<constructor specifiers="explicit"><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: constructs an empty list.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks). </para></description></constructor>
<constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Constructs a list equal to [b ,e).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in distance(b, e). No copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks). </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>slist</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a container moving resources from another container. Internal value traits are move constructed and nodes belonging to x (except the node representing the "end") are linked to *this.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node's move constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the move constructor of value traits throws. </para></description></constructor>
<copy-assignment><type><classname>slist</classname> &amp;</type><parameter name="x"><paramtype><classname>slist</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to swap </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: If it's a safe-mode or auto-unlink value, the destructor does nothing (ie. no code is generated). Otherwise it detaches all elements from this. In this case the objects in the list are not deleted (i.e. no destructors are called), but the hooks according to the <classname alt="boost::intrusive::value_traits">value_traits</classname> template parameter are set to their default value.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the list, if it's a safe-mode or auto-unlink value. Otherwise constant. </para></description></destructor>
<method-group name="public static functions">
<method name="container_from_end_iterator" specifiers="static"><type><classname>slist</classname> &amp;</type><parameter name="end_iterator"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of slist.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the slist associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_end_iterator" specifiers="static"><type>const <classname>slist</classname> &amp;</type><parameter name="end_iterator"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end const_iterator of slist.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the slist associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be a reference to a value inserted in a list.</para><para><emphasis role="bold">Effects</emphasis>: This function returns a const_iterator pointing to the element</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated. This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be a const reference to a value inserted in a list.</para><para><emphasis role="bold">Effects</emphasis>: This function returns an iterator pointing to the element.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated. This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
</method-group>
<method-group name="private member functions">
<method name="priv_splice_after"><type>void</type><parameter name="prev_pos_n"><paramtype>node_ptr</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><parameter name="before_f_n"><paramtype>node_ptr</paramtype></parameter><parameter name="before_l_n"><paramtype>node_ptr</paramtype></parameter></method>
<method name="priv_incorporate_after"><type>void</type><parameter name="prev_pos_n"><paramtype>node_ptr</paramtype></parameter><parameter name="first_n"><paramtype>node_ptr</paramtype></parameter><parameter name="before_l_n"><paramtype>node_ptr</paramtype></parameter></method>
<method name="priv_reverse"><type>void</type><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></method>
<method name="priv_reverse"><type>void</type><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></method>
<method name="priv_shift_backwards"><type>void</type><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></method>
<method name="priv_shift_backwards"><type>void</type><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></method>
<method name="priv_shift_forward"><type>void</type><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></method>
<method name="priv_shift_forward"><type>void</type><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></method>
</method-group>
<method-group name="private static functions">
<method name="priv_swap_cache_last" specifiers="static"><type>void</type><parameter name="this_impl"><paramtype><classname>slist</classname> *</paramtype></parameter><parameter name="other_impl"><paramtype><classname>slist</classname> *</paramtype></parameter></method>
<method name="priv_swap_lists" specifiers="static"><type>void</type><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><parameter name="other_node"><paramtype>node_ptr</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></method>
<method name="priv_swap_lists" specifiers="static"><type>void</type><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><parameter name="other_node"><paramtype>node_ptr</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></method>
<method name="priv_container_from_end_iterator" specifiers="static"><type><classname>slist</classname> &amp;</type><parameter name="end_iterator"><paramtype>const const_iterator &amp;</paramtype></parameter></method>
</method-group>
</class>



















































</namespace>
</namespace>
</header>
<header name="boost/intrusive/slist_hook.hpp">
<namespace name="boost">
<namespace name="intrusive">
<struct name="make_slist_base_hook"><template>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput><classname alt="boost::intrusive::slist_base_hook">slist_base_hook</classname></computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct><struct name="make_slist_member_hook"><template>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput><classname alt="boost::intrusive::slist_member_hook">slist_member_hook</classname></computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct><class name="slist_base_hook"><template>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><inherit access="public">make_slist_base_hook::type&lt; O1, O2, O3 &gt;</inherit><description><para>Derive a class from <classname alt="boost::intrusive::slist_base_hook">slist_base_hook</classname> in order to store objects in in an list. <classname alt="boost::intrusive::slist_base_hook">slist_base_hook</classname> holds the data necessary to maintain the list and provides an appropriate <classname alt="boost::intrusive::value_traits">value_traits</classname> class for list.</para><para>The hook admits the following options: <computeroutput>tag&lt;&gt;</computeroutput>, <computeroutput>void_pointer&lt;&gt;</computeroutput> and <computeroutput>link_mode&lt;&gt;</computeroutput>.</para><para><computeroutput>tag&lt;&gt;</computeroutput> defines a tag to identify the node. The same tag value can be used in different classes, but if a class is derived from more than one <computeroutput><classname alt="boost::intrusive::list_base_hook">list_base_hook</classname></computeroutput>, then each <computeroutput><classname alt="boost::intrusive::list_base_hook">list_base_hook</classname></computeroutput> needs its unique tag.</para><para><computeroutput>link_mode&lt;&gt;</computeroutput> will specify the linking mode of the hook (<computeroutput>normal_link</computeroutput>, <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput>).</para><para><computeroutput>void_pointer&lt;&gt;</computeroutput> is the pointer type that will be used internally in the hook and the container configured to use this hook. </para></description><method-group name="public member functions">
<method name="swap_nodes"><type>void</type><parameter name="other"><paramtype><classname>slist_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swapping two nodes swaps the position of the elements related to those nodes in one or two containers. That is, if the node this is part of the element e1, the node x is part of the element e2 and both elements are included in the containers s1 and s2, then after the swap-operation e1 is in s2 at the position of e2 and e2 is in s1 at the position of e1. If one element is not in a container, then after the swap-operation the other element is not in a container. Iterators to e1 and e2 related to those nodes are invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="is_linked" cv="const"><type>bool</type><description><para><emphasis role="bold">Precondition</emphasis>: <classname alt="boost::intrusive::link_mode">link_mode</classname> must be <computeroutput>safe_link</computeroutput> or <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: true, if the node belongs to a container, false otherwise. This function can be used to test whether <computeroutput>slist::iterator_to</computeroutput> will return a valid iterator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method>
<method name="unlink"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the node if it's inserted in a container. This function is only allowed if <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></constructor>
<constructor><parameter name=""><paramtype>const <classname>slist_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing a copy-constructor makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></constructor>
<copy-assignment><type><classname>slist_base_hook</classname> &amp;</type><parameter name=""><paramtype>const <classname>slist_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Empty function. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing an assignment operator makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>normal_link</computeroutput>, the destructor does nothing (ie. no code is generated). If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>safe_link</computeroutput> and the object is stored in an slist an assertion is raised. If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> and <computeroutput>is_linked()</computeroutput> is true, the node is unlinked.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor>
</class><class name="slist_member_hook"><template>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><inherit access="public">make_slist_member_hook::type&lt; O1, O2, O3 &gt;</inherit><description><para>Put a public data member <classname alt="boost::intrusive::slist_member_hook">slist_member_hook</classname> in order to store objects of this class in an list. <classname alt="boost::intrusive::slist_member_hook">slist_member_hook</classname> holds the data necessary for maintaining the list and provides an appropriate <classname alt="boost::intrusive::value_traits">value_traits</classname> class for list.</para><para>The hook admits the following options: <computeroutput>void_pointer&lt;&gt;</computeroutput> and <computeroutput>link_mode&lt;&gt;</computeroutput>.</para><para><computeroutput>link_mode&lt;&gt;</computeroutput> will specify the linking mode of the hook (<computeroutput>normal_link</computeroutput>, <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput>).</para><para><computeroutput>void_pointer&lt;&gt;</computeroutput> is the pointer type that will be used internally in the hook and the container configured to use this hook. </para></description><method-group name="public member functions">
<method name="swap_nodes"><type>void</type><parameter name="other"><paramtype><classname>slist_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swapping two nodes swaps the position of the elements related to those nodes in one or two containers. That is, if the node this is part of the element e1, the node x is part of the element e2 and both elements are included in the containers s1 and s2, then after the swap-operation e1 is in s2 at the position of e2 and e2 is in s1 at the position of e1. If one element is not in a container, then after the swap-operation the other element is not in a container. Iterators to e1 and e2 related to those nodes are invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="is_linked" cv="const"><type>bool</type><description><para><emphasis role="bold">Precondition</emphasis>: <classname alt="boost::intrusive::link_mode">link_mode</classname> must be <computeroutput>safe_link</computeroutput> or <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: true, if the node belongs to a container, false otherwise. This function can be used to test whether <computeroutput>slist::iterator_to</computeroutput> will return a valid iterator.</para><para><emphasis role="bold">Note</emphasis>: If this member is called when the value is inserted in a slist with the option linear&lt;true&gt;, this function will return "false" for the last element, as it is not linked to anything (the next element is null), so use with care.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method>
<method name="unlink"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the node if it's inserted in a container. This function is only allowed if <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></constructor>
<constructor><parameter name=""><paramtype>const <classname>slist_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing a copy-constructor makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></constructor>
<copy-assignment><type><classname>slist_member_hook</classname> &amp;</type><parameter name=""><paramtype>const <classname>slist_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Empty function. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing an assignment operator makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>normal_link</computeroutput>, the destructor does nothing (ie. no code is generated). If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>safe_link</computeroutput> and the object is stored in an slist an assertion is raised. If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> and <computeroutput>is_linked()</computeroutput> is true, the node is unlinked.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor>
</class>



















































</namespace>
</namespace>
</header>
<header name="boost/intrusive/splay_set.hpp">
<namespace name="boost">
<namespace name="intrusive">
<struct name="make_splay_multiset"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput><classname alt="boost::intrusive::splay_multiset">splay_multiset</classname></computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct><struct name="make_splay_set"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput><classname alt="boost::intrusive::splay_set">splay_set</classname></computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct><class name="splay_multiset"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>The class template <classname alt="boost::intrusive::splay_multiset">splay_multiset</classname> is an intrusive container, that mimics most of the interface of std::multiset as described in the C++ standard.</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput> and <computeroutput>compare&lt;&gt;</computeroutput>. </para></description><typedef name="value_type"><type>implementation_defined::value_type</type></typedef>
<typedef name="key_type"><type>implementation_defined::key_type</type></typedef>
<typedef name="key_of_value"><type>implementation_defined::key_of_value</type></typedef>
<typedef name="value_traits"><type>implementation_defined::value_traits</type></typedef>
<typedef name="pointer"><type>implementation_defined::pointer</type></typedef>
<typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef>
<typedef name="reference"><type>implementation_defined::reference</type></typedef>
<typedef name="const_reference"><type>implementation_defined::const_reference</type></typedef>
<typedef name="difference_type"><type>implementation_defined::difference_type</type></typedef>
<typedef name="size_type"><type>implementation_defined::size_type</type></typedef>
<typedef name="value_compare"><type>implementation_defined::value_compare</type></typedef>
<typedef name="key_compare"><type>implementation_defined::key_compare</type></typedef>
<typedef name="iterator"><type>implementation_defined::iterator</type></typedef>
<typedef name="const_iterator"><type>implementation_defined::const_iterator</type></typedef>
<typedef name="reverse_iterator"><type>implementation_defined::reverse_iterator</type></typedef>
<typedef name="const_reverse_iterator"><type>implementation_defined::const_reverse_iterator</type></typedef>
<typedef name="insert_commit_data"><type>implementation_defined::insert_commit_data</type></typedef>
<typedef name="node_traits"><type>implementation_defined::node_traits</type></typedef>
<typedef name="node"><type>implementation_defined::node</type></typedef>
<typedef name="node_ptr"><type>implementation_defined::node_ptr</type></typedef>
<typedef name="const_node_ptr"><type>implementation_defined::const_node_ptr</type></typedef>
<typedef name="node_algorithms"><type>implementation_defined::node_algorithms</type></typedef>
<data-member name="constant_time_size" specifiers="static"><type>const bool</type></data-member>
<method-group name="public member functions">
<method name="begin"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rbegin"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a iterator pointing to the root node of the container or end() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="croot" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the key_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If key_compare copy-constructor throws. </para></description></method>
<method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the value_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_compare copy-constructor throws. </para></description></method>
<method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this if constant-time size option is disabled. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="swap"><type>void</type><parameter name="other"><paramtype><classname>splay_multiset</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of two containers.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison functor's swap call throws. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>splay_multiset</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee. Additional notes: it also copies the alpha factor from the source container. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype><classname>splay_multiset</classname> &amp;&amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(reference) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: This version can modify the source container, useful to implement move semantics. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the container before the upper bound.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal key_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and "hint" must be a valid iterator.</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container, using "hint" as a hint to where it will be inserted. If "hint" is the upper_bound the insertion takes constant time (two comparisons in the worst case)</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the internal key_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Inserts a each element of a range into the container before the upper bound of the key of each element.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_before"><type>iterator</type><parameter name="pos"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, "pos" must be a valid iterator (or end) and must be the succesor of value once inserted according to the predicate</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container before "pos".</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if "pos" is not the successor of "value" container ordering invariant will be broken. This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_back"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no less than the greatest inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the last position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is less than the greatest inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_front"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no greater than the minimum inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the first position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is greater than the minimum inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="i"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp".</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk) and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="clear"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="clear_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements calling disposer(p) for each node to be erased. <emphasis role="bold">Complexity</emphasis>: Average complexity for is at most O(log(size() + N)), where N is the number of elements in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. Calls N times to disposer functor. </para></description></method>
<method name="count"><type>size_type</type><parameter name=""><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given value</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given value.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. Additional note: non-const function, splaying is performed. </para></description></method>
<method name="count"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. Additional note: const function, no splaying is performed </para></description></method>
<method name="lower_bound"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. Additional note: non-const function, splaying is performed. </para></description></method>
<method name="lower_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. Additional note: non-const function, splaying is performed for the first element of the equal range of "key" </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. Additional note: const function, no splaying is performed </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. Additional note: const function, no splaying is performed </para></description></method>
<method name="upper_bound"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. Additional note: non-const function, splaying is performed for the first element of the equal range of "value" </para></description></method>
<method name="upper_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. Additional note: non-const function, splaying is performed for the first element of the equal range of "key" </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. Additional note: const function, no splaying is performed </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. Additional note: const function, no splaying is performed </para></description></method>
<method name="find"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. Additional note: non-const function, splaying is performed for the first element of the equal range of "value" </para></description></method>
<method name="find"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. Additional note: non-const function, splaying is performed for the first element of the equal range of "key" </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. Additional note: const function, no splaying is performed </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. Additional note: const function, no splaying is performed </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. Additional note: non-const function, splaying is performed for the first element of the equal range of "value" </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. Additional note: non-const function, splaying is performed for the first element of the equal range of "key" </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. Additional note: const function, no splaying is performed </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. Additional note: const function, no splaying is performed </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="lower_value"><paramtype>const_reference</paramtype></parameter><parameter name="upper_value"><paramtype>const_reference</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="lower_value"><paramtype>const_reference</paramtype></parameter><parameter name="upper_value"><paramtype>const_reference</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="iterator_to"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="unlink_leftmost_without_rebalance"><type>pointer</type><description><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the container.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the container and the container can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the container. </para></description></method>
<method name="replace_node"><type>void</type><parameter name="replace_this"><paramtype>iterator</paramtype></parameter><parameter name="with_this"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: replace_this must be a valid iterator of *this and with_this must not be inserted in any container.</para><para><emphasis role="bold">Effects</emphasis>: Replaces replace_this in its position in the container with with_this. The container does not need to be rebalanced.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if with_this is not equivalent to *replace_this according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. </para></description></method>
<method name="remove_node"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: removes "value" from the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic time.</para><para><emphasis role="bold">Note</emphasis>: This static function is only usable with non-constant time size containers that have stateless comparison functors.</para><para>If the user calls this function with a constant time size container or stateful comparison functor a compilation error will be issued. </para></description></method>
<method name="splay_up"><type>void</type><parameter name="i"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: i must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Rearranges the container so that the element pointed by i is placed as the root of the tree, improving future searches of this value.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="splay_down"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Rearranges the container so that if *this stores an element with a key equivalent to value the element is placed as the root of the tree. If the element is not present returns the last node compared with the key. If the tree is empty, end() is returned.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the new root of the tree, end() if the tree is empty.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison functor throws. </para></description></method>
<method name="splay_down"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Rearranges the container so that if *this stores an element with a key equivalent to value the element is placed as the root of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the new root of the tree, end() if the tree is empty.</para><para><emphasis role="bold">Throws</emphasis>: If the predicate throws. </para></description></method>
<method name="rebalance"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Rebalances the tree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear. </para></description></method>
<method name="rebalance_subtree"><type>iterator</type><parameter name="root"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: old_root is a node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Rebalances the subtree rooted at old_root.</para><para><emphasis role="bold">Returns</emphasis>: The new root of the subtree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements in the subtree. </para></description></method>
<method name="merge"><type>void</type><template>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="source"><paramtype><classname>splay_multiset</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Extracts each element in source and insert it into a using the comparison object of *this.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="source"><paramtype><classname>splay_set</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Extracts each element in source and insert it into a using the comparison object of *this.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container with given comparison and traits.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype><default>key_compare()</default></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type. cmp must be a comparison function that induces a strict weak ordering.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container and inserts elements from [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if [b, e) is already sorted using comp and otherwise N * log N, where N is the distance between first and last.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor/operator() of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>splay_multiset</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a container moving resources from another container. Internal comparison object and value traits are move constructed and nodes belonging to x (except the node representing the "end") are linked to *this.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node's move constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the move constructor of the comparison objet throws. </para></description></constructor>
<copy-assignment><type><classname>splay_multiset</classname> &amp;</type><parameter name="x"><paramtype><classname>splay_multiset</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to swap </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the set are not deleted (i.e. no destructors are called), but the nodes according to the <classname alt="boost::intrusive::value_traits">value_traits</classname> template parameter are reinitialized and thus can be reused.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor>
<method-group name="public static functions">
<method name="container_from_end_iterator" specifiers="static"><type><classname>splay_multiset</classname> &amp;</type><parameter name="end_iterator"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_end_iterator" specifiers="static"><type>const <classname>splay_multiset</classname> &amp;</type><parameter name="end_iterator"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type><classname>splay_multiset</classname> &amp;</type><parameter name="it"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type>const <classname>splay_multiset</classname> &amp;</type><parameter name="it"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="init_node" specifiers="static"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value shall not be in a container.</para><para><emphasis role="bold">Effects</emphasis>: init_node puts the hook of a value in a well-known default state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: This function puts the hook in the well-known default state used by auto_unlink and safe hooks. </para></description></method>
</method-group>
</class><class name="splay_set"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>The class template <classname alt="boost::intrusive::splay_set">splay_set</classname> is an intrusive container, that mimics most of the interface of std::set as described in the C++ standard.</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput> and <computeroutput>compare&lt;&gt;</computeroutput>. </para></description><typedef name="value_type"><type>implementation_defined::value_type</type></typedef>
<typedef name="key_type"><type>implementation_defined::key_type</type></typedef>
<typedef name="key_of_value"><type>implementation_defined::key_of_value</type></typedef>
<typedef name="value_traits"><type>implementation_defined::value_traits</type></typedef>
<typedef name="pointer"><type>implementation_defined::pointer</type></typedef>
<typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef>
<typedef name="reference"><type>implementation_defined::reference</type></typedef>
<typedef name="const_reference"><type>implementation_defined::const_reference</type></typedef>
<typedef name="difference_type"><type>implementation_defined::difference_type</type></typedef>
<typedef name="size_type"><type>implementation_defined::size_type</type></typedef>
<typedef name="value_compare"><type>implementation_defined::value_compare</type></typedef>
<typedef name="key_compare"><type>implementation_defined::key_compare</type></typedef>
<typedef name="iterator"><type>implementation_defined::iterator</type></typedef>
<typedef name="const_iterator"><type>implementation_defined::const_iterator</type></typedef>
<typedef name="reverse_iterator"><type>implementation_defined::reverse_iterator</type></typedef>
<typedef name="const_reverse_iterator"><type>implementation_defined::const_reverse_iterator</type></typedef>
<typedef name="insert_commit_data"><type>implementation_defined::insert_commit_data</type></typedef>
<typedef name="node_traits"><type>implementation_defined::node_traits</type></typedef>
<typedef name="node"><type>implementation_defined::node</type></typedef>
<typedef name="node_ptr"><type>implementation_defined::node_ptr</type></typedef>
<typedef name="const_node_ptr"><type>implementation_defined::const_node_ptr</type></typedef>
<typedef name="node_algorithms"><type>implementation_defined::node_algorithms</type></typedef>
<data-member name="constant_time_size" specifiers="static"><type>const bool</type></data-member>
<method-group name="public member functions">
<method name="begin"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rbegin"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a iterator pointing to the root node of the container or end() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="croot" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the key_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If key_compare copy-constructor throws. </para></description></method>
<method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the value_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_compare copy-constructor throws. </para></description></method>
<method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this if constant-time size option is disabled. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="swap"><type>void</type><parameter name="other"><paramtype><classname>splay_set</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of two containers.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison functor's swap call throws. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>splay_set</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee. Additional notes: it also copies the alpha factor from the source container. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype><classname>splay_set</classname> &amp;&amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(reference) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: This version can modify the source container, useful to implement move semantics. </para></description></method>
<method name="insert"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the container if the value is not already present.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and "hint" must be a valid iterator</para><para><emphasis role="bold">Effects</emphasis>: Tries to insert x into the container, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time (two comparisons in the worst case) if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_check"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee. </para></description></method>
<method name="insert_check"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it's amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee. </para></description></method>
<method name="insert_check"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must be a comparison function that induces the same strict weak ordering as key_compare. The difference is that comp compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the container. </para></description></method>
<method name="insert_check"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must be a comparison function that induces the same strict weak ordering as key_compare. The difference is that comp compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it's amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the constructing that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that key to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This can give a total constant-time complexity to the insertion: check(O(1)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the container. </para></description></method>
<method name="insert"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Tries to insert each element of a range into the container.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_commit"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><parameter name="commit_data"><paramtype>const insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue of type value_type. commit_data must have been obtained from a previous call to "insert_check". No objects should have been inserted or erased from the container between the "insert_check" that filled "commit_data" and the call to "insert_commit".</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value in the container using the information obtained from the "commit_data" that a previous "insert_check" filled.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the newly inserted object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function has only sense if a "insert_check" has been previously executed to fill "commit_data". No value should be inserted or erased between the "insert_check" and "insert_commit" calls. </para></description></method>
<method name="insert_before"><type>iterator</type><parameter name="pos"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, "pos" must be a valid iterator (or end) and must be the succesor of value once inserted according to the predicate</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container before "pos".</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if "pos" is not the successor of "value" container ordering invariant will be broken. This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_back"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no less than the greatest inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the last position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is less than the greatest inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_front"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no greater than the minimum inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the first position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is greater than the minimum inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="i"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp".</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk) and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="clear"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="clear_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements calling disposer(p) for each node to be erased. <emphasis role="bold">Complexity</emphasis>: Average complexity for is at most O(log(size() + N)), where N is the number of elements in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. Calls N times to disposer functor. </para></description></method>
<method name="count" cv="const"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given value</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given value.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. Additional note: const function, no splaying is performed </para></description></method>
<method name="count" cv="const"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. Additional note: const function, no splaying is performed </para></description></method>
<method name="count" cv="const"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given value</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given value.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. Additional note: const function, no splaying is performed </para></description></method>
<method name="count" cv="const"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. Additional note: const function, no splaying is performed </para></description></method>
<method name="lower_bound"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. Additional note: non-const function, splaying is performed. </para></description></method>
<method name="lower_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. Additional note: non-const function, splaying is performed for the first element of the equal range of "key" </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. Additional note: const function, no splaying is performed </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. Additional note: const function, no splaying is performed </para></description></method>
<method name="upper_bound"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. Additional note: non-const function, splaying is performed for the first element of the equal range of "value" </para></description></method>
<method name="upper_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. Additional note: non-const function, splaying is performed for the first element of the equal range of "key" </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. Additional note: const function, no splaying is performed </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. Additional note: const function, no splaying is performed </para></description></method>
<method name="find"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. Additional note: non-const function, splaying is performed for the first element of the equal range of "value" </para></description></method>
<method name="find"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. Additional note: non-const function, splaying is performed for the first element of the equal range of "key" </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. Additional note: const function, no splaying is performed </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. Additional note: const function, no splaying is performed </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="lower_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="lower_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="iterator_to"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="unlink_leftmost_without_rebalance"><type>pointer</type><description><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the container.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the container and the container can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the container. </para></description></method>
<method name="replace_node"><type>void</type><parameter name="replace_this"><paramtype>iterator</paramtype></parameter><parameter name="with_this"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: replace_this must be a valid iterator of *this and with_this must not be inserted in any container.</para><para><emphasis role="bold">Effects</emphasis>: Replaces replace_this in its position in the container with with_this. The container does not need to be rebalanced.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if with_this is not equivalent to *replace_this according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. </para></description></method>
<method name="remove_node"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: removes "value" from the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic time.</para><para><emphasis role="bold">Note</emphasis>: This static function is only usable with non-constant time size containers that have stateless comparison functors.</para><para>If the user calls this function with a constant time size container or stateful comparison functor a compilation error will be issued. </para></description></method>
<method name="splay_up"><type>void</type><parameter name="i"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: i must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Rearranges the container so that the element pointed by i is placed as the root of the tree, improving future searches of this value.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="splay_down"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Rearranges the container so that if *this stores an element with a key equivalent to value the element is placed as the root of the tree. If the element is not present returns the last node compared with the key. If the tree is empty, end() is returned.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the new root of the tree, end() if the tree is empty.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison functor throws. </para></description></method>
<method name="splay_down"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Rearranges the container so that if *this stores an element with a key equivalent to value the element is placed as the root of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the new root of the tree, end() if the tree is empty.</para><para><emphasis role="bold">Throws</emphasis>: If the predicate throws. </para></description></method>
<method name="rebalance"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Rebalances the tree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear. </para></description></method>
<method name="rebalance_subtree"><type>iterator</type><parameter name="root"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: old_root is a node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Rebalances the subtree rooted at old_root.</para><para><emphasis role="bold">Returns</emphasis>: The new root of the subtree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements in the subtree. </para></description></method>
<method name="merge"><type>void</type><template>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="source"><paramtype><classname>splay_set</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="source"><paramtype><classname>splay_multiset</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container with given comparison and traits.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype><default>key_compare()</default></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type. cmp must be a comparison function that induces a strict weak ordering.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container and inserts elements from [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if [b, e) is already sorted using comp and otherwise N * log N, where N is the distance between first and last.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor/operator() of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>splay_set</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a container moving resources from another container. Internal comparison object and value traits are move constructed and nodes belonging to x (except the node representing the "end") are linked to *this.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node's move constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the move constructor of the comparison objet throws. </para></description></constructor>
<copy-assignment><type><classname>splay_set</classname> &amp;</type><parameter name="x"><paramtype><classname>splay_set</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to swap </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the set are not deleted (i.e. no destructors are called), but the nodes according to the <classname alt="boost::intrusive::value_traits">value_traits</classname> template parameter are reinitialized and thus can be reused.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor>
<method-group name="public static functions">
<method name="container_from_end_iterator" specifiers="static"><type><classname>splay_set</classname> &amp;</type><parameter name="end_iterator"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_end_iterator" specifiers="static"><type>const <classname>splay_set</classname> &amp;</type><parameter name="end_iterator"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type><classname>splay_set</classname> &amp;</type><parameter name="it"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type>const <classname>splay_set</classname> &amp;</type><parameter name="it"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="init_node" specifiers="static"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value shall not be in a container.</para><para><emphasis role="bold">Effects</emphasis>: init_node puts the hook of a value in a well-known default state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: This function puts the hook in the well-known default state used by auto_unlink and safe hooks. </para></description></method>
</method-group>
</class><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>splay_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>splay_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>splay_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>splay_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>splay_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>splay_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>splay_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>splay_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype><classname>splay_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>splay_set</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>splay_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>splay_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>splay_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>splay_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>splay_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>splay_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>splay_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>splay_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>
<function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype><classname>splay_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>splay_multiset</classname>&lt; T, Options... &gt; &amp;</paramtype></parameter></function>










































</namespace>
</namespace>
</header>
<header name="boost/intrusive/splaytree.hpp">
<namespace name="boost">
<namespace name="intrusive">
<struct name="make_splaytree"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>splaytree</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct><class name="splaytree"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>The class template splaytree is an intrusive splay tree container that is used to construct intrusive <classname alt="boost::intrusive::splay_set">splay_set</classname> and <classname alt="boost::intrusive::splay_multiset">splay_multiset</classname> containers. The no-throw guarantee holds only, if the key_compare object doesn't throw.</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput> and <computeroutput>compare&lt;&gt;</computeroutput>. </para></description><typedef name="value_traits"><type>ValueTraits</type></typedef>
<typedef name="pointer"><type>implementation_defined::pointer</type></typedef>
<typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef>
<typedef name="value_type"><type>implementation_defined::value_type</type></typedef>
<typedef name="key_type"><type>implementation_defined::key_type</type></typedef>
<typedef name="key_of_value"><type>implementation_defined::key_of_value</type></typedef>
<typedef name="reference"><type>implementation_defined::reference</type></typedef>
<typedef name="const_reference"><type>implementation_defined::const_reference</type></typedef>
<typedef name="difference_type"><type>implementation_defined::difference_type</type></typedef>
<typedef name="size_type"><type>implementation_defined::size_type</type></typedef>
<typedef name="value_compare"><type>implementation_defined::value_compare</type></typedef>
<typedef name="key_compare"><type>implementation_defined::key_compare</type></typedef>
<typedef name="iterator"><type>implementation_defined::iterator</type></typedef>
<typedef name="const_iterator"><type>implementation_defined::const_iterator</type></typedef>
<typedef name="reverse_iterator"><type>implementation_defined::reverse_iterator</type></typedef>
<typedef name="const_reverse_iterator"><type>implementation_defined::const_reverse_iterator</type></typedef>
<typedef name="node_traits"><type>implementation_defined::node_traits</type></typedef>
<typedef name="node"><type>implementation_defined::node</type></typedef>
<typedef name="node_ptr"><type>implementation_defined::node_ptr</type></typedef>
<typedef name="const_node_ptr"><type>implementation_defined::const_node_ptr</type></typedef>
<typedef name="node_algorithms"><type>implementation_defined::node_algorithms</type></typedef>
<typedef name="insert_commit_data"><type>implementation_defined::insert_commit_data</type></typedef>
<data-member name="constant_time_size" specifiers="static"><type>const bool</type></data-member>
<method-group name="public member functions">
<method name="begin"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rbegin"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a iterator pointing to the root node of the container or end() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="croot" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the key_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If key_compare copy-constructor throws. </para></description></method>
<method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the value_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_compare copy-constructor throws. </para></description></method>
<method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this if constant-time size option is disabled. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="swap"><type>void</type><parameter name="other"><paramtype><classname>splaytree</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of two containers.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison functor's swap call throws. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>splaytree</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee. Additional notes: it also copies the alpha factor from the source container. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype><classname>splaytree</classname> &amp;&amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(reference) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: This version can modify the source container, useful to implement move semantics. </para></description></method>
<method name="insert_equal"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the container before the upper bound.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal key_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_equal"><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and "hint" must be a valid iterator.</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container, using "hint" as a hint to where it will be inserted. If "hint" is the upper_bound the insertion takes constant time (two comparisons in the worst case)</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the internal key_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_equal"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Inserts a each element of a range into the container before the upper bound of the key of each element.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_unique"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the container if the value is not already present.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_unique"><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and "hint" must be a valid iterator</para><para><emphasis role="bold">Effects</emphasis>: Tries to insert x into the container, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time (two comparisons in the worst case) if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_unique_check"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee. </para></description></method>
<method name="insert_unique_check"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it's amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee. </para></description></method>
<method name="insert_unique_check"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must be a comparison function that induces the same strict weak ordering as key_compare. The difference is that comp compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the container. </para></description></method>
<method name="insert_unique_check"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must be a comparison function that induces the same strict weak ordering as key_compare. The difference is that comp compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it's amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the constructing that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that key to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This can give a total constant-time complexity to the insertion: check(O(1)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the container. </para></description></method>
<method name="insert_unique_commit"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><parameter name="commit_data"><paramtype>const insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue of type value_type. commit_data must have been obtained from a previous call to "insert_check". No objects should have been inserted or erased from the container between the "insert_check" that filled "commit_data" and the call to "insert_commit".</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value in the container using the information obtained from the "commit_data" that a previous "insert_check" filled.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the newly inserted object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function has only sense if a "insert_check" has been previously executed to fill "commit_data". No value should be inserted or erased between the "insert_check" and "insert_commit" calls. </para></description></method>
<method name="insert_unique"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Tries to insert each element of a range into the container.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_before"><type>iterator</type><parameter name="pos"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, "pos" must be a valid iterator (or end) and must be the succesor of value once inserted according to the predicate</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container before "pos".</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if "pos" is not the successor of "value" container ordering invariant will be broken. This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_back"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no less than the greatest inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the last position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is less than the greatest inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_front"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no greater than the minimum inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the first position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is greater than the minimum inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="i"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp".</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk) and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="clear"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="clear_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements calling disposer(p) for each node to be erased. <emphasis role="bold">Complexity</emphasis>: Average complexity for is at most O(log(size() + N)), where N is the number of elements in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. Calls N times to disposer functor. </para></description></method>
<method name="count"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given value</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given value.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. Additional note: non-const function, splaying is performed. </para></description></method>
<method name="count"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. Additional note: non-const function, splaying is performed. </para></description></method>
<method name="count" cv="const"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given value</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given value.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. Additional note: const function, no splaying is performed </para></description></method>
<method name="count" cv="const"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. Additional note: const function, no splaying is performed </para></description></method>
<method name="lower_bound"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. Additional note: non-const function, splaying is performed. </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. Additional note: const function, no splaying is performed </para></description></method>
<method name="lower_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. Additional note: non-const function, splaying is performed for the first element of the equal range of "key" </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. Additional note: const function, no splaying is performed </para></description></method>
<method name="upper_bound"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. Additional note: non-const function, splaying is performed for the first element of the equal range of "value" </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. Additional note: const function, no splaying is performed </para></description></method>
<method name="upper_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. Additional note: non-const function, splaying is performed for the first element of the equal range of "key" </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. Additional note: const function, no splaying is performed </para></description></method>
<method name="find"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. Additional note: non-const function, splaying is performed for the first element of the equal range of "value" </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. Additional note: const function, no splaying is performed </para></description></method>
<method name="find"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. Additional note: non-const function, splaying is performed for the first element of the equal range of "key" </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. Additional note: const function, no splaying is performed </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. Additional note: non-const function, splaying is performed for the first element of the equal range of "value" </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. Additional note: const function, no splaying is performed </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. Additional note: non-const function, splaying is performed for the first element of the equal range of "key" </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. Additional note: const function, no splaying is performed </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="lower_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="lower_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="iterator_to"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="unlink_leftmost_without_rebalance"><type>pointer</type><description><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the container.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the container and the container can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the container. </para></description></method>
<method name="replace_node"><type>void</type><parameter name="replace_this"><paramtype>iterator</paramtype></parameter><parameter name="with_this"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: replace_this must be a valid iterator of *this and with_this must not be inserted in any container.</para><para><emphasis role="bold">Effects</emphasis>: Replaces replace_this in its position in the container with with_this. The container does not need to be rebalanced.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if with_this is not equivalent to *replace_this according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. </para></description></method>
<method name="remove_node"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: removes "value" from the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic time.</para><para><emphasis role="bold">Note</emphasis>: This static function is only usable with non-constant time size containers that have stateless comparison functors.</para><para>If the user calls this function with a constant time size container or stateful comparison functor a compilation error will be issued. </para></description></method>
<method name="merge_unique"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name=""><paramtype><classname>splaytree</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge_equal"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name=""><paramtype><classname>splaytree</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Extracts each element in source and insert it into a using the comparison object of *this.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="splay_up"><type>void</type><parameter name="i"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: i must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Rearranges the container so that the element pointed by i is placed as the root of the tree, improving future searches of this value.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="splay_down"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Rearranges the container so that if *this stores an element with a key equivalent to value the element is placed as the root of the tree. If the element is not present returns the last node compared with the key. If the tree is empty, end() is returned.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the new root of the tree, end() if the tree is empty.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison functor throws. </para></description></method>
<method name="splay_down"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Rearranges the container so that if *this stores an element with a key equivalent to value the element is placed as the root of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the new root of the tree, end() if the tree is empty.</para><para><emphasis role="bold">Throws</emphasis>: If the predicate throws. </para></description></method>
<method name="rebalance"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Rebalances the tree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear. </para></description></method>
<method name="rebalance_subtree"><type>iterator</type><parameter name="root"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: old_root is a node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Rebalances the subtree rooted at old_root.</para><para><emphasis role="bold">Returns</emphasis>: The new root of the subtree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements in the subtree. </para></description></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container with given comparison and traits.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="unique"><paramtype>bool</paramtype></parameter><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype><default>key_compare()</default></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type. cmp must be a comparison function that induces a strict weak ordering.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container and inserts elements from [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if [b, e) is already sorted using comp and otherwise N * log N, where N is the distance between first and last.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor/operator() of the key_compare object throws. Basic guarantee. </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>splaytree</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a container moving resources from another container. Internal comparison object and value traits are move constructed and nodes belonging to x (except the node representing the "end") are linked to *this.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node's move constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the move constructor of the comparison objet throws. </para></description></constructor>
<copy-assignment><type><classname>splaytree</classname> &amp;</type><parameter name="x"><paramtype><classname>splaytree</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to swap </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the set are not deleted (i.e. no destructors are called), but the nodes according to the <classname alt="boost::intrusive::value_traits">value_traits</classname> template parameter are reinitialized and thus can be reused.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor>
<method-group name="public static functions">
<method name="container_from_end_iterator" specifiers="static"><type><classname>splaytree</classname> &amp;</type><parameter name="end_iterator"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_end_iterator" specifiers="static"><type>const <classname>splaytree</classname> &amp;</type><parameter name="end_iterator"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type><classname>splaytree</classname> &amp;</type><parameter name="it"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type>const <classname>splaytree</classname> &amp;</type><parameter name="it"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="init_node" specifiers="static"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value shall not be in a container.</para><para><emphasis role="bold">Effects</emphasis>: init_node puts the hook of a value in a well-known default state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: This function puts the hook in the well-known default state used by auto_unlink and safe hooks. </para></description></method>
</method-group>
</class>



















































</namespace>
</namespace>
</header>
<header name="boost/intrusive/splaytree_algorithms.hpp">
<namespace name="boost">
<namespace name="intrusive">
<class name="splaytree_algorithms"><template>
      <template-type-parameter name="NodeTraits"/>
    </template><description><para>A splay tree is an implementation of a binary search tree. The tree is self balancing using the splay algorithm as described in</para><para>"Self-Adjusting Binary Search Trees by Daniel Dominic Sleator and Robert Endre Tarjan AT&amp;T Bell Laboratories, Murray Hill, NJ Journal of the ACM, Vol 32, no 3, July 1985, pp 652-686</para><para><classname alt="boost::intrusive::splaytree_algorithms">splaytree_algorithms</classname> is configured with a NodeTraits class, which encapsulates the information about the node to be manipulated. NodeTraits must support the following interface:</para><para><emphasis role="bold">Typedefs</emphasis>:</para><para><computeroutput>node</computeroutput>: The type of the node that forms the binary search tree</para><para><computeroutput>node_ptr</computeroutput>: A pointer to a node</para><para><computeroutput>const_node_ptr</computeroutput>: A pointer to a const node</para><para><emphasis role="bold">Static functions</emphasis>:</para><para><computeroutput>static node_ptr get_parent(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_parent(node_ptr n, node_ptr parent);</computeroutput></para><para><computeroutput>static node_ptr get_left(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_left(node_ptr n, node_ptr left);</computeroutput></para><para><computeroutput>static node_ptr get_right(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_right(node_ptr n, node_ptr right);</computeroutput> </para></description><typedef name="node"><type>NodeTraits::node</type></typedef>
<typedef name="node_traits"><type>NodeTraits</type></typedef>
<typedef name="node_ptr"><type>NodeTraits::node_ptr</type></typedef>
<typedef name="const_node_ptr"><type>NodeTraits::const_node_ptr</type></typedef>
<typedef name="insert_commit_data"><description><para>This type is the information that will be filled by insert_unique_check </para></description><type>bstree_algo::insert_commit_data</type></typedef>
<method-group name="public static functions">
<method name="get_header" specifiers="static"><type>node_ptr</type><parameter name="n"><paramtype>const const_node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'node' is a node of the tree or a header node.</para><para><emphasis role="bold">Effects</emphasis>: Returns the header of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="begin_node" specifiers="static"><type>node_ptr</type><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'header' is the header node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Returns the first node of the tree, the header if the tree is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end_node" specifiers="static"><type>node_ptr</type><parameter name="header"><paramtype>const const_node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'header' is the header node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Returns the header of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="swap_tree" specifiers="static"><type>void</type><parameter name="header1"><paramtype>const node_ptr &amp;</paramtype></parameter><parameter name="header2"><paramtype>const node_ptr &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header1 and header2 must be the header nodes of two trees.</para><para><emphasis role="bold">Effects</emphasis>: Swaps two trees. After the function header1 will contain links to the second tree and header2 will have links to the first tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="swap_nodes" specifiers="static"><type>void</type><parameter name="node1"><paramtype>node_ptr</paramtype></parameter><parameter name="node2"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node1 and node2 can't be header nodes of two trees.</para><para><emphasis role="bold">Effects</emphasis>: Swaps two nodes. After the function node1 will be inserted in the position node2 before the function. node2 will be inserted in the position node1 had before the function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if node1 and node2 are not equivalent according to the ordering rules.</para><para>Experimental function </para></description></method>
<method name="swap_nodes" specifiers="static"><type>void</type><parameter name="node1"><paramtype>node_ptr</paramtype></parameter><parameter name="header1"><paramtype>node_ptr</paramtype></parameter><parameter name="node2"><paramtype>node_ptr</paramtype></parameter><parameter name="header2"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node1 and node2 can't be header nodes of two trees with header header1 and header2.</para><para><emphasis role="bold">Effects</emphasis>: Swaps two nodes. After the function node1 will be inserted in the position node2 before the function. node2 will be inserted in the position node1 had before the function.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if node1 and node2 are not equivalent according to the ordering rules.</para><para>Experimental function </para></description></method>
<method name="replace_node" specifiers="static"><type>void</type><parameter name="node_to_be_replaced"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node_to_be_replaced must be inserted in a tree and new_node must not be inserted in a tree.</para><para><emphasis role="bold">Effects</emphasis>: Replaces node_to_be_replaced in its position in the tree with new_node. The tree does not need to be rebalanced</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if new_node is not equivalent to node_to_be_replaced according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing and comparison is needed. Experimental function </para></description></method>
<method name="replace_node" specifiers="static"><type>void</type><parameter name="node_to_be_replaced"><paramtype>node_ptr</paramtype></parameter><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node_to_be_replaced must be inserted in a tree with header "header" and new_node must not be inserted in a tree.</para><para><emphasis role="bold">Effects</emphasis>: Replaces node_to_be_replaced in its position in the tree with new_node. The tree does not need to be rebalanced</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if new_node is not equivalent to node_to_be_replaced according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. Experimental function </para></description></method>
<method name="unlink" specifiers="static"><type>void</type><parameter name="node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node is a tree node but not the header.</para><para><emphasis role="bold">Effects</emphasis>: Unlinks the node and rebalances the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="unlink_leftmost_without_rebalance" specifiers="static"><type>node_ptr</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header is the header of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the tree, and updates the header link to the new leftmost node.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the tree and the tree can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the tree. </para></description></method>
<method name="unique" specifiers="static"><type>bool</type><parameter name="node"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'node' is a node of the tree or a node initialized by init(...) or init_node.</para><para><emphasis role="bold">Effects</emphasis>: Returns true if the node is initialized by init() or init_node().</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="size" specifiers="static"><type>std::size_t</type><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node is a node of the tree but it's not the header.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of nodes of the subtree.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="next_node" specifiers="static"><type>node_ptr</type><parameter name="node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'node' is a node from the tree except the header.</para><para><emphasis role="bold">Effects</emphasis>: Returns the next node of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="prev_node" specifiers="static"><type>node_ptr</type><parameter name="node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'node' is a node from the tree except the leftmost node.</para><para><emphasis role="bold">Effects</emphasis>: Returns the previous node of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="init" specifiers="static"><type>void</type><parameter name="node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'node' must not be part of any tree.</para><para><emphasis role="bold">Effects</emphasis>: After the function unique(node) == true.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Nodes</emphasis>: If node is inserted in a tree, this function corrupts the tree. </para></description></method>
<method name="init_header" specifiers="static"><type>void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node must not be part of any tree.</para><para><emphasis role="bold">Effects</emphasis>: Initializes the header to represent an empty tree. unique(header) == true.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Nodes</emphasis>: If node is inserted in a tree, this function corrupts the tree. </para></description></method>
<method name="erase" specifiers="static"><type>void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="z"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header must be the header of a tree, z a node of that tree and z != header.</para><para><emphasis role="bold">Effects</emphasis>: Erases node "z" from the tree with header "header".</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. Additional notes: the previous node of z is splayed to speed up range deletions. </para></description></method>
<method name="transfer_unique" specifiers="static"><type>bool</type><template>
          <template-type-parameter name="NodePtrCompare"/>
        </template><parameter name="header1"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><parameter name="header2"><paramtype>node_ptr</paramtype></parameter><parameter name="z"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header1 and header2 must be the headers of trees tree1 and tree2 respectively, z a non-header node of tree1. NodePtrCompare is the comparison function of tree1..</para><para><emphasis role="bold">Effects</emphasis>: Transfers node "z" from tree1 to tree2 if tree1 does not contain a node that is equivalent to z.</para><para><emphasis role="bold">Returns</emphasis>: True if the node was trasferred, false otherwise.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison throws. </para></description></method>
<method name="transfer_equal" specifiers="static"><type>void</type><template>
          <template-type-parameter name="NodePtrCompare"/>
        </template><parameter name="header1"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><parameter name="header2"><paramtype>node_ptr</paramtype></parameter><parameter name="z"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header1 and header2 must be the headers of trees tree1 and tree2 respectively, z a non-header node of tree1. NodePtrCompare is the comparison function of tree1..</para><para><emphasis role="bold">Effects</emphasis>: Transfers node "z" from tree1 to tree2.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison throws. </para></description></method>
<method name="clone" specifiers="static"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="source_header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="target_header"><paramtype>node_ptr</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "cloner" must be a function object taking a node_ptr and returning a new cloned node of it. "disposer" must take a node_ptr and shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: First empties target tree calling <computeroutput>void disposer::operator()(const node_ptr &amp;)</computeroutput> for every node of the tree except the header.</para><para>Then, duplicates the entire tree pointed by "source_header" cloning each source node with <computeroutput>node_ptr Cloner::operator()(const node_ptr &amp;)</computeroutput> to obtain the nodes of the target tree. If "cloner" throws, the cloned target nodes are disposed using <computeroutput>void disposer(const node_ptr &amp;)</computeroutput>.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of element of the source tree plus the number of elements of tree target tree when calling this function.</para><para><emphasis role="bold">Throws</emphasis>: If cloner functor throws. If this happens target nodes are disposed. </para></description></method>
<method name="clear_and_dispose" specifiers="static"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "disposer" must be an object function taking a node_ptr parameter and shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Empties the target tree calling <computeroutput>void disposer::operator()(const node_ptr &amp;)</computeroutput> for every node of the tree except the header.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of element of the source tree plus the. number of elements of tree target tree when calling this function.</para><para><emphasis role="bold">Throws</emphasis>: If cloner functor throws. If this happens target nodes are disposed. </para></description></method>
<method name="count" specifiers="static"><type>std::size_t</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements with a key equivalent to "key" according to "comp".</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. Additional notes: an element with key <computeroutput>key</computeroutput> is splayed. </para></description></method>
<method name="count" specifiers="static"><type>std::size_t</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements with a key equivalent to "key" according to "comp".</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. Additional note: no splaying is performed </para></description></method>
<method name="lower_bound" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns a node_ptr to the first element that is not less than "key" according to "comp" or "header" if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. Additional notes: the first node of the range is splayed. </para></description></method>
<method name="lower_bound" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns a node_ptr to the first element that is not less than "key" according to "comp" or "header" if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. Additional note: no splaying is performed </para></description></method>
<method name="upper_bound" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns a node_ptr to the first element that is greater than "key" according to "comp" or "header" if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. Additional notes: the first node of the range is splayed. </para></description></method>
<method name="upper_bound" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns a node_ptr to the first element that is greater than "key" according to "comp" or "header" if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. Additional note: no splaying is performed </para></description></method>
<method name="find" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns a node_ptr to the first element that is equivalent to "key" according to "comp" or "header" if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. Additional notes: the found node of the lower bound is splayed. </para></description></method>
<method name="find" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns a node_ptr to the first element that is equivalent to "key" according to "comp" or "header" if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. Additional note: no splaying is performed </para></description></method>
<method name="equal_range" specifiers="static"><type>std::pair&lt; node_ptr, node_ptr &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair of node_ptr delimiting a range containing all elements that are equivalent to "key" according to "comp" or an empty range that indicates the position where those elements would be if there are no equivalent elements.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. Additional notes: the first node of the range is splayed. </para></description></method>
<method name="equal_range" specifiers="static"><type>std::pair&lt; node_ptr, node_ptr &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair of node_ptr delimiting a range containing all elements that are equivalent to "key" according to "comp" or an empty range that indicates the position where those elements would be if there are no equivalent elements.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. Additional note: no splaying is performed </para></description></method>
<method name="lower_bound_range" specifiers="static"><type>std::pair&lt; node_ptr, node_ptr &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair of node_ptr delimiting a range containing the first element that is equivalent to "key" according to "comp" or an empty range that indicates the position where that element would be if there are no equivalent elements.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. Additional notes: the first node of the range is splayed. </para></description></method>
<method name="lower_bound_range" specifiers="static"><type>std::pair&lt; node_ptr, node_ptr &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair of node_ptr delimiting a range containing the first element that is equivalent to "key" according to "comp" or an empty range that indicates the position where that element would be if there are no equivalent elements.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. Additional note: no splaying is performed </para></description></method>
<method name="bounded_range" specifiers="static"><type>std::pair&lt; node_ptr, node_ptr &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs. 'lower_key' must not be greater than 'upper_key' according to 'comp'. If 'lower_key' == 'upper_key', ('left_closed' || 'right_closed') must be true.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change. Additional notes: the first node of the range is splayed. </para></description></method>
<method name="bounded_range" specifiers="static"><type>std::pair&lt; node_ptr, node_ptr &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs. 'lower_key' must not be greater than 'upper_key' according to 'comp'. If 'lower_key' == 'upper_key', ('left_closed' || 'right_closed') must be true.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change. Additional note: no splaying is performed </para></description></method>
<method name="insert_equal_upper_bound" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="NodePtrCompare"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "h" must be the header node of a tree. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares two node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree before the upper bound according to "comp".</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. Additional note: the inserted node is splayed </para></description></method>
<method name="insert_equal_lower_bound" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="NodePtrCompare"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "h" must be the header node of a tree. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares two node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree before the lower bound according to "comp".</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. Additional note: the inserted node is splayed </para></description></method>
<method name="insert_equal" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="NodePtrCompare"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="hint"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares two node_ptrs. "hint" is node from the "header"'s tree.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree, using "hint" as a hint to where it will be inserted. If "hint" is the upper_bound the insertion takes constant time (two comparisons in the worst case).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time if new_node is inserted immediately before "hint".</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. Additional note: the inserted node is splayed </para></description></method>
<method name="insert_before" specifiers="static"><type>node_ptr</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="pos"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. "pos" must be a valid iterator or header (end) node. "pos" must be an iterator pointing to the successor to "new_node" once inserted according to the order of already inserted nodes. This function does not check "pos" and this precondition must be guaranteed by the caller.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree before "pos".</para><para><emphasis role="bold">Complexity</emphasis>: Constant-time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: If "pos" is not the successor of the newly inserted "new_node" tree invariants might be broken. Additional note: the inserted node is splayed </para></description></method>
<method name="push_back" specifiers="static"><type>void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. "new_node" must be, according to the used ordering no less than the greatest inserted key.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree before "pos".</para><para><emphasis role="bold">Complexity</emphasis>: Constant-time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: If "new_node" is less than the greatest inserted key tree invariants are broken. This function is slightly faster than using "insert_before". Additional note: the inserted node is splayed </para></description></method>
<method name="push_front" specifiers="static"><type>void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. "new_node" must be, according to the used ordering, no greater than the lowest inserted key.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree before "pos".</para><para><emphasis role="bold">Complexity</emphasis>: Constant-time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: If "new_node" is greater than the lowest inserted key tree invariants are broken. This function is slightly faster than using "insert_before". Additional note: the inserted node is splayed </para></description></method>
<method name="insert_unique_check" specifiers="static"><type>std::pair&lt; node_ptr, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares KeyType with a node_ptr.</para><para><emphasis role="bold">Effects</emphasis>: Checks if there is an equivalent node to "key" in the tree according to "comp" and obtains the needed information to realize a constant-time node insertion if there is no equivalent node.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing a node_ptr to the already present node and false. If there is not equivalent key can be inserted returns true in the returned pair's boolean and fills "commit_data" that is meant to be used with the "insert_commit" function to achieve a constant-time insertion function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a node is expensive and the user does not want to have two equivalent nodes in the tree: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the node and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the node and use "insert_commit" to insert the node in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_unique_commit" only if no more objects are inserted or erased from the set. Additional note: nodes with the given key are splayed </para></description></method>
<method name="insert_unique_check" specifiers="static"><type>std::pair&lt; node_ptr, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="hint"><paramtype>node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares KeyType with a node_ptr. "hint" is node from the "header"'s tree.</para><para><emphasis role="bold">Effects</emphasis>: Checks if there is an equivalent node to "key" in the tree according to "comp" using "hint" as a hint to where it should be inserted and obtains the needed information to realize a constant-time node insertion if there is no equivalent node. If "hint" is the upper_bound the function has constant time complexity (two comparisons in the worst case).</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing a node_ptr to the already present node and false. If there is not equivalent key can be inserted returns true in the returned pair's boolean and fills "commit_data" that is meant to be used with the "insert_commit" function to achieve a constant-time insertion function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic, but it is amortized constant time if new_node should be inserted immediately before "hint".</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a node is expensive and the user does not want to have two equivalent nodes in the tree: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the node and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the node and use "insert_commit" to insert the node in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_unique_commit" only if no more objects are inserted or erased from the set. Additional note: nodes with the given key are splayed </para></description></method>
<method name="insert_unique_commit" specifiers="static"><type>void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_value"><paramtype>node_ptr</paramtype></parameter><parameter name="commit_data"><paramtype>const insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. "commit_data" must have been obtained from a previous call to "insert_unique_check". No objects should have been inserted or erased from the set between the "insert_unique_check" that filled "commit_data" and the call to "insert_commit".</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node in the set using the information obtained from the "commit_data" that a previous "insert_check" filled.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function has only sense if a "insert_unique_check" has been previously executed to fill "commit_data". No value should be inserted or erased between the "insert_check" and "insert_commit" calls. </para></description></method>
<method name="is_header" specifiers="static"><type>bool</type><parameter name="p"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p is a node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Returns true if p is the header of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rebalance" specifiers="static"><type>void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header must be the header of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Rebalances the tree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear. </para></description></method>
<method name="rebalance_subtree" specifiers="static"><type>node_ptr</type><parameter name="old_root"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: old_root is a node of a tree. It shall not be null.</para><para><emphasis role="bold">Effects</emphasis>: Rebalances the subtree rooted at old_root.</para><para><emphasis role="bold">Returns</emphasis>: The new root of the subtree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear. </para></description></method>
<method name="splay_up" specifiers="static"><type>void</type><parameter name="node"><paramtype>node_ptr</paramtype></parameter><parameter name="header"><paramtype>node_ptr</paramtype></parameter></method>
<method name="splay_down" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><parameter name="pfound"><paramtype>bool *</paramtype><default>0</default></parameter></method>
</method-group>
</class>



















































</namespace>
</namespace>
</header>
<header name="boost/intrusive/treap.hpp">
<namespace name="boost">
<namespace name="intrusive">
<struct name="make_treap"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>treap</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="packed_options"><type><classname>pack_options</classname>&lt; treap_defaults, O1, O2, O3, O4, O5, O6, O7 &gt;::<classname>type</classname></type></typedef>
<typedef name="value_traits"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="implementation_defined"><type><classname>treap</classname>&lt; value_traits, typename packed_options::key_of_value, typename packed_options::compare, typename packed_options::priority_of_value, typename packed_options::priority, typename packed_options::size_type, packed_options::constant_time_size, typename packed_options::header_holder_type &gt;</type></typedef>
<typedef name="type"><type><classname>implementation_defined</classname></type></typedef>
</struct><class name="treap"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>The class template treap is an intrusive treap container that is used to construct intrusive set and multiset containers. The no-throw guarantee holds only, if the key_compare object and priority_compare object don't throw.</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput>, <computeroutput>compare&lt;&gt;</computeroutput>, <computeroutput>priority&lt;&gt;</computeroutput> and <computeroutput>priority_of_value&lt;&gt;</computeroutput> </para></description><typedef name="value_traits"><type>ValueTraits</type></typedef>
<typedef name="pointer"><type>implementation_defined::pointer</type></typedef>
<typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef>
<typedef name="value_type"><type>implementation_defined::value_type</type></typedef>
<typedef name="key_type"><type>implementation_defined::key_type</type></typedef>
<typedef name="key_of_value"><type>implementation_defined::key_of_value</type></typedef>
<typedef name="reference"><type>implementation_defined::reference</type></typedef>
<typedef name="const_reference"><type>implementation_defined::const_reference</type></typedef>
<typedef name="difference_type"><type>implementation_defined::difference_type</type></typedef>
<typedef name="size_type"><type>implementation_defined::size_type</type></typedef>
<typedef name="value_compare"><type>implementation_defined::value_compare</type></typedef>
<typedef name="key_compare"><type>implementation_defined::key_compare</type></typedef>
<typedef name="iterator"><type>implementation_defined::iterator</type></typedef>
<typedef name="const_iterator"><type>implementation_defined::const_iterator</type></typedef>
<typedef name="reverse_iterator"><type>implementation_defined::reverse_iterator</type></typedef>
<typedef name="const_reverse_iterator"><type>implementation_defined::const_reverse_iterator</type></typedef>
<typedef name="node_traits"><type>implementation_defined::node_traits</type></typedef>
<typedef name="node"><type>implementation_defined::node</type></typedef>
<typedef name="node_ptr"><type>implementation_defined::node_ptr</type></typedef>
<typedef name="const_node_ptr"><type>implementation_defined::const_node_ptr</type></typedef>
<typedef name="node_algorithms"><type>implementation_defined</type></typedef>
<typedef name="priority_type"><type>implementation_defined</type></typedef>
<typedef name="priority_of_value"><type>implementation_defined</type></typedef>
<typedef name="priority_compare"><type>implementation_defined</type></typedef>
<typedef name="prio_node_prio_comp_t"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="insert_commit_data"><type>node_algorithms::insert_commit_data</type></typedef>
<data-member name="constant_time_size" specifiers="static"><type>const bool</type></data-member>
<data-member name="stateful_value_traits" specifiers="static"><type>const bool</type></data-member>
<data-member name="safemode_or_autounlink" specifiers="static"><type>const bool</type></data-member>
<method-group name="public member functions">
<method name="prio_node_prio_comp" cv="const"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="PrioPrioComp"/>
        </template><parameter name="priopriocomp"><paramtype>PrioPrioComp</paramtype></parameter></method>
<method name="begin"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="top"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the highest priority object of the treap.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="top" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the highest priority object of the treap..</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="ctop" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the highest priority object of the treap..</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rbegin"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a iterator pointing to the root node of the container or end() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="croot" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rtop"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the highest priority object of the reversed treap.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rtop" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the highest priority objec of the reversed treap.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crtop" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the highest priority object of the reversed treap.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the key_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If key_compare copy-constructor throws. </para></description></method>
<method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the value_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_compare copy-constructor throws. </para></description></method>
<method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this if constant-time size option is disabled. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="priority_comp" cv="const"><type>priority_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the priority_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If priority_compare copy-constructor throws. </para></description></method>
<method name="swap"><type>void</type><parameter name="other"><paramtype><classname>treap</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of two treaps.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison functor's swap call throws. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>treap</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype><classname>treap</classname> &amp;&amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(reference) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee. </para></description></method>
<method name="insert_equal"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the container before the upper bound.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal key_compare or priority_compare functions throw. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_equal"><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and "hint" must be a valid iterator.</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container, using "hint" as a hint to where it will be inserted. If "hint" is the upper_bound the insertion takes constant time (two comparisons in the worst case)</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the internal key_compare or priority_compare functions throw. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_equal"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Inserts a each element of a range into the container before the upper bound of the key of each element.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by key_comp().</para><para><emphasis role="bold">Throws</emphasis>: If the internal key_compare or priority_compare functions throw. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_unique"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the container if the value is not already present.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal key_compare or priority_compare functions throw. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_unique"><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and "hint" must be a valid iterator</para><para><emphasis role="bold">Effects</emphasis>: Tries to insert x into the container, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time (two comparisons in the worst case) if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the internal key_compare or priority_compare functions throw. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_unique"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Tries to insert each element of a range into the container.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by key_comp().</para><para><emphasis role="bold">Throws</emphasis>: If the internal key_compare or priority_compare functions throw. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_unique_check"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="prio"><paramtype>const priority_type &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison or predicate functions throw. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the container. </para></description></method>
<method name="insert_unique_check"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="prio"><paramtype>const priority_type &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it's amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison or predicate functions throw. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the constructing that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that key to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This can give a total constant-time complexity to the insertion: check(O(1)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the container. </para></description></method>
<method name="insert_unique_check"><type>std::pair&lt; iterator BOOST_INTRUSIVE_I bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
          <template-type-parameter name="PrioType"/>
          <template-type-parameter name="PrioValuePrioCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="prio"><paramtype>const PrioType &amp;</paramtype></parameter><parameter name="prio_value_pcomp"><paramtype>PrioValuePrioCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must be a comparison function that induces the same strict weak ordering as key_compare. prio_value_pcomp must be a comparison function that induces the same strict weak ordering as priority_compare. The difference is that prio_value_pcomp and comp compare an arbitrary key/priority with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the comp or prio_value_pcomp ordering functions throw. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the container. </para></description></method>
<method name="insert_unique_check"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
          <template-type-parameter name="PrioType"/>
          <template-type-parameter name="PrioValuePrioCompare"/>
        </template><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="prio"><paramtype>const PrioType &amp;</paramtype></parameter><parameter name="prio_value_pcomp"><paramtype>PrioValuePrioCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must be a comparison function that induces the same strict weak ordering as key_compare. prio_value_pcomp must be a comparison function that induces the same strict weak ordering as priority_compare. The difference is that prio_value_pcomp and comp compare an arbitrary key/priority with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it's amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the comp or prio_value_pcomp ordering functions throw. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the constructing that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that key to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This can give a total constant-time complexity to the insertion: check(O(1)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the container. </para></description></method>
<method name="insert_unique_commit"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><parameter name="commit_data"><paramtype>const insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue of type value_type. commit_data must have been obtained from a previous call to "insert_check". No objects should have been inserted or erased from the container between the "insert_check" that filled "commit_data" and the call to "insert_commit".</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value in the <classname alt="boost::intrusive::avl_set">avl_set</classname> using the information obtained from the "commit_data" that a previous "insert_check" filled.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the newly inserted object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Notes</emphasis>: This function has only sense if a "insert_check" has been previously executed to fill "commit_data". No value should be inserted or erased between the "insert_check" and "insert_commit" calls. </para></description></method>
<method name="insert_before"><type>iterator</type><parameter name="pos"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, "pos" must be a valid iterator (or end) and must be the succesor of value once inserted according to the predicate</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container before "pos".</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: If the internal priority_compare function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if "pos" is not the successor of "value" container ordering invariant will be broken. This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_back"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no less than the greatest inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the last position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: If the internal priority_compare function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is less than the greatest inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_front"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no greater than the minimum inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the first position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: If the internal priority_compare function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is greater than the minimum inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="i"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: if the internal priority_compare function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: if the internal priority_compare function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: if the internal priority_compare function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp".</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: if the internal priority_compare function throws. Equivalent guarantee to <emphasis>while(beg != end) erase(beg++);</emphasis></para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: if the internal priority_compare function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: if the internal priority_compare function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: if the priority_compare function throws then weak guarantee and heap invariants are broken. The safest thing would be to clear or destroy the container.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: if the priority_compare function throws then weak guarantee and heap invariants are broken. The safest thing would be to clear or destroy the container.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="clear"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="clear_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements calling disposer(p) for each node to be erased. <emphasis role="bold">Complexity</emphasis>: Average complexity for is at most O(log(size() + N)), where N is the number of elements in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. Calls N times to disposer functor. </para></description></method>
<method name="merge_unique"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name=""><paramtype><classname>sgtree</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="while"><type/><parameter name=""><paramtype>it !</paramtype><default>itend</default></parameter></method>
<method name="merge_equal"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name=""><paramtype><classname>sgtree</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Extracts each element in source and insert it into a using the comparison object of *this.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="while"><type/><parameter name=""><paramtype>it !</paramtype><default>itend</default></parameter></method>
<method name="check" cv="const"><type>void</type><template>
          <template-type-parameter name="ExtraChecker"/>
        </template><parameter name="extra_checker"><paramtype>ExtraChecker</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Asserts the integrity of the container with additional checks provided by the user.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time.</para><para><emphasis role="bold">Note</emphasis>: The method might not have effect when asserts are turned off (e.g., with NDEBUG). Experimental function, interface might change in future versions. </para></description></method>
<method name="check" cv="const"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Asserts the integrity of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time.</para><para><emphasis role="bold">Note</emphasis>: The method has no effect when asserts are turned off (e.g., with NDEBUG). Experimental function, interface might change in future versions. </para></description></method>
<method name="count" cv="const"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given value</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given value.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="count" cv="const"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="lower_bound"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="find"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="find"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="lower_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="lower_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="iterator_to"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="unlink_leftmost_without_rebalance"><type>pointer</type><description><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the container.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the container and the container can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the container. </para></description></method>
<method name="replace_node"><type>void</type><parameter name="replace_this"><paramtype>iterator</paramtype></parameter><parameter name="with_this"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: replace_this must be a valid iterator of *this and with_this must not be inserted in any container.</para><para><emphasis role="bold">Effects</emphasis>: Replaces replace_this in its position in the container with with_this. The container does not need to be rebalanced.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if with_this is not equivalent to *replace_this according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. </para></description></method>
<method name="remove_node"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: removes "value" from the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic time.</para><para><emphasis role="bold">Note</emphasis>: This static function is only usable with non-constant time size containers that have stateless comparison functors.</para><para>If the user calls this function with a constant time size container or stateful comparison functor a compilation error will be issued. </para></description></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the value_compare/priority_compare objects throw. Basic guarantee. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype></parameter><parameter name="pcmp"><paramtype>const priority_compare &amp;</paramtype><default>priority_compare()</default></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the value_compare/priority_compare objects throw. Basic guarantee. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="unique"><paramtype>bool</paramtype></parameter><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype><default>key_compare()</default></parameter><parameter name="pcmp"><paramtype>const priority_compare &amp;</paramtype><default>priority_compare()</default></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type. cmp must be a comparison function that induces a strict weak ordering.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container and inserts elements from [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if [b, e) is already sorted using comp and otherwise N * log N, where N is the distance between first and last.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor/operator() of the key_compare/priority_compare objects throw. Basic guarantee. </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>treap</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a container moving resources from another container. Internal comparison object and value traits are move constructed and nodes belonging to x (except the node representing the "end") are linked to *this.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node's move constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the move constructor of the comparison objet throws. </para></description></constructor>
<copy-assignment><type><classname>treap</classname> &amp;</type><parameter name="x"><paramtype><classname>treap</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to swap </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the set are not deleted (i.e. no destructors are called), but the nodes according to the <classname alt="boost::intrusive::value_traits">value_traits</classname> template parameter are reinitialized and thus can be reused.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor>
<method-group name="public static functions">
<method name="container_from_end_iterator" specifiers="static"><type><classname>treap</classname> &amp;</type><parameter name="end_iterator"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_end_iterator" specifiers="static"><type>const <classname>treap</classname> &amp;</type><parameter name="end_iterator"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type><classname>treap</classname> &amp;</type><parameter name="it"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type>const <classname>treap</classname> &amp;</type><parameter name="it"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="init_node" specifiers="static"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value shall not be in a container.</para><para><emphasis role="bold">Effects</emphasis>: init_node puts the hook of a value in a well-known default state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: This function puts the hook in the well-known default state used by auto_unlink and safe hooks. </para></description></method>
</method-group>
</class>



















































</namespace>
</namespace>
</header>
<header name="boost/intrusive/treap_algorithms.hpp">
<namespace name="boost">
<namespace name="intrusive">
<class name="treap_algorithms"><template>
      <template-type-parameter name="NodeTraits"/>
    </template><description><para><classname alt="boost::intrusive::treap_algorithms">treap_algorithms</classname> provides basic algorithms to manipulate nodes forming a treap.</para><para>(1) the header node is maintained with links not only to the root but also to the leftmost node of the tree, to enable constant time begin(), and to the rightmost node of the tree, to enable linear time performance when used with the generic set algorithms (set_union, etc.);</para><para>(2) when a node being deleted has two children its successor node is relinked into its place, rather than copied, so that the only pointers invalidated are those referring to the deleted node.</para><para><classname alt="boost::intrusive::treap_algorithms">treap_algorithms</classname> is configured with a NodeTraits class, which encapsulates the information about the node to be manipulated. NodeTraits must support the following interface:</para><para><emphasis role="bold">Typedefs</emphasis>:</para><para><computeroutput>node</computeroutput>: The type of the node that forms the treap</para><para><computeroutput>node_ptr</computeroutput>: A pointer to a node</para><para><computeroutput>const_node_ptr</computeroutput>: A pointer to a const node</para><para><emphasis role="bold">Static functions</emphasis>:</para><para><computeroutput>static node_ptr get_parent(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_parent(node_ptr n, node_ptr parent);</computeroutput></para><para><computeroutput>static node_ptr get_left(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_left(node_ptr n, node_ptr left);</computeroutput></para><para><computeroutput>static node_ptr get_right(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_right(node_ptr n, node_ptr right);</computeroutput> </para></description><struct name="insert_commit_data"><description><para>This type is the information that will be filled by insert_unique_check </para></description></struct><typedef name="node_traits"><type>NodeTraits</type></typedef>
<typedef name="node"><type>NodeTraits::node</type></typedef>
<typedef name="node_ptr"><type>NodeTraits::node_ptr</type></typedef>
<typedef name="const_node_ptr"><type>NodeTraits::const_node_ptr</type></typedef>
<method-group name="public static functions">
<method name="get_header" specifiers="static"><type>node_ptr</type><parameter name="n"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'node' is a node of the tree or a header node.</para><para><emphasis role="bold">Effects</emphasis>: Returns the header of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="begin_node" specifiers="static"><type>node_ptr</type><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'header' is the header node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Returns the first node of the tree, the header if the tree is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end_node" specifiers="static"><type>node_ptr</type><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'header' is the header node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Returns the header of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="swap_tree" specifiers="static"><type>void</type><parameter name="header1"><paramtype>node_ptr</paramtype></parameter><parameter name="header2"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header1 and header2 must be the header nodes of two trees.</para><para><emphasis role="bold">Effects</emphasis>: Swaps two trees. After the function header1 will contain links to the second tree and header2 will have links to the first tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="swap_nodes" specifiers="static"><type>void</type><parameter name="node1"><paramtype>node_ptr</paramtype></parameter><parameter name="node2"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node1 and node2 can't be header nodes of two trees.</para><para><emphasis role="bold">Effects</emphasis>: Swaps two nodes. After the function node1 will be inserted in the position node2 before the function. node2 will be inserted in the position node1 had before the function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if node1 and node2 are not equivalent according to the ordering rules.</para><para>Experimental function </para></description></method>
<method name="swap_nodes" specifiers="static"><type>void</type><parameter name="node1"><paramtype>node_ptr</paramtype></parameter><parameter name="header1"><paramtype>node_ptr</paramtype></parameter><parameter name="node2"><paramtype>node_ptr</paramtype></parameter><parameter name="header2"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node1 and node2 can't be header nodes of two trees with header header1 and header2.</para><para><emphasis role="bold">Effects</emphasis>: Swaps two nodes. After the function node1 will be inserted in the position node2 before the function. node2 will be inserted in the position node1 had before the function.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if node1 and node2 are not equivalent according to the ordering rules.</para><para>Experimental function </para></description></method>
<method name="replace_node" specifiers="static"><type>void</type><parameter name="node_to_be_replaced"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node_to_be_replaced must be inserted in a tree and new_node must not be inserted in a tree.</para><para><emphasis role="bold">Effects</emphasis>: Replaces node_to_be_replaced in its position in the tree with new_node. The tree does not need to be rebalanced</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if new_node is not equivalent to node_to_be_replaced according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing and comparison is needed. Experimental function </para></description></method>
<method name="replace_node" specifiers="static"><type>void</type><parameter name="node_to_be_replaced"><paramtype>node_ptr</paramtype></parameter><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node_to_be_replaced must be inserted in a tree with header "header" and new_node must not be inserted in a tree.</para><para><emphasis role="bold">Effects</emphasis>: Replaces node_to_be_replaced in its position in the tree with new_node. The tree does not need to be rebalanced</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if new_node is not equivalent to node_to_be_replaced according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. Experimental function </para></description></method>
<method name="unlink" specifiers="static"><type>void</type><template>
          <template-type-parameter name="NodePtrPriorityCompare"/>
        </template><parameter name="node"><paramtype>node_ptr</paramtype></parameter><parameter name="pcomp"><paramtype>NodePtrPriorityCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node is a tree node but not the header.</para><para><emphasis role="bold">Effects</emphasis>: Unlinks the node and rebalances the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="unlink_leftmost_without_rebalance" specifiers="static"><type>node_ptr</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header is the header of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the tree, and updates the header link to the new leftmost node.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the tree and the tree can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the tree. </para></description></method>
<method name="unique" specifiers="static"><type>bool</type><parameter name="node"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'node' is a node of the tree or a node initialized by init(...) or init_node.</para><para><emphasis role="bold">Effects</emphasis>: Returns true if the node is initialized by init() or init_node().</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="size" specifiers="static"><type>std::size_t</type><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node is a node of the tree but it's not the header.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of nodes of the subtree.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="next_node" specifiers="static"><type>node_ptr</type><parameter name="node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'node' is a node from the tree except the header.</para><para><emphasis role="bold">Effects</emphasis>: Returns the next node of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="prev_node" specifiers="static"><type>node_ptr</type><parameter name="node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'node' is a node from the tree except the leftmost node.</para><para><emphasis role="bold">Effects</emphasis>: Returns the previous node of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="init" specifiers="static"><type>void</type><parameter name="node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: 'node' must not be part of any tree.</para><para><emphasis role="bold">Effects</emphasis>: After the function unique(node) == true.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Nodes</emphasis>: If node is inserted in a tree, this function corrupts the tree. </para></description></method>
<method name="init_header" specifiers="static"><type>void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node must not be part of any tree.</para><para><emphasis role="bold">Effects</emphasis>: Initializes the header to represent an empty tree. unique(header) == true.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Nodes</emphasis>: If node is inserted in a tree, this function corrupts the tree. </para></description></method>
<method name="erase" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="NodePtrPriorityCompare"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="z"><paramtype>node_ptr</paramtype></parameter><parameter name="pcomp"><paramtype>NodePtrPriorityCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header must be the header of a tree, z a node of that tree and z != header.</para><para><emphasis role="bold">Effects</emphasis>: Erases node "z" from the tree with header "header".</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="clone" specifiers="static"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="source_header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="target_header"><paramtype>node_ptr</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "cloner" must be a function object taking a node_ptr and returning a new cloned node of it. "disposer" must take a node_ptr and shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: First empties target tree calling <computeroutput>void disposer::operator()(const node_ptr &amp;)</computeroutput> for every node of the tree except the header.</para><para>Then, duplicates the entire tree pointed by "source_header" cloning each source node with <computeroutput>node_ptr Cloner::operator()(const node_ptr &amp;)</computeroutput> to obtain the nodes of the target tree. If "cloner" throws, the cloned target nodes are disposed using <computeroutput>void disposer(const node_ptr &amp;)</computeroutput>.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of element of the source tree plus the number of elements of tree target tree when calling this function.</para><para><emphasis role="bold">Throws</emphasis>: If cloner functor throws. If this happens target nodes are disposed. </para></description></method>
<method name="clear_and_dispose" specifiers="static"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "disposer" must be an object function taking a node_ptr parameter and shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Empties the target tree calling <computeroutput>void disposer::operator()(const node_ptr &amp;)</computeroutput> for every node of the tree except the header.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of element of the source tree plus the. number of elements of tree target tree when calling this function.</para><para><emphasis role="bold">Throws</emphasis>: If cloner functor throws. If this happens target nodes are disposed. </para></description></method>
<method name="lower_bound" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns a node_ptr to the first element that is not less than "key" according to "comp" or "header" if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="upper_bound" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns a node_ptr to the first element that is greater than "key" according to "comp" or "header" if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="find" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns a node_ptr to the first element that is equivalent to "key" according to "comp" or "header" if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="equal_range" specifiers="static"><type>std::pair&lt; node_ptr, node_ptr &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair of node_ptr delimiting a range containing all elements that are equivalent to "key" according to "comp" or an empty range that indicates the position where those elements would be if there are no equivalent elements.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="bounded_range" specifiers="static"><type>std::pair&lt; node_ptr, node_ptr &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs. 'lower_key' must not be greater than 'upper_key' according to 'comp'. If 'lower_key' == 'upper_key', ('left_closed' || 'right_closed') must be true.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change. </para></description></method>
<method name="count" specifiers="static"><type>std::size_t</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements with a key equivalent to "key" according to "comp".</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="insert_equal_upper_bound" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="NodePtrCompare"/>
          <template-type-parameter name="NodePtrPriorityCompare"/>
        </template><parameter name="h"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><parameter name="pcomp"><paramtype>NodePtrPriorityCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "h" must be the header node of a tree. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares two node_ptrs. NodePtrPriorityCompare is a priority function object that induces a strict weak ordering compatible with the one used to create the the tree. NodePtrPriorityCompare compares two node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree before the upper bound according to "comp" and rotates the tree according to "pcomp".</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throw or "pcomp" throw. </para></description></method>
<method name="insert_equal_lower_bound" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="NodePtrCompare"/>
          <template-type-parameter name="NodePtrPriorityCompare"/>
        </template><parameter name="h"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><parameter name="pcomp"><paramtype>NodePtrPriorityCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "h" must be the header node of a tree. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares two node_ptrs. NodePtrPriorityCompare is a priority function object that induces a strict weak ordering compatible with the one used to create the the tree. NodePtrPriorityCompare compares two node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree before the upper bound according to "comp" and rotates the tree according to "pcomp".</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method>
<method name="insert_equal" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="NodePtrCompare"/>
          <template-type-parameter name="NodePtrPriorityCompare"/>
        </template><parameter name="h"><paramtype>node_ptr</paramtype></parameter><parameter name="hint"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><parameter name="pcomp"><paramtype>NodePtrPriorityCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares two node_ptrs. "hint" is node from the "header"'s tree. NodePtrPriorityCompare is a priority function object that induces a strict weak ordering compatible with the one used to create the the tree. NodePtrPriorityCompare compares two node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree, using "hint" as a hint to where it will be inserted. If "hint" is the upper_bound the insertion takes constant time (two comparisons in the worst case). Rotates the tree according to "pcomp".</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time if new_node is inserted immediately before "hint".</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throw or "pcomp" throw. </para></description></method>
<method name="insert_before" specifiers="static"><type>node_ptr</type><template>
          <template-type-parameter name="NodePtrPriorityCompare"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="pos"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="pcomp"><paramtype>NodePtrPriorityCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. "pos" must be a valid node of the tree (including header end) node. "pos" must be a node pointing to the successor to "new_node" once inserted according to the order of already inserted nodes. This function does not check "pos" and this precondition must be guaranteed by the caller. NodePtrPriorityCompare is a priority function object that induces a strict weak ordering compatible with the one used to create the the tree. NodePtrPriorityCompare compares two node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree before "pos" and rotates the tree according to "pcomp".</para><para><emphasis role="bold">Complexity</emphasis>: Constant-time.</para><para><emphasis role="bold">Throws</emphasis>: If "pcomp" throws, strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: If "pos" is not the successor of the newly inserted "new_node" tree invariants might be broken. </para></description></method>
<method name="push_back" specifiers="static"><type>void</type><template>
          <template-type-parameter name="NodePtrPriorityCompare"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="pcomp"><paramtype>NodePtrPriorityCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. "new_node" must be, according to the used ordering no less than the greatest inserted key. NodePtrPriorityCompare is a priority function object that induces a strict weak ordering compatible with the one used to create the the tree. NodePtrPriorityCompare compares two node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the tree in the last position and rotates the tree according to "pcomp".</para><para><emphasis role="bold">Complexity</emphasis>: Constant-time.</para><para><emphasis role="bold">Throws</emphasis>: If "pcomp" throws, strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: If "new_node" is less than the greatest inserted key tree invariants are broken. This function is slightly faster than using "insert_before". </para></description></method>
<method name="push_front" specifiers="static"><type>void</type><template>
          <template-type-parameter name="NodePtrPriorityCompare"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="pcomp"><paramtype>NodePtrPriorityCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. "new_node" must be, according to the used ordering, no greater than the lowest inserted key. NodePtrPriorityCompare is a priority function object that induces a strict weak ordering compatible with the one used to create the the tree. NodePtrPriorityCompare compares two node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the tree in the first position and rotates the tree according to "pcomp".</para><para><emphasis role="bold">Complexity</emphasis>: Constant-time.</para><para><emphasis role="bold">Throws</emphasis>: If "pcomp" throws, strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: If "new_node" is greater than the lowest inserted key tree invariants are broken. This function is slightly faster than using "insert_before". </para></description></method>
<method name="insert_unique_check" specifiers="static"><type>std::pair&lt; node_ptr, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
          <template-type-parameter name="PrioType"/>
          <template-type-parameter name="PrioNodePtrPrioCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><parameter name="prio"><paramtype>const PrioType &amp;</paramtype></parameter><parameter name="pcomp"><paramtype>PrioNodePtrPrioCompare</paramtype></parameter><parameter name="commit_data"><paramtype><classname>insert_commit_data</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares KeyType with a node_ptr.</para><para><emphasis role="bold">Effects</emphasis>: Checks if there is an equivalent node to "key" in the tree according to "comp" and obtains the needed information to realize a constant-time node insertion if there is no equivalent node.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing a node_ptr to the already present node and false. If there is not equivalent key can be inserted returns true in the returned pair's boolean and fills "commit_data" that is meant to be used with the "insert_commit" function to achieve a constant-time insertion function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a node is expensive and the user does not want to have two equivalent nodes in the tree: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the node and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the node and use "insert_commit" to insert the node in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_unique_commit" only if no more objects are inserted or erased from the set. </para></description></method>
<method name="insert_unique_check" specifiers="static"><type>std::pair&lt; node_ptr, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
          <template-type-parameter name="PrioType"/>
          <template-type-parameter name="PrioNodePtrPrioCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="hint"><paramtype>node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><parameter name="prio"><paramtype>const PrioType &amp;</paramtype></parameter><parameter name="pcomp"><paramtype>PrioNodePtrPrioCompare</paramtype></parameter><parameter name="commit_data"><paramtype><classname>insert_commit_data</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares KeyType with a node_ptr. "hint" is node from the "header"'s tree.</para><para><emphasis role="bold">Effects</emphasis>: Checks if there is an equivalent node to "key" in the tree according to "comp" using "hint" as a hint to where it should be inserted and obtains the needed information to realize a constant-time node insertion if there is no equivalent node. If "hint" is the upper_bound the function has constant time complexity (two comparisons in the worst case).</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing a node_ptr to the already present node and false. If there is not equivalent key can be inserted returns true in the returned pair's boolean and fills "commit_data" that is meant to be used with the "insert_commit" function to achieve a constant-time insertion function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic, but it is amortized constant time if new_node should be inserted immediately before "hint".</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a node is expensive and the user does not want to have two equivalent nodes in the tree: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the node and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the node and use "insert_commit" to insert the node in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_unique_commit" only if no more objects are inserted or erased from the set. </para></description></method>
<method name="insert_unique_commit" specifiers="static"><type>void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="commit_data"><paramtype>const <classname>insert_commit_data</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. "commit_data" must have been obtained from a previous call to "insert_unique_check". No objects should have been inserted or erased from the set between the "insert_unique_check" that filled "commit_data" and the call to "insert_commit".</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node in the set using the information obtained from the "commit_data" that a previous "insert_check" filled.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function has only sense if a "insert_unique_check" has been previously executed to fill "commit_data". No value should be inserted or erased between the "insert_check" and "insert_commit" calls. </para></description></method>
<method name="transfer_unique" specifiers="static"><type>bool</type><template>
          <template-type-parameter name="NodePtrCompare"/>
          <template-type-parameter name="PrioNodePtrPrioCompare"/>
        </template><parameter name="header1"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><parameter name="pcomp"><paramtype>PrioNodePtrPrioCompare</paramtype></parameter><parameter name="header2"><paramtype>node_ptr</paramtype></parameter><parameter name="z"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header1 and header2 must be the headers of trees tree1 and tree2 respectively, z a non-header node of tree1. NodePtrCompare is the comparison function of tree1..</para><para><emphasis role="bold">Effects</emphasis>: Transfers node "z" from tree1 to tree2 if tree1 does not contain a node that is equivalent to z.</para><para><emphasis role="bold">Returns</emphasis>: True if the node was trasferred, false otherwise.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison throws. </para></description></method>
<method name="transfer_equal" specifiers="static"><type>void</type><template>
          <template-type-parameter name="NodePtrCompare"/>
          <template-type-parameter name="PrioNodePtrPrioCompare"/>
        </template><parameter name="header1"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><parameter name="pcomp"><paramtype>PrioNodePtrPrioCompare</paramtype></parameter><parameter name="header2"><paramtype>node_ptr</paramtype></parameter><parameter name="z"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header1 and header2 must be the headers of trees tree1 and tree2 respectively, z a non-header node of tree1. NodePtrCompare is the comparison function of tree1..</para><para><emphasis role="bold">Effects</emphasis>: Transfers node "z" from tree1 to tree2.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison throws. </para></description></method>
<method name="is_header" specifiers="static"><type>bool</type><parameter name="p"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p is a node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Returns true if p is the header of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
</method-group>
</class>



















































</namespace>
</namespace>
</header>
<header name="boost/intrusive/treap_set.hpp">
<namespace name="boost">
<namespace name="intrusive">
<struct name="make_treap_multiset"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput><classname alt="boost::intrusive::treap_multiset">treap_multiset</classname></computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="packed_options"><type><classname>pack_options</classname>&lt; treap_defaults, O1, O2, O3, O4, O5, O6, O7 &gt;::<classname>type</classname></type></typedef>
<typedef name="value_traits"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="implementation_defined"><type><classname>treap_multiset</classname>&lt; value_traits, typename packed_options::key_of_value, typename packed_options::compare, typename packed_options::priority_of_value, typename packed_options::priority, typename packed_options::size_type, packed_options::constant_time_size, typename packed_options::header_holder_type &gt;</type></typedef>
<typedef name="type"><type><classname>implementation_defined</classname></type></typedef>
</struct><struct name="make_treap_set"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput><classname alt="boost::intrusive::treap_set">treap_set</classname></computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="packed_options"><type><classname>pack_options</classname>&lt; treap_defaults, O1, O2, O3, O4, O5, O6, O7 &gt;::<classname>type</classname></type></typedef>
<typedef name="value_traits"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="implementation_defined"><type><classname>treap_set</classname>&lt; value_traits, typename packed_options::key_of_value, typename packed_options::compare, typename packed_options::priority_of_value, typename packed_options::priority, typename packed_options::size_type, packed_options::constant_time_size, typename packed_options::header_holder_type &gt;</type></typedef>
<typedef name="type"><type><classname>implementation_defined</classname></type></typedef>
</struct><class name="treap_multiset"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>The class template <classname alt="boost::intrusive::treap_multiset">treap_multiset</classname> is an intrusive container, that mimics most of the interface of std::treap_multiset as described in the C++ standard.</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput>, <computeroutput>compare&lt;&gt;</computeroutput>, <computeroutput>priority&lt;&gt;</computeroutput> and <computeroutput>priority_of_value&lt;&gt;</computeroutput> </para></description><typedef name="value_type"><type>implementation_defined::value_type</type></typedef>
<typedef name="value_traits"><type>implementation_defined::value_traits</type></typedef>
<typedef name="key_type"><type>implementation_defined::key_type</type></typedef>
<typedef name="key_of_value"><type>implementation_defined::key_of_value</type></typedef>
<typedef name="pointer"><type>implementation_defined::pointer</type></typedef>
<typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef>
<typedef name="reference"><type>implementation_defined::reference</type></typedef>
<typedef name="const_reference"><type>implementation_defined::const_reference</type></typedef>
<typedef name="difference_type"><type>implementation_defined::difference_type</type></typedef>
<typedef name="size_type"><type>implementation_defined::size_type</type></typedef>
<typedef name="value_compare"><type>implementation_defined::value_compare</type></typedef>
<typedef name="key_compare"><type>implementation_defined::key_compare</type></typedef>
<typedef name="priority_type"><type>implementation_defined::priority_type</type></typedef>
<typedef name="priority_compare"><type>implementation_defined::priority_compare</type></typedef>
<typedef name="iterator"><type>implementation_defined::iterator</type></typedef>
<typedef name="const_iterator"><type>implementation_defined::const_iterator</type></typedef>
<typedef name="reverse_iterator"><type>implementation_defined::reverse_iterator</type></typedef>
<typedef name="const_reverse_iterator"><type>implementation_defined::const_reverse_iterator</type></typedef>
<typedef name="insert_commit_data"><type>implementation_defined::insert_commit_data</type></typedef>
<typedef name="node_traits"><type>implementation_defined::node_traits</type></typedef>
<typedef name="node"><type>implementation_defined::node</type></typedef>
<typedef name="node_ptr"><type>implementation_defined::node_ptr</type></typedef>
<typedef name="const_node_ptr"><type>implementation_defined::const_node_ptr</type></typedef>
<typedef name="node_algorithms"><type>implementation_defined::node_algorithms</type></typedef>
<data-member name="constant_time_size" specifiers="static"><type>const bool</type></data-member>
<method-group name="public member functions">
<method name="begin"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rbegin"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a iterator pointing to the root node of the container or end() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="croot" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the key_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If key_compare copy-constructor throws. </para></description></method>
<method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the value_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_compare copy-constructor throws. </para></description></method>
<method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this if constant-time size option is disabled. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="swap"><type>void</type><parameter name="other"><paramtype><classname>treap_multiset</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of two treaps.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison functor's swap call throws. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>treap_multiset</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype><classname>treap_multiset</classname> &amp;&amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(reference) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee. </para></description></method>
<method name="top"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the highest priority object of the treap.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="top" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the highest priority object of the treap..</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="ctop" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the highest priority object of the treap..</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rtop"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the highest priority object of the reversed treap.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rtop" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the highest priority objec of the reversed treap.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crtop" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the highest priority object of the reversed treap.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="priority_comp" cv="const"><type>priority_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the highest priority object of the reversed treap.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the container before the upper bound.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal key_compare or priority_compare functions throw. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and "hint" must be a valid iterator.</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container, using "hint" as a hint to where it will be inserted. If "hint" is the upper_bound the insertion takes constant time (two comparisons in the worst case)</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the internal key_compare or priority_compare functions throw. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Inserts a each element of a range into the container before the upper bound of the key of each element.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by key_comp().</para><para><emphasis role="bold">Throws</emphasis>: If the internal key_compare or priority_compare functions throw. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_before"><type>iterator</type><parameter name="pos"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, "pos" must be a valid iterator (or end) and must be the succesor of value once inserted according to the predicate</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container before "pos".</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: If the internal priority_compare function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if "pos" is not the successor of "value" container ordering invariant will be broken. This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_back"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no less than the greatest inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the last position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: If the internal priority_compare function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is less than the greatest inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_front"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no greater than the minimum inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the first position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: If the internal priority_compare function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is greater than the minimum inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="i"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: if the internal priority_compare function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: if the internal priority_compare function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: if the internal priority_compare function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp".</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: if the internal priority_compare function throws. Equivalent guarantee to <emphasis>while(beg != end) erase(beg++);</emphasis></para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: if the internal priority_compare function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: if the internal priority_compare function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: if the priority_compare function throws then weak guarantee and heap invariants are broken. The safest thing would be to clear or destroy the container.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: if the priority_compare function throws then weak guarantee and heap invariants are broken. The safest thing would be to clear or destroy the container.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="clear"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="clear_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements calling disposer(p) for each node to be erased. <emphasis role="bold">Complexity</emphasis>: Average complexity for is at most O(log(size() + N)), where N is the number of elements in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. Calls N times to disposer functor. </para></description></method>
<method name="count" cv="const"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given value</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given value.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="count" cv="const"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="lower_bound"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="find"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="find"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="lower_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="lower_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="iterator_to"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="unlink_leftmost_without_rebalance"><type>pointer</type><description><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the container.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the container and the container can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the container. </para></description></method>
<method name="replace_node"><type>void</type><parameter name="replace_this"><paramtype>iterator</paramtype></parameter><parameter name="with_this"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: replace_this must be a valid iterator of *this and with_this must not be inserted in any container.</para><para><emphasis role="bold">Effects</emphasis>: Replaces replace_this in its position in the container with with_this. The container does not need to be rebalanced.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if with_this is not equivalent to *replace_this according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. </para></description></method>
<method name="remove_node"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: removes "value" from the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic time.</para><para><emphasis role="bold">Note</emphasis>: This static function is only usable with non-constant time size containers that have stateless comparison functors.</para><para>If the user calls this function with a constant time size container or stateful comparison functor a compilation error will be issued. </para></description></method>
<method name="merge"><type>void</type><template>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="source"><paramtype><classname>treap_multiset</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="source"><paramtype><classname>treap_set</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the value_compare/priority_compare objects throw. Basic guarantee. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype></parameter><parameter name="pcmp"><paramtype>const priority_compare &amp;</paramtype><default>priority_compare()</default></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the value_compare/priority_compare objects throw. Basic guarantee. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype><default>key_compare()</default></parameter><parameter name="pcmp"><paramtype>const priority_compare &amp;</paramtype><default>priority_compare()</default></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type. cmp must be a comparison function that induces a strict weak ordering.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container and inserts elements from [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if [b, e) is already sorted using comp and otherwise N * log N, where N is the distance between first and last.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor/operator() of the key_compare/priority_compare objects throw. Basic guarantee. </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>treap_multiset</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: to-do </para></description></constructor>
<copy-assignment><type><classname>treap_multiset</classname> &amp;</type><parameter name="x"><paramtype><classname>treap_multiset</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: to-do </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the set are not deleted (i.e. no destructors are called), but the nodes according to the <classname alt="boost::intrusive::value_traits">value_traits</classname> template parameter are reinitialized and thus can be reused.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor>
<method-group name="public static functions">
<method name="container_from_end_iterator" specifiers="static"><type><classname>treap_multiset</classname> &amp;</type><parameter name="end_iterator"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_end_iterator" specifiers="static"><type>const <classname>treap_multiset</classname> &amp;</type><parameter name="end_iterator"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type><classname>treap_multiset</classname> &amp;</type><parameter name="it"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type>const <classname>treap_multiset</classname> &amp;</type><parameter name="it"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="init_node" specifiers="static"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value shall not be in a container.</para><para><emphasis role="bold">Effects</emphasis>: init_node puts the hook of a value in a well-known default state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: This function puts the hook in the well-known default state used by auto_unlink and safe hooks. </para></description></method>
</method-group>
</class><class name="treap_set"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>The class template <classname alt="boost::intrusive::treap_set">treap_set</classname> is an intrusive container, that mimics most of the interface of std::set as described in the C++ standard.</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput>, <computeroutput>compare&lt;&gt;</computeroutput>, <computeroutput>priority&lt;&gt;</computeroutput> and <computeroutput>priority_of_value&lt;&gt;</computeroutput> </para></description><typedef name="value_type"><type>implementation_defined::value_type</type></typedef>
<typedef name="value_traits"><type>implementation_defined::value_traits</type></typedef>
<typedef name="key_type"><type>implementation_defined::key_type</type></typedef>
<typedef name="key_of_value"><type>implementation_defined::key_of_value</type></typedef>
<typedef name="pointer"><type>implementation_defined::pointer</type></typedef>
<typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef>
<typedef name="reference"><type>implementation_defined::reference</type></typedef>
<typedef name="const_reference"><type>implementation_defined::const_reference</type></typedef>
<typedef name="difference_type"><type>implementation_defined::difference_type</type></typedef>
<typedef name="size_type"><type>implementation_defined::size_type</type></typedef>
<typedef name="value_compare"><type>implementation_defined::value_compare</type></typedef>
<typedef name="key_compare"><type>implementation_defined::key_compare</type></typedef>
<typedef name="priority_type"><type>implementation_defined::priority_type</type></typedef>
<typedef name="priority_compare"><type>implementation_defined::priority_compare</type></typedef>
<typedef name="iterator"><type>implementation_defined::iterator</type></typedef>
<typedef name="const_iterator"><type>implementation_defined::const_iterator</type></typedef>
<typedef name="reverse_iterator"><type>implementation_defined::reverse_iterator</type></typedef>
<typedef name="const_reverse_iterator"><type>implementation_defined::const_reverse_iterator</type></typedef>
<typedef name="insert_commit_data"><type>implementation_defined::insert_commit_data</type></typedef>
<typedef name="node_traits"><type>implementation_defined::node_traits</type></typedef>
<typedef name="node"><type>implementation_defined::node</type></typedef>
<typedef name="node_ptr"><type>implementation_defined::node_ptr</type></typedef>
<typedef name="const_node_ptr"><type>implementation_defined::const_node_ptr</type></typedef>
<typedef name="node_algorithms"><type>implementation_defined::node_algorithms</type></typedef>
<data-member name="constant_time_size" specifiers="static"><type>const bool</type></data-member>
<method-group name="public member functions">
<method name="begin"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rbegin"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a iterator pointing to the root node of the container or end() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="root" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="croot" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the root node of the container or cend() if not present.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the key_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If key_compare copy-constructor throws. </para></description></method>
<method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the value_compare object used by the container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_compare copy-constructor throws. </para></description></method>
<method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this if constant-time size option is disabled. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="swap"><type>void</type><parameter name="other"><paramtype><classname>treap_set</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of two treaps.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison functor's swap call throws. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>treap_set</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype><classname>treap_set</classname> &amp;&amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(reference) and inserts them on *this. Copies the predicate from the source container.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws or predicate copy assignment throws. Basic guarantee. </para></description></method>
<method name="top"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the highest priority object of the treap.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="top" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the highest priority object of the treap..</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="ctop" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the highest priority object of the treap..</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rtop"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the highest priority object of the reversed treap.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="rtop" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the highest priority objec of the reversed treap.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="crtop" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the highest priority object of the reversed treap.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="priority_comp" cv="const"><type>priority_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the highest priority object of the reversed treap.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="insert"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the container if the value is not already present.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal key_compare or priority_compare functions throw. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and "hint" must be a valid iterator</para><para><emphasis role="bold">Effects</emphasis>: Tries to insert x into the container, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time (two comparisons in the worst case) if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the internal key_compare or priority_compare functions throw. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_check"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="prio"><paramtype>const priority_type &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison or predicate functions throw. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the container. </para></description></method>
<method name="insert_check"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="prio"><paramtype>const priority_type &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it's amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison or predicate functions throw. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the constructing that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that key to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This can give a total constant-time complexity to the insertion: check(O(1)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the container. </para></description></method>
<method name="insert_check"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
          <template-type-parameter name="PrioType"/>
          <template-type-parameter name="PrioValuePrioCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="prio"><paramtype>const PrioType &amp;</paramtype></parameter><parameter name="pcomp"><paramtype>PrioValuePrioCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter></method>
<method name="insert_check"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
          <template-type-parameter name="PrioType"/>
          <template-type-parameter name="PrioValuePrioCompare"/>
        </template><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="prio"><paramtype>const PrioType &amp;</paramtype></parameter><parameter name="pcomp"><paramtype>PrioValuePrioCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter></method>
<method name="insert"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Tries to insert each element of a range into the container.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by key_comp().</para><para><emphasis role="bold">Throws</emphasis>: If the internal key_compare or priority_compare functions throw. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_commit"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><parameter name="commit_data"><paramtype>const insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue of type value_type. commit_data must have been obtained from a previous call to "insert_check". No objects should have been inserted or erased from the container between the "insert_check" that filled "commit_data" and the call to "insert_commit".</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value in the <classname alt="boost::intrusive::avl_set">avl_set</classname> using the information obtained from the "commit_data" that a previous "insert_check" filled.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the newly inserted object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Notes</emphasis>: This function has only sense if a "insert_check" has been previously executed to fill "commit_data". No value should be inserted or erased between the "insert_check" and "insert_commit" calls. </para></description></method>
<method name="insert_before"><type>iterator</type><parameter name="pos"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, "pos" must be a valid iterator (or end) and must be the succesor of value once inserted according to the predicate</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container before "pos".</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: If the internal priority_compare function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if "pos" is not the successor of "value" container ordering invariant will be broken. This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_back"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no less than the greatest inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the last position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: If the internal priority_compare function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is less than the greatest inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="push_front"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and it must be no greater than the minimum inserted key</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the container in the first position.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: If the internal priority_compare function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: This function does not check preconditions so if value is greater than the minimum inserted key container ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="i"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: if the internal priority_compare function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: if the internal priority_compare function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: if the internal priority_compare function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp".</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: if the internal priority_compare function throws. Equivalent guarantee to <emphasis>while(beg != end) erase(beg++);</emphasis></para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: if the internal priority_compare function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: if the internal priority_compare function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: if the priority_compare function throws then weak guarantee and heap invariants are broken. The safest thing would be to clear or destroy the container.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: if the priority_compare function throws then weak guarantee and heap invariants are broken. The safest thing would be to clear or destroy the container.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="clear"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="clear_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements calling disposer(p) for each node to be erased. <emphasis role="bold">Complexity</emphasis>: Average complexity for is at most O(log(size() + N)), where N is the number of elements in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. Calls N times to disposer functor. </para></description></method>
<method name="count" cv="const"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given value</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given value.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="count" cv="const"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="lower_bound"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="find"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="find"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), and nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, key) and !comp(key, nk), with comp(nk, key) implying !comp(key, nk), with nk the key_type of a value_type inserted into <computeroutput>*this</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws. </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="lower_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="lower_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to key_compare. [key_comp()(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!key_comp()(upper_key, lower_key) &amp;&amp; !key_comp()(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</para><para>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>key_compare</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="bounded_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyTypeKeyCompare"/>
        </template><parameter name="lower_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="upper_key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyTypeKeyCompare</paramtype></parameter><parameter name="left_closed"><paramtype>bool</paramtype></parameter><parameter name="right_closed"><paramtype>bool</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>lower_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to comp(nk, lower_key) if left_closed is true, with respect to !comp(lower_key, nk) otherwise.</para><para><computeroutput>upper_key</computeroutput> is a value such that <computeroutput>*this</computeroutput> is partitioned with respect to !comp(upper_key, nk) if right_closed is true, with respect to comp(nk, upper_key) otherwise.</para><para><computeroutput>upper_key</computeroutput> shall not precede <computeroutput>lower_key</computeroutput> according to comp [comp(upper_key, lower_key) shall be false]</para><para>If <computeroutput>lower_key</computeroutput> is equivalent to <computeroutput>upper_key</computeroutput> [!comp(upper_key, lower_key) &amp;&amp; !comp(lower_key, upper_key)] then ('left_closed' || 'right_closed') must be false.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair with the following criteria:</para><para>first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise</para><para>second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If <computeroutput>comp</computeroutput> throws.</para><para><emphasis role="bold">Note</emphasis>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</para><para><emphasis role="bold">Note</emphasis>: Experimental function, the interface might change in future releases. </para></description></method>
<method name="iterator_to"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="unlink_leftmost_without_rebalance"><type>pointer</type><description><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the container.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the container and the container can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the container. </para></description></method>
<method name="replace_node"><type>void</type><parameter name="replace_this"><paramtype>iterator</paramtype></parameter><parameter name="with_this"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: replace_this must be a valid iterator of *this and with_this must not be inserted in any container.</para><para><emphasis role="bold">Effects</emphasis>: Replaces replace_this in its position in the container with with_this. The container does not need to be rebalanced.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if with_this is not equivalent to *replace_this according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. </para></description></method>
<method name="remove_node"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: removes "value" from the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic time.</para><para><emphasis role="bold">Note</emphasis>: This static function is only usable with non-constant time size containers that have stateless comparison functors.</para><para>If the user calls this function with a constant time size container or stateful comparison functor a compilation error will be issued. </para></description></method>
<method name="merge"><type>void</type><template>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="source"><paramtype><classname>treap_set</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-nontype-parameter name="Options2"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="source"><paramtype><classname>treap_multiset</classname>&lt; T, Options2... &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "source" container's Options can only can differ in the comparison function from *this.</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the value_compare/priority_compare objects throw. Basic guarantee. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype></parameter><parameter name="pcmp"><paramtype>const priority_compare &amp;</paramtype><default>priority_compare()</default></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the value_compare/priority_compare objects throw. Basic guarantee. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="cmp"><paramtype>const key_compare &amp;</paramtype><default>key_compare()</default></parameter><parameter name="pcmp"><paramtype>const priority_compare &amp;</paramtype><default>priority_compare()</default></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type. cmp must be a comparison function that induces a strict weak ordering.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container and inserts elements from [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if [b, e) is already sorted using comp and otherwise N * log N, where N is the distance between first and last.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor/operator() of the key_compare/priority_compare objects throw. Basic guarantee. </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>treap_set</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: to-do </para></description></constructor>
<copy-assignment><type><classname>treap_set</classname> &amp;</type><parameter name="x"><paramtype><classname>treap_set</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: to-do </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the set are not deleted (i.e. no destructors are called), but the nodes according to the <classname alt="boost::intrusive::value_traits">value_traits</classname> template parameter are reinitialized and thus can be reused.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor>
<method-group name="public static functions">
<method name="container_from_end_iterator" specifiers="static"><type><classname>treap_set</classname> &amp;</type><parameter name="end_iterator"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_end_iterator" specifiers="static"><type>const <classname>treap_set</classname> &amp;</type><parameter name="end_iterator"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type><classname>treap_set</classname> &amp;</type><parameter name="it"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="container_from_iterator" specifiers="static"><type>const <classname>treap_set</classname> &amp;</type><parameter name="it"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of the container.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the container associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="s_iterator_to" specifiers="static"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="init_node" specifiers="static"><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value shall not be in a container.</para><para><emphasis role="bold">Effects</emphasis>: init_node puts the hook of a value in a well-known default state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: This function puts the hook in the well-known default state used by auto_unlink and safe hooks. </para></description></method>
</method-group>
</class>



















































</namespace>
</namespace>
</header>
<header name="boost/intrusive/trivial_value_traits.hpp">
<namespace name="boost">
<namespace name="intrusive">
<struct name="trivial_value_traits"><template>
      <template-type-parameter name="NodeTraits"/>
      <template-nontype-parameter name="LinkMode"><type>link_mode_type</type><default>safe_link</default></template-nontype-parameter>
    </template><description><para>This value traits template is used to create value traits from user defined node traits where value_traits::value_type and node_traits::node should be equal </para></description><typedef name="node_traits"><type>NodeTraits</type></typedef>
<typedef name="node_ptr"><type>node_traits::node_ptr</type></typedef>
<typedef name="const_node_ptr"><type>node_traits::const_node_ptr</type></typedef>
<typedef name="value_type"><type>node_traits::node</type></typedef>
<typedef name="pointer"><type>node_ptr</type></typedef>
<typedef name="const_pointer"><type>const_node_ptr</type></typedef>
<data-member name="link_mode" specifiers="static"><type>const link_mode_type</type></data-member>
<method-group name="public static functions">
<method name="to_node_ptr" specifiers="static"><type>node_ptr</type><parameter name="value"><paramtype>value_type &amp;</paramtype></parameter></method>
<method name="to_node_ptr" specifiers="static"><type>const_node_ptr</type><parameter name="value"><paramtype>const value_type &amp;</paramtype></parameter></method>
<method name="to_value_ptr" specifiers="static"><type>const pointer &amp;</type><parameter name="n"><paramtype>const node_ptr &amp;</paramtype></parameter></method>
<method name="to_value_ptr" specifiers="static"><type>const const_pointer &amp;</type><parameter name="n"><paramtype>const const_node_ptr &amp;</paramtype></parameter></method>
</method-group>
</struct>



















































</namespace>
</namespace>
</header>
<header name="boost/intrusive/unordered_set.hpp">
<namespace name="boost">
<namespace name="intrusive">
<struct name="make_unordered_multiset"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define an <computeroutput><classname alt="boost::intrusive::unordered_multiset">unordered_multiset</classname></computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct><struct name="make_unordered_set"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define an <computeroutput><classname alt="boost::intrusive::unordered_set">unordered_set</classname></computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct><class name="unordered_multiset"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><inherit access="public">boost::intrusive::hashtable&lt; ValueTraits, VoidOrKeyOfValue, VoidOrKeyHash, VoidOrKeyEqual, BucketTraits, SizeType, BoolFlags &gt;</inherit><description><para>The class template <classname alt="boost::intrusive::unordered_multiset">unordered_multiset</classname> is an intrusive container, that mimics most of the interface of std::tr1::unordered_multiset as described in the C++ TR1.</para><para><classname alt="boost::intrusive::unordered_multiset">unordered_multiset</classname> is a semi-intrusive container: each object to be stored in the container must contain a proper hook, but the container also needs additional auxiliary memory to work: <classname alt="boost::intrusive::unordered_multiset">unordered_multiset</classname> needs a pointer to an array of type <computeroutput>bucket_type</computeroutput> to be passed in the constructor. This bucket array must have at least the same lifetime as the container. This makes the use of <classname alt="boost::intrusive::unordered_multiset">unordered_multiset</classname> more complicated than purely intrusive containers. <computeroutput>bucket_type</computeroutput> is default-constructible, copyable and assignable</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput>, <computeroutput>hash&lt;&gt;</computeroutput> and <computeroutput>equal&lt;&gt;</computeroutput> <computeroutput>bucket_traits&lt;&gt;</computeroutput>, <computeroutput>power_2_buckets&lt;&gt;</computeroutput> and <computeroutput>cache_begin&lt;&gt;</computeroutput>.</para><para><classname alt="boost::intrusive::unordered_multiset">unordered_multiset</classname> only provides forward iterators but it provides 4 iterator types: iterator and const_iterator to navigate through the whole container and local_iterator and const_local_iterator to navigate through the values stored in a single bucket. Local iterators are faster and smaller.</para><para>It's not recommended to use non constant-time size unordered_multisets because several key functions, like "empty()", become non-constant time functions. Non constant-time size unordered_multisets are mainly provided to support auto-unlink hooks.</para><para><classname alt="boost::intrusive::unordered_multiset">unordered_multiset</classname>, unlike std::unordered_set, does not make automatic rehashings nor offers functions related to a load factor. Rehashing can be explicitly requested and the user must provide a new bucket array that will be used from that moment.</para><para>Since no automatic rehashing is done, iterators are never invalidated when inserting or erasing elements. Iterators are only invalidated when rehasing. </para></description><typedef name="value_type"><type>implementation_defined::value_type</type></typedef>
<typedef name="key_type"><type>implementation_defined::key_type</type></typedef>
<typedef name="value_traits"><type>implementation_defined::value_traits</type></typedef>
<typedef name="bucket_traits"><type>implementation_defined::bucket_traits</type></typedef>
<typedef name="pointer"><type>implementation_defined::pointer</type></typedef>
<typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef>
<typedef name="reference"><type>implementation_defined::reference</type></typedef>
<typedef name="const_reference"><type>implementation_defined::const_reference</type></typedef>
<typedef name="difference_type"><type>implementation_defined::difference_type</type></typedef>
<typedef name="size_type"><type>implementation_defined::size_type</type></typedef>
<typedef name="key_equal"><type>implementation_defined::key_equal</type></typedef>
<typedef name="hasher"><type>implementation_defined::hasher</type></typedef>
<typedef name="bucket_type"><type>implementation_defined::bucket_type</type></typedef>
<typedef name="bucket_ptr"><type>implementation_defined::bucket_ptr</type></typedef>
<typedef name="iterator"><type>implementation_defined::iterator</type></typedef>
<typedef name="const_iterator"><type>implementation_defined::const_iterator</type></typedef>
<typedef name="insert_commit_data"><type>implementation_defined::insert_commit_data</type></typedef>
<typedef name="local_iterator"><type>implementation_defined::local_iterator</type></typedef>
<typedef name="const_local_iterator"><type>implementation_defined::const_local_iterator</type></typedef>
<typedef name="node_traits"><type>implementation_defined::node_traits</type></typedef>
<typedef name="node"><type>implementation_defined::node</type></typedef>
<typedef name="node_ptr"><type>implementation_defined::node_ptr</type></typedef>
<typedef name="const_node_ptr"><type>implementation_defined::const_node_ptr</type></typedef>
<typedef name="node_algorithms"><type>implementation_defined::node_algorithms</type></typedef>
<method-group name="public member functions">
<method name="begin"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. Worst case (empty <classname alt="boost::intrusive::unordered_set">unordered_set</classname>): O(this-&gt;bucket_count())</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. Worst case (empty <classname alt="boost::intrusive::unordered_set">unordered_set</classname>): O(this-&gt;bucket_count())</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. Worst case (empty <classname alt="boost::intrusive::unordered_set">unordered_set</classname>): O(this-&gt;bucket_count())</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="hash_function" cv="const"><type>hasher</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the hasher object used by the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If hasher copy-constructor throws. </para></description></method>
<method name="key_eq" cv="const"><type>key_equal</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the key_equal object used by the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If key_equal copy-constructor throws. </para></description></method>
<method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: if constant-time size and <classname alt="boost::intrusive::cache_begin">cache_begin</classname> options are disabled, average constant time (worst case, with empty() == true: O(this-&gt;bucket_count()). Otherwise constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this if <classname alt="boost::intrusive::constant_time_size">constant_time_size</classname> is false. Constant-time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="swap"><type>void</type><parameter name="other"><paramtype><classname>unordered_multiset</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: buckets must not be being used by any other resource.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::intrusive::unordered_set">unordered_set</classname>, storing a reference to the bucket array and copies of the key_hasher and equal_func functors.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor or invocation of hash_func or equal_func throws.</para><para><emphasis role="bold">Notes</emphasis>: buckets array must be disposed only after *this is disposed. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>unordered_multiset</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw Cloner should yield to nodes that compare equal and produce the same hash than the original node.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this. The hash function and the equality predicate are copied from the source.</para><para>If <classname alt="boost::intrusive::store_hash">store_hash</classname> option is true, this method does not use the hash function.</para><para>If any operation throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner or hasher throw or hash or equality predicate copying throws. Basic guarantee. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype><classname>unordered_multiset</classname> &amp;&amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw Cloner should yield to nodes that compare equal and produce the same hash than the original node.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(reference) and inserts them on *this. The hash function and the equality predicate are copied from the source.</para><para>If <classname alt="boost::intrusive::store_hash">store_hash</classname> option is true, this method does not use the hash function.</para><para>If any operation throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner or hasher throw or hash or equality predicate copying throws. Basic guarantee. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value into the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the inserted value.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Equivalent to this-&gt;insert_equal(t) for each element in [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(N), where N is distance(b, e). Worst case O(N*this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="erase"><type>void</type><parameter name="i"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased element. No destructors are called. </para></description></method>
<method name="erase"><type>void</type><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(distance(b, e)), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyEqual</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"equal_func" must be a equality function that induces the same equality as key_equal. The difference is that "equal_func" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements that have the same hash and compare equal with the given key.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hash_func or equal_func throw. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(distance(b, e)), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyEqual"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyEqual</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "equal_func". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hash_func or equal_func throw. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="clear"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="clear_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="count" cv="const"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given value</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. </para></description></method>
<method name="count" cv="const"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyEqual</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"equal_func" must be a equality function that induces the same equality as key_equal. The difference is that "equal_func" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hash_func or equal throw. </para></description></method>
<method name="find"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element is equal to "value" or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. </para></description></method>
<method name="find"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyEqual</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"equal_func" must be a equality function that induces the same equality as key_equal. The difference is that "equal_func" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is "key" according to the given hash and equality functor or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hash_func or equal_func throw.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given value</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyEqual</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"equal_func" must be a equality function that induces the same equality as key_equal. The difference is that "equal_func" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is "key" according to the given hasher and equality functor or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hash_func or equal_func throw.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns a range containing all elements with values equivalent to value. Returns std::make_pair(this-&gt;end(), this-&gt;end()) if no such elements exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyEqual</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"equal_func" must be a equality function that induces the same equality as key_equal. The difference is that "equal_func" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Returns a range containing all elements with equivalent keys. Returns std::make_pair(this-&gt;end(), this-&gt;end()) if no such elements exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(key, hash_func, equal_func)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hash_func or the equal_func throw.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns a range containing all elements with values equivalent to value. Returns std::make_pair(this-&gt;end(), this-&gt;end()) if no such elements exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyEqual</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"equal_func" must be a equality function that induces the same equality as key_equal. The difference is that "equal_func" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Returns a range containing all elements with equivalent keys. Returns std::make_pair(this-&gt;end(), this-&gt;end()) if no such elements exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(key, hash_func, equal_func)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the hasher or equal_func throw.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method>
<method name="iterator_to"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a <classname alt="boost::intrusive::unordered_set">unordered_set</classname> of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator belonging to the <classname alt="boost::intrusive::unordered_set">unordered_set</classname> that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the internal hash function throws. </para></description></method>
<method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a <classname alt="boost::intrusive::unordered_set">unordered_set</classname> of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator belonging to the <classname alt="boost::intrusive::unordered_set">unordered_set</classname> that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the internal hash function throws. </para></description></method>
<method name="local_iterator_to"><type>local_iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a <classname alt="boost::intrusive::unordered_set">unordered_set</classname> of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid local_iterator belonging to the <classname alt="boost::intrusive::unordered_set">unordered_set</classname> that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="local_iterator_to" cv="const"><type>const_local_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a <classname alt="boost::intrusive::unordered_set">unordered_set</classname> of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid local_iterator belonging to the <classname alt="boost::intrusive::unordered_set">unordered_set</classname> that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="bucket_count" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of buckets passed in the constructor or the last rehash function.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="bucket_size" cv="const"><type>size_type</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements in the nth bucket.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="bucket" cv="const"><type>size_type</type><parameter name="k"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the index of the bucket in which elements with keys equivalent to k would be found, if any such element existed.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the hash functor throws.</para><para><emphasis role="bold">Note</emphasis>: the return value is in the range [0, this-&gt;bucket_count()). </para></description></method>
<method name="bucket" cv="const"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
        </template><parameter name="k"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para><emphasis role="bold">Effects</emphasis>: Returns the index of the bucket in which elements with keys equivalent to k would be found, if any such element existed.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If hash_func throws.</para><para><emphasis role="bold">Note</emphasis>: the return value is in the range [0, this-&gt;bucket_count()). </para></description></method>
<method name="bucket_pointer" cv="const"><type>bucket_ptr</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the bucket array pointer passed in the constructor or the last rehash function.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="begin"><type>local_iterator</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a local_iterator pointing to the beginning of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method>
<method name="begin" cv="const"><type>const_local_iterator</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_local_iterator pointing to the beginning of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method>
<method name="cbegin" cv="const"><type>const_local_iterator</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_local_iterator pointing to the beginning of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method>
<method name="end"><type>local_iterator</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a local_iterator pointing to the end of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method>
<method name="end" cv="const"><type>const_local_iterator</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_local_iterator pointing to the end of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method>
<method name="cend" cv="const"><type>const_local_iterator</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_local_iterator pointing to the end of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method>
<method name="rehash"><type>void</type><parameter name="new_bucket_traits"><paramtype>const bucket_traits &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: new_bucket_traits can hold a pointer to a new bucket array or the same as the old bucket array with a different length. new_size is the length of the the array pointed by new_buckets. If new_bucket_traits.bucket_begin() == this-&gt;bucket_pointer() new_bucket_traits.bucket_count() can be bigger or smaller than this-&gt;bucket_count(). 'new_bucket_traits' copy constructor should not throw.</para><para><emphasis role="bold">Effects</emphasis>: If <computeroutput>new_bucket_traits.bucket_begin() == this-&gt;bucket_pointer()</computeroutput> is false, unlinks values from the old bucket and inserts then in the new one according to the hash value of values.</para><para>If <computeroutput>new_bucket_traits.bucket_begin() == this-&gt;bucket_pointer()</computeroutput> is true, the implementations avoids moving values as much as possible.</para><para>Bucket traits hold by *this is assigned from new_bucket_traits. If the container is configured as incremental&lt;&gt;, the split bucket is set to the new bucket_count().</para><para>If <classname alt="boost::intrusive::store_hash">store_hash</classname> option is true, this method does not use the hash function. If false, the implementation tries to minimize calls to the hash function (e.g. once for equivalent values if optimize_multikey&lt;true&gt; is true).</para><para>If rehash is successful updates the internal <classname alt="boost::intrusive::bucket_traits">bucket_traits</classname> with new_bucket_traits.</para><para><emphasis role="bold">Complexity</emphasis>: Average case linear in this-&gt;size(), worst case quadratic.</para><para><emphasis role="bold">Throws</emphasis>: If the hasher functor throws. Basic guarantee. </para></description></method>
<method name="full_rehash"><type>void</type><description><para><emphasis role="bold">Note</emphasis>: This function is used when keys from inserted elements are changed (e.g. a language change when key is a string) but uniqueness and hash properties are preserved so a fast full rehash recovers invariants for *this without extracting and reinserting all elements again.</para><para><emphasis role="bold">Requires</emphasis>: Calls produced to the hash function should not alter the value uniqueness properties of already inserted elements. If hasher(key1) == hasher(key2) was true when elements were inserted, it shall be true during calls produced in the execution of this function.</para><para>key_equal is not called inside this function so it is assumed that key_equal(value1, value2) should produce the same results as before for inserted elements.</para><para><emphasis role="bold">Effects</emphasis>: Reprocesses all values hold by *this, recalculating their hash values and redistributing them though the buckets.</para><para>If <classname alt="boost::intrusive::store_hash">store_hash</classname> option is true, this method uses the hash function and updates the stored hash value.</para><para><emphasis role="bold">Complexity</emphasis>: Average case linear in this-&gt;size(), worst case quadratic.</para><para><emphasis role="bold">Throws</emphasis>: If the hasher functor throws. Basic guarantee. </para></description></method>
<method name="incremental_rehash"><type>bool</type><parameter name="grow"><paramtype>bool</paramtype><default>true</default></parameter><description><para><emphasis role="bold">Requires</emphasis>:</para><para><emphasis role="bold">Effects</emphasis>:</para><para><emphasis role="bold">Complexity</emphasis>:</para><para><emphasis role="bold">Throws</emphasis>:</para><para><emphasis role="bold">Note</emphasis>: this method is only available if incremental&lt;true&gt; option is activated. </para></description></method>
<method name="incremental_rehash"><type>bool</type><parameter name="new_bucket_traits"><paramtype>const bucket_traits &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If new_bucket_traits.bucket_count() is not this-&gt;bucket_count()/2 or this-&gt;bucket_count()*2, or this-&gt;split_bucket() != new_bucket_traits.bucket_count() returns false and does nothing.</para><para>Otherwise, copy assigns new_bucket_traits to the internal <classname alt="boost::intrusive::bucket_traits">bucket_traits</classname> and transfers all the objects from old buckets to the new ones.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to size().</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Note</emphasis>: this method is only available if incremental&lt;true&gt; option is activated. </para></description></method>
<method name="split_count" cv="const"><type>size_type</type><description><para><emphasis role="bold">Requires</emphasis>: incremental&lt;&gt; option must be set</para><para><emphasis role="bold">Effects</emphasis>: returns the current split count</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing </para></description></method>
</method-group>
<constructor specifiers="explicit"><parameter name="b_traits"><paramtype>const bucket_traits &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>const hasher &amp;</paramtype><default>hasher()</default></parameter><parameter name="equal_func"><paramtype>const key_equal &amp;</paramtype><default>key_equal()</default></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: buckets must not be being used by any other resource.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::intrusive::unordered_set">unordered_set</classname>, storing a reference to the bucket array and copies of the key_hasher and equal_func functors.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor or invocation of hash_func or equal_func throws.</para><para><emphasis role="bold">Notes</emphasis>: buckets array must be disposed only after *this is disposed. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="b_traits"><paramtype>const bucket_traits &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>const hasher &amp;</paramtype><default>hasher()</default></parameter><parameter name="equal_func"><paramtype>const key_equal &amp;</paramtype><default>key_equal()</default></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: buckets must not be being used by any other resource and dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container and inserts elements from [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: If N is distance(b, e): Average case is O(N) (with a good hash function and with buckets_len &gt;= N),worst case O(N^2).</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor or invocation of hasher or key_equal throws.</para><para><emphasis role="bold">Notes</emphasis>: buckets array must be disposed only after *this is disposed. </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>unordered_multiset</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: to-do </para></description></constructor>
<copy-assignment><type><classname>unordered_multiset</classname> &amp;</type><parameter name="x"><paramtype><classname>unordered_multiset</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: to-do </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the <classname alt="boost::intrusive::unordered_set">unordered_set</classname> are not deleted (i.e. no destructors are called).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>, if it's a safe-mode or auto-unlink value. Otherwise constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor>
<method-group name="public static functions">
<method name="s_local_iterator_to" specifiers="static"><type>local_iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a <classname alt="boost::intrusive::unordered_set">unordered_set</classname> of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid local_iterator belonging to the <classname alt="boost::intrusive::unordered_set">unordered_set</classname> that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="s_local_iterator_to" specifiers="static"><type>const_local_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a <classname alt="boost::intrusive::unordered_set">unordered_set</classname> of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid local_iterator belonging to the <classname alt="boost::intrusive::unordered_set">unordered_set</classname> that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="suggested_upper_bucket_count" specifiers="static"><type>size_type</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the nearest new bucket count optimized for the container that is bigger or equal than n. This suggestion can be used to create bucket arrays with a size that will usually improve container's performance. If such value does not exist, the higher possible value is returned.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="suggested_lower_bucket_count" specifiers="static"><type>size_type</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the nearest new bucket count optimized for the container that is smaller or equal than n. This suggestion can be used to create bucket arrays with a size that will usually improve container's performance. If such value does not exist, the lowest possible value is returned.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
</method-group>
</class><class name="unordered_set"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><inherit access="public">boost::intrusive::hashtable&lt; ValueTraits, VoidOrKeyOfValue, VoidOrKeyHash, VoidOrKeyEqual, BucketTraits, SizeType, BoolFlags|hash_bool_flags::unique_keys_pos &gt;</inherit><description><para>The class template <classname alt="boost::intrusive::unordered_set">unordered_set</classname> is an intrusive container, that mimics most of the interface of std::tr1::unordered_set as described in the C++ TR1.</para><para><classname alt="boost::intrusive::unordered_set">unordered_set</classname> is a semi-intrusive container: each object to be stored in the container must contain a proper hook, but the container also needs additional auxiliary memory to work: <classname alt="boost::intrusive::unordered_set">unordered_set</classname> needs a pointer to an array of type <computeroutput>bucket_type</computeroutput> to be passed in the constructor. This bucket array must have at least the same lifetime as the container. This makes the use of <classname alt="boost::intrusive::unordered_set">unordered_set</classname> more complicated than purely intrusive containers. <computeroutput>bucket_type</computeroutput> is default-constructible, copyable and assignable</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput>, <computeroutput>hash&lt;&gt;</computeroutput> and <computeroutput>equal&lt;&gt;</computeroutput> <computeroutput>bucket_traits&lt;&gt;</computeroutput>, <computeroutput>power_2_buckets&lt;&gt;</computeroutput> and <computeroutput>cache_begin&lt;&gt;</computeroutput>.</para><para><classname alt="boost::intrusive::unordered_set">unordered_set</classname> only provides forward iterators but it provides 4 iterator types: iterator and const_iterator to navigate through the whole container and local_iterator and const_local_iterator to navigate through the values stored in a single bucket. Local iterators are faster and smaller.</para><para>It's not recommended to use non constant-time size unordered_sets because several key functions, like "empty()", become non-constant time functions. Non constant-time size unordered_sets are mainly provided to support auto-unlink hooks.</para><para><classname alt="boost::intrusive::unordered_set">unordered_set</classname>, unlike std::unordered_set, does not make automatic rehashings nor offers functions related to a load factor. Rehashing can be explicitly requested and the user must provide a new bucket array that will be used from that moment.</para><para>Since no automatic rehashing is done, iterators are never invalidated when inserting or erasing elements. Iterators are only invalidated when rehasing. </para></description><typedef name="value_type"><type>implementation_defined::value_type</type></typedef>
<typedef name="key_type"><type>implementation_defined::key_type</type></typedef>
<typedef name="key_of_value"><type>implementation_defined::key_of_value</type></typedef>
<typedef name="value_traits"><type>implementation_defined::value_traits</type></typedef>
<typedef name="bucket_traits"><type>implementation_defined::bucket_traits</type></typedef>
<typedef name="pointer"><type>implementation_defined::pointer</type></typedef>
<typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef>
<typedef name="reference"><type>implementation_defined::reference</type></typedef>
<typedef name="const_reference"><type>implementation_defined::const_reference</type></typedef>
<typedef name="difference_type"><type>implementation_defined::difference_type</type></typedef>
<typedef name="size_type"><type>implementation_defined::size_type</type></typedef>
<typedef name="key_equal"><type>implementation_defined::key_equal</type></typedef>
<typedef name="hasher"><type>implementation_defined::hasher</type></typedef>
<typedef name="bucket_type"><type>implementation_defined::bucket_type</type></typedef>
<typedef name="bucket_ptr"><type>implementation_defined::bucket_ptr</type></typedef>
<typedef name="iterator"><type>implementation_defined::iterator</type></typedef>
<typedef name="const_iterator"><type>implementation_defined::const_iterator</type></typedef>
<typedef name="insert_commit_data"><type>implementation_defined::insert_commit_data</type></typedef>
<typedef name="local_iterator"><type>implementation_defined::local_iterator</type></typedef>
<typedef name="const_local_iterator"><type>implementation_defined::const_local_iterator</type></typedef>
<typedef name="node_traits"><type>implementation_defined::node_traits</type></typedef>
<typedef name="node"><type>implementation_defined::node</type></typedef>
<typedef name="node_ptr"><type>implementation_defined::node_ptr</type></typedef>
<typedef name="const_node_ptr"><type>implementation_defined::const_node_ptr</type></typedef>
<typedef name="node_algorithms"><type>implementation_defined::node_algorithms</type></typedef>
<method-group name="public member functions">
<method name="begin"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. Worst case (empty <classname alt="boost::intrusive::unordered_set">unordered_set</classname>): O(this-&gt;bucket_count())</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. Worst case (empty <classname alt="boost::intrusive::unordered_set">unordered_set</classname>): O(this-&gt;bucket_count())</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. Worst case (empty <classname alt="boost::intrusive::unordered_set">unordered_set</classname>): O(this-&gt;bucket_count())</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="hash_function" cv="const"><type>hasher</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the hasher object used by the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If hasher copy-constructor throws. </para></description></method>
<method name="key_eq" cv="const"><type>key_equal</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the key_equal object used by the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If key_equal copy-constructor throws. </para></description></method>
<method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: if constant-time size and <classname alt="boost::intrusive::cache_begin">cache_begin</classname> options are disabled, average constant time (worst case, with empty() == true: O(this-&gt;bucket_count()). Otherwise constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this if <classname alt="boost::intrusive::constant_time_size">constant_time_size</classname> is false. Constant-time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="swap"><type>void</type><parameter name="other"><paramtype><classname>unordered_set</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: buckets must not be being used by any other resource.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::intrusive::unordered_set">unordered_set</classname>, storing a reference to the bucket array and copies of the key_hasher and equal_func functors.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor or invocation of hash_func or equal_func throws.</para><para><emphasis role="bold">Notes</emphasis>: buckets array must be disposed only after *this is disposed. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>unordered_set</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw Cloner should yield to nodes that compare equal and produce the same hash than the original node.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this. The hash function and the equality predicate are copied from the source.</para><para>If <classname alt="boost::intrusive::store_hash">store_hash</classname> option is true, this method does not use the hash function.</para><para>If any operation throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner or hasher throw or hash or equality predicate copying throws. Basic guarantee. </para></description></method>
<method name="clone_from"><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype><classname>unordered_set</classname> &amp;&amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw Cloner should yield to nodes that compare equal and produce the same hash than the original node.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(reference) and inserts them on *this. The hash function and the equality predicate are copied from the source.</para><para>If <classname alt="boost::intrusive::store_hash">store_hash</classname> option is true, this method does not use the hash function.</para><para>If any operation throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner or hasher throw or hash or equality predicate copying throws. Basic guarantee. </para></description></method>
<method name="insert"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Tries to inserts value into the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>.</para><para><emphasis role="bold">Returns</emphasis>: If the value is not already present inserts it and returns a pair containing the iterator to the new value and true. If there is an equivalent value returns a pair containing an iterator to the already present value and false.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Equivalent to this-&gt;insert_unique(t) for each element in [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(N), where N is distance(b, e). Worst case O(N*this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method>
<method name="insert_check"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>, using a user provided key instead of the value itself.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hasher or key_compare throw. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the hash or the equality is much cheaper to construct than the value_type and this function offers the possibility to use that the part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time.</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>.</para><para>After a successful rehashing insert_commit_data remains valid. </para></description></method>
<method name="insert_check"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hasher"><paramtype>KeyHasher</paramtype></parameter><parameter name="key_value_equal"><paramtype>KeyEqual</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"equal_func" must be a equality function that induces the same equality as key_equal. The difference is that "equal_func" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>, using a user provided key instead of the value itself.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hash_func or equal_func throw. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the hash or the equality is much cheaper to construct than the value_type and this function offers the possibility to use that the part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time.</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>.</para><para>After a successful rehashing insert_commit_data remains valid. </para></description></method>
<method name="insert_commit"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><parameter name="commit_data"><paramtype>const insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue of type value_type. commit_data must have been obtained from a previous call to "insert_check". No objects should have been inserted or erased from the <classname alt="boost::intrusive::unordered_set">unordered_set</classname> between the "insert_check" that filled "commit_data" and the call to "insert_commit".</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value in the <classname alt="boost::intrusive::unordered_set">unordered_set</classname> using the information obtained from the "commit_data" that a previous "insert_check" filled.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the newly inserted object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function has only sense if a "insert_check" has been previously executed to fill "commit_data". No value should be inserted or erased between the "insert_check" and "insert_commit" calls.</para><para>After a successful rehashing insert_commit_data remains valid. </para></description></method>
<method name="erase"><type>void</type><parameter name="i"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased element. No destructors are called. </para></description></method>
<method name="erase"><type>void</type><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(distance(b, e)), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyEqual</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"equal_func" must be a equality function that induces the same equality as key_equal. The difference is that "equal_func" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements that have the same hash and compare equal with the given key.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hash_func or equal_func throw. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(distance(b, e)), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="erase_and_dispose"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyEqual"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyEqual</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "equal_func". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hash_func or equal_func throw. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method>
<method name="clear"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="clear_and_dispose"><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method>
<method name="count" cv="const"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given value</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. </para></description></method>
<method name="count" cv="const"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyEqual</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"equal_func" must be a equality function that induces the same equality as key_equal. The difference is that "equal_func" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hash_func or equal throw. </para></description></method>
<method name="find"><type>iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element is equal to "value" or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. </para></description></method>
<method name="find"><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyEqual</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"equal_func" must be a equality function that induces the same equality as key_equal. The difference is that "equal_func" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is "key" according to the given hash and equality functor or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hash_func or equal_func throw.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given value</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyEqual</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"equal_func" must be a equality function that induces the same equality as key_equal. The difference is that "equal_func" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is "key" according to the given hasher and equality functor or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hash_func or equal_func throw.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns a range containing all elements with values equivalent to value. Returns std::make_pair(this-&gt;end(), this-&gt;end()) if no such elements exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyEqual</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"equal_func" must be a equality function that induces the same equality as key_equal. The difference is that "equal_func" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Returns a range containing all elements with equivalent keys. Returns std::make_pair(this-&gt;end(), this-&gt;end()) if no such elements exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(key, hash_func, equal_func)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hash_func or the equal_func throw.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns a range containing all elements with values equivalent to value. Returns std::make_pair(this-&gt;end(), this-&gt;end()) if no such elements exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyEqual</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"equal_func" must be a equality function that induces the same equality as key_equal. The difference is that "equal_func" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Returns a range containing all elements with equivalent keys. Returns std::make_pair(this-&gt;end(), this-&gt;end()) if no such elements exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(key, hash_func, equal_func)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the hasher or equal_func throw.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method>
<method name="iterator_to"><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a <classname alt="boost::intrusive::unordered_set">unordered_set</classname> of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator belonging to the <classname alt="boost::intrusive::unordered_set">unordered_set</classname> that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the internal hash function throws. </para></description></method>
<method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a <classname alt="boost::intrusive::unordered_set">unordered_set</classname> of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator belonging to the <classname alt="boost::intrusive::unordered_set">unordered_set</classname> that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the internal hash function throws. </para></description></method>
<method name="local_iterator_to"><type>local_iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a <classname alt="boost::intrusive::unordered_set">unordered_set</classname> of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid local_iterator belonging to the <classname alt="boost::intrusive::unordered_set">unordered_set</classname> that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="local_iterator_to" cv="const"><type>const_local_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a <classname alt="boost::intrusive::unordered_set">unordered_set</classname> of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid local_iterator belonging to the <classname alt="boost::intrusive::unordered_set">unordered_set</classname> that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="bucket_count" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of buckets passed in the constructor or the last rehash function.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="bucket_size" cv="const"><type>size_type</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements in the nth bucket.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="bucket" cv="const"><type>size_type</type><parameter name="k"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the index of the bucket in which elements with keys equivalent to k would be found, if any such element existed.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the hash functor throws.</para><para><emphasis role="bold">Note</emphasis>: the return value is in the range [0, this-&gt;bucket_count()). </para></description></method>
<method name="bucket" cv="const"><type>size_type</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
        </template><parameter name="k"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para><emphasis role="bold">Effects</emphasis>: Returns the index of the bucket in which elements with keys equivalent to k would be found, if any such element existed.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If hash_func throws.</para><para><emphasis role="bold">Note</emphasis>: the return value is in the range [0, this-&gt;bucket_count()). </para></description></method>
<method name="bucket_pointer" cv="const"><type>bucket_ptr</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the bucket array pointer passed in the constructor or the last rehash function.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="begin"><type>local_iterator</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a local_iterator pointing to the beginning of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method>
<method name="begin" cv="const"><type>const_local_iterator</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_local_iterator pointing to the beginning of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method>
<method name="cbegin" cv="const"><type>const_local_iterator</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_local_iterator pointing to the beginning of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method>
<method name="end"><type>local_iterator</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a local_iterator pointing to the end of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method>
<method name="end" cv="const"><type>const_local_iterator</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_local_iterator pointing to the end of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method>
<method name="cend" cv="const"><type>const_local_iterator</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_local_iterator pointing to the end of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method>
<method name="rehash"><type>void</type><parameter name="new_bucket_traits"><paramtype>const bucket_traits &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: new_bucket_traits can hold a pointer to a new bucket array or the same as the old bucket array with a different length. new_size is the length of the the array pointed by new_buckets. If new_bucket_traits.bucket_begin() == this-&gt;bucket_pointer() new_bucket_traits.bucket_count() can be bigger or smaller than this-&gt;bucket_count(). 'new_bucket_traits' copy constructor should not throw.</para><para><emphasis role="bold">Effects</emphasis>: If <computeroutput>new_bucket_traits.bucket_begin() == this-&gt;bucket_pointer()</computeroutput> is false, unlinks values from the old bucket and inserts then in the new one according to the hash value of values.</para><para>If <computeroutput>new_bucket_traits.bucket_begin() == this-&gt;bucket_pointer()</computeroutput> is true, the implementations avoids moving values as much as possible.</para><para>Bucket traits hold by *this is assigned from new_bucket_traits. If the container is configured as incremental&lt;&gt;, the split bucket is set to the new bucket_count().</para><para>If <classname alt="boost::intrusive::store_hash">store_hash</classname> option is true, this method does not use the hash function. If false, the implementation tries to minimize calls to the hash function (e.g. once for equivalent values if optimize_multikey&lt;true&gt; is true).</para><para>If rehash is successful updates the internal <classname alt="boost::intrusive::bucket_traits">bucket_traits</classname> with new_bucket_traits.</para><para><emphasis role="bold">Complexity</emphasis>: Average case linear in this-&gt;size(), worst case quadratic.</para><para><emphasis role="bold">Throws</emphasis>: If the hasher functor throws. Basic guarantee. </para></description></method>
<method name="full_rehash"><type>void</type><description><para><emphasis role="bold">Note</emphasis>: This function is used when keys from inserted elements are changed (e.g. a language change when key is a string) but uniqueness and hash properties are preserved so a fast full rehash recovers invariants for *this without extracting and reinserting all elements again.</para><para><emphasis role="bold">Requires</emphasis>: Calls produced to the hash function should not alter the value uniqueness properties of already inserted elements. If hasher(key1) == hasher(key2) was true when elements were inserted, it shall be true during calls produced in the execution of this function.</para><para>key_equal is not called inside this function so it is assumed that key_equal(value1, value2) should produce the same results as before for inserted elements.</para><para><emphasis role="bold">Effects</emphasis>: Reprocesses all values hold by *this, recalculating their hash values and redistributing them though the buckets.</para><para>If <classname alt="boost::intrusive::store_hash">store_hash</classname> option is true, this method uses the hash function and updates the stored hash value.</para><para><emphasis role="bold">Complexity</emphasis>: Average case linear in this-&gt;size(), worst case quadratic.</para><para><emphasis role="bold">Throws</emphasis>: If the hasher functor throws. Basic guarantee. </para></description></method>
<method name="incremental_rehash"><type>bool</type><parameter name="grow"><paramtype>bool</paramtype><default>true</default></parameter><description><para><emphasis role="bold">Requires</emphasis>:</para><para><emphasis role="bold">Effects</emphasis>:</para><para><emphasis role="bold">Complexity</emphasis>:</para><para><emphasis role="bold">Throws</emphasis>:</para><para><emphasis role="bold">Note</emphasis>: this method is only available if incremental&lt;true&gt; option is activated. </para></description></method>
<method name="incremental_rehash"><type>bool</type><parameter name="new_bucket_traits"><paramtype>const bucket_traits &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If new_bucket_traits.bucket_count() is not this-&gt;bucket_count()/2 or this-&gt;bucket_count()*2, or this-&gt;split_bucket() != new_bucket_traits.bucket_count() returns false and does nothing.</para><para>Otherwise, copy assigns new_bucket_traits to the internal <classname alt="boost::intrusive::bucket_traits">bucket_traits</classname> and transfers all the objects from old buckets to the new ones.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to size().</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Note</emphasis>: this method is only available if incremental&lt;true&gt; option is activated. </para></description></method>
<method name="split_count" cv="const"><type>size_type</type><description><para><emphasis role="bold">Requires</emphasis>: incremental&lt;&gt; option must be set</para><para><emphasis role="bold">Effects</emphasis>: returns the current split count</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing </para></description></method>
</method-group>
<constructor specifiers="explicit"><parameter name="b_traits"><paramtype>const bucket_traits &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>const hasher &amp;</paramtype><default>hasher()</default></parameter><parameter name="equal_func"><paramtype>const key_equal &amp;</paramtype><default>key_equal()</default></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: buckets must not be being used by any other resource.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::intrusive::unordered_set">unordered_set</classname>, storing a reference to the bucket array and copies of the key_hasher and equal_func functors.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor or invocation of hash_func or equal_func throws.</para><para><emphasis role="bold">Notes</emphasis>: buckets array must be disposed only after *this is disposed. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="b_traits"><paramtype>const bucket_traits &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>const hasher &amp;</paramtype><default>hasher()</default></parameter><parameter name="equal_func"><paramtype>const key_equal &amp;</paramtype><default>key_equal()</default></parameter><parameter name="v_traits"><paramtype>const value_traits &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: buckets must not be being used by any other resource and dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container and inserts elements from [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: If N is distance(b, e): Average case is O(N) (with a good hash function and with buckets_len &gt;= N),worst case O(N^2).</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor or invocation of hasher or key_equal throws.</para><para><emphasis role="bold">Notes</emphasis>: buckets array must be disposed only after *this is disposed. </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>unordered_set</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a container moving resources from another container. Internal value traits, bucket traits, hasher and comparison are move constructed and nodes belonging to x are linked to *this.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node's move constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the move constructor of value traits, bucket traits, hasher or comparison throws. </para></description></constructor>
<copy-assignment><type><classname>unordered_set</classname> &amp;</type><parameter name="x"><paramtype><classname>unordered_set</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to swap. </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the <classname alt="boost::intrusive::unordered_set">unordered_set</classname> are not deleted (i.e. no destructors are called).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the <classname alt="boost::intrusive::unordered_set">unordered_set</classname>, if it's a safe-mode or auto-unlink value. Otherwise constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor>
<method-group name="public static functions">
<method name="s_local_iterator_to" specifiers="static"><type>local_iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a <classname alt="boost::intrusive::unordered_set">unordered_set</classname> of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid local_iterator belonging to the <classname alt="boost::intrusive::unordered_set">unordered_set</classname> that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="s_local_iterator_to" specifiers="static"><type>const_local_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a <classname alt="boost::intrusive::unordered_set">unordered_set</classname> of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid local_iterator belonging to the <classname alt="boost::intrusive::unordered_set">unordered_set</classname> that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the <emphasis>value traits</emphasis> is stateless. </para></description></method>
<method name="suggested_upper_bucket_count" specifiers="static"><type>size_type</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the nearest new bucket count optimized for the container that is bigger or equal than n. This suggestion can be used to create bucket arrays with a size that will usually improve container's performance. If such value does not exist, the higher possible value is returned.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="suggested_lower_bucket_count" specifiers="static"><type>size_type</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the nearest new bucket count optimized for the container that is smaller or equal than n. This suggestion can be used to create bucket arrays with a size that will usually improve container's performance. If such value does not exist, the lowest possible value is returned.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
</method-group>
</class>



















































</namespace>
</namespace>
</header>
<header name="boost/intrusive/unordered_set_hook.hpp">
<namespace name="boost">
<namespace name="intrusive">
<struct name="make_unordered_set_base_hook"><template>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput><classname alt="boost::intrusive::unordered_set_base_hook">unordered_set_base_hook</classname></computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct><struct name="make_unordered_set_member_hook"><template>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput><classname alt="boost::intrusive::unordered_set_member_hook">unordered_set_member_hook</classname></computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct><class name="unordered_set_base_hook"><template>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><inherit access="public">make_unordered_set_base_hook::type&lt; O1, O2, O3, O4 &gt;</inherit><description><para>Derive a class from <classname alt="boost::intrusive::unordered_set_base_hook">unordered_set_base_hook</classname> in order to store objects in in an unordered_set/unordered_multi_set. <classname alt="boost::intrusive::unordered_set_base_hook">unordered_set_base_hook</classname> holds the data necessary to maintain the unordered_set/unordered_multi_set and provides an appropriate <classname alt="boost::intrusive::value_traits">value_traits</classname> class for unordered_set/unordered_multi_set.</para><para>The hook admits the following options: <computeroutput>tag&lt;&gt;</computeroutput>, <computeroutput>void_pointer&lt;&gt;</computeroutput>, <computeroutput>link_mode&lt;&gt;</computeroutput>, <computeroutput>store_hash&lt;&gt;</computeroutput> and <computeroutput>optimize_multikey&lt;&gt;</computeroutput>.</para><para><computeroutput>tag&lt;&gt;</computeroutput> defines a tag to identify the node. The same tag value can be used in different classes, but if a class is derived from more than one <computeroutput><classname alt="boost::intrusive::list_base_hook">list_base_hook</classname></computeroutput>, then each <computeroutput><classname alt="boost::intrusive::list_base_hook">list_base_hook</classname></computeroutput> needs its unique tag.</para><para><computeroutput>void_pointer&lt;&gt;</computeroutput> is the pointer type that will be used internally in the hook and the container configured to use this hook.</para><para><computeroutput>link_mode&lt;&gt;</computeroutput> will specify the linking mode of the hook (<computeroutput>normal_link</computeroutput>, <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput>).</para><para><computeroutput>store_hash&lt;&gt;</computeroutput> will tell the hook to store the hash of the value to speed up rehashings.</para><para><computeroutput>optimize_multikey&lt;&gt;</computeroutput> will tell the hook to store a link to form a group with other value with the same value to speed up searches and insertions in unordered_multisets with a great number of with equivalent keys. </para></description><method-group name="public member functions">
<method name="swap_nodes"><type>void</type><parameter name="other"><paramtype><classname>unordered_set_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swapping two nodes swaps the position of the elements related to those nodes in one or two containers. That is, if the node this is part of the element e1, the node x is part of the element e2 and both elements are included in the containers s1 and s2, then after the swap-operation e1 is in s2 at the position of e2 and e2 is in s1 at the position of e1. If one element is not in a container, then after the swap-operation the other element is not in a container. Iterators to e1 and e2 related to those nodes are invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="is_linked" cv="const"><type>bool</type><description><para><emphasis role="bold">Precondition</emphasis>: <classname alt="boost::intrusive::link_mode">link_mode</classname> must be <computeroutput>safe_link</computeroutput> or <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: true, if the node belongs to a container, false otherwise. This function can be used to test whether <computeroutput>unordered_set::iterator_to</computeroutput> will return a valid iterator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method>
<method name="unlink"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the node if it's inserted in a container. This function is only allowed if <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></constructor>
<constructor><parameter name=""><paramtype>const <classname>unordered_set_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing a copy-constructor makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></constructor>
<copy-assignment><type><classname>unordered_set_base_hook</classname> &amp;</type><parameter name=""><paramtype>const <classname>unordered_set_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Empty function. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing an assignment operator makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>normal_link</computeroutput>, the destructor does nothing (ie. no code is generated). If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>safe_link</computeroutput> and the object is stored in an <classname alt="boost::intrusive::unordered_set">unordered_set</classname> an assertion is raised. If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> and <computeroutput>is_linked()</computeroutput> is true, the node is unlinked.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor>
</class><class name="unordered_set_member_hook"><template>
      <template-nontype-parameter name="Options"><type>class ...</type></template-nontype-parameter>
    </template><inherit access="public">make_unordered_set_member_hook::type&lt; O1, O2, O3, O4 &gt;</inherit><description><para>Put a public data member <classname alt="boost::intrusive::unordered_set_member_hook">unordered_set_member_hook</classname> in order to store objects of this class in an unordered_set/unordered_multi_set. <classname alt="boost::intrusive::unordered_set_member_hook">unordered_set_member_hook</classname> holds the data necessary for maintaining the unordered_set/unordered_multi_set and provides an appropriate <classname alt="boost::intrusive::value_traits">value_traits</classname> class for unordered_set/unordered_multi_set.</para><para>The hook admits the following options: <computeroutput>void_pointer&lt;&gt;</computeroutput>, <computeroutput>link_mode&lt;&gt;</computeroutput> and <computeroutput>store_hash&lt;&gt;</computeroutput>.</para><para><computeroutput>void_pointer&lt;&gt;</computeroutput> is the pointer type that will be used internally in the hook and the container configured to use this hook.</para><para><computeroutput>link_mode&lt;&gt;</computeroutput> will specify the linking mode of the hook (<computeroutput>normal_link</computeroutput>, <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput>).</para><para><computeroutput>store_hash&lt;&gt;</computeroutput> will tell the hook to store the hash of the value to speed up rehashings. </para></description><method-group name="public member functions">
<method name="swap_nodes"><type>void</type><parameter name="other"><paramtype><classname>unordered_set_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swapping two nodes swaps the position of the elements related to those nodes in one or two containers. That is, if the node this is part of the element e1, the node x is part of the element e2 and both elements are included in the containers s1 and s2, then after the swap-operation e1 is in s2 at the position of e2 and e2 is in s1 at the position of e1. If one element is not in a container, then after the swap-operation the other element is not in a container. Iterators to e1 and e2 related to those nodes are invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="is_linked" cv="const"><type>bool</type><description><para><emphasis role="bold">Precondition</emphasis>: <classname alt="boost::intrusive::link_mode">link_mode</classname> must be <computeroutput>safe_link</computeroutput> or <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: true, if the node belongs to a container, false otherwise. This function can be used to test whether <computeroutput>unordered_set::iterator_to</computeroutput> will return a valid iterator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method>
<method name="unlink"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the node if it's inserted in a container. This function is only allowed if <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></constructor>
<constructor><parameter name=""><paramtype>const <classname>unordered_set_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing a copy-constructor makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></constructor>
<copy-assignment><type><classname>unordered_set_member_hook</classname> &amp;</type><parameter name=""><paramtype>const <classname>unordered_set_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Empty function. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing an assignment operator makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>normal_link</computeroutput>, the destructor does nothing (ie. no code is generated). If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>safe_link</computeroutput> and the object is stored in an <classname alt="boost::intrusive::unordered_set">unordered_set</classname> an assertion is raised. If <classname alt="boost::intrusive::link_mode">link_mode</classname> is <computeroutput>auto_unlink</computeroutput> and <computeroutput>is_linked()</computeroutput> is true, the node is unlinked.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor>
</class>



















































</namespace>
</namespace>
</header>
</library-reference>