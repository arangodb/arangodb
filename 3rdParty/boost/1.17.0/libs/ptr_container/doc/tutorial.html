<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.14: http://docutils.sourceforge.net/" />
<title>Boost Pointer Container Library</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7952 2016-07-26 18:15:59Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

.subscript {
  vertical-align: sub;
  font-size: smaller }

.superscript {
  vertical-align: super;
  font-size: smaller }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left, table.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right, table.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

table.align-center {
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

.align-top    {
  vertical-align: top }

.align-middle {
  vertical-align: middle }

.align-bottom {
  vertical-align: bottom }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em ;
  margin-right: 2em }

pre.code .ln { color: grey; } /* line numbers */
pre.code, code { background-color: #eeeeee }
pre.code .comment, code .comment { color: #5C6576 }
pre.code .keyword, code .keyword { color: #3B0D06; font-weight: bold }
pre.code .literal.string, code .literal.string { color: #0C5404 }
pre.code .name.builtin, code .name.builtin { color: #352B84 }
pre.code .deleted, code .deleted { background-color: #DEB0A1}
pre.code .inserted, code .inserted { background-color: #A3D289}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

/* "booktabs" style (no vertical lines) */
table.docutils.booktabs {
  border: 0px;
  border-top: 2px solid;
  border-bottom: 2px solid;
  border-collapse: collapse;
}
table.docutils.booktabs * {
  border: 0px;
}
table.docutils.booktabs th {
  border-bottom: thin solid;
  text-align: left;
}

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="boost-pointer-container-library">
<h1 class="title"><img alt="Boost" src="boost.png" /> Pointer Container Library</h1>
<h2 class="subtitle" id="tutorial">Tutorial</h2>

<p>The tutorial shows you the most simple usage of the
library. It is assumed that the reader is familiar
with the use of standard containers. Although
the tutorial is devided into sections, it is recommended
that you read it all from top to bottom.</p>
<ul class="simple">
<li><a class="reference internal" href="#basic-usage">Basic usage</a></li>
<li><a class="reference internal" href="#indirected-interface">Indirected interface</a></li>
<li><a class="reference internal" href="#sequence-containers">Sequence containers</a></li>
<li><a class="reference internal" href="#associative-containers">Associative containers</a></li>
<li><a class="reference internal" href="#null-values">Null values</a></li>
<li><a class="reference internal" href="#cloneability">Cloneability</a></li>
<li><a class="reference internal" href="#new-functions">New functions</a></li>
<li><a class="reference internal" href="#compatible-smart-pointer-overloads">Compatible smart pointer overloads</a></li>
<li><a class="reference internal" href="#algorithms">Algorithms</a></li>
</ul>
<div class="section" id="basic-usage">
<h1>Basic usage</h1>
<p>The most important aspect of a pointer container is that it manages
memory for you. This means that you in most cases do not need to worry
about deleting memory.</p>
<p>Let us assume that we have an OO-hierarchy of animals</p>
<pre class="literal-block">
class animal : <a class="reference external" href="http://www.boost.org/libs/utility/utility.htm#Class_noncopyable">boost::noncopyable</a>
{
public:
    virtual      ~animal()   {}
    virtual void eat()       = 0;
    virtual int  age() const = 0;
    // ...
};

class mammal : public animal
{
    // ...
};

class bird : public animal
{
    // ...
};
</pre>
<p>Then the managing of the animals is straight-forward. Imagine a
Zoo:</p>
<pre class="literal-block">
class zoo
{
    boost::ptr_vector&lt;animal&gt; the_animals;
public:

    void add_animal( animal* a )
    {
        the_animals.push_back( a );
    }
};
</pre>
<p>Notice how we just pass the class name to the container; there
is no <tt class="docutils literal">*</tt> to indicate it is a pointer.
With this declaration we can now say:</p>
<pre class="literal-block">
zoo the_zoo;
the_zoo.add_animal( new mammal(&quot;joe&quot;) );
the_zoo.add_animal( new bird(&quot;dodo&quot;) );
</pre>
<p>Thus we heap-allocate all elements of the container
and never rely on copy-semantics.</p>
</div>
<div class="section" id="indirected-interface">
<h1>Indirected interface</h1>
<p>A particular feature of the pointer containers is that
the query interface is indirected. For example,</p>
<pre class="literal-block">
boost::ptr_vector&lt;animal&gt; vec;
vec.push_back( new animal ); // you add it as pointer ...
vec[0].eat();                // but get a reference back
</pre>
<p>This indirection also happens to iterators, so</p>
<pre class="literal-block">
typedef std::vector&lt;animal*&gt; std_vec;
std_vec vec;
...
std_vec::iterator i = vec.begin();
(*i)-&gt;eat(); // '*' needed
</pre>
<p>now becomes</p>
<pre class="literal-block">
typedef boost::ptr_vector&lt;animal&gt;  ptr_vec;
ptr_vec vec;
ptr_vec::iterator i = vec.begin();
i-&gt;eat(); // no indirection needed
</pre>
</div>
<div class="section" id="sequence-containers">
<h1>Sequence containers</h1>
<p>The sequence containers are used when you do not need to
keep an ordering on your elements. You can basically
expect all operations of the normal standard containers
to be available. So, for example, with a  <tt class="docutils literal">ptr_deque</tt>
and <tt class="docutils literal">ptr_list</tt> object you can say:</p>
<pre class="literal-block">
boost::ptr_deque&lt;animal&gt; deq;
deq.push_front( new animal );
deq.pop_front();
</pre>
<p>because <tt class="docutils literal"><span class="pre">std::deque</span></tt> and <tt class="docutils literal"><span class="pre">std::list</span></tt> have <tt class="docutils literal">push_front()</tt>
and <tt class="docutils literal">pop_front()</tt> members.</p>
<p>If the standard sequence supports
random access, so does the pointer container; for example:</p>
<pre class="literal-block">
for( boost::ptr_deque&lt;animal&gt;::size_type i = 0u;
     i != deq.size(); ++i )
     deq[i].eat();
</pre>
<p>The <tt class="docutils literal">ptr_vector</tt> also allows you to specify the size of
the buffer to allocate; for example</p>
<pre class="literal-block">
boost::ptr_vector&lt;animal&gt; animals( 10u );
</pre>
<p>will reserve room for 10 animals.</p>
</div>
<div class="section" id="associative-containers">
<h1>Associative containers</h1>
<p>To keep an ordering on our animals, we could use a <tt class="docutils literal">ptr_set</tt>:</p>
<pre class="literal-block">
boost::ptr_set&lt;animal&gt; set;
set.insert( new monkey(&quot;bobo&quot;) );
set.insert( new whale(&quot;anna&quot;) );
...
</pre>
<p>This requires that <tt class="docutils literal"><span class="pre">operator&lt;()</span></tt> is defined for animals. One
way to do this could be</p>
<pre class="literal-block">
inline bool operator&lt;( const animal&amp; l, const animal&amp; r )
{
    return l.name() &lt; r.name();
}
</pre>
<p>if we wanted to keep the animals sorted by name.</p>
<p>Maybe you want to keep all the animals in zoo ordered wrt.
their name, but it so happens that many animals have the
same name. We can then use a <tt class="docutils literal">ptr_multimap</tt>:</p>
<pre class="literal-block">
typedef boost::ptr_multimap&lt;std::string,animal&gt; zoo_type;
zoo_type zoo;
std::string bobo = &quot;bobo&quot;,
            anna = &quot;anna&quot;;
zoo.insert( bobo, new monkey(bobo) );
zoo.insert( bobo, new elephant(bobo) );
zoo.insert( anna, new whale(anna) );
zoo.insert( anna, new emu(anna) );
</pre>
<p>Note that must create the key as an lvalue
(due to exception-safety issues); the following would not
have compiled</p>
<pre class="literal-block">
zoo.insert( &quot;bobo&quot;, // this is bad, but you get compile error
            new monkey(&quot;bobo&quot;) );
</pre>
<p>If a multimap is not needed, we can use <tt class="docutils literal"><span class="pre">operator[]()</span></tt>
to avoid the clumsiness:</p>
<pre class="literal-block">
boost::ptr_map&lt;std::string,animal&gt; animals;
animals[&quot;bobo&quot;].set_name(&quot;bobo&quot;);
</pre>
<p>This requires a default constructor for animals and
a function to do the initialization, in this case <tt class="docutils literal">set_name()</tt>.</p>
<p>A better alternative is to use <a class="reference external" href="../../assign/index.html">Boost.Assign</a>
to help you out. In particular, consider</p>
<ul class="simple">
<li><a class="reference external" href="../../assign/doc/index.html#ptr_push_back">ptr_push_back(), ptr_push_front(), ptr_insert() and ptr_map_insert()</a></li>
<li><a class="reference external" href="../../assign/doc/index.html#ptr_list_of">ptr_list_of()</a></li>
</ul>
<p>For example, the above insertion may now be written</p>
<pre class="literal-block">
boost::ptr_multimap&lt;std::string,animal&gt; animals;

using namespace boost::assign;
ptr_map_insert&lt;monkey&gt;( animals )( &quot;bobo&quot;, &quot;bobo&quot; );
ptr_map_insert&lt;elephant&gt;( animals )( &quot;bobo&quot;, &quot;bobo&quot; );
ptr_map_insert&lt;whale&gt;( animals )( &quot;anna&quot;, &quot;anna&quot; );
ptr_map_insert&lt;emu&gt;( animals )( &quot;anna&quot;, &quot;anna&quot; );
</pre>
</div>
<div class="section" id="null-values">
<h1>Null values</h1>
<p>By default, if you try to insert null into a container, an exception
is thrown. If you want to allow nulls, then you must
say so explicitly when declaring the container variable</p>
<pre class="literal-block">
boost::ptr_vector&lt; boost::nullable&lt;animal&gt; &gt; animals_type;
animals_type animals;
...
animals.insert( animals.end(), new dodo(&quot;fido&quot;) );
animals.insert( animals.begin(), 0 ) // ok
</pre>
<p>Once you have inserted a null into the container, you must
always check if the value is null before accessing the object</p>
<pre class="literal-block">
for( animals_type::iterator i = animals.begin();
     i != animals.end(); ++i )
{
    if( !boost::is_null(i) ) // always check for validity
        i-&gt;eat();
}
</pre>
<p>If the container support random access, you may also check this as</p>
<pre class="literal-block">
for( animals_type::size_type i = 0u;
     i != animals.size(); ++i )
{
    if( !animals.is_null(i) )
         animals[i].eat();
}
</pre>
<p>Note that it is meaningless to insert
null into <tt class="docutils literal">ptr_set</tt> and <tt class="docutils literal">ptr_multiset</tt>.</p>
</div>
<div class="section" id="cloneability">
<h1>Cloneability</h1>
<p>In OO programming it is typical to prohibit copying of objects; the
objects may sometimes be allowed to be Cloneable; for example,:</p>
<pre class="literal-block">
animal* animal::clone() const
{
    return do_clone(); // implemented by private virtual function
}
</pre>
<p>If the OO hierarchy thus allows cloning, we need to tell the
pointer containers how cloning is to be done. This is simply
done by defining a free-standing function, <tt class="docutils literal">new_clone()</tt>,
in the same namespace as
the object hierarchy:</p>
<pre class="literal-block">
inline animal* new_clone( const animal&amp; a )
{
    return a.clone();
}
</pre>
<p>That is all, now a lot of functions in a pointer container
can exploit the cloneability of the animal objects. For example</p>
<pre class="literal-block">
typedef boost::ptr_list&lt;animal&gt; zoo_type;
zoo_type zoo, another_zoo;
...
another_zoo.assign( zoo.begin(), zoo.end() );
</pre>
<p>will fill another zoo with clones of the first zoo. Similarly,
<tt class="docutils literal">insert()</tt> can now insert clones into your pointer container</p>
<pre class="literal-block">
another_zoo.insert( another_zoo.begin(), zoo.begin(), zoo.end() );
</pre>
<p>The whole container can now also be cloned</p>
<pre class="literal-block">
zoo_type yet_another_zoo = zoo.clone();
</pre>
<p>Copying or assigning the container has the same effect as cloning (though it is slightly cheaper):</p>
<pre class="literal-block">
zoo_type yet_another_zoo = zoo;
</pre>
<p>Copying also support derived-to-base class conversions:</p>
<pre class="literal-block">
boost::ptr_vector&lt;monkey&gt; monkeys = boost::assign::ptr_list_of&lt;monkey&gt;( &quot;bobo&quot; )( &quot;bebe&quot;)( &quot;uhuh&quot; );
boost::ptr_vector&lt;animal&gt; animals = monkeys;
</pre>
<p>This also works for maps:</p>
<pre class="literal-block">
boost::ptr_map&lt;std::string,monkey&gt; monkeys = ...;
boost::ptr_map&lt;std::string,animal&gt; animals = monkeys;
</pre>
</div>
<div class="section" id="new-functions">
<h1>New functions</h1>
<p>Given that we know we are working with pointers, a few new functions
make sense. For example, say you want to remove an
animal from the zoo</p>
<pre class="literal-block">
zoo_type::auto_type the_animal = zoo.release( zoo.begin() );
the_animal-&gt;eat();
animal* the_animal_ptr = the_animal.release(); // now this is not deleted
zoo.release(2); // for random access containers
</pre>
<p>You can think of <tt class="docutils literal">auto_type</tt> as a non-copyable form of
<tt class="docutils literal"><span class="pre">std::auto_ptr</span></tt>. Notice that when you release an object, the
pointer is removed from the container and the containers size
shrinks. For containers that store nulls, we can exploit that
<tt class="docutils literal">auto_type</tt> is convertible to <tt class="docutils literal">bool</tt>:</p>
<pre class="literal-block">
if( ptr_vector&lt; nullable&lt;T&gt; &gt;::auto_type r = vec.pop_back() )
{
  ...
}
</pre>
<p>You can also release the entire container if you
want to return it from a function</p>
<pre class="literal-block">
<a class="reference external" href="compatible_smart_ptr.html"><em>compatible-smart-ptr</em></a>&lt; boost::ptr_deque&lt;animal&gt; &gt; get_zoo()
{
    boost::ptr_deque&lt;animal&gt;  result;
    ...
    return result.release(); // give up ownership
}
...
boost::ptr_deque&lt;animal&gt; animals = get_zoo();
</pre>
<p>Let us assume we want to move an animal object from
one zoo to another. In other words, we want to move the
animal and the responsibility of it to another zoo</p>
<pre class="literal-block">
another_zoo.transfer( another_zoo.end(), // insert before end
                      zoo.begin(),       // insert this animal ...
                      zoo );             // from this container
</pre>
<p>This kind of &quot;move-semantics&quot; is different from
normal value-based containers. You can think of <tt class="docutils literal">transfer()</tt>
as the same as <tt class="docutils literal">splice()</tt> on <tt class="docutils literal"><span class="pre">std::list</span></tt>.</p>
<p>If you want to replace an element, you can easily do so</p>
<pre class="literal-block">
zoo_type::auto_type old_animal = zoo.replace( zoo.begin(), new monkey(&quot;bibi&quot;) );
zoo.replace( 2, old_animal.release() ); // for random access containers
</pre>
<p>A map is slightly different to iterate over than standard maps.
Now we say</p>
<pre class="literal-block">
typedef boost::ptr_map&lt;std::string, boost::nullable&lt;animal&gt; &gt; animal_map;
animal_map map;
...
for( animal_map::const_iterator i = map.begin(), e = map.end(); i != e; ++i )
{
    std::cout &lt;&lt; &quot;\n key: &quot; &lt;&lt; i-&gt;first;
    std::cout &lt;&lt; &quot;\n age: &quot;;

    if( boost::is_null(i) )
        std::cout &lt;&lt; &quot;unknown&quot;;
    else
        std::cout &lt;&lt; i-&gt;second-&gt;age();
 }
</pre>
<p>Except for the check for null, this looks like it would with a normal map. But if <tt class="docutils literal">age()</tt> had
not been a <tt class="docutils literal">const</tt> member function,
it would not have compiled.</p>
<p>Maps can also be indexed with bounds-checking</p>
<pre class="literal-block">
try
{
    animal&amp; bobo = map.at(&quot;bobo&quot;);
}
catch( boost::bad_ptr_container_operation&amp; e )
{
    // &quot;bobo&quot; not found
}
</pre>
</div>
<div class="section" id="compatible-smart-pointer-overloads">
<h1>Compatible smart pointer overloads</h1>
<p>Every time there is a function that takes a <tt class="docutils literal">T*</tt> parameter, there is
also a function overload (or two) taking a <tt class="docutils literal"><span class="pre"><a class="reference external" href="compatible_smart_ptr.html"><em>compatible-smart-ptr</em></a>&lt;U&gt;</span></tt>
parameter. This is of course done to make the library intregrate
seamlessly with <tt class="docutils literal"><span class="pre">std::auto_ptr</span></tt> or <tt class="docutils literal"><span class="pre">std::unique_ptr</span></tt>. For example,
consider a statement like</p>
<pre class="literal-block">
std::ptr_vector&lt;Base&gt; vec;
vec.push_back( new Base );
</pre>
<p>If the compiler supports <tt class="docutils literal"><span class="pre">std::auto_ptr</span></tt>, this is complemented
by</p>
<pre class="literal-block">
std::auto_ptr&lt;Derived&gt; p( new Derived );
vec.push_back( p );
</pre>
<p>Similarly if <tt class="docutils literal"><span class="pre">std::unique_ptr</span></tt> is available, we can write</p>
<pre class="literal-block">
std::unique_ptr&lt;Derived&gt; p( new Derived );
vec.push_back( std::move( p ) );
</pre>
<p>Notice that the template argument for <tt class="docutils literal"><span class="pre"><a class="reference external" href="compatible_smart_ptr.html"><em>compatible-smart-ptr</em></a></span></tt> does not need to
follow the template argument for <tt class="docutils literal">ptr_vector</tt> as long as <tt class="docutils literal">Derived*</tt>
can be implicitly converted to <tt class="docutils literal">Base*</tt>.</p>
</div>
<div class="section" id="algorithms">
<h1>Algorithms</h1>
<p>Unfortunately it is not possible to use pointer containers with
mutating algorithms from the standard library. However,
the most useful ones
are instead provided as member functions:</p>
<pre class="literal-block">
boost::ptr_vector&lt;animal&gt; zoo;
...
zoo.sort();                               // assume 'bool operator&lt;( const animal&amp;, const animal&amp; )'
zoo.sort( std::less&lt;animal&gt;() );          // the same, notice no '*' is present
zoo.sort( zoo.begin(), zoo.begin() + 5 ); // sort selected range
</pre>
<p>Notice that predicates are automatically wrapped in an <a class="reference external" href="indirect_fun.html">indirect_fun</a> object.</p>
<p>You can remove equal and adjacent elements using <tt class="docutils literal">unique()</tt>:</p>
<pre class="literal-block">
zoo.unique();                             // assume 'bool operator==( const animal&amp;, const animal&amp; )'
zoo.unique( zoo.begin(), zoo.begin() + 5, my_comparison_predicate() );
</pre>
<p>If you just want to remove certain elements, use <tt class="docutils literal">erase_if</tt>:</p>
<pre class="literal-block">
zoo.erase_if( my_predicate() );
</pre>
<p>Finally you may want to merge two sorted containers:</p>
<pre class="literal-block">
boost::ptr_vector&lt;animal&gt; another_zoo = ...;
another_zoo.sort();                      // sorted wrt. to same order as 'zoo'
zoo.merge( another_zoo );
BOOST_ASSERT( another_zoo.empty() );
</pre>
<p>That is all; now you have learned all the basics!</p>
<hr><p><strong>See also</strong></p>
<ul class="simple">
<li><a class="reference external" href="guidelines.html">Usage guidelines</a></li>
<li><a class="reference external" href="../../conversion/cast.htm#Polymorphic_castl">Cast utilities</a></li>
</ul>
<p><strong>Navigate</strong></p>
<ul class="simple">
<li><a class="reference external" href="ptr_container.html">home</a></li>
<li><a class="reference external" href="examples.html">examples</a></li>
</ul>
<hr><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Copyright:</th><td class="field-body">Thorsten Ottosen 2004-2006. Use, modification and distribution is subject to the Boost Software License, Version 1.0 (see <a class="reference external" href="http://www.boost.org/LICENSE_1_0.txt">LICENSE_1_0.txt</a>).</td>
</tr>
</tbody>
</table>
</div>
</div>
</body>
</html>
