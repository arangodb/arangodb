<?xml version="1.0" standalone="yes"?>
<library-reference id="variadic_macro_data_reference"><title>Variadic Macro Data Reference</title><header name="boost/vmd/assert.hpp">
<macro name="BOOST_VMD_ASSERT" kind="functionlike"><macro-parameter name="..."/><purpose>Conditionally causes an error to be generated. </purpose><description><para>... = variadic parameters, maximum of 2 will be considered. Any variadic parameters beyond the maximum of 2 are just ignored.</para><para>The first variadic parameter is:</para><para>cond = A condition that determines whether an assertion occurs. Valid values range from 0 to BOOST_PP_LIMIT_MAG.</para><para>The second variadic parameter (optional) is:</para><para>errstr = An error string for generating a compiler error when using the VC++ compiler. The VC++ compiler is incapable of producing a preprocessor error so when the 'cond' is 0, a compiler error is generated by outputting C++ code in the form of:</para><para><programlisting language="c++">typedef char errstr[-1];
</programlisting></para><para>The errstr defaults to BOOST_VMD_ASSERT_ERROR if not supplied. It is only relevant for VC++.</para><para>returns = If cond expands to 0, this macro causes an error. Otherwise, it expands to nothing. For all compilers other than Visual C++ the error is a preprocessing error. For Visual C++ the error is caused by output invalid C++: this error could be masked if the invalid output is ignored by a macro which invokes this macro. </para></description></macro>
</header>
<header name="boost/vmd/assert_is_array.hpp">
<macro name="BOOST_VMD_ASSERT_IS_ARRAY" kind="functionlike"><macro-parameter name="sequence"/><purpose>Asserts that the sequence is a Boost PP array. </purpose><description><para>The macro checks that the sequence is a Boost PP array. If it is not a Boost PP array, it forces a compiler error.</para><para>The macro normally checks for a Boost PP array only in debug mode. However an end-user can force the macro to check or not check by defining the macro BOOST_VMD_ASSERT_DATA to 1 or 0 respectively.</para><para>sequence = a possible Boost PP array.</para><para><programlisting language="c++">returns  = Normally the macro returns nothing. 

           If the sequence is a Boost PP array, nothing is 
           output.
          
           For VC++, because there is no sure way of forcing  
           a compiler error from within a macro without producing
           output, if the sequence is not a Boost PP array the 
           macro forces a compiler error by outputting invalid C++.
          
           For all other compilers a compiler error is forced 
           without producing output if the sequence is not a 
           Boost PP array.
</programlisting> </para></description></macro>
<macro name="BOOST_VMD_ASSERT_IS_ARRAY_D" kind="functionlike"><macro-parameter name="d"/><macro-parameter name="sequence"/><purpose>Asserts that the sequence is a Boost PP array. Re-entrant version. </purpose><description><para>The macro checks that the sequence is a Boost PP array. If it is not a Boost PP array, it forces a compiler error.</para><para>The macro normally checks for a Boost PP array only in debug mode. However an end-user can force the macro to check or not check by defining the macro BOOST_VMD_ASSERT_DATA to 1 or 0 respectively.</para><para>d = The next available BOOST_PP_WHILE iteration. <sbr/>
 sequence = a possible Boost PP sequence.</para><para><programlisting language="c++">returns  = Normally the macro returns nothing. 

           If the sequence is a Boost PP array, nothing is 
           output.
          
           For VC++, because there is no sure way of forcing  
           a compiler error from within a macro without producing
           output, if the sequence is not a Boost PP array the 
           macro forces a compiler error by outputting invalid C++.
          
           For all other compilers a compiler error is forced 
           without producing output if the sequence is not a 
           Boost PP array.
</programlisting> </para></description></macro>
</header>
<header name="boost/vmd/assert_is_empty.hpp">
<macro name="BOOST_VMD_ASSERT_IS_EMPTY" kind="functionlike"><macro-parameter name="..."/><purpose>Asserts that the input is empty. </purpose><description><para>The macro checks to see if the input is empty or not. If it is not empty, it forces a compiler error.</para><para>The macro is a variadic macro taking any input. For the VC++8 compiler (VS2005) the macro takes a single parameter of input to check and not variadic data.</para><para>The macro normally checks for emptiness only in debug mode. However an end-user can force the macro to check or not check by defining the macro BOOST_VMD_ASSERT_DATA to 1 or 0 respectively.</para><para>.... = variadic input, for VC++8 this must be a single parameter.</para><para><programlisting language="c++">returns = Normally the macro returns nothing. 

          If the input is empty, nothing is output.
          
          For VC++, because there is no sure way of forcing  
          a compiler error from within a macro without producing
          output, if the input is not empty the 
          macro forces a compiler error by outputting invalid C++.
          
          For all other compilers a compiler error is forced 
          without producing output if the input is not empty.
</programlisting></para><para>It is recommended to append BOOST_PP_EMPTY() to whatever input is being tested in order to avoid possible warning messages from some compilers about no parameters being passed to the macro when the input is truly empty. </para></description></macro>
</header>
<header name="boost/vmd/assert_is_identifier.hpp">
<macro name="BOOST_VMD_ASSERT_IS_IDENTIFIER" kind="functionlike"><macro-parameter name="..."/><purpose>Asserts that the sequence is an identifier. </purpose><description><para>The macro checks that the sequence is an identifier. If it is not an identifier, it forces a compiler error.</para><para>The macro normally checks for an identifier only in debug mode. However an end-user can force the macro to check or not check by defining the macro BOOST_VMD_ASSERT_DATA to 1 or 0 respectively.</para><para>... = variadic parameters</para><para>The variadic parameters are:</para><para>sequence = A sequence to test as an identifier. <sbr/>
 ids (optional) = The data may take one of two forms: it is either one or more single identifiers or a single Boost PP tuple of identifiers.</para><para><programlisting language="c++">returns = Normally the macro returns nothing. 

          If the sequence is an identifier, nothing is 
          output. If optional ids are specified, for the 
          sequence to be an identifier it must be an
          identifier that matches one of the optional
          ids.
          
          For VC++, because there is no sure way of forcing  
          a compiler error from within a macro without producing
          output, if the sequence is not an identifier the 
          macro forces a compiler error by outputting invalid C++.
          
          For all other compilers a compiler error is forced 
          without producing output if the sequence is not an
          identifier.
</programlisting></para><para>Identifiers are registered in VMD with:</para><para><programlisting language="c++">#define BOOST_VMD_REG_XXX (XXX) where XXX is a v-identifier.
</programlisting></para><para>The identifier must be registered to be found.</para><para>Identifiers are pre-detected in VMD with:</para><para><programlisting language="c++">#define BOOST_VMD_DETECT_XXX_XXX where XXX is an identifier.
</programlisting></para><para>If you specify optional ids and have not specified the detection of an optional id, that id will never match an identifier. </para></description></macro>
<macro name="BOOST_VMD_ASSERT_IS_IDENTIFIER_D" kind="functionlike"><macro-parameter name="d"/><macro-parameter name="..."/><purpose>Asserts that the sequence is an identifier. Re-entrant version. </purpose><description><para>The macro checks that the sequence is an identifier. If it is not an identifier, it forces a compiler error.</para><para>The macro normally checks for an identifier only in debug mode. However an end-user can force the macro to check or not check by defining the macro BOOST_VMD_ASSERT_DATA to 1 or 0 respectively.</para><para>d = The next available BOOST_PP_WHILE iteration. <sbr/>
 ... = variadic parameters</para><para>The variadic parameters are:</para><para>sequence = A sequence to test as an identifier. <sbr/>
 ids (optional) = The data may take one of two forms: it is either one or more single identifiers or a single Boost PP tuple of identifiers.</para><para><programlisting language="c++">returns = Normally the macro returns nothing. 

          If the sequence is an identifier, nothing is 
          output. If optional ids are specified, for the 
          sequence to be an identifier it must be an
          identifier that matches one of the optional
          ids.
          
          For VC++, because there is no sure way of forcing  
          a compiler error from within a macro without producing
          output, if the sequence is not an identifier the 
          macro forces a compiler error by outputting invalid C++.
          
          For all other compilers a compiler error is forced 
          without producing output if the sequence is not an
          identifier.
</programlisting></para><para>Identifiers are registered in VMD with:</para><para><programlisting language="c++">#define BOOST_VMD_REG_XXX (XXX) where XXX is a v-identifier.
</programlisting></para><para>The identifier must be registered to be found.</para><para>Identifiers are pre-detected in VMD with:</para><para><programlisting language="c++">#define BOOST_VMD_DETECT_XXX_XXX where XXX is an identifier.
</programlisting></para><para>If you specify optional ids and have not specified the detection of an optional id, that id will never match an identifier. </para></description></macro>
</header>
<header name="boost/vmd/assert_is_list.hpp">
<macro name="BOOST_VMD_ASSERT_IS_LIST" kind="functionlike"><macro-parameter name="sequence"/><purpose>Asserts that the sequence is a Boost PP list. </purpose><description><para>The macro checks that the sequence is a Boost PP list. If it is not a Boost PP list, it forces a compiler error.</para><para>The macro normally checks for a Boost PP list only in debug mode. However an end-user can force the macro to check or not check by defining the macro BOOST_VMD_ASSERT_DATA to 1 or 0 respectively.</para><para>sequence = a possible Boost PP list.</para><para><programlisting language="c++">returns  = Normally the macro returns nothing. 

           If the sequence is a Boost PP list, nothing is 
           output.
          
           For VC++, because there is no sure way of forcing  
           a compiler error from within a macro without producing
           output, if the sequence is not a Boost PP list the 
           macro forces a compiler error by outputting invalid C++.
          
           For all other compilers a compiler error is forced 
           without producing output if the parameter is not a 
           Boost PP list.
</programlisting> </para></description></macro>
<macro name="BOOST_VMD_ASSERT_IS_LIST_D" kind="functionlike"><macro-parameter name="d"/><macro-parameter name="sequence"/><purpose>Asserts that the sequence is a Boost PP list. Re-entrant version. </purpose><description><para>The macro checks that the sequence is a Boost PP list. If it is not a Boost PP list, it forces a compiler error.</para><para>The macro normally checks for a Boost PP list only in debug mode. However an end-user can force the macro to check or not check by defining the macro BOOST_VMD_ASSERT_DATA to 1 or 0 respectively.</para><para>d = The next available BOOST_PP_WHILE iteration. <sbr/>
 sequence = a possible Boost PP list.</para><para><programlisting language="c++">returns  = Normally the macro returns nothing. 

           If the sequence is a Boost PP list, nothing is 
           output.
          
           For VC++, because there is no sure way of forcing  
           a compiler error from within a macro without producing
           output, if the sequence is not a Boost PP list the 
           macro forces a compiler error by outputting invalid C++.
          
           For all other compilers a compiler error is forced 
           without producing output if the parameter is not a 
           Boost PP list.
</programlisting> </para></description></macro>
</header>
<header name="boost/vmd/assert_is_number.hpp">
<macro name="BOOST_VMD_ASSERT_IS_NUMBER" kind="functionlike"><macro-parameter name="sequence"/><purpose>Asserts that the sequence is a number. </purpose><description><para>The macro checks that the parameter is a number. If it is not a number, it forces a compiler error.</para><para>The macro normally checks for a number only in debug mode. However an end-user can force the macro to check or not check by defining the macro BOOST_VMD_ASSERT_DATA to 1 or 0 respectively.</para><para>sequence = a possible number.</para><para><programlisting language="c++">returns  = Normally the macro returns nothing. 

           If the sequence is a number, nothing is 
           output.
          
           For VC++, because there is no sure way of forcing  
           a compiler error from within a macro without producing
           output, if the sequence is not a number the 
           macro forces a compiler error by outputting invalid C++.
          
           For all other compilers a compiler error is forced 
           without producing output if the sequence is not a 
           number.
</programlisting> </para></description></macro>
</header>
<header name="boost/vmd/assert_is_seq.hpp">
<macro name="BOOST_VMD_ASSERT_IS_SEQ" kind="functionlike"><macro-parameter name="sequence"/><purpose>Asserts that the sequence is a Boost PP seq. </purpose><description><para>The macro checks that the sequence is a Boost PP seq. If it is not a Boost PP seq, it forces a compiler error.</para><para>The macro normally checks for a Boost PP seq only in debug mode. However an end-user can force the macro to check or not check by defining the macro BOOST_VMD_ASSERT_DATA to 1 or 0 respectively.</para><para>sequence = a possible Boost PP seq.</para><para><programlisting language="c++">returns  = Normally the macro returns nothing. 

           If the sequence is a Boost PP seq, nothing is 
           output.
          
           For VC++, because there is no sure way of forcing  
           a compiler error from within a macro without producing
           output, if the sequence is not a Boost PP seq the 
           macro forces a compiler error by outputting invalid C++.
          
           For all other compilers a compiler error is forced 
           without producing output if the sequence is not a 
           Boost PP seq.
</programlisting> </para></description></macro>
<macro name="BOOST_VMD_ASSERT_IS_SEQ_D" kind="functionlike"><macro-parameter name="d"/><macro-parameter name="sequence"/><purpose>Asserts that the sequence is a Boost PP seq. Re-entrant version. </purpose><description><para>The macro checks that the sequence is a Boost PP seq. If it is not a Boost PP seq, it forces a compiler error.</para><para>The macro normally checks for a Boost PP seq only in debug mode. However an end-user can force the macro to check or not check by defining the macro BOOST_VMD_ASSERT_DATA to 1 or 0 respectively.</para><para>d = The next available BOOST_PP_WHILE iteration. <sbr/>
 sequence = a possible Boost PP seq.</para><para><programlisting language="c++">returns  = Normally the macro returns nothing. 

           If the sequence is a Boost PP seq, nothing is 
           output.
          
           For VC++, because there is no sure way of forcing  
           a compiler error from within a macro without producing
           output, if the sequence is not a Boost PP seq the 
           macro forces a compiler error by outputting invalid C++.
          
           For all other compilers a compiler error is forced 
           without producing output if the sequence is not a 
           Boost PP seq.
</programlisting> </para></description></macro>
</header>
<header name="boost/vmd/assert_is_tuple.hpp">
<macro name="BOOST_VMD_ASSERT_IS_TUPLE" kind="functionlike"><macro-parameter name="sequence"/><purpose>Asserts that the sequence is a Boost PP tuple. </purpose><description><para>The macro checks that the sequence is a Boost PP tuple. If it is not a Boost PP tuple, it forces a compiler error.</para><para>The macro normally checks for a Boost PP tuple only in debug mode. However an end-user can force the macro to check or not check by defining the macro BOOST_VMD_ASSERT_DATA to 1 or 0 respectively.</para><para>sequence = a possible Boost PP tuple.</para><para><programlisting language="c++">returns  = Normally the macro returns nothing. 

           If the sequence is a Boost PP tuple, nothing is 
           output.
          
           For VC++, because there is no sure way of forcing  
           a compiler error from within a macro without producing
           output, if the sequence is not a Boost PP tuple the 
           macro forces a compiler error by outputting invalid C++. 
          
           For all other compilers a compiler error is forced 
           without producing output if the sequence is not a 
           Boost PP tuple.
</programlisting> </para></description></macro>
</header>
<header name="boost/vmd/assert_is_type.hpp">
<macro name="BOOST_VMD_ASSERT_IS_TYPE" kind="functionlike"><macro-parameter name="sequence"/><purpose>Asserts that the sequence is a VMD type. </purpose><description><para>The macro checks that the sequence is a VMD type. If it is not a VMD type, it forces a compiler error.</para><para>The macro normally checks for a VMD type only in debug mode. However an end-user can force the macro to check or not check by defining the macro BOOST_VMD_ASSERT_DATA to 1 or 0 respectively.</para><para>sequence = a possible VMD type.</para><para><programlisting language="c++">returns = Normally the macro returns nothing. 

          If the sequence is a VMD type, nothing is 
          output.
          
          For VC++, because there is no sure way of forcing  
          a compiler error from within a macro without producing
          output, if the sequence is not a VMD type the 
          macro forces a compiler error by outputting invalid C++.
          
          For all other compilers a compiler error is forced 
          without producing output if the sequence is not a 
          VMD type.
</programlisting> </para></description></macro>
<macro name="BOOST_VMD_ASSERT_IS_TYPE_D" kind="functionlike"><macro-parameter name="d"/><macro-parameter name="sequence"/><purpose>Asserts that the sequence is a VMD type. Re-entrant version. </purpose><description><para>The macro checks that the sequence is a VMD type. If it is not a VMD type, it forces a compiler error.</para><para>The macro normally checks for a VMD type only in debug mode. However an end-user can force the macro to check or not check by defining the macro BOOST_VMD_ASSERT_DATA to 1 or 0 respectively.</para><para>d = The next available BOOST_PP_WHILE iteration. <sbr/>
 sequence = a possible VMD type.</para><para><programlisting language="c++">returns = Normally the macro returns nothing. 

          If the sequence is a VMD type, nothing is 
          output.
          
          For VC++, because there is no sure way of forcing  
          a compiler error from within a macro without producing
          output, if the sequence is not a VMD type the 
          macro forces a compiler error by outputting invalid C++.
          
          For all other compilers a compiler error is forced 
          without producing output if the sequence is not a 
          VMD type.
</programlisting> </para></description></macro>
</header>
<header name="boost/vmd/elem.hpp">
<macro name="BOOST_VMD_ELEM" kind="functionlike"><macro-parameter name="elem"/><macro-parameter name="..."/><purpose>Accesses an element of a sequence. </purpose><description><para>elem = A sequence element number. From 0 to sequence size - 1. <sbr/>
 ... = Variadic parameters.</para><para>The first variadic parameter is required and is the sequence to access. Further variadic parameters are all optional.</para><para>With no further variadic parameters the macro returns the particular element in the sequence. If the element number is outside the bounds of the sequence macro access fails and the macro turns emptiness.</para><para>Optional parameters determine what it means that an element is successfully accessed as well as what data is returned by the macro.</para><para>Filters: specifying a VMD type tells the macro to return the element only if it is of the VMD type specified, else macro access fails. If more than one VMD type is specified as an optional parameter the last one specified is the filter.</para><para>Matching Identifiers: If the filter is specified as the identifier type, BOOST_VMD_TYPE_IDENTIFIER, optional parameters which are identifiers specify that the element accessed must match one of the identifiers else access fails. The identifiers may be specified multiple times as single optional parameters or once as a tuple of identifier parameters. If the identifiers are specified as single optional parameters they cannot be any of the specific BOOST_VMD_ optional parameters in order to be recognized as matching identifiers. Normally this should never be the case. The only situation where this could occur is if the VMD types, which are filters, are used as matching identifiers; in this case the matching identifiers need to be passed as a tuple of identifier parameters so they are not treated as filters.</para><para>Filters and matching identifiers change what it means that an element is successfully accessed. They do not change what data is returned by the macro. The remaining optional parameters do not change what it means that an element is successfully accessed but they do change what data is returned by the macro.</para><para><programlisting language="c++">Splitting: Splitting allows the macro to return the rest of the sequence
         after the element accessed.

         If BOOST_VMD_RETURN_AFTER is specified the return is a tuple
         with the element accessed as the first tuple parameter and the rest of
         the sequence as the second tuple parameter. If element access fails 
         both tuple parameters are empty. 
         
         If BOOST_VMD_RETURN_ONLY_AFTER
         is specified the return is the rest of the sequence after the element accessed
         found. If the element access fails the return is emptiness. 
         
         If BOOST_VMD_RETURN_NO_AFTER, the default, is specified no splitting
         occurs. 
         
         If more than one of the splitting identifiers are specified
         the last one specified determines the splitting.
         
 Return Type: The element accessed can be changed to return both the type
         of the element as well as the element data with optional return type 
         parameters. When a type is returned, the element accessed which is returned becomes a
         two-element tuple where the type of the element accessed is the first tuple element and the element
         data itself is the second tuple element. If the macro fails to access the
         element the element access returned is emptiness and not a tuple. 
         
         If BOOST_VMD_RETURN_NO_TYPE, the default, is specified no type is returned 
         as part of the element accessed. 
         
         If BOOST_VMD_RETURN_TYPE is specified the specific type of the element
         is returned in the tuple. 
         
         If BOOST_VMD_RETURN_TYPE_ARRAY is specified
         an array type is returned if the element is an array, else a tuple
         type is returned if the element is a tuple, else the actual type
         is returned for non-tuple data. 
         
         If BOOST_VMD_RETURN_TYPE_LIST is specified
         a list type is returned if the element is a list, else a tuple
         type is returned if the element is a tuple, else the actual type
         is returned for non-tuple data. 
         
         If BOOST_VMD_RETURN_TYPE_TUPLE is specified
         a tuple type is returned for all tuple-like data, else the actual type
         is returned for non-tuple data. 
         
         If more than one return type optional
         parameter is specified the last one specified determines the return type.
         
         If a filter is specified optional return type parameters are ignored and
         the default BOOST_VMD_RETURN_NO_TYPE is in effect.
         
 Index:  If the filter is specified as the identifier type, BOOST_VMD_TYPE_IDENTIFIER,
         and matching identifiers are specified, an index parameter specifies that the
         numeric index, starting with 0, of the matching identifier found, be returned
         as part of the result. 
         
         If BOOST_VMD_RETURN_INDEX is specified an index is returned
         as part of the result. 
         
         If BOOST_VMD_RETURN_NO_INDEX, the default, is specified
         no index is returned as part of the result. 
         
         If both are specified the last one specified determines the index parameter. 
         
         When an index is returned as part of the result, the result is a tuple where the 
         element accessed is the first tuple parameter and the index is the last tuple parameter. 
         If element access fails the index is empty. If there is no BOOST_VMD_TYPE_IDENTIFIER 
         filter or if there are no matching identifiers the BOOST_VMD_RETURN_INDEX is ignored 
         and no index is returned as part of the result.
</programlisting></para><para>returns = With no optional parameters the element accessed is returned, or emptiness if element is outside the bounds of the sequence. Filters and matching identifiers can change the meaning of whether the element accessed is returned or failure occurs, but whenever failure occurs emptiness is returned as the element access part of that failure, else the element accessed is returned. Return type optional parameters, when filters are not used, return the element accessed as a two-element tuple where the first tuple element is the type and the second tuple element is the data; if the element is not accessed then emptiness is returned as the element access and not a tuple. Splitting with BOOST_VMD_RETURN_AFTER returns a tuple where the element accessed is the first tuple element and the rest of the sequence is the second tuple element. Splitting with BOOST_VMD_RETURN_ONLY_AFTER returns the rest of the sequence after the element accessed or emptiness if the element can not be accessed. Indexing returns the index as part of the output only if filtering with BOOST_VMD_TYPE_IDENTIFIER is specified and matching identifiers are specified. When the index is returned with BOOST_VMD_RETURN_AFTER it is the third element of the tuple returned, else it is the second element of a tuple where the element accessed is the first element of the tuple. </para></description></macro>
<macro name="BOOST_VMD_ELEM_D" kind="functionlike"><macro-parameter name="d"/><macro-parameter name="elem"/><macro-parameter name="..."/><purpose>Accesses an element of a sequence. Re-entrant version. </purpose><description><para>d = The next available BOOST_PP_WHILE iteration. <sbr/>
 elem = A sequence element number. From 0 to sequence size - 1. <sbr/>
 ... = Variadic parameters.</para><para>The first variadic parameter is required and is the sequence to access. Further variadic parameters are all optional.</para><para>With no further variadic parameters the macro returns the particular element in the sequence. If the element number is outside the bounds of the sequence macro access fails and the macro turns emptiness.</para><para>Optional parameters determine what it means that an element is successfully accessed as well as what data is returned by the macro.</para><para>Filters: specifying a VMD type tells the macro to return the element only if it is of the VMD type specified, else macro access fails. If more than one VMD type is specified as an optional parameter the last one specified is the filter.</para><para>Matching Identifiers: If the filter is specified as the identifier type, BOOST_VMD_TYPE_IDENTIFIER, optional parameters which are identifiers specify that the element accessed must match one of the identifiers else access fails. The identifiers may be specified multiple times as single optional parameters or once as a tuple of identifier parameters. If the identifiers are specified as single optional parameters they cannot be any of the specific BOOST_VMD_ optional parameters in order to be recognized as matching identifiers. Normally this should never be the case. The only situation where this could occur is if the VMD types, which are filters, are used as matching identifiers; in this case the matching identifiers need to be passed as a tuple of identifier parameters so they are not treated as filters.</para><para>Filters and matching identifiers change what it means that an element is successfully accessed. They do not change what data is returned by the macro. The remaining optional parameters do not change what it means that an element is successfully accessed but they do change what data is returned by the macro.</para><para><programlisting language="c++">Splitting: Splitting allows the macro to return the rest of the sequence
         after the element accessed.

         If BOOST_VMD_RETURN_AFTER is specified the return is a tuple
         with the element accessed as the first tuple parameter and the rest of
         the sequence as the second tuple parameter. If element access fails 
         both tuple parameters are empty. 
         
         If BOOST_VMD_RETURN_ONLY_AFTER
         is specified the return is the rest of the sequence after the element accessed
         found. If the element access fails the return is emptiness. 
         
         If BOOST_VMD_RETURN_NO_AFTER, the default, is specified no splitting
         occurs. 
         
         If more than one of the splitting identifiers are specified
         the last one specified determines the splitting.
         
 Return Type: The element accessed can be changed to return both the type
         of the element as well as the element data with optional return type 
         parameters. When a type is returned, the element accessed which is returned becomes a
         two-element tuple where the type of the element accessed is the first tuple element and the element
         data itself is the second tuple element. If the macro fails to access the
         element the element access returned is emptiness and not a tuple. 
         
         If BOOST_VMD_RETURN_NO_TYPE, the default, is specified no type is returned 
         as part of the element accessed. 
         
         If BOOST_VMD_RETURN_TYPE is specified the specific type of the element
         is returned in the tuple. 
         
         If BOOST_VMD_RETURN_TYPE_ARRAY is specified
         an array type is returned if the element is an array, else a tuple
         type is returned if the element is a tuple, else the actual type
         is returned for non-tuple data. 
         
         If BOOST_VMD_RETURN_TYPE_LIST is specified
         a list type is returned if the element is a list, else a tuple
         type is returned if the element is a tuple, else the actual type
         is returned for non-tuple data. 
         
         If BOOST_VMD_RETURN_TYPE_TUPLE is specified
         a tuple type is returned for all tuple-like data, else the actual type
         is returned for non-tuple data. If more than one return type optional
         parameter is specified the last one specified determines the return type.
         
         If a filter is specified optional return type parameters are ignored and
         the default BOOST_VMD_RETURN_NO_TYPE is in effect.
         
 Index:  If the filter is specified as the identifier type, BOOST_VMD_TYPE_IDENTIFIER,
         and matching identifiers are specified, an index parameter specifies that the
         numeric index, starting with 0, of the matching identifier found, be returned
         as part of the result. 
         
         If BOOST_VMD_RETURN_INDEX is specified an index is returned
         as part of the result. 
         
         If BOOST_VMD_RETURN_NO_INDEX, the default, is specified
         no index is returned as part of the result. 
         
         If both are specified the last one specified determines the index parameter. 
         
         When an index is returned as part of the result, the result is a tuple where the 
         element accessed is the first tuple parameter and the index is the last tuple parameter. 
         If element access fails the index is empty. If there is no BOOST_VMD_TYPE_IDENTIFIER 
         filter or if there are no matching identifiers the BOOST_VMD_RETURN_INDEX is ignored 
         and no index is returned as part of the result.
</programlisting></para><para>returns = With no optional parameters the element accessed is returned, or emptiness if element is outside the bounds of the sequence. Filters and matching identifiers can change the meaning of whether the element accessed is returned or failure occurs, but whenever failure occurs emptiness is returned as the element access part of that failure, else the element accessed is returned. Return type optional parameters, when filters are not used, return the element accessed as a two-element tuple where the first tuple element is the type and the second tuple element is the data; if the element is not accessed then emptiness is returned as the element access and not a tuple. Splitting with BOOST_VMD_RETURN_AFTER returns a tuple where the element accessed is the first tuple element and the rest of the sequence is the second tuple element. Splitting with BOOST_VMD_RETURN_ONLY_AFTER returns the rest of the sequence after the element accessed or emptiness if the element can not be accessed. Indexing returns the index as part of the output only if filtering with BOOST_VMD_TYPE_IDENTIFIER is specified and matching identifiers are specified. When the index is returned with BOOST_VMD_RETURN_AFTER it is the third element of the tuple returned, else it is the second element of a tuple where the element accessed is the first element of the tuple. </para></description></macro>
</header>
<header name="boost/vmd/empty.hpp">
<macro name="BOOST_VMD_EMPTY" kind="functionlike"><macro-parameter name="..."/><purpose>Outputs emptiness. </purpose><description><para>... = any variadic parameters. The parameters are ignored.</para><para>This macro is used to output emptiness ( nothing ) no matter what is passed to it.</para><para>If you use this macro to return a result, as in 'result BOOST_VMD_EMPTY' subsequently invoked, you should surround the result with BOOST_VMD_IDENTITY_RESULT to smooth over a VC++ problem. </para></description></macro>
</header>
<header name="boost/vmd/enum.hpp">
<macro name="BOOST_VMD_ENUM" kind="functionlike"><macro-parameter name="..."/><purpose>Converts a sequence to comma-separated elements which are the elements of the sequence. </purpose><description><para>... = Variadic parameters.</para><para>The first variadic parameter is required and is the sequence to convert.</para><para>Further optional variadic parameters can be return type parameters. Return type parameters allow each element in the sequence to be converted to a two-element tuple where the first tuple element is the type and the second tuple element is the element data.</para><para>The BOOST_VMD_RETURN_NO_TYPE, the default, does not return the type as part of each converted element but just the data. All of the rest return the type and data as the two-element tuple. If BOOST_VMD_RETURN_TYPE is specified the specific type of the element is returned in the tuple. If BOOST_VMD_RETURN_TYPE_ARRAY is specified an array type is returned if the element is an array, else a tuple type is returned if the element is a tuple, else the actual type is returned for non-tuple data. If BOOST_VMD_RETURN_TYPE_LIST is specified a list type is returned if the element is a list, else a tuple type is returned if the element is a tuple, else the actual type is returned for non-tuple data. If BOOST_VMD_RETURN_TYPE_TUPLE is specified a tuple type is returned for all tuple-like data, else the actual type is returned for non-tuple data. If more than one return type optional parameter is specified the last one specified determines the return type.</para><para>returns = Comma-separated data, otherwise known as variadic data. If the sequence is empty the variadic data is empty. If an optional return type other than BOOST_VMD_RETURN_NO_TYPE is specified the type and the data of each element is returned as part of the variadic data. Otherwise just the data of each element is returned, which is the default. </para></description></macro>
<macro name="BOOST_VMD_ENUM_D" kind="functionlike"><macro-parameter name="d"/><macro-parameter name="..."/><purpose>Converts a sequence to comma-separated elements which are the elements of the sequence. Re-entrant version. </purpose><description><para>d = The next available BOOST_PP_WHILE iteration. <sbr/>
 ... = Variadic parameters.</para><para>The first variadic parameter is required and is the sequence to convert.</para><para>Further optional variadic parameters can be return type parameters. Return type parameters allow each element in the sequence to be converted to a two-element tuple where the first tuple element is the type and the second tuple element is the element data.</para><para>The BOOST_VMD_RETURN_NO_TYPE, the default, does not return the type as part of each converted element but just the data. All of the rest return the type and data as the two-element tuple. If BOOST_VMD_RETURN_TYPE is specified the specific type of the element is returned in the tuple. If BOOST_VMD_RETURN_TYPE_ARRAY is specified an array type is returned if the element is an array, else a tuple type is returned if the element is a tuple, else the actual type is returned for non-tuple data. If BOOST_VMD_RETURN_TYPE_LIST is specified a list type is returned if the element is a list, else a tuple type is returned if the element is a tuple, else the actual type is returned for non-tuple data. If BOOST_VMD_RETURN_TYPE_TUPLE is specified a tuple type is returned for all tuple-like data, else the actual type is returned for non-tuple data. If more than one return type optional parameter is specified the last one specified determines the return type.</para><para>returns = Comma-separated data, otherwise known as variadic data. If the sequence is empty the variadic data is empty. If an optional return type other than BOOST_VMD_RETURN_NO_TYPE is specified the type and the data of each element is returned as part of the variadic data. Otherwise just the data of each element is returned, which is the default. </para></description></macro>
</header>
<header name="boost/vmd/equal.hpp">
<macro name="BOOST_VMD_EQUAL" kind="functionlike"><macro-parameter name="sequence"/><macro-parameter name="..."/><purpose>Tests any two sequences for equality. </purpose><description><para>sequence = First sequence. <sbr/>
 ... = variadic parameters, maximum of 2.</para><para>The first variadic parameter is required and is the second sequence to test. The optional second variadic parameter is a VMD type as a filter.</para><para>The macro tests any two sequences for equality. For sequences to be equal the VMD types of each sequence must be equal and the individual elements of the sequence must be equal. For Boost PP composite types the macro tests that the composite types have the same size and then tests that each element of the composite type is equal. This means that all elements of a composite type must be a VMD type in order to use this macro successfully.</para><para>The single optional parameter is a filter. The filter is a VMD type which specifies that both sequences to test must be of that VMD type, as well as being equal to each other, for the test to succeed.</para><para>returns = 1 upon success or 0 upon failure. Success means that both sequences are equal and, if the optional parameter is specified, that the sequences are of the optional VMD type. </para></description></macro>
<macro name="BOOST_VMD_EQUAL_D" kind="functionlike"><macro-parameter name="d"/><macro-parameter name="sequence"/><macro-parameter name="..."/><purpose>Tests any two sequences for equality. Re-entrant version. </purpose><description><para>d = The next available BOOST_PP_WHILE iteration. <sbr/>
 sequence = First sequence. <sbr/>
 ... = variadic parameters, maximum of 2.</para><para>The first variadic parameter is required and is the second sequence to test. The optional second variadic parameter is a VMD type as a filter.</para><para>The macro tests any two sequences for equality. For sequences to be equal the VMD types of each sequence must be equal and the individual elements of the sequence must be equal. For Boost PP composite types the macro tests that the composite types have the same size and then tests that each element of the composite type is equal. This means that all elements of a composite type must be a VMD type in order to use this macro successfully.</para><para>The single optional parameter is a filter. The filter is a VMD type which specifies that both sequences to test must be of that VMD type, as well as being equal to each other, for the test to succeed.</para><para>returns = 1 upon success or 0 upon failure. Success means that both sequences are equal and, if the optional parameter is specified, that the sequences are of the optional VMD type. </para></description></macro>
</header>
<header name="boost/vmd/get_type.hpp">
<macro name="BOOST_VMD_GET_TYPE" kind="functionlike"><macro-parameter name="..."/><purpose>Returns the type of a sequence as a VMD type. </purpose><description><para>... = variadic parameters.</para><para>The first variadic parameter is required and is the sequence whose type we are getting.</para><para>The optional variadic parameters are return type parameters.</para><para>The macro returns the type of a sequence as a VMD type. The type of an empty sequence is always BOOST_VMD_TYPE_EMPTY and the type of a multi-element is always BOOST_VMD_TYPE_SEQUENCE. The type of a single-element sequence is the type of that single element.</para><para>The type returned can be modified by specifying an optional return type parameter.</para><para>If BOOST_VMD_RETURN_TYPE, the default, is specified the specific type of the element is returned.</para><para>If BOOST_VMD_RETURN_TYPE_ARRAY is specified an array type is returned if the element is an array, else a tuple type is returned if the element is a tuple, else the actual type is returned for non-tuple data.</para><para>If BOOST_VMD_RETURN_TYPE_LIST is specified a list type is returned if the element is a list, else a tuple type is returned if the element is a tuple, else the actual type is returned for non-tuple data.</para><para>If BOOST_VMD_RETURN_TYPE_TUPLE is specified a tuple type is returned for all tuple-like data, else the actual type is returned for non-tuple data.</para><para>If BOOST_VMD_RETURN_NO_TYPE is specified it is ignored since the macro always returns the type of the sequence.</para><para>If more than one return type optional parameter is specified the last one specified determines the return type.</para><para>returns = the type of the sequence as a VMD type. </para></description></macro>
<macro name="BOOST_VMD_GET_TYPE_D" kind="functionlike"><macro-parameter name="d"/><macro-parameter name="..."/><purpose>Returns the type of a sequence as a VMD type. Re-entrant version. </purpose><description><para>d = The next available BOOST_PP_WHILE iteration. <sbr/>
 ... = variadic parameters.</para><para>The first variadic parameter is required and is the sequence whose type we are getting.</para><para>The optional variadic parameters are return type parameters.</para><para>The macro returns the type of a sequence as a VMD type. The type of an empty sequence is always BOOST_VMD_TYPE_EMPTY and the type of a multi-element is always BOOST_VMD_TYPE_SEQUENCE. The type of a single-element sequence is the type of that single element.</para><para>The type returned can be modified by specifying an optional return type parameter.</para><para>If BOOST_VMD_RETURN_TYPE, the default, is specified the specific type of the element is returned.</para><para>If BOOST_VMD_RETURN_TYPE_ARRAY is specified an array type is returned if the element is an array, else a tuple type is returned if the element is a tuple, else the actual type is returned for non-tuple data.</para><para>If BOOST_VMD_RETURN_TYPE_LIST is specified a list type is returned if the element is a list, else a tuple type is returned if the element is a tuple, else the actual type is returned for non-tuple data.</para><para>If BOOST_VMD_RETURN_TYPE_TUPLE is specified a tuple type is returned for all tuple-like data, else the actual type is returned for non-tuple data.</para><para>If BOOST_VMD_RETURN_NO_TYPE is specified it is ignored since the macro always returns the type of the sequence.</para><para>If more than one return type optional parameter is specified the last one specified determines the return type.</para><para>returns = the type of the sequence as a VMD type. </para></description></macro>
</header>
<header name="boost/vmd/identity.hpp">
<macro name="BOOST_VMD_IDENTITY" kind="functionlike"><macro-parameter name="item"/><purpose>Macro which expands to its argument when invoked with any number of parameters. </purpose><description><para>item = any single argument</para><para>When BOOST_VMD_IDENTITY(item) is subsequently invoked with any number of parameters it expands to 'item'. Subsequently invoking the macro is done as 'BOOST_VMD_IDENTITY(item)(zero_or_more_arguments)'.</para><para>The macro is equivalent to the Boost PP macro BOOST_PP_IDENTITY(item) with the difference being that BOOST_PP_IDENTITY(item) is always invoked with no arguments, as in 'BOOST_VMD_IDENTITY(item)()' whereas BOOST_VMD_IDENTITY can be invoked with any number of arguments.</para><para>The macro is meant to be used in BOOST_PP_IF and BOOST_PP_IIF statements when only one of the clauses needs to be invoked with calling another macro and the other is meant to return an 'item'.</para><para>returns = the macro as 'BOOST_VMD_IDENTITY(item)', when invoked with any number of parameters as in '(zero_or_more_arguments)', returns 'item'. The macro itself returns 'item BOOST_VMD_EMPTY'. </para></description></macro>
<macro name="BOOST_VMD_IDENTITY_RESULT" kind="functionlike"><macro-parameter name="result"/><purpose>Macro which wraps any result which can return its value using BOOST_VMD_IDENTITY or 'item BOOST_VMD_EMPTY'. </purpose><description><para>result = any single result returned when BOOST_VMD_IDENTITY is used or 'item BOOST_VMD_EMPTY'.</para><para>The reason for this macro is to smooth over a problem when using VC++ with BOOST_VMD_IDENTITY. If your BOOST_VMD_IDENTITY macro can be used where VC++ is the compiler then you need to surround your macro code which could return a result with this macro in order that VC++ handles BOOST_VMD_IDENTITY correctly.</para><para>If you are not using VC++ you do not have to use this macro, but doing so does no harm. </para></description></macro>
</header>
<header name="boost/vmd/is_array.hpp">
<macro name="BOOST_VMD_IS_ARRAY" kind="functionlike"><macro-parameter name="sequence"/><purpose>Determines if a sequence is a Boost PP array. </purpose><description><para>The macro checks that the sequence is a Boost PP array. It returns 1 if it is an array, else if returns 0.</para><para>sequence = a possible Boost PP array.</para><para>returns = 1 if it is an array, else returns 0.</para><para>The macro will generate a preprocessing error if the input is in the form of an array but its first tuple element, instead of being a number, is a preprocessor token which VMD cannot parse, as in the example '(&amp;2,(0,1))' which is a valid tuple but an invalid array. </para></description></macro>
<macro name="BOOST_VMD_IS_ARRAY_D" kind="functionlike"><macro-parameter name="d"/><macro-parameter name="sequence"/><purpose>Determines if a sequence is a Boost PP array. Re-entrant version. </purpose><description><para>The macro checks that the sequence is a Boost PP array. It returns 1 if it is an array, else if returns 0.</para><para>d = The next available BOOST_PP_WHILE iteration. <sbr/>
 sequence = a possible Boost PP array.</para><para>returns = 1 if it is an array, else returns 0.</para><para>The macro will generate a preprocessing error if the input is in the form of an array but its first tuple element, instead of being a number, is a preprocessor token which VMD cannot parse, as in the example '(&amp;2,(0,1))' which is a valid tuple but an invalid array. </para></description></macro>
</header>
<header name="boost/vmd/is_empty.hpp">
<macro name="BOOST_VMD_IS_EMPTY" kind="functionlike"><macro-parameter name="..."/><purpose>Tests whether its input is empty or not. </purpose><description><para>The macro checks to see if the input is empty or not. It returns 1 if the input is empty, else returns 0.</para><para>The macro is a variadic macro taking any input. For the VC++8 compiler (VS2005) the macro takes a single parameter of input to check.</para><para>For all levels of C++ prior to C++20 the macro is not perfect, and can not be so. The problem area is if the input to be checked is a function-like macro name, in which case either a compiler error can result or a false result can occur.</para><para>For C++20, with its support for the new <emphasis role="bold">VA_OPT</emphasis> preprocessor construct, the macro will always work correctly no matter what the variadic input, and is therefore 100% reliable.</para><para>This macro is a replacement, using variadic macro support, for the undocumented macro BOOST_PP_IS_EMPTY in the Boost PP library. The code is taken from a posting by Paul Mensonides of a variadic version for BOOST_PP_IS_EMPTY, and changed in order to also support VC++. The code for the C++20 implementation of the macro, using the <emphasis role="bold">VA_OPT</emphasis> preprocessor construct, is the author's own and reuses code added to the Boost preprocessor library by this author.</para><para>... = variadic input, for VC++8 this must be a single parameter</para><para>returns = 1 if the input is empty, 0 if it is not</para><para>It is recommended to append BOOST_PP_EMPTY() to whatever input is being tested in order to avoid possible warning messages from some compilers about no parameters being passed to the macro when the input is truly empty. </para></description></macro>
<macro name="BOOST_VMD_IS_EMPTY_NO_OPT" kind="functionlike"><macro-parameter name="..."/></macro>
</header>
<header name="boost/vmd/is_empty_array.hpp">
<macro name="BOOST_VMD_IS_EMPTY_ARRAY" kind="functionlike"><macro-parameter name="sequence"/><purpose>Tests whether a sequence is an empty Boost PP array. </purpose><description><para>An empty Boost PP array is a two element tuple where the first size element is 0 and the second element is a tuple with a single empty element, ie. '(0,())'.</para><para>sequence = a possible empty array</para><para>returns = 1 if the sequence is an empty Boost PP array, 0 if it is not.</para><para>The macro will generate a preprocessing error if the sequence is in the form of an array but its first tuple element, instead of being a number, is a preprocessor token which VMD cannot parse, as in the example '(&amp;0,())' which is a valid tuple but an invalid array. </para></description></macro>
<macro name="BOOST_VMD_IS_EMPTY_ARRAY_D" kind="functionlike"><macro-parameter name="d"/><macro-parameter name="sequence"/><purpose>Tests whether a sequence is an empty Boost PP array. Re-entrant version. </purpose><description><para>An empty Boost PP array is a two element tuple where the first size element is 0 and the second element is a tuple with a single empty element, ie. '(0,())'.</para><para>d = The next available BOOST_PP_WHILE iteration. <sbr/>
 sequence = a possible empty array</para><para>returns = 1 if the sequence is an empty Boost PP array, 0 if it is not.</para><para>The macro will generate a preprocessing error if the sequence is in the form of an array but its first tuple element, instead of being a number, is a preprocessor token which VMD cannot parse, as in the example '(&amp;0,())' which is a valid tuple but an invalid array. </para></description></macro>
</header>
<header name="boost/vmd/is_empty_list.hpp">
<macro name="BOOST_VMD_IS_EMPTY_LIST" kind="functionlike"><macro-parameter name="sequence"/><purpose>Tests whether a sequence is an empty Boost PP list. </purpose><description><para>An empty Boost PP list consists of the single identifier 'BOOST_PP_NIL'. This identifier also serves as a list terminator for a non-empty list.</para><para>sequence = a preprocessor parameter</para><para>returns = 1 if the sequence is an empty Boost PP list, 0 if it is not.</para><para>The macro will generate a preprocessing error if the input as an empty list marker, instead of being an identifier, is a preprocessor token which VMD cannot parse, as in the example '&amp;BOOST_PP_NIL'. </para></description></macro>
<macro name="BOOST_VMD_IS_EMPTY_LIST_D" kind="functionlike"><macro-parameter name="d"/><macro-parameter name="sequence"/><purpose>Tests whether a sequence is an empty Boost PP list. Re-entrant version. </purpose><description><para>An empty Boost PP list consists of the single identifier 'BOOST_PP_NIL'. This identifier also serves as a list terminator for a non-empty list.</para><para>d = The next available BOOST_PP_WHILE iteration <sbr/>
 sequence = a preprocessor parameter</para><para>returns = 1 if the sequence is an empty Boost PP list, 0 if it is not.</para><para>The macro will generate a preprocessing error if the input as an empty list marker, instead of being an identifier, is a preprocessor token which VMD cannot parse, as in the example '&amp;BOOST_PP_NIL'. </para></description></macro>
</header>
<header name="boost/vmd/is_general_identifier.hpp">
<macro name="BOOST_VMD_IS_GENERAL_IDENTIFIER" kind="functionlike"><macro-parameter name="..."/><purpose>Tests whether a parameter is a general identifier. </purpose><description><para>... = variadic parameters</para><para>The first variadic parameter is required and it is the input to test.</para><para>Passing more than one variadic argument is an error.</para><para><programlisting language="c++">returns   = 1 if the parameter is any general identifier and only a single variadic argument is given, otherwise 0.
</programlisting></para><para>The argument to the macro should be a single possible identifier and not a VMD sequence of preprocessor tokens.</para><para>If the input is not a VMD data type this macro could lead to a preprocessor error. This is because the macro uses preprocessor concatenation to determine if the input is an identifier once it is determined that the input is not empty and does not start with parenthesis. If the data being concatenated would lead to an invalid preprocessor token the compiler can issue a preprocessor error. </para></description></macro>
</header>
<header name="boost/vmd/is_identifier.hpp">
<macro name="BOOST_VMD_IS_IDENTIFIER" kind="functionlike"><macro-parameter name="..."/><purpose>Tests whether a parameter is an identifier. </purpose><description><para>... = variadic parameters</para><para>The first variadic parameter is required and it is the input to test.</para><para>Further variadic parameters are optional and are identifiers to match. The data may take one of two forms; it is either one or more single identifiers or a single Boost PP tuple of identifiers.</para><para><programlisting language="c++">returns   = 1 if the parameter is an identifier, otherwise 0.
            
            If the parameter is not an identifier, 
            or if optional identifiers are specified and the identifier
            does not match any of the optional identifiers, the macro returns 0.
</programlisting></para><para>Identifiers are registered in VMD with:</para><para><programlisting language="c++">#define BOOST_VMD_REG_XXX (XXX) where XXX is a v-identifier.
</programlisting></para><para>The identifier must be registered to be found.</para><para>Identifiers are pre-detected in VMD with:</para><para><programlisting language="c++">#define BOOST_VMD_DETECT_XXX_XXX where XXX is an identifier.
</programlisting></para><para>If you specify optional identifiers and have not specified the detection of an optional identifier, that optional identifier will never match the input.</para><para>If the input is not a VMD data type this macro could lead to a preprocessor error. This is because the macro uses preprocessor concatenation to determine if the input is an identifier once it is determined that the input does not start with parenthesis. If the data being concatenated would lead to an invalid preprocessor token the compiler can issue a preprocessor error. </para></description></macro>
<macro name="BOOST_VMD_IS_IDENTIFIER_D" kind="functionlike"><macro-parameter name="d"/><macro-parameter name="..."/><purpose>Tests whether a parameter is an identifier. Re-entrant version. </purpose><description><para>d = The next available BOOST_PP_WHILE iteration. <sbr/>
 ... = variadic parameters</para><para>The first variadic parameter is required and it is the input to test.</para><para>Further variadic parameters are optional and are identifiers to match. The data may take one of two forms; it is either one or more single identifiers or a single Boost PP tuple of identifiers.</para><para><programlisting language="c++">returns   = 1 if the parameter is an identifier, otherwise 0.
            
            If the parameter is not an identifier, 
            or if optional identifiers are specified and the identifier
            does not match any of the optional identifiers, the macro returns 0.
</programlisting></para><para>Identifiers are registered in VMD with:</para><para><programlisting language="c++">#define BOOST_VMD_REG_XXX (XXX) where XXX is a v-identifier.
</programlisting></para><para>The identifier must be registered to be found.</para><para>Identifiers are pre-detected in VMD with:</para><para><programlisting language="c++">#define BOOST_VMD_DETECT_XXX_XXX where XXX is an identifier.
</programlisting></para><para>If you specify optional identifiers and have not specified the detection of an optional identifier, that optional identifier will never match the input.</para><para>If the input is not a VMD data type this macro could lead to a preprocessor error. This is because the macro uses preprocessor concatenation to determine if the input is an identifier once it is determined that the input does not start with parenthesis. If the data being concatenated would lead to an invalid preprocessor token the compiler can issue a preprocessor error. </para></description></macro>
</header>
<header name="boost/vmd/is_list.hpp">
<macro name="BOOST_VMD_IS_LIST" kind="functionlike"><macro-parameter name="sequence"/><purpose>Determines if a sequence is a Boost pplib list. </purpose><description><para>The macro checks that the sequence is a pplib list. It returns 1 if it is a list, else if returns 0.</para><para>sequence = input as a possible Boost PP list.</para><para>returns = 1 if it a list, else returns 0.</para><para>The macro will generate a preprocessing error if the input is in the form of a list but its end-of-list marker, instead of being an identifier, is a preprocessor token which VMD cannot parse, as in the example '(anything,&amp;BOOST_PP_NIL)' which is a valid tuple but an invalid list. </para></description></macro>
<macro name="BOOST_VMD_IS_LIST_D" kind="functionlike"><macro-parameter name="d"/><macro-parameter name="sequence"/><purpose>Determines if a sequence is a Boost pplib list. Re-entrant version. </purpose><description><para>The macro checks that the sequence is a pplib list. It returns 1 if it is a list, else if returns 0.</para><para>d = The next available BOOST_PP_WHILE iteration. <sbr/>
 sequence = input as a possible Boost PP list.</para><para>returns = 1 if it a list, else returns 0.</para><para>The macro will generate a preprocessing error if the input is in the form of a list but its end-of-list marker, instead of being an identifier, is a preprocessor token which VMD cannot parse, as in the example '(anything,&amp;BOOST_PP_NIL)' which is a valid tuple but an invalid list. </para></description></macro>
</header>
<header name="boost/vmd/is_multi.hpp">
<macro name="BOOST_VMD_IS_MULTI" kind="functionlike"><macro-parameter name="sequence"/><purpose>Determines if the sequence has more than one element, referred to as a multi-element sequence. </purpose><description><para>sequence = a sequence</para><para>returns = 1 if the sequence is a multi-element sequence, else returns 0.</para><para>If the size of a sequence is known it is faster comparing that size to be greater than one to find out if the sequence is multi-element. But if the size of the sequence is not known it is faster calling this macro than getting the size and doing the previously mentioned comparison in order to determine if the sequence is multi-element or not. </para></description></macro>
<macro name="BOOST_VMD_IS_MULTI_D" kind="functionlike"><macro-parameter name="d"/><macro-parameter name="sequence"/><purpose>Determines if the sequence has more than one element, referred to as a multi-element sequence. </purpose><description><para>d = The next available BOOST_PP_WHILE iteration. <sbr/>
 sequence = a sequence</para><para>returns = 1 if the sequence is a multi-element sequence, else returns 0.</para><para>If the size of a sequence is known it is faster comparing that size to be greater than one to find out if the sequence is multi-element. But if the size of the sequence is not known it is faster calling this macro than getting the size and doing the previously mentioned comparison in order to determine if the sequence is multi-element or not. </para></description></macro>
</header>
<header name="boost/vmd/is_number.hpp">
<macro name="BOOST_VMD_IS_NUMBER" kind="functionlike"><macro-parameter name="sequence"/><purpose>Tests whether a sequence is a Boost PP number. </purpose><description><para>The macro checks to see if a sequence is a Boost PP number. A Boost PP number is a value from 0 to BOOST_PP_LIMIT_MAG.</para><para>sequence = a possible number</para><para>returns = 1 if the sequence is a Boost PP number, 0 if it is not.</para><para>If the input is not a VMD data type this macro could lead to a preprocessor error. This is because the macro uses preprocessor concatenation to determine if the input is a number once it is determined that the input does not start with parenthesis. If the data being concatenated would lead to an invalid preprocessor token the compiler can issue a preprocessor error. </para></description></macro>
</header>
<header name="boost/vmd/is_parens_empty.hpp">
<macro name="BOOST_VMD_IS_PARENS_EMPTY" kind="functionlike"><macro-parameter name="sequence"/><purpose>Determines if the sequence is a set of parens with no data. </purpose><description><para>sequence = a VMD sequence</para><para>returns = 1 if the sequence is a set of parens with no data, else returns 0.</para><para><programlisting language="c++">A set of parens with no data may be:

1) a tuple whose size is a single element which is empty

            or
            
2) a single element seq whose data is empty
</programlisting> </para></description></macro>
<macro name="BOOST_VMD_IS_PARENS_EMPTY_D" kind="functionlike"><macro-parameter name="d"/><macro-parameter name="sequence"/><purpose>Determines if the sequence is a set of parens with no data. Re-entrant version. </purpose><description><para>d = The next available BOOST_PP_WHILE iteration. <sbr/>
 sequence = a VMD sequence</para><para>returns = 1 if the sequence is a set of parens with no data, else returns 0.</para><para><programlisting language="c++">A set of parens with no data may be:

1) a tuple whose size is a single element which is empty

            or
            
2) a single element seq whose data is empty
</programlisting> </para></description></macro>
</header>
<header name="boost/vmd/is_seq.hpp">
<macro name="BOOST_VMD_IS_SEQ" kind="functionlike"><macro-parameter name="sequence"/><purpose>Determines if a sequence is a Boost PP seq. </purpose><description><para>The macro checks that the sequence is a Boost PP seq. It returns 1 if it is a seq, else if returns 0.</para><para>sequence = a possible Boost PP seq</para><para>returns = 1 if it a seq, else returns 0.</para><para>A single set of parentheses, with a single element, is parsed as a tuple and not a seq. To be parsed as a seq the input needs to be more than one consecutive sets of parentheses, each with a single element of data. </para></description></macro>
<macro name="BOOST_VMD_IS_SEQ_D" kind="functionlike"><macro-parameter name="d"/><macro-parameter name="sequence"/><purpose>Determines if a sequence is a Boost PP seq. Re-entrant version. </purpose><description><para>The macro checks that the sequence is a Boost PP seq. It returns 1 if it is a seq, else if returns 0.</para><para>d = The next available BOOST_PP_WHILE iteration. <sbr/>
 sequence = a possible Boost PP seq</para><para>returns = 1 if it a seq, else returns 0.</para><para>A single set of parentheses, with a single element, is parsed as a tuple and not a seq. To be parsed as a seq the input needs to be more than one consecutive sets of parentheses, each with a single element of data. </para></description></macro>
</header>
<header name="boost/vmd/is_tuple.hpp">
<macro name="BOOST_VMD_IS_TUPLE" kind="functionlike"><macro-parameter name="sequence"/><purpose>Tests whether a sequence is a Boost PP tuple. </purpose><description><para>The macro checks to see if a sequence is a Boost PP tuple. A Boost PP tuple is preprocessor tokens enclosed by a set of parentheses with no preprocessing tokens before or after the parentheses.</para><para>sequence = a possible tuple</para><para>returns = 1 if the sequence is a Boost PP tuple, 0 if it is not. </para></description></macro>
</header>
<header name="boost/vmd/is_type.hpp">
<macro name="BOOST_VMD_IS_TYPE" kind="functionlike"><macro-parameter name="sequence"/><purpose>Tests whether a sequence is a VMD type. </purpose><description><para>sequence = a possible VMD type</para><para>returns = 1 if the sequence is a VMD type, 0 if it is not.</para><para>If the sequence is not a VMD data type this macro could lead to a preprocessor error. This is because the macro uses preprocessor concatenation to determine if the sequence is an identifier once it is determined that the sequence does not start with parentheses. If the data being concatenated would lead to an invalid preprocessor token the compiler can issue a preprocessor error. </para></description></macro>
<macro name="BOOST_VMD_IS_TYPE_D" kind="functionlike"><macro-parameter name="d"/><macro-parameter name="sequence"/><purpose>Tests whether a sequence is a VMD type. Re-entrant version. </purpose><description><para>d = The next available BOOST_PP_WHILE iteration. <sbr/>
 sequence = a possible VMD type</para><para>returns = 1 if the sequence is a VMD type, 0 if it is not.</para><para>If the sequence is not a VMD data type this macro could lead to a preprocessor error. This is because the macro uses preprocessor concatenation to determine if the sequence is an identifier once it is determined that the sequence does not start with parentheses. If the data being concatenated would lead to an invalid preprocessor token the compiler can issue a preprocessor error. </para></description></macro>
</header>
<header name="boost/vmd/is_unary.hpp">
<macro name="BOOST_VMD_IS_UNARY" kind="functionlike"><macro-parameter name="sequence"/><purpose>Determines if the sequence has only a single element, referred to as a single-element sequence. </purpose><description><para>sequence = a VMD sequence</para><para>returns = 1 if the sequence is a single-element sequence, else returns 0.</para><para>If the size of a sequence is known it is faster comparing that size to be equal to one to find out if the sequence is single-element. But if the size of the sequence is not known it is faster calling this macro than getting the size and doing the previously mentioned comparison in order to determine if the sequence is single-element or not. </para></description></macro>
<macro name="BOOST_VMD_IS_UNARY_D" kind="functionlike"><macro-parameter name="d"/><macro-parameter name="sequence"/><purpose>Determines if the sequence has only a single element, referred to as a single-element sequence. Re-entrant version. </purpose><description><para>d = The next available BOOST_PP_WHILE iteration. <sbr/>
 sequence = a sequence</para><para>returns = 1 if the sequence is a single-element sequence, else returns 0.</para><para>If the size of a sequence is known it is faster comparing that size to be equal to one to find out if the sequence is single-element. But if the size of the sequence is not known it is faster calling this macro than getting the size and doing the previously mentioned comparison in order to determine if the sequence is single-element or not. </para></description></macro>
</header>
<header name="boost/vmd/not_equal.hpp">
<macro name="BOOST_VMD_NOT_EQUAL" kind="functionlike"><macro-parameter name="sequence"/><macro-parameter name="..."/><purpose>Tests any two sequences for inequality. </purpose><description><para>sequence = First sequence. <sbr/>
 ... = variadic parameters, maximum of 2.</para><para>The first variadic parameter is required and is the second sequence to test. The optional second variadic parameter is a VMD type as a filter.</para><para>The macro tests any two sequences for inequality. For sequences to be unequal either the VMD types of each sequence must be unequal or the individual elements of the sequence must be unequal.</para><para>The single optional parameter is a filter. The filter is a VMD type which specifies that both sequences to test must be of that VMD type, as well as being equal to each other, for the test to fail, else it succeeds.</para><para>returns = 1 upon success or 0 upon failure. Success means that the sequences are unequal or, if the optional parameter is specified, that the sequences are not of the optional VMD type; otherwise 0 is returned if the sequences are equal.</para><para>The macro is implemented as the complement of BOOST_VMD_EQUAL, so that whenever BOOST_VMD_EQUAL would return 1 the macro returns 0 and whenever BOOST_VMD_EQUAL would return 0 the macro would return 1. </para></description></macro>
<macro name="BOOST_VMD_NOT_EQUAL_D" kind="functionlike"><macro-parameter name="d"/><macro-parameter name="sequence"/><macro-parameter name="..."/><purpose>Tests any two sequences for inequality. Re-entrant version. </purpose><description><para>d = The next available BOOST_PP_WHILE iteration. <sbr/>
 sequence = First sequence. <sbr/>
 ... = variadic parameters, maximum of 2.</para><para>The first variadic parameter is required and is the second sequence to test. The optional second variadic parameter is a VMD type as a filter.</para><para>The macro tests any two sequences for inequality. For sequences to be unequal either the VMD types of each sequence must be unequal or the individual elements of the sequence must be unequal.</para><para>The single optional parameter is a filter. The filter is a VMD type which specifies that both sequences to test must be of that VMD type, as well as being equal to each other, for the test to fail, else it succeeds.</para><para>returns = 1 upon success or 0 upon failure. Success means that the sequences are unequal or, if the optional parameter is specified, that the sequences are not of the optional VMD type; otherwise 0 is returned if the sequences are equal.</para><para>The macro is implemented as the complement of BOOST_VMD_EQUAL, so that whenever BOOST_VMD_EQUAL would return 1 the macro returns 0 and whenever BOOST_VMD_EQUAL would return 0 the macro would return 1. </para></description></macro>
</header>
<header name="boost/vmd/seq/is_vmd_seq.hpp">
<macro name="BOOST_VMD_IS_VMD_SEQ" kind="functionlike"><macro-parameter name="sequence"/><purpose>Determines if a sequence is a VMD seq. </purpose><description><para>The macro checks that the sequence is a VMD seq. A VMD seq, which may be a Boost PP seq or emptiness, is a superset of a Boost PP seq. It returns 1 if it is a VMD seq, else if returns 0.</para><para>sequence = a possible Boost PP seq</para><para>returns = 1 if it a VMD seq, else returns 0. </para></description></macro>
</header>
<header name="boost/vmd/seq/pop_back.hpp">
<macro name="BOOST_VMD_SEQ_POP_BACK" kind="functionlike"><macro-parameter name="seq"/><purpose>pops an element from the end of a seq. </purpose><description><para>seq = seq to pop an element from.</para><para>If the seq is an empty seq the result is undefined. If the seq is a single element the result is an empty seq. Otherwise the result is a seq after removing the last element. </para></description></macro>
</header>
<header name="boost/vmd/tuple/pop_back.hpp">
<macro name="BOOST_VMD_TUPLE_POP_BACK" kind="functionlike"><macro-parameter name="tuple"/><purpose>pops an element from the end of a tuple. </purpose><description><para>tuple = tuple to pop an element from.</para><para>If the tuple is an empty tuple the result is undefined. If the tuple is a single element the result is an empty tuple. Otherwise the result is a tuple after removing the last element. </para></description></macro>
<macro name="BOOST_VMD_TUPLE_POP_BACK_Z" kind="functionlike"><macro-parameter name="z"/><macro-parameter name="tuple"/><purpose>pops an element from the end of a tuple. It reenters BOOST_PP_REPEAT with maximum efficiency. </purpose><description><para>z = the next available BOOST_PP_REPEAT dimension. <sbr/>
 tuple = tuple to pop an element from.</para><para>If the tuple is an empty tuple the result is undefined. If the tuple is a single element the result is an empty tuple. Otherwise the result is a tuple after removing the last element. </para></description></macro>
</header>
<header name="boost/vmd/seq/pop_front.hpp">
<macro name="BOOST_VMD_SEQ_POP_FRONT" kind="functionlike"><macro-parameter name="seq"/><purpose>pops an element from the front of a seq. </purpose><description><para>seq = seq to pop an element from.</para><para>If the seq is an empty seq the result is undefined. If the seq is a single element the result is an empty seq. Otherwise the result is a seq after removing the first element. </para></description></macro>
</header>
<header name="boost/vmd/tuple/pop_front.hpp">
<macro name="BOOST_VMD_TUPLE_POP_FRONT" kind="functionlike"><macro-parameter name="tuple"/><purpose>pops an element from the front of a tuple. </purpose><description><para>tuple = tuple to pop an element from.</para><para>If the tuple is an empty tuple the result is undefined. If the tuple is a single element the result is an empty tuple. Otherwise the result is a tuple after removing the first element. </para></description></macro>
<macro name="BOOST_VMD_TUPLE_POP_FRONT_Z" kind="functionlike"><macro-parameter name="z"/><macro-parameter name="tuple"/><purpose>pops an element from the front of a tuple. It reenters BOOST_PP_REPEAT with maximum efficiency. </purpose><description><para>z = the next available BOOST_PP_REPEAT dimension. <sbr/>
 tuple = tuple to pop an element from.</para><para>If the tuple is an empty tuple the result is undefined. If the tuple is a single element the result is an empty tuple. Otherwise the result is a tuple after removing the first element. </para></description></macro>
</header>
<header name="boost/vmd/seq/push_back.hpp">
<macro name="BOOST_VMD_SEQ_PUSH_BACK" kind="functionlike"><macro-parameter name="seq"/><macro-parameter name="elem"/><purpose>appends an element to the end of a seq. </purpose><description><para>seq = seq to to append an element to. <sbr/>
 elem = element to append.</para><para>If the seq is an empty seq the result is a seq with the single element. Otherwise the result is a seq after adding the element to the end. </para></description></macro>
</header>
<header name="boost/vmd/tuple/push_back.hpp">
<macro name="BOOST_VMD_TUPLE_PUSH_BACK" kind="functionlike"><macro-parameter name="tuple"/><macro-parameter name="elem"/><purpose>appends an element to the end of a tuple. </purpose><description><para>tuple = tuple to to append an element to. <sbr/>
 elem = element to append.</para><para>If the tuple is an empty tuple the result is a tuple with the single element. Otherwise the result is a tuple after adding the element to the end. </para></description></macro>
</header>
<header name="boost/vmd/seq/push_front.hpp">
<macro name="BOOST_VMD_SEQ_PUSH_FRONT" kind="functionlike"><macro-parameter name="seq"/><macro-parameter name="elem"/><purpose>inserts an element at the beginning of a seq. </purpose><description><para>seq = seq to insert an element at. <sbr/>
 elem = element to insert.</para><para>If the seq is an empty seq the result is a seq with the single element. Otherwise the result is a seq after inserting the element at the beginning. </para></description></macro>
</header>
<header name="boost/vmd/tuple/push_front.hpp">
<macro name="BOOST_VMD_TUPLE_PUSH_FRONT" kind="functionlike"><macro-parameter name="tuple"/><macro-parameter name="elem"/><purpose>inserts an element at the beginning of a tuple. </purpose><description><para>tuple = tuple to insert an element at. <sbr/>
 elem = element to insert.</para><para>If the tuple is an empty tuple the result is a tuple with the single element. Otherwise the result is a tuple after inserting the element at the beginning. </para></description></macro>
</header>
<header name="boost/vmd/seq/remove.hpp">
<macro name="BOOST_VMD_SEQ_REMOVE" kind="functionlike"><macro-parameter name="seq"/><macro-parameter name="index"/><purpose>removes an element from a seq. </purpose><description><para>seq = seq from which an element is to be removed. <sbr/>
 index = The zero-based position in seq of the element to be removed.</para><para>If index is greater or equal to the seq size the result is undefined. If the seq is a single element and the index is 0 the result is an empty seq. Otherwise the result is a seq after removing the index element. </para></description></macro>
</header>
<header name="boost/vmd/tuple/remove.hpp">
<macro name="BOOST_VMD_TUPLE_REMOVE" kind="functionlike"><macro-parameter name="tuple"/><macro-parameter name="index"/><purpose>removes an element from a tuple. </purpose><description><para>tuple = tuple from which an element is to be removed. <sbr/>
 index = The zero-based position in tuple of the element to be removed.</para><para>If index is greater or equal to the tuple size the result is undefined. If the tuple is a single element and the index is 0 the result is an empty tuple. Otherwise the result is a tuple after removing the index element. </para></description></macro>
<macro name="BOOST_VMD_TUPLE_REMOVE_D" kind="functionlike"><macro-parameter name="d"/><macro-parameter name="tuple"/><macro-parameter name="index"/><purpose>removes an element from a tuple. It reenters BOOST_PP_WHILE with maximum efficiency. </purpose><description><para>d = The next available BOOST_PP_WHILE iteration. <sbr/>
 tuple = tuple from which an element is to be removed. <sbr/>
 index = The zero-based position in tuple of the element to be removed.</para><para>If index is greater or equal to the tuple size the result is undefined. If the tuple is a single element and the index is 0 the result is an empty tuple. Otherwise the result is a tuple after removing the index element. </para></description></macro>
</header>
<header name="boost/vmd/size.hpp">
<macro name="BOOST_VMD_SIZE" kind="functionlike"><macro-parameter name="sequence"/><purpose>Returns the size of a sequence. </purpose><description><para>sequence = A sequence to test.</para><para>returns = If the sequence is empty returns 0, else returns the number of elements in the sequence. </para></description></macro>
<macro name="BOOST_VMD_SIZE_D" kind="functionlike"><macro-parameter name="d"/><macro-parameter name="sequence"/><purpose>Returns the size of a sequence. Re-entrant version. </purpose><description><para>d = The next available BOOST_PP_WHILE iteration. <sbr/>
 sequence = A sequence to test.</para><para>returns = If the sequence is empty returns 0, else returns the number of elements in the sequence. </para></description></macro>
</header>
<header name="boost/vmd/seq/size.hpp">
<macro name="BOOST_VMD_SEQ_SIZE" kind="functionlike"><macro-parameter name="seq"/><purpose>expands to the size of the seq passed to it. </purpose><description><para>seq = seq whose size is to be extracted.</para><para>If the seq is an empty seq its size is 0. Otherwise the result is the number of elements in the seq. </para></description></macro>
</header>
<header name="boost/vmd/tuple/size.hpp">
<macro name="BOOST_VMD_TUPLE_SIZE" kind="functionlike"><macro-parameter name="tuple"/><purpose>expands to the size of the tuple passed to it. </purpose><description><para>tuple = tuple whose size is to be extracted.</para><para>If the tuple is an empty tuple its size is 0. Otherwise the result is the number of elements in the tuple. </para></description></macro>
</header>
<header name="boost/vmd/to_array.hpp">
<macro name="BOOST_VMD_TO_ARRAY" kind="functionlike"><macro-parameter name="..."/><purpose>Converts a sequence to a Boost PP array whose elements are the elements of the sequence. </purpose><description><para>... = Variadic parameters.</para><para>The first variadic parameter is required and is the sequence to convert.</para><para>Further optional variadic parameters can be return type parameters. Return type parameters allow each element in the sequence to be converted to a two-element tuple where the first tuple element is the type and the second tuple element is the element data.</para><para>The BOOST_VMD_RETURN_NO_TYPE, the default, does not return the type as part of each converted element but just the data. All of the rest return the type and data as the two-element tuple. If BOOST_VMD_RETURN_TYPE is specified the specific type of the element is returned in the tuple. If BOOST_VMD_RETURN_TYPE_ARRAY is specified an array type is returned if the element is an array, else a tuple type is returned if the element is a tuple, else the actual type is returned for non-tuple data. If BOOST_VMD_RETURN_TYPE_LIST is specified a list type is returned if the element is a list, else a tuple type is returned if the element is a tuple, else the actual type is returned for non-tuple data. If BOOST_VMD_RETURN_TYPE_TUPLE is specified a tuple type is returned for all tuple-like data, else the actual type is returned for non-tuple data. If more than one return type optional parameter is specified the last one specified determines the return type.</para><para>returns = A Boost PP array. The sequence is empty the Boost PP array is an empty array. If an optional return type other than BOOST_VMD_RETURN_NO_TYPE is specified the type and the data of each element is returned as the array element. Otherwise just the data is returned as the array element, which is the default. </para></description></macro>
<macro name="BOOST_VMD_TO_ARRAY_D" kind="functionlike"><macro-parameter name="d"/><macro-parameter name="..."/><purpose>Converts a sequence to a Boost PP array whose elements are the elements of the sequence. Re-entrant version. </purpose><description><para>d = The next available BOOST_PP_WHILE iteration. <sbr/>
 ... = Variadic parameters.</para><para>The first variadic parameter is required and is the sequence to convert.</para><para>Further optional variadic parameters can be return type parameters. Return type parameters allow each element in the sequence to be converted to a two-element tuple where the first tuple element is the type and the second tuple element is the element data.</para><para>The BOOST_VMD_RETURN_NO_TYPE, the default, does not return the type as part of each converted element but just the data. All of the rest return the type and data as the two-element tuple. If BOOST_VMD_RETURN_TYPE is specified the specific type of the element is returned in the tuple. If BOOST_VMD_RETURN_TYPE_ARRAY is specified an array type is returned if the element is an array, else a tuple type is returned if the element is a tuple, else the actual type is returned for non-tuple data. If BOOST_VMD_RETURN_TYPE_LIST is specified a list type is returned if the element is a list, else a tuple type is returned if the element is a tuple, else the actual type is returned for non-tuple data. If BOOST_VMD_RETURN_TYPE_TUPLE is specified a tuple type is returned for all tuple-like data, else the actual type is returned for non-tuple data. If more than one return type optional parameter is specified the last one specified determines the return type.</para><para>returns = A Boost PP array. The sequence is empty the Boost PP array is empty. If an optional return type other than BOOST_VMD_RETURN_NO_TYPE is specified the type and the data of each element is returned as the array element. Otherwise just the data is returned as the array element, which is the default. </para></description></macro>
</header>
<header name="boost/vmd/seq/to_array.hpp">
<macro name="BOOST_VMD_SEQ_TO_ARRAY" kind="functionlike"><macro-parameter name="seq"/><purpose>converts a seq to an array. </purpose><description><para>seq = seq to be converted.</para><para>If the seq is an empty seq it is converted to an array with 0 elements. Otherwise the seq is converted to an array with the same number of elements as the seq. </para></description></macro>
</header>
<header name="boost/vmd/tuple/to_array.hpp">
<macro name="BOOST_VMD_TUPLE_TO_ARRAY" kind="functionlike"><macro-parameter name="tuple"/><purpose>converts a tuple to an array. </purpose><description><para>tuple = tuple to be converted.</para><para>If the tuple is an empty tuple it is converted to an array with 0 elements. Otherwise the tuple is converted to an array with the same number of elements as the tuple. </para></description></macro>
</header>
<header name="boost/vmd/to_list.hpp">
<macro name="BOOST_VMD_TO_LIST" kind="functionlike"><macro-parameter name="..."/><purpose>Converts a sequence to a Boost PP list whose elements are the elements of the sequence. </purpose><description><para>... = Variadic parameters.</para><para>The first variadic parameter is required and is the sequence to convert.</para><para>Further optional variadic parameters can be return type parameters. Return type parameters allow each element in the sequence to be converted to a two-element tuple where the first tuple element is the type and the second tuple element is the element data.</para><para>The BOOST_VMD_RETURN_NO_TYPE, the default, does not return the type as part of each converted element but just the data. All of the rest return the type and data as the two-element tuple. If BOOST_VMD_RETURN_TYPE is specified the specific type of the element is returned in the tuple. If BOOST_VMD_RETURN_TYPE_ARRAY is specified an array type is returned if the element is an array, else a tuple type is returned if the element is a tuple, else the actual type is returned for non-tuple data. If BOOST_VMD_RETURN_TYPE_LIST is specified a list type is returned if the element is a list, else a tuple type is returned if the element is a tuple, else the actual type is returned for non-tuple data. If BOOST_VMD_RETURN_TYPE_TUPLE is specified a tuple type is returned for all tuple-like data, else the actual type is returned for non-tuple data. If more than one return type optional parameter is specified the last one specified determines the return type.</para><para>returns = A Boost PP list. The sequence is empty the Boost PP list is an empty list. If an optional return type other than BOOST_VMD_RETURN_NO_TYPE is specified the type and the data of each element is returned as the list element. Otherwise just the data is returned as the list element, which is the default. </para></description></macro>
<macro name="BOOST_VMD_TO_LIST_D" kind="functionlike"><macro-parameter name="d"/><macro-parameter name="..."/><purpose>Converts a sequence to a Boost PP list whose elements are the elements of the sequence. Re-entrant version. </purpose><description><para>d = The next available BOOST_PP_WHILE iteration. <sbr/>
 ... = Variadic parameters.</para><para>The first variadic parameter is required and is the sequence to convert.</para><para>Further optional variadic parameters can be return type parameters. Return type parameters allow each element in the sequence to be converted to a two-element tuple where the first tuple element is the type and the second tuple element is the element data.</para><para>The BOOST_VMD_RETURN_NO_TYPE, the default, does not return the type as part of each converted element but just the data. All of the rest return the type and data as the two-element tuple. If BOOST_VMD_RETURN_TYPE is specified the specific type of the element is returned in the tuple. If BOOST_VMD_RETURN_TYPE_ARRAY is specified an array type is returned if the element is an array, else a tuple type is returned if the element is a tuple, else the actual type is returned for non-tuple data. If BOOST_VMD_RETURN_TYPE_LIST is specified a list type is returned if the element is a list, else a tuple type is returned if the element is a tuple, else the actual type is returned for non-tuple data. If BOOST_VMD_RETURN_TYPE_TUPLE is specified a tuple type is returned for all tuple-like data, else the actual type is returned for non-tuple data. If more than one return type optional parameter is specified the last one specified determines the return type.</para><para>returns = A Boost PP list. The sequence is empty the Boost PP list is an empty list. If an optional return type other than BOOST_VMD_RETURN_NO_TYPE is specified the type and the data of each element is returned as the list element. Otherwise just the data is returned as the list element, which is the default. </para></description></macro>
</header>
<header name="boost/vmd/seq/to_list.hpp">
<macro name="BOOST_VMD_SEQ_TO_LIST" kind="functionlike"><macro-parameter name="seq"/><purpose>converts a seq to a list. </purpose><description><para>seq = seq to be converted.</para><para>If the seq is an empty seq it is converted to an empty list (BOOST_PP_NIL). Otherwise the seq is converted to a list with the same number of elements as the seq. </para></description></macro>
</header>
<header name="boost/vmd/tuple/to_list.hpp">
<macro name="BOOST_VMD_TUPLE_TO_LIST" kind="functionlike"><macro-parameter name="tuple"/><purpose>converts a tuple to a list. </purpose><description><para>tuple = tuple to be converted.</para><para>If the tuple is an empty tuple it is converted to an empty list (BOOST_PP_NIL). Otherwise the tuple is converted to a list with the same number of elements as the tuple. </para></description></macro>
</header>
<header name="boost/vmd/to_seq.hpp">
<macro name="BOOST_VMD_TO_SEQ" kind="functionlike"><macro-parameter name="..."/><purpose>Converts a sequence to a Boost PP seq whose elements are the elements of the sequence. </purpose><description><para>... = Variadic parameters.</para><para>The first variadic parameter is required and is the sequence to convert.</para><para>Further optional variadic parameters can be return type parameters. Return type parameters allow each element in the sequence to be converted to a two-element tuple where the first tuple element is the type and the second tuple element is the element data.</para><para>The BOOST_VMD_RETURN_NO_TYPE, the default, does not return the type as part of each converted element but just the data. All of the rest return the type and data as the two-element tuple. If BOOST_VMD_RETURN_TYPE is specified the specific type of the element is returned in the tuple. If BOOST_VMD_RETURN_TYPE_ARRAY is specified an array type is returned if the element is an array, else a tuple type is returned if the element is a tuple, else the actual type is returned for non-tuple data. If BOOST_VMD_RETURN_TYPE_LIST is specified a list type is returned if the element is a list, else a tuple type is returned if the element is a tuple, else the actual type is returned for non-tuple data. If BOOST_VMD_RETURN_TYPE_TUPLE is specified a tuple type is returned for all tuple-like data, else the actual type is returned for non-tuple data. If more than one return type optional parameter is specified the last one specified determines the return type.</para><para>returns = A Boost PP seq. If the sequence is empty the return is emptiness since an empty seq does not exist. If an optional return type other than BOOST_VMD_RETURN_NO_TYPE is specified the type and the data of each element is returned as the seq element. Otherwise just the data is returned as the seq element, which is the default. </para></description></macro>
<macro name="BOOST_VMD_TO_SEQ_D" kind="functionlike"><macro-parameter name="d"/><macro-parameter name="..."/><purpose>Converts a sequence to a Boost PP seq whose elements are the elements of the sequence. Re-entrant version. </purpose><description><para>d = The next available BOOST_PP_WHILE iteration. <sbr/>
 ... = Variadic parameters.</para><para>The first variadic parameter is required and is the sequence to convert.</para><para>Further optional variadic parameters can be return type parameters. Return type parameters allow each element in the sequence to be converted to a two-element tuple where the first tuple element is the type and the second tuple element is the element data.</para><para>The BOOST_VMD_RETURN_NO_TYPE, the default, does not return the type as part of each converted element but just the data. All of the rest return the type and data as the two-element tuple. If BOOST_VMD_RETURN_TYPE is specified the specific type of the element is returned in the tuple. If BOOST_VMD_RETURN_TYPE_ARRAY is specified an array type is returned if the element is an array, else a tuple type is returned if the element is a tuple, else the actual type is returned for non-tuple data. If BOOST_VMD_RETURN_TYPE_LIST is specified a list type is returned if the element is a list, else a tuple type is returned if the element is a tuple, else the actual type is returned for non-tuple data. If BOOST_VMD_RETURN_TYPE_TUPLE is specified a tuple type is returned for all tuple-like data, else the actual type is returned for non-tuple data. If more than one return type optional parameter is specified the last one specified determines the return type.</para><para>returns = A Boost PP seq. If the sequence is empty the return is emptiness since an empty seq does not exist. If an optional return type other than BOOST_VMD_RETURN_NO_TYPE is specified the type and the data of each element is returned as the seq element. Otherwise just the data is returned as the seq element, which is the default. </para></description></macro>
</header>
<header name="boost/vmd/array/to_seq.hpp">
<macro name="BOOST_VMD_ARRAY_TO_SEQ" kind="functionlike"><macro-parameter name="array"/><purpose>converts an array to a seq. </purpose><description><para>array = array to be converted.</para><para>If the array is an array of 0 elements it is converted to an empty seq. Otherwise the array is converted to a seq with the same number of elements as the array. </para></description></macro>
</header>
<header name="boost/vmd/list/to_seq.hpp">
<macro name="BOOST_VMD_LIST_TO_SEQ" kind="functionlike"><macro-parameter name="list"/><purpose>converts a list to a seq. </purpose><description><para>list = list to be converted.</para><para>If the list is an empty list (BOOST_PP_NIL) it is converted to an empty seq. Otherwise the list is converted to a seq with the same number of elements as the list. </para></description></macro>
</header>
<header name="boost/vmd/tuple/to_seq.hpp">
<macro name="BOOST_VMD_TUPLE_TO_SEQ" kind="functionlike"><macro-parameter name="tuple"/><purpose>converts a tuple to a seq. </purpose><description><para>tuple = tuple to be converted.</para><para>If the tuple is an empty tuple it is converted to an empty seq. Otherwise the tuple is converted to a seq with the same number of elements as the tuple. </para></description></macro>
</header>
<header name="boost/vmd/to_tuple.hpp">
<macro name="BOOST_VMD_TO_TUPLE" kind="functionlike"><macro-parameter name="..."/><purpose>Converts a sequence to a Boost PP tuple whose elements are the elements of the sequence. </purpose><description><para>... = Variadic parameters.</para><para>The first variadic parameter is required and is the sequence to convert.</para><para>Further optional variadic parameters can be return type parameters. Return type parameters allow each element in the sequence to be converted to a two-element tuple where the first tuple element is the type and the second tuple element is the element data.</para><para>The BOOST_VMD_RETURN_NO_TYPE, the default, does not return the type as part of each converted element but just the data. All of the rest return the type and data as the two-element tuple. If BOOST_VMD_RETURN_TYPE is specified the specific type of the element is returned in the tuple. If BOOST_VMD_RETURN_TYPE_ARRAY is specified an array type is returned if the element is an array, else a tuple type is returned if the element is a tuple, else the actual type is returned for non-tuple data. If BOOST_VMD_RETURN_TYPE_LIST is specified a list type is returned if the element is a list, else a tuple type is returned if the element is a tuple, else the actual type is returned for non-tuple data. If BOOST_VMD_RETURN_TYPE_TUPLE is specified a tuple type is returned for all tuple-like data, else the actual type is returned for non-tuple data. If more than one return type optional parameter is specified the last one specified determines the return type.</para><para>returns = A Boost PP tuple. If the sequence is empty the return is emptiness since an empty tuple does not exist. If an optional return type other than BOOST_VMD_RETURN_NO_TYPE is specified the type and the data of each element is returned as the tuple element. Otherwise just the data is returned as the tuple element, which is the default. </para></description></macro>
<macro name="BOOST_VMD_TO_TUPLE_D" kind="functionlike"><macro-parameter name="d"/><macro-parameter name="..."/><purpose>Converts a sequence to a Boost PP tuple whose elements are the elements of the sequence. Re-entrant version. </purpose><description><para>d = The next available BOOST_PP_WHILE iteration. <sbr/>
 ... = Variadic parameters.</para><para>The first variadic parameter is required and is the sequence to convert.</para><para>Further optional variadic parameters can be return type parameters. Return type parameters allow each element in the sequence to be converted to a two-element tuple where the first tuple element is the type and the second tuple element is the element data.</para><para>The BOOST_VMD_RETURN_NO_TYPE, the default, does not return the type as part of each converted element but just the data. All of the rest return the type and data as the two-element tuple. If BOOST_VMD_RETURN_TYPE is specified the specific type of the element is returned in the tuple. If BOOST_VMD_RETURN_TYPE_ARRAY is specified an array type is returned if the element is an array, else a tuple type is returned if the element is a tuple, else the actual type is returned for non-tuple data. If BOOST_VMD_RETURN_TYPE_LIST is specified a list type is returned if the element is a list, else a tuple type is returned if the element is a tuple, else the actual type is returned for non-tuple data. If BOOST_VMD_RETURN_TYPE_TUPLE is specified a tuple type is returned for all tuple-like data, else the actual type is returned for non-tuple data. If more than one return type optional parameter is specified the last one specified determines the return type.</para><para>returns = A Boost PP tuple. If the sequence is empty the return is emptiness since an empty tuple does not exist. If an optional return type other than BOOST_VMD_RETURN_NO_TYPE is specified the type and the data of each element is returned as the tuple element. Otherwise just the data is returned as the tuple element, which is the default. </para></description></macro>
</header>
<header name="boost/vmd/array/to_tuple.hpp">
<macro name="BOOST_VMD_ARRAY_TO_TUPLE" kind="functionlike"><macro-parameter name="array"/><purpose>converts an array to a tuple. </purpose><description><para>array = array to be converted.</para><para>If the array is an array of 0 elements it is converted to an empty tuple. Otherwise the array is converted to a tuple with the same number of elements as the array. </para></description></macro>
</header>
<header name="boost/vmd/list/to_tuple.hpp">
<macro name="BOOST_VMD_LIST_TO_TUPLE" kind="functionlike"><macro-parameter name="list"/><purpose>converts a list to a tuple. </purpose><description><para>list = list to be converted.</para><para>If the list is an empty list (BOOST_PP_NIL) it is converted to an empty tuple. Otherwise the list is converted to a tuple with the same number of elements as the list. </para></description></macro>
</header>
<header name="boost/vmd/seq/to_tuple.hpp">
<macro name="BOOST_VMD_SEQ_TO_TUPLE" kind="functionlike"><macro-parameter name="seq"/><purpose>converts a seq to a tuple. </purpose><description><para>seq = seq to be converted.</para><para>If the seq is an empty seq it is converted to an empty tuple. Otherwise the seq is converted to a tuple with the same number of elements as the seq. </para></description></macro>
</header>
<header name="boost/vmd/tuple/is_vmd_tuple.hpp">
<macro name="BOOST_VMD_IS_VMD_TUPLE" kind="functionlike"><macro-parameter name="sequence"/><purpose>Determines if a sequence is a VMD tuple. </purpose><description><para>The macro checks that the sequence is a VMD tuple. A VMD tuple, which may be a Boost PP tuple or emptiness, is a superset of a Boost PP tuple. It returns 1 if it is a VMD tuple, else if returns 0.</para><para>sequence = a possible Boost PP tuple</para><para>returns = 1 if it a VMD tuple, else returns 0. </para></description></macro>
</header>
</library-reference>