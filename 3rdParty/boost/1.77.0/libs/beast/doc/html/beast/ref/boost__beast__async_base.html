<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>async_base</title>
<link rel="stylesheet" href="../../../../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../../index.html" title="Chapter 1. Boost.Beast">
<link rel="up" href="../ref.html" title="This Page Intentionally Left Blank 2/2">
<link rel="prev" href="boost__beast__unit_test__amount/operator_lt__lt_.html" title="unit_test::amount::operator&lt;&lt;">
<link rel="next" href="boost__beast__async_base/executor_type.html" title="async_base::executor_type">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="boost__beast__unit_test__amount/operator_lt__lt_.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../ref.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="boost__beast__async_base/executor_type.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="beast.ref.boost__beast__async_base"></a><a class="link" href="boost__beast__async_base.html" title="async_base">async_base</a>
</h4></div></div></div>
<p>
        Base class to assist writing composed operations.
      </p>
<h5>
<a name="beast.ref.boost__beast__async_base.h0"></a>
        <span class="phrase"><a name="beast.ref.boost__beast__async_base.synopsis"></a></span><a class="link" href="boost__beast__async_base.html#beast.ref.boost__beast__async_base.synopsis">Synopsis</a>
      </h5>
<p>
        Defined in header <code class="literal">&lt;<a href="../../../../../../boost/beast/core/async_base.hpp" target="_top">boost/beast/core/async_base.hpp</a>&gt;</code>
      </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span>
    <span class="keyword">class</span> <a href="../../../../../../doc/html/boost_asio/reference/Handler.html" target="_top"><span class="emphasis"><em>Handler</em></span></a><span class="special">,</span>
    <span class="keyword">class</span> <a href="../../../../../../doc/html/boost_asio/reference/Executor1.html" target="_top"><span class="emphasis"><em>Executor1</em></span></a><span class="special">,</span>
    <span class="keyword">class</span> <a href="https://en.cppreference.com/w/cpp/named_req/Allocator" target="_top"><span class="emphasis"><em>Allocator</em></span></a> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;&gt;</span>
<span class="keyword">class</span> <span class="identifier">async_base</span>
</pre>
<h5>
<a name="beast.ref.boost__beast__async_base.h1"></a>
        <span class="phrase"><a name="beast.ref.boost__beast__async_base.types"></a></span><a class="link" href="boost__beast__async_base.html#beast.ref.boost__beast__async_base.types">Types</a>
      </h5>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                <p>
                  Name
                </p>
              </th>
<th>
                <p>
                  Description
                </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
                <p>
                  <span class="bold"><strong><a class="link" href="boost__beast__async_base/allocator_type.html" title="async_base::allocator_type">allocator_type</a></strong></span>
                </p>
              </td>
<td>
                <p>
                  The type of allocator associated with this object.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <span class="bold"><strong><a class="link" href="boost__beast__async_base/executor_type.html" title="async_base::executor_type">executor_type</a></strong></span>
                </p>
              </td>
<td>
                <p>
                  The type of executor associated with this object.
                </p>
              </td>
</tr>
</tbody>
</table></div>
<h5>
<a name="beast.ref.boost__beast__async_base.h2"></a>
        <span class="phrase"><a name="beast.ref.boost__beast__async_base.member_functions"></a></span><a class="link" href="boost__beast__async_base.html#beast.ref.boost__beast__async_base.member_functions">Member
        Functions</a>
      </h5>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                <p>
                  Name
                </p>
              </th>
<th>
                <p>
                  Description
                </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
                <p>
                  <span class="bold"><strong><a class="link" href="boost__beast__async_base/async_base.html" title="async_base::async_base">async_base</a> <span class="silver">[constructor]</span></strong></span>
                </p>
              </td>
<td>
                <p>
                  Constructor. <br> <span class="silver">—</span><br> Move
                  Constructor. <br> <span class="silver">—</span><br>
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <span class="bold"><strong><a class="link" href="boost__beast__async_base/complete.html" title="async_base::complete">complete</a></strong></span>
                </p>
              </td>
<td>
                <p>
                  Invoke the final completion handler, maybe using post.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <span class="bold"><strong><a class="link" href="boost__beast__async_base/complete_now.html" title="async_base::complete_now">complete_now</a></strong></span>
                </p>
              </td>
<td>
                <p>
                  Invoke the final completion handler.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <span class="bold"><strong><a class="link" href="boost__beast__async_base/get_allocator.html" title="async_base::get_allocator">get_allocator</a></strong></span>
                </p>
              </td>
<td>
                <p>
                  Returns the allocator associated with this object.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <span class="bold"><strong><a class="link" href="boost__beast__async_base/get_executor.html" title="async_base::get_executor">get_executor</a></strong></span>
                </p>
              </td>
<td>
                <p>
                  Returns the executor associated with this object.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <span class="bold"><strong><a class="link" href="boost__beast__async_base/handler.html" title="async_base::handler">handler</a></strong></span>
                </p>
              </td>
<td>
                <p>
                  Returns the handler associated with this object.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <span class="bold"><strong><a class="link" href="boost__beast__async_base/operator_eq_.html" title="async_base::operator=">operator=</a></strong></span>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <span class="bold"><strong><a class="link" href="boost__beast__async_base/release_handler.html" title="async_base::release_handler">release_handler</a></strong></span>
                </p>
              </td>
<td>
                <p>
                  Returns ownership of the handler associated with this object.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <span class="bold"><strong><a class="link" href="boost__beast__async_base/_async_base.html" title="async_base::~async_base">~async_base</a> <span class="silver">[destructor]</span></strong></span>
                </p>
              </td>
<td>
              </td>
</tr>
</tbody>
</table></div>
<h5>
<a name="beast.ref.boost__beast__async_base.h3"></a>
        <span class="phrase"><a name="beast.ref.boost__beast__async_base.description"></a></span><a class="link" href="boost__beast__async_base.html#beast.ref.boost__beast__async_base.description">Description</a>
      </h5>
<p>
        A function object submitted to intermediate initiating functions during a
        composed operation may derive from this type to inherit all of the boilerplate
        to forward the executor, allocator, and legacy customization points associated
        with the completion handler invoked at the end of the composed operation.
        The composed operation must be typical; that is, associated with one executor
        of an I/O object, and invoking a caller-provided completion handler when
        the operation is finished. Classes derived from <a class="link" href="boost__beast__async_base.html" title="async_base"><code class="computeroutput"><span class="identifier">async_base</span></code></a> will acquire these properties:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            Ownership of the final completion handler provided upon construction.
          </li>
<li class="listitem">
            If the final handler has an associated allocator, this allocator will
            be propagated to the composed operation subclass. Otherwise, the associated
            allocator will be the type specified in the allocator template parameter,
            or the default of <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;</span></code> if the parameter is omitted.
          </li>
<li class="listitem">
            If the final handler has an associated executor, then it will be used
            as the executor associated with the composed operation. Otherwise, the
            specified <code class="computeroutput"><span class="identifier">Executor1</span></code> will
            be the type of executor associated with the composed operation.
          </li>
<li class="listitem">
            An instance of <code class="computeroutput"><span class="identifier">net</span><span class="special">::</span><span class="identifier">executor_work_guard</span></code> for the instance
            of <code class="computeroutput"><span class="identifier">Executor1</span></code> shall be
            maintained until either the final handler is invoked, or the operation
            base is destroyed, whichever comes first.
          </li>
<li class="listitem">
            Calls to the legacy customization points <code class="computeroutput"><span class="identifier">asio_handler_invoke</span></code>,
            <code class="computeroutput"><span class="identifier">asio_handler_allocate</span></code>,
            <code class="computeroutput"><span class="identifier">asio_handler_deallocate</span></code>,
            and <code class="computeroutput"><span class="identifier">asio_handler_is_continuation</span></code>,
            which use argument-dependent lookup, will be forwarded to the legacy
            customization points associated with the handler.
          </li>
</ul></div>
<h5>
<a name="beast.ref.boost__beast__async_base.h4"></a>
        <span class="phrase"><a name="beast.ref.boost__beast__async_base.example"></a></span><a class="link" href="boost__beast__async_base.html#beast.ref.boost__beast__async_base.example">Example</a>
      </h5>
<p>
        The following code demonstrates how <a class="link" href="boost__beast__async_base.html" title="async_base"><code class="computeroutput"><span class="identifier">async_base</span></code></a> may be be used to assist
        authoring an asynchronous initiating function, by providing all of the boilerplate
        to manage the final completion handler in a way that maintains the allocator
        and executor associations:
      </p>
<pre class="programlisting"><span class="comment">// Asynchronously read into a buffer until the buffer is full, or an error occurs</span>
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">AsyncReadStream</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">ReadHandler</span><span class="special">&gt;</span>
<span class="keyword">typename</span> <span class="identifier">net</span><span class="special">::</span><span class="identifier">async_result</span><span class="special">&lt;</span><span class="identifier">ReadHandler</span><span class="special">,</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">error_code</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span><span class="special">)&gt;::</span><span class="identifier">return_type</span>
<span class="identifier">async_read</span><span class="special">(</span><span class="identifier">AsyncReadStream</span><span class="special">&amp;</span> <span class="identifier">stream</span><span class="special">,</span> <span class="identifier">net</span><span class="special">::</span><span class="identifier">mutable_buffer</span> <span class="identifier">buffer</span><span class="special">,</span> <span class="identifier">ReadHandler</span><span class="special">&amp;&amp;</span> <span class="identifier">handler</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">using</span> <span class="identifier">handler_type</span> <span class="special">=</span> <span class="identifier">BOOST_ASIO_HANDLER_TYPE</span><span class="special">(</span><span class="identifier">ReadHandler</span><span class="special">,</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">error_code</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span><span class="special">));</span>
    <span class="keyword">using</span> <span class="identifier">base_type</span> <span class="special">=</span> <span class="identifier">async_base</span><span class="special">&lt;</span><span class="identifier">handler_type</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">AsyncReadStream</span><span class="special">::</span><span class="identifier">executor_type</span><span class="special">&gt;;</span>

    <span class="keyword">struct</span> <span class="identifier">op</span> <span class="special">:</span> <span class="identifier">base_type</span>
    <span class="special">{</span>
        <span class="identifier">AsyncReadStream</span><span class="special">&amp;</span> <span class="identifier">stream_</span><span class="special">;</span>
        <span class="identifier">net</span><span class="special">::</span><span class="identifier">mutable_buffer</span> <span class="identifier">buffer_</span><span class="special">;</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">total_bytes_transferred_</span><span class="special">;</span>

        <span class="identifier">op</span><span class="special">(</span>
            <span class="identifier">AsyncReadStream</span><span class="special">&amp;</span> <span class="identifier">stream</span><span class="special">,</span>
            <span class="identifier">net</span><span class="special">::</span><span class="identifier">mutable_buffer</span> <span class="identifier">buffer</span><span class="special">,</span>
            <span class="identifier">handler_type</span><span class="special">&amp;</span> <span class="identifier">handler</span><span class="special">)</span>
            <span class="special">:</span> <span class="identifier">base_type</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">handler</span><span class="special">),</span> <span class="identifier">stream</span><span class="special">.</span><span class="identifier">get_executor</span><span class="special">())</span>
            <span class="special">,</span> <span class="identifier">stream_</span><span class="special">(</span><span class="identifier">stream</span><span class="special">)</span>
            <span class="special">,</span> <span class="identifier">buffer_</span><span class="special">(</span><span class="identifier">buffer</span><span class="special">)</span>
            <span class="special">,</span> <span class="identifier">total_bytes_transferred_</span><span class="special">(</span><span class="number">0</span><span class="special">)</span>
        <span class="special">{</span>
            <span class="special">(*</span><span class="keyword">this</span><span class="special">)({},</span> <span class="number">0</span><span class="special">,</span> <span class="keyword">false</span><span class="special">);</span> <span class="comment">// start the operation</span>
        <span class="special">}</span>

        <span class="keyword">void</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">error_code</span> <span class="identifier">ec</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">bytes_transferred</span><span class="special">,</span> <span class="keyword">bool</span> <span class="identifier">is_continuation</span> <span class="special">=</span> <span class="keyword">true</span><span class="special">)</span>
        <span class="special">{</span>
            <span class="comment">// Adjust the count of bytes and advance our buffer</span>
            <span class="identifier">total_bytes_transferred_</span> <span class="special">+=</span> <span class="identifier">bytes_transferred</span><span class="special">;</span>
            <span class="identifier">buffer_</span> <span class="special">=</span> <span class="identifier">buffer_</span> <span class="special">+</span> <span class="identifier">bytes_transferred</span><span class="special">;</span>

            <span class="comment">// Keep reading until buffer is full or an error occurs</span>
            <span class="keyword">if</span><span class="special">(!</span> <span class="identifier">ec</span> <span class="special">&amp;&amp;</span> <span class="identifier">buffer_</span><span class="special">.</span><span class="identifier">size</span><span class="special">()</span> <span class="special">&gt;</span> <span class="number">0</span><span class="special">)</span>
                <span class="keyword">return</span> <span class="identifier">stream_</span><span class="special">.</span><span class="identifier">async_read_some</span><span class="special">(</span><span class="identifier">buffer_</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(*</span><span class="keyword">this</span><span class="special">));</span>

            <span class="comment">// Call the completion handler with the result. If `is_continuation` is</span>
            <span class="comment">// false, which happens on the first time through this function, then</span>
            <span class="comment">// `net::post` will be used to call the completion handler, otherwise</span>
            <span class="comment">// the completion handler will be invoked directly.</span>

            <span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">complete</span><span class="special">(</span><span class="identifier">is_continuation</span><span class="special">,</span> <span class="identifier">ec</span><span class="special">,</span> <span class="identifier">total_bytes_transferred_</span><span class="special">);</span>
        <span class="special">}</span>
    <span class="special">};</span>

    <span class="identifier">net</span><span class="special">::</span><span class="identifier">async_completion</span><span class="special">&lt;</span><span class="identifier">ReadHandler</span><span class="special">,</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">error_code</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span><span class="special">)&gt;</span> <span class="identifier">init</span><span class="special">{</span><span class="identifier">handler</span><span class="special">};</span>
    <span class="identifier">op</span><span class="special">(</span><span class="identifier">stream</span><span class="special">,</span> <span class="identifier">buffer</span><span class="special">,</span> <span class="identifier">init</span><span class="special">.</span><span class="identifier">completion_handler</span><span class="special">);</span>
    <span class="keyword">return</span> <span class="identifier">init</span><span class="special">.</span><span class="identifier">result</span><span class="special">.</span><span class="identifier">get</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
        Data members of composed operations implemented as completion handlers do
        not have stable addresses, as the composed operation object is move constructed
        upon each call to an initiating function. For most operations this is not
        a problem. For complex operations requiring stable temporary storage, the
        class <a class="link" href="boost__beast__stable_async_base.html" title="stable_async_base"><code class="computeroutput"><span class="identifier">stable_async_base</span></code></a> is provided which
        offers additional functionality:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            The free function <a class="link" href="boost__beast__allocate_stable.html" title="allocate_stable"><code class="computeroutput"><span class="identifier">allocate_stable</span></code></a> may be used
            to allocate one or more temporary objects associated with the composed
            operation.
          </li>
<li class="listitem">
            Memory for stable temporary objects is allocated using the allocator
            associated with the composed operation.
          </li>
<li class="listitem">
            Stable temporary objects are automatically destroyed, and the memory
            freed using the associated allocator, either before the final completion
            handler is invoked (a Networking requirement) or when the composed operation
            is destroyed, whichever occurs first.
          </li>
</ul></div>
<h5>
<a name="beast.ref.boost__beast__async_base.h5"></a>
        <span class="phrase"><a name="beast.ref.boost__beast__async_base.temporary_storage_example"></a></span><a class="link" href="boost__beast__async_base.html#beast.ref.boost__beast__async_base.temporary_storage_example">Temporary
        Storage Example</a>
      </h5>
<p>
        The following example demonstrates how a composed operation may store a temporary
        object.
      </p>
<h5>
<a name="beast.ref.boost__beast__async_base.h6"></a>
        <span class="phrase"><a name="beast.ref.boost__beast__async_base.template_parameters"></a></span><a class="link" href="boost__beast__async_base.html#beast.ref.boost__beast__async_base.template_parameters">Template
        Parameters</a>
      </h5>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                <p>
                  Type
                </p>
              </th>
<th>
                <p>
                  Description
                </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">Handler</span></code>
                </p>
              </td>
<td>
                <p>
                  The type of the completion handler to store. This type must meet
                  the requirements of <span class="emphasis"><em>CompletionHandler</em></span>.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">Executor1</span></code>
                </p>
              </td>
<td>
                <p>
                  The type of the executor used when the handler has no associated
                  executor. An instance of this type must be provided upon construction.
                  The implementation will maintain an executor work guard and a copy
                  of this instance.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">Allocator</span></code>
                </p>
              </td>
<td>
                <p>
                  The allocator type to use if the handler does not have an associated
                  allocator. If this parameter is omitted, then <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;</span></code> will be used. If the specified
                  allocator is not default constructible, an instance of the type
                  must be provided upon construction.
                </p>
              </td>
</tr>
</tbody>
</table></div>
<h5>
<a name="beast.ref.boost__beast__async_base.h7"></a>
        <span class="phrase"><a name="beast.ref.boost__beast__async_base.see_also"></a></span><a class="link" href="boost__beast__async_base.html#beast.ref.boost__beast__async_base.see_also">See
        Also</a>
      </h5>
<p>
        <a class="link" href="boost__beast__stable_async_base.html" title="stable_async_base"><code class="computeroutput"><span class="identifier">stable_async_base</span></code></a>
      </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2016-2019 Vinnie
      Falco<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="boost__beast__unit_test__amount/operator_lt__lt_.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../ref.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="boost__beast__async_base/executor_type.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
