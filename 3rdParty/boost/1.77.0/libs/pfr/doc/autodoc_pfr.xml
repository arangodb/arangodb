<?xml version="1.0" standalone="yes"?>
<library-reference id="reference_section"><title>Reference Section</title><header name="boost/pfr.hpp">
<para>Includes all the Boost.PFR headers </para></header>
<header name="boost/pfr/core.hpp">
<para>Contains all the basic tuple-like interfaces <link linkend="boost.pfr.get"> boost::pfr::get </link>, <link linkend="boost.pfr.tuple_size"> boost::pfr::tuple_size </link>, <link linkend="boost.pfr.tuple_element_t"> boost::pfr::tuple_element_t </link>, and others.</para><para><emphasis role="bold">Synopsis:</emphasis> </para><namespace name="boost">
<namespace name="pfr">
<typedef name="tuple_element"><purpose><computeroutput>tuple_element</computeroutput> has a member typedef <computeroutput>type</computeroutput> that returns the type of a field with index I in <link linkend="boost_pfr.limitations_and_configuration"> simple aggregate </link> T. </purpose><description><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">std::vector&lt; boost::pfr::tuple_element&lt;0, my_structure&gt;::type &gt; v;
</programlisting> </para></description><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="tuple_element_t"><purpose>Type of a field with index <computeroutput>I</computeroutput> in <link linkend="boost_pfr.limitations_and_configuration"> simple aggregate </link> <computeroutput>T</computeroutput>. </purpose><description><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">std::vector&lt; boost::pfr::tuple_element_t&lt;0, my_structure&gt; &gt; v;
</programlisting> </para></description><type>typename tuple_element&lt; I, T &gt;::type</type></typedef>























<overloaded-function name="get"><signature><type>decltype(auto) constexpr</type><template>
          <template-nontype-parameter name="I"><type>std::size_t</type></template-nontype-parameter>
          <template-type-parameter name="T"/>
        </template><parameter name="val"><paramtype>const T &amp;</paramtype></parameter></signature><signature><type>decltype(auto) constexpr</type><template>
          <template-nontype-parameter name="I"><type>std::size_t</type></template-nontype-parameter>
          <template-type-parameter name="T"/>
        </template><parameter name="val"><paramtype>T &amp;</paramtype></parameter><parameter name=""><paramtype>std::enable_if_t&lt; std::is_assignable&lt; T, T &gt;::value &gt; *</paramtype><default>nullptr</default></parameter></signature><signature><type>constexpr auto</type><template>
          <template-nontype-parameter name="I"><type>std::size_t</type></template-nontype-parameter>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype>T &amp;</paramtype></parameter><parameter name=""><paramtype>std::enable_if_t&lt;!std::is_assignable&lt; T, T &gt;::value &gt; *</paramtype><default>nullptr</default></parameter></signature><signature><type>constexpr auto</type><template>
          <template-nontype-parameter name="I"><type>std::size_t</type></template-nontype-parameter>
          <template-type-parameter name="T"/>
        </template><parameter name="val"><paramtype>T &amp;&amp;</paramtype></parameter><parameter name=""><paramtype>std::enable_if_t&lt; std::is_rvalue_reference&lt; T &amp;&amp; &gt;::value &gt; *</paramtype><default>0</default></parameter></signature><purpose>Returns reference or const reference to a field with index <computeroutput>I</computeroutput> in <link linkend="boost_pfr.limitations_and_configuration"> simple aggregate </link> <computeroutput>val</computeroutput>. </purpose><description><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">struct my_struct { int i, short s; };
my_struct s {10, 11};
assert(boost::pfr::get&lt;0&gt;(s) == 10);
boost::pfr::get&lt;1&gt;(s) = 0;
</programlisting> </para></description></overloaded-function>



<function name="structure_to_tuple"><type>constexpr auto</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="val"><paramtype>const T &amp;</paramtype></parameter><purpose>Creates a <computeroutput>std::tuple</computeroutput> from fields of an <link linkend="boost_pfr.limitations_and_configuration"> simple aggregate </link> <computeroutput>val</computeroutput>. </purpose><description><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">struct my_struct { int i, short s; };
my_struct s {10, 11};
std::tuple&lt;int, short&gt; t = make_tuple(s);
assert(get&lt;0&gt;(t) == 10);
</programlisting> </para></description></function>
<overloaded-function name="structure_tie"><signature><type>constexpr auto</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="val"><paramtype>const T &amp;</paramtype></parameter></signature><signature><type>constexpr auto</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="val"><paramtype>T &amp;</paramtype></parameter><parameter name=""><paramtype>std::enable_if_t&lt; std::is_assignable&lt; T, T &gt;::value &gt; *</paramtype><default>nullptr</default></parameter></signature><signature><type>constexpr auto</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype>T &amp;</paramtype></parameter><parameter name=""><paramtype>std::enable_if_t&lt;!std::is_assignable&lt; T, T &gt;::value &gt; *</paramtype><default>nullptr</default></parameter></signature><signature><type>constexpr auto</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype>T &amp;&amp;</paramtype></parameter><parameter name=""><paramtype>std::enable_if_t&lt; std::is_rvalue_reference&lt; T &amp;&amp; &gt;::value &gt; *</paramtype><default>0</default></parameter></signature><purpose>std::tie` like function that ties fields of a structure. </purpose><description><para>
<emphasis role="bold">Example:</emphasis> <programlisting language="c++">void foo(const int&amp;, const short&amp;);
struct my_struct { int i, short s; };

const my_struct const_s{1, 2};
std::apply(foo, structure_tie(const_s));

my_struct s;
structure_tie(s) = std::tuple&lt;int, short&gt;{10, 11};
assert(s.s == 11);
</programlisting> </para></description><returns><para>a <computeroutput>std::tuple</computeroutput> with lvalue and const lvalue references to fields of an <link linkend="boost_pfr.limitations_and_configuration"> simple aggregate </link> <computeroutput>val</computeroutput>.</para>
</returns></overloaded-function>



<function name="for_each_field"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="F"/>
        </template><parameter name="value"><paramtype>T &amp;&amp;</paramtype><description><para>To each field of this variable will be the <computeroutput>func</computeroutput> applied.</para></description></parameter><parameter name="func"><paramtype>F &amp;&amp;</paramtype><description><para>must have one of the following signatures:<itemizedlist>
<listitem><para>any_return_type func(U&amp;&amp; field) // field of value is perfect forwarded to function</para>
</listitem><listitem><para>any_return_type func(U&amp;&amp; field, std::size_t i)</para>
</listitem><listitem><para>any_return_type func(U&amp;&amp; value, I i) // Here I is an <computeroutput>std::integral_constant&lt;size_t, field_index&gt;</computeroutput></para>
</listitem></itemizedlist>
</para></description></parameter><description><para>Calls <computeroutput>func</computeroutput> for each field of a <computeroutput>value</computeroutput>.</para><para>
<emphasis role="bold">Example:</emphasis> <programlisting language="c++">struct my_struct { int i, short s; };
int sum = 0;
for_each_field(my_struct{20, 22}, [&amp;sum](const auto&amp; field) { sum += field; });
assert(sum == 42);
</programlisting> </para></description></function>
<function name="tie_from_structure"><type><emphasis>unspecified</emphasis></type><template>
          <template-nontype-parameter name="Elements"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>Elements &amp;...</paramtype></parameter><purpose>std::tie-like function that allows assigning to tied values from aggregates. </purpose><description><para>
<emphasis role="bold">Example:</emphasis> <programlisting language="c++">auto f() {
  struct { struct { int x, y } p; short s; } res { { 4, 5 }, 6 };
  return res;
}
auto [p, s] = f();
tie_from_structure(p, s) = f();
</programlisting> </para></description><returns><para>an object with lvalue references to <computeroutput>args...</computeroutput>; on assignment of an <link linkend="boost_pfr.limitations_and_configuration"> simple aggregate </link> value to that object each field of an aggregate is assigned to the corresponding <computeroutput>args...</computeroutput> reference.</para>
</returns></function>
</namespace>
</namespace>
</header>
<header name="boost/pfr/functions_for.hpp">
<para>Contains BOOST_PFR_FUNCTIONS_FOR macro that defined comparison and stream operators for T along with hash_value function. <emphasis role="bold">Example:</emphasis> <programlisting language="c++">#include &lt;boost/pfr/functions_for.hpp&gt;

namespace my_namespace {
    struct my_struct {      // No operators defined for that structure
        int i; short s; char data[7]; bool bl; int a,b,c,d,e,f;
    };
    BOOST_PFR_FUNCTIONS_FOR(my_struct)
}
</programlisting></para><para><emphasis role="bold">See</emphasis> <emphasis role="bold">Also</emphasis> : <link linkend="boost_pfr.tutorial.three_ways_of_getting_operators"> 'Three ways of getting operators' </link> for other ways to define operators and more details.</para><para><emphasis role="bold">Synopsis:</emphasis> </para><macro name="BOOST_PFR_FUNCTIONS_FOR" kind="functionlike"><macro-parameter name="T"/><description><para>Defines comparison and stream operators for T along with hash_value function.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">#include &lt;boost/pfr/functions_for.hpp&gt;
struct comparable_struct {      // No operators defined for that structure
    int i; short s; char data[7]; bool bl; int a,b,c,d,e,f;
};
BOOST_PFR_FUNCTIONS_FOR(comparable_struct)
// ...

comparable_struct s1 {0, 1, "Hello", false, 6,7,8,9,10,11};
comparable_struct s2 {0, 1, "Hello", false, 6,7,8,9,10,11111};
assert(s1 &lt; s2);
std::cout &lt;&lt; s1 &lt;&lt; std::endl; // Outputs: {0, 1, H, e, l, l, o, , , 0, 6, 7, 8, 9, 10, 11}
</programlisting></para><para><emphasis role="bold">See</emphasis> <emphasis role="bold">Also</emphasis> : <link linkend="boost_pfr.tutorial.three_ways_of_getting_operators"> 'Three ways of getting operators' </link> for other ways to define operators and more details.</para><para><emphasis role="bold">Defines</emphasis> <emphasis role="bold">following</emphasis> <emphasis role="bold">for</emphasis> <emphasis role="bold">T:</emphasis> <programlisting language="c++">bool operator==(const T&amp; lhs, const T&amp; rhs);
bool operator!=(const T&amp; lhs, const T&amp; rhs);
bool operator&lt; (const T&amp; lhs, const T&amp; rhs);
bool operator&gt; (const T&amp; lhs, const T&amp; rhs);
bool operator&lt;=(const T&amp; lhs, const T&amp; rhs);
bool operator&gt;=(const T&amp; lhs, const T&amp; rhs);

template &lt;class Char, class Traits&gt;
std::basic_ostream&lt;Char, Traits&gt;&amp; operator&lt;&lt;(std::basic_ostream&lt;Char, Traits&gt;&amp; out, const T&amp; value);

template &lt;class Char, class Traits&gt;
std::basic_istream&lt;Char, Traits&gt;&amp; operator&gt;&gt;(std::basic_istream&lt;Char, Traits&gt;&amp; in, T&amp; value);

// helper function for Boost unordered containers and boost::hash&lt;&gt;.
std::size_t hash_value(const T&amp; value);
</programlisting> </para></description></macro>
</header>
<header name="boost/pfr/functors.hpp">
<para>Contains functors that are close to the Standard Library ones. Each functor calls corresponding Boost.PFR function from boost/pfr/ops.hpp</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">#include &lt;boost/pfr/functors.hpp&gt;
struct my_struct {      // No operators defined for that structure
    int i; short s; char data[7]; bool bl; int a,b,c,d,e,f;
};
// ...

std::unordered_set&lt;
    my_struct,
    boost::pfr::hash&lt;&gt;,
    boost::pfr::equal_to&lt;&gt;
&gt; my_set;
</programlisting></para><para><emphasis role="bold">Synopsis:</emphasis> </para><namespace name="boost">
<namespace name="pfr">
<struct name="equal_to"><template>
      <template-type-parameter name="T"><default>void</default></template-type-parameter>
    </template><purpose>std::equal_to like comparator that returns <link linkend="boost.pfr.eq"> boost::pfr::eq </link>(x, y) </purpose><method-group name="public member functions">
<method name="operator()" cv="const"><type>bool</type><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><parameter name="y"><paramtype>const T &amp;</paramtype></parameter><description><para>
</para></description><returns><para><emphasis role="bold">true</emphasis> if each field of <emphasis role="bold">x</emphasis> equals the field with same index of <emphasis role="bold">y</emphasis>. </para>
</returns></method>
</method-group>
</struct><struct name="greater"><template>
      <template-type-parameter name="T"><default>void</default></template-type-parameter>
    </template><purpose>std::greater like comparator that returns <link linkend="boost.pfr.gt"> boost::pfr::gt </link>(x, y) </purpose><method-group name="public member functions">
<method name="operator()" cv="const"><type>bool</type><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><parameter name="y"><paramtype>const T &amp;</paramtype></parameter><description><para>
</para></description><returns><para><emphasis role="bold">true</emphasis> if field of <emphasis role="bold">x</emphasis> greater than the field with same index of <emphasis role="bold">y</emphasis> and all previous fields of <emphasis role="bold">x</emphasis> equal to the same fields of <emphasis role="bold">y</emphasis>. </para>
</returns></method>
</method-group>
</struct><struct name="greater_equal"><template>
      <template-type-parameter name="T"><default>void</default></template-type-parameter>
    </template><purpose>std::greater_equal like comparator that returns <link linkend="boost.pfr.ge"> boost::pfr::ge </link>(x, y) </purpose><method-group name="public member functions">
<method name="operator()" cv="const"><type>bool</type><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><parameter name="y"><paramtype>const T &amp;</paramtype></parameter><description><para>
</para></description><returns><para><emphasis role="bold">true</emphasis> if field of <emphasis role="bold">x</emphasis> greater than the field with same index of <emphasis role="bold">y</emphasis> and all previous fields of <emphasis role="bold">x</emphasis> equal to the same fields of <emphasis role="bold">y</emphasis>; or if each field of <emphasis role="bold">x</emphasis> equals the field with same index of <emphasis role="bold">y</emphasis>. </para>
</returns></method>
</method-group>
</struct><struct name="hash"><template>
      <template-type-parameter name="T"/>
    </template><purpose>std::hash like functor that returns <link linkend="boost.pfr.hash_value"> boost::pfr::hash_value </link>(x) </purpose><method-group name="public member functions">
<method name="operator()" cv="const"><type>std::size_t</type><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><description><para>
</para></description><returns><para>hash value of <emphasis role="bold">x</emphasis>. </para>
</returns></method>
</method-group>
</struct><struct name="less"><template>
      <template-type-parameter name="T"><default>void</default></template-type-parameter>
    </template><purpose>std::less like comparator that returns <link linkend="boost.pfr.lt"> boost::pfr::lt </link>(x, y) </purpose><method-group name="public member functions">
<method name="operator()" cv="const"><type>bool</type><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><parameter name="y"><paramtype>const T &amp;</paramtype></parameter><description><para>
</para></description><returns><para><emphasis role="bold">true</emphasis> if field of <emphasis role="bold">x</emphasis> less than the field with same index of <emphasis role="bold">y</emphasis> and all previous fields of <emphasis role="bold">x</emphasis> equal to the same fields of <emphasis role="bold">y</emphasis>. </para>
</returns></method>
</method-group>
</struct><struct name="less_equal"><template>
      <template-type-parameter name="T"><default>void</default></template-type-parameter>
    </template><purpose>std::less_equal like comparator that returns <link linkend="boost.pfr.le"> boost::pfr::le </link>(x, y) </purpose><method-group name="public member functions">
<method name="operator()" cv="const"><type>bool</type><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><parameter name="y"><paramtype>const T &amp;</paramtype></parameter><description><para>
</para></description><returns><para><emphasis role="bold">true</emphasis> if field of <emphasis role="bold">x</emphasis> less than the field with same index of <emphasis role="bold">y</emphasis> and all previous fields of <emphasis role="bold">x</emphasis> equal to the same fields of <emphasis role="bold">y</emphasis>; or if each field of <emphasis role="bold">x</emphasis> equals the field with same index of <emphasis role="bold">y</emphasis>. </para>
</returns></method>
</method-group>
</struct><struct name="not_equal"><template>
      <template-type-parameter name="T"><default>void</default></template-type-parameter>
    </template><purpose>std::not_equal like comparator that returns <link linkend="boost.pfr.ne"> boost::pfr::ne </link>(x, y) </purpose><method-group name="public member functions">
<method name="operator()" cv="const"><type>bool</type><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><parameter name="y"><paramtype>const T &amp;</paramtype></parameter><description><para>
</para></description><returns><para><emphasis role="bold">true</emphasis> if at least one field <emphasis role="bold">x</emphasis> not equals the field with same index of <emphasis role="bold">y</emphasis>. </para>
</returns></method>
</method-group>
</struct>

































</namespace>
</namespace>
</header>
<header name="boost/pfr/io.hpp">
<para>Contains IO stream manipulator <link linkend="boost.pfr.io"> boost::pfr::io </link> for types. If type is streamable using its own operator or its conversion operator, then the types operator is used.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">#include &lt;boost/pfr/io.hpp&gt;
struct comparable_struct {      // No operators defined for that structure
    int i; short s; char data[7]; bool bl; int a,b,c,d,e,f;
};
// ...

comparable_struct s1 {0, 1, "Hello", false, 6,7,8,9,10,11};
std::cout &lt;&lt; boost::pfr::io(s1);  // Outputs: {0, 1, H, e, l, l, o, , , 0, 6, 7, 8, 9, 10, 11}
</programlisting></para><para><emphasis role="bold">See</emphasis> <emphasis role="bold">Also</emphasis> : <link linkend="boost_pfr.tutorial.three_ways_of_getting_operators"> 'Three ways of getting operators' </link> for other ways to define operators and more details.</para><para><emphasis role="bold">Synopsis:</emphasis> </para><namespace name="boost">
<namespace name="pfr">






















<function name="io"><type>auto</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="value"><paramtype>T &amp;&amp;</paramtype></parameter><description><para>IO manupulator to read/write <link linkend="boost_pfr.limitations_and_configuration"> simple aggregate </link> <computeroutput>value</computeroutput> using its IO stream operators or using <link linkend="boost.pfr.io_fields"> boost::pfr::io_fields </link> if operators are not awailable.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">struct my_struct { int i; short s; };
my_struct s;
std::stringstream ss;
ss &lt;&lt; "{ 12, 13 }";
ss &gt;&gt; boost::pfr::io(s);
assert(s.i == 12);
assert(s.i == 13);
</programlisting></para><para><emphasis role="bold">See</emphasis> <emphasis role="bold">Also</emphasis> : <link linkend="boost_pfr.tutorial.custom_printing_of_aggregates"> 'Custom printing of aggregates' </link> for info on how to implement your own manipulator with custom format. </para></description></function>











</namespace>
</namespace>
</header>
<header name="boost/pfr/io_fields.hpp">
<para>Contains IO manupulator <link linkend="boost.pfr.io_fields"> boost::pfr::io_fields </link> to read/write <link linkend="boost_pfr.limitations_and_configuration"> simple aggregate </link> <computeroutput>value</computeroutput> field-by-field.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">struct my_struct {
    int i;
    short s;
};

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const my_struct&amp; x) {
    return os &lt;&lt; boost::pfr::io_fields(x);  // Equivalent to: os &lt;&lt; "{ " &lt;&lt; x.i &lt;&lt; " ," &lt;&lt;  x.s &lt;&lt; " }"
}

std::istream&amp; operator&gt;&gt;(std::istream&amp; is, my_struct&amp; x) {
    return is &gt;&gt; boost::pfr::io_fields(x);  // Equivalent to: is &gt;&gt; "{ " &gt;&gt; x.i &gt;&gt; " ," &gt;&gt;  x.s &gt;&gt; " }"
}
</programlisting></para><para><emphasis role="bold">See</emphasis> <emphasis role="bold">Also</emphasis> : <link linkend="boost_pfr.tutorial.three_ways_of_getting_operators"> 'Three ways of getting operators' </link> for other ways to define operators and more details.</para><para><emphasis role="bold">Synopsis:</emphasis> </para><namespace name="boost">
<namespace name="pfr">





















<function name="io_fields"><type>auto</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="value"><paramtype>T &amp;&amp;</paramtype></parameter><description><para>IO manupulator to read/write <link linkend="boost_pfr.limitations_and_configuration"> simple aggregate </link> <computeroutput>value</computeroutput> field-by-field.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">struct my_struct {
    int i;
    short s;
};

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const my_struct&amp; x) {
    return os &lt;&lt; boost::pfr::io_fields(x);  // Equivalent to: os &lt;&lt; "{ " &lt;&lt; x.i &lt;&lt; " ," &lt;&lt;  x.s &lt;&lt; " }"
}

std::istream&amp; operator&gt;&gt;(std::istream&amp; is, my_struct&amp; x) {
    return is &gt;&gt; boost::pfr::io_fields(x);  // Equivalent to: is &gt;&gt; "{ " &gt;&gt; x.i &gt;&gt; " ," &gt;&gt;  x.s &gt;&gt; " }"
}
</programlisting></para><para>Input and output streaming operators for <computeroutput>boost::pfr::io_fields</computeroutput> are symmetric, meaning that you get the original value by streaming it and reading back if each fields streaming operator is symmetric.</para><para><emphasis role="bold">See</emphasis> <emphasis role="bold">Also</emphasis> : <link linkend="boost_pfr.tutorial.custom_printing_of_aggregates"> 'Custom printing of aggregates' </link> for info on how to implement your own manipulator with custom format. </para></description></function>












</namespace>
</namespace>
</header>
<header name="boost/pfr/ops.hpp">
<para>Contains comparison and hashing functions. If type is comparable using its own operator or its conversion operator, then the types operator is used. Otherwise the operation is done via corresponding function from boost/pfr/ops.hpp header.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">#include &lt;boost/pfr/ops.hpp&gt;
struct comparable_struct {      // No operators defined for that structure
    int i; short s; char data[7]; bool bl; int a,b,c,d,e,f;
};
// ...

comparable_struct s1 {0, 1, "Hello", false, 6,7,8,9,10,11};
comparable_struct s2 {0, 1, "Hello", false, 6,7,8,9,10,11111};
assert(boost::pfr::lt(s1, s2));
</programlisting></para><para><emphasis role="bold">See</emphasis> <emphasis role="bold">Also</emphasis> : <link linkend="boost_pfr.tutorial.three_ways_of_getting_operators"> 'Three ways of getting operators' </link> for other ways to define operators and more details.</para><para><emphasis role="bold">Synopsis:</emphasis> </para><namespace name="boost">
<namespace name="pfr">







<overloaded-function name="eq"><signature><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter></signature><signature><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter></signature><purpose>Compares lhs and rhs for equality using their own comparison and conversion operators; if no operators avalable returns <link linkend="boost.pfr.eq_fields"> boost::pfr::eq_fields </link>(lhs, rhs). </purpose><description><para>
</para></description><returns><para>true if lhs is equal to rhs; false otherwise </para>
</returns></overloaded-function>

<overloaded-function name="ne"><signature><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter></signature><signature><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter></signature><purpose>Compares lhs and rhs for inequality using their own comparison and conversion operators; if no operators avalable returns <link linkend="boost.pfr.ne_fields"> boost::pfr::ne_fields </link>(lhs, rhs). </purpose><description><para>
</para></description><returns><para>true if lhs is not equal to rhs; false otherwise </para>
</returns></overloaded-function>

<overloaded-function name="lt"><signature><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter></signature><signature><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter></signature><purpose>Compares lhs and rhs for less-than using their own comparison and conversion operators; if no operators avalable returns <link linkend="boost.pfr.lt_fields"> boost::pfr::lt_fields </link>(lhs, rhs). </purpose><description><para>
</para></description><returns><para>true if lhs is less than rhs; false otherwise </para>
</returns></overloaded-function>

<overloaded-function name="gt"><signature><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter></signature><signature><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter></signature><purpose>Compares lhs and rhs for greater-than using their own comparison and conversion operators; if no operators avalable returns <link linkend="boost.pfr.lt_fields"> boost::pfr::lt_fields </link>(lhs, rhs). </purpose><description><para>
</para></description><returns><para>true if lhs is greater than rhs; false otherwise </para>
</returns></overloaded-function>

<overloaded-function name="le"><signature><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter></signature><signature><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter></signature><purpose>Compares lhs and rhs for less-equal using their own comparison and conversion operators; if no operators avalable returns <link linkend="boost.pfr.le_fields"> boost::pfr::le_fields </link>(lhs, rhs). </purpose><description><para>
</para></description><returns><para>true if lhs is less or equal to rhs; false otherwise </para>
</returns></overloaded-function>

<overloaded-function name="ge"><signature><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter></signature><signature><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter></signature><purpose>Compares lhs and rhs for greater-equal using their own comparison and conversion operators; if no operators avalable returns <link linkend="boost.pfr.ge_fields"> boost::pfr::ge_fields </link>(lhs, rhs). </purpose><description><para>
</para></description><returns><para>true if lhs is greater or equal to rhs; false otherwise </para>
</returns></overloaded-function>

<overloaded-function name="hash_value"><signature><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="value"><paramtype>const T &amp;</paramtype></parameter></signature><signature><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="value"><paramtype>const T &amp;</paramtype></parameter></signature><purpose>Hashes value using its own std::hash specialization; if no std::hash specialization avalable returns <link linkend="boost.pfr.hash_fields"> boost::pfr::hash_fields </link>(value). </purpose><description><para>
</para></description><returns><para>std::size_t with hash of the value </para>
</returns></overloaded-function>














</namespace>
</namespace>
</header>
<header name="boost/pfr/ops_fields.hpp">
<para>Contains field-by-fields comparison and hash functions.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">#include &lt;boost/pfr/ops_fields.hpp&gt;
struct comparable_struct {      // No operators defined for that structure
    int i; short s;
};
// ...

comparable_struct s1 {0, 1};
comparable_struct s2 {0, 2};
assert(boost::pfr::lt_fields(s1, s2));
</programlisting></para><para><emphasis role="bold">See</emphasis> <emphasis role="bold">Also</emphasis> : <link linkend="boost_pfr.tutorial.three_ways_of_getting_operators"> 'Three ways of getting operators' </link> for other ways to define operators and more details.</para><para><emphasis role="bold">Synopsis:</emphasis> </para><namespace name="boost">
<namespace name="pfr">
<function name="eq_fields"><type>constexpr bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter><description><para>Does a field-by-field equality comparison.</para><para>
</para></description><returns><para><computeroutput>L == R &amp;&amp; tuple_size_v&lt;T&gt; == tuple_size_v&lt;U&gt;</computeroutput>, where <computeroutput>L</computeroutput> and <computeroutput>R</computeroutput> are the results of calling <computeroutput>std::tie</computeroutput> on first <computeroutput>N</computeroutput> fields of <computeroutput>lhs</computeroutput> and </para>
</returns></function>
<function name="ne_fields"><type>constexpr bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter><description><para>Does a field-by-field inequality comparison.</para><para>
</para></description><returns><para><computeroutput>L != R || tuple_size_v&lt;T&gt; != tuple_size_v&lt;U&gt;</computeroutput>, where <computeroutput>L</computeroutput> and <computeroutput>R</computeroutput> are the results of calling <computeroutput>std::tie</computeroutput> on first <computeroutput>N</computeroutput> fields of <computeroutput>lhs</computeroutput> and </para>
</returns></function>
<function name="gt_fields"><type>constexpr bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter><description><para>Does a field-by-field greter comparison.</para><para>
</para></description><returns><para><computeroutput>L &gt; R || (L == R &amp;&amp; tuple_size_v&lt;T&gt; &gt; tuple_size_v&lt;U&gt;)</computeroutput>, where <computeroutput>L</computeroutput> and <computeroutput>R</computeroutput> are the results of calling <computeroutput>std::tie</computeroutput> on first <computeroutput>N</computeroutput> fields of <computeroutput>lhs</computeroutput> and </para>
</returns></function>
<function name="lt_fields"><type>constexpr bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter><description><para>Does a field-by-field less comparison.</para><para>
</para></description><returns><para><computeroutput>L &lt; R || (L == R &amp;&amp; tuple_size_v&lt;T&gt; &lt; tuple_size_v&lt;U&gt;)</computeroutput>, where <computeroutput>L</computeroutput> and <computeroutput>R</computeroutput> are the results of calling <computeroutput>std::tie</computeroutput> on first <computeroutput>N</computeroutput> fields of <computeroutput>lhs</computeroutput> and </para>
</returns></function>
<function name="ge_fields"><type>constexpr bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter><description><para>Does a field-by-field greater equal comparison.</para><para>
</para></description><returns><para><computeroutput>L &gt; R || (L == R &amp;&amp; tuple_size_v&lt;T&gt; &gt;= tuple_size_v&lt;U&gt;)</computeroutput>, where <computeroutput>L</computeroutput> and <computeroutput>R</computeroutput> are the results of calling <computeroutput>std::tie</computeroutput> on first <computeroutput>N</computeroutput> fields of <computeroutput>lhs</computeroutput> and </para>
</returns></function>
<function name="le_fields"><type>constexpr bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter><description><para>Does a field-by-field less equal comparison.</para><para>
</para></description><returns><para><computeroutput>L &lt; R || (L == R &amp;&amp; tuple_size_v&lt;T&gt; &lt;= tuple_size_v&lt;U&gt;)</computeroutput>, where <computeroutput>L</computeroutput> and <computeroutput>R</computeroutput> are the results of calling <computeroutput>std::tie</computeroutput> on first <computeroutput>N</computeroutput> fields of <computeroutput>lhs</computeroutput> and </para>
</returns></function>
<function name="hash_fields"><type>std::size_t</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><description><para>Does a field-by-field hashing.</para><para>
</para></description><returns><para>combined hash of all the fields </para>
</returns></function>



























</namespace>
</namespace>
</header>
<header name="boost/pfr/tuple_size.hpp">
<para>Contains tuple-like interfaces to get fields count <link linkend="boost.pfr.tuple_size"> boost::pfr::tuple_size </link>, <link linkend="boost.pfr.tuple_size_v"> boost::pfr::tuple_size_v </link>.</para><para><emphasis role="bold">Synopsis:</emphasis> </para><namespace name="boost">
<namespace name="pfr">
<typedef name="tuple_size"><description><para>Has a static const member variable <computeroutput>value</computeroutput> that contains fields count in a T. Works for any T that supports aggregate initialization.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">std::array&lt;int, boost::pfr::tuple_size&lt;my_structure&gt;::value &gt; a;
</programlisting> </para></description><type><emphasis>unspecified</emphasis></type></typedef>
<data-member name="tuple_size_v"><type>constexpr std::size_t</type><description><para><computeroutput>tuple_size_v</computeroutput> is a template variable that contains fields count in a T and works for any T that supports aggregate initialization.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">std::array&lt;int, boost::pfr::tuple_size_v&lt;my_structure&gt; &gt; a;
</programlisting> </para></description></data-member>


































</namespace>
</namespace>
</header>
</library-reference>