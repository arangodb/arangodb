<?xml version="1.0" standalone="yes"?>
<library-reference id="statistics_library_reference"><title>Statistics Library Reference</title><header name="boost/accumulators/statistics.hpp">
<para>Includes all of the Statistical Accumulators Library </para></header>
<header name="boost/accumulators/statistics/count.hpp">
<namespace name="boost">
<namespace name="accumulators">
<namespace name="extract">
<data-member name="count"><type><classname>extractor</classname>&lt; <classname>tag::count</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">
<struct name="count_impl"><inherit access="public">accumulator_base</inherit><typedef name="result_type"><type>std::size_t</type></typedef>
<method-group name="public member functions">
<method name="operator()"><type>void</type><parameter name=""><paramtype>dont_care</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><parameter name=""><paramtype>dont_care</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><parameter name=""><paramtype>dont_care</paramtype></parameter></constructor>
</struct>
</namespace>
<namespace name="tag">
<struct name="count"><inherit access="public">boost::accumulators::depends_on&lt;&gt;</inherit></struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/covariance.hpp">
<namespace name="boost">
<namespace name="accumulators">
<struct-specialization name="as_weighted_feature"><template>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><specialization><template-arg>tag::covariance&lt; VariateType</template-arg><template-arg>VariateTag &gt;</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_covariance</classname>&lt; VariateType, VariateTag &gt;</type></typedef>
</struct-specialization><struct-specialization name="feature_of"><template>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><specialization><template-arg>tag::covariance&lt; VariateType</template-arg><template-arg>VariateTag &gt;</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::abstract_covariance &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><specialization><template-arg>tag::weighted_covariance&lt; VariateType</template-arg><template-arg>VariateTag &gt;</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::covariance&lt; VariateType, VariateTag &gt; &gt;</inherit></struct-specialization><namespace name="extract">
<data-member name="covariance"><type><classname>extractor</classname>&lt; <classname>tag::abstract_covariance</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
<struct name="abstract_covariance"><inherit access="public">boost::accumulators::depends_on&lt;&gt;</inherit></struct></namespace>
</namespace>
<namespace name="numeric">
<namespace name="functional">
<struct name="outer_product"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="LeftTag"><default>typename tag&lt;Left&gt;::type</default></template-type-parameter>
      <template-type-parameter name="RightTag"><default>typename tag&lt;Right&gt;::type</default></template-type-parameter>
    </template><inherit access="public">boost::numeric::functional::outer_product_base&lt; Left, Right, void &gt;</inherit></struct><struct-specialization name="outer_product"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
    </template><specialization><template-arg>Left</template-arg><template-arg>Right</template-arg><template-arg>std_vector_tag</template-arg><template-arg>std_vector_tag</template-arg></specialization><typedef name="first_argument_type"><type>Left</type></typedef>
<typedef name="second_argument_type"><type>Right</type></typedef>
<typedef name="result_type"><type>ublas::matrix&lt; typename functional::multiplies&lt; typename Left::value_type, typename Right::value_type &gt;::result_type &gt;</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>result_type</type><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></method>
</method-group>
</struct-specialization><struct name="outer_product_base"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="EnableIf"><default>void</default></template-type-parameter>
    </template><inherit access="public">functional::multiplies&lt; Left, Right &gt;</inherit></struct></namespace>
<namespace name="op">
<struct name="outer_product"/></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/density.hpp">
<namespace name="boost">
<namespace name="accumulators">
<struct-specialization name="as_weighted_feature"><template>
    </template><specialization><template-arg>tag::density</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_density</classname></type></typedef>
</struct-specialization><struct-specialization name="feature_of"><template>
    </template><specialization><template-arg>tag::weighted_density</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::density &gt;</inherit></struct-specialization><namespace name="extract">
<data-member name="density"><type><classname>extractor</classname>&lt; <classname>tag::density</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
<struct name="density"><inherit access="public">boost::accumulators::depends_on&lt; count, min, max &gt;</inherit><inherit access="public">density_cache_size</inherit><inherit access="public">density_num_bins</inherit><data-member name="cache_size" specifiers="static"><type>boost::parameter::keyword&lt; density_cache_size &gt; const</type><description><para>tag::density::cache_size named parameter tag::density::num_bins named parameter </para></description></data-member>
<data-member name="num_bins" specifiers="static"><type>boost::parameter::keyword&lt; density_num_bins &gt; const</type></data-member>
</struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/error_of.hpp">
<namespace name="boost">
<namespace name="accumulators">
<struct-specialization name="as_feature"><template>
      <template-type-parameter name="Feature"/>
    </template><specialization><template-arg>tag::error_of&lt; Feature &gt;</template-arg></specialization><typedef name="type"><type><classname>tag::error_of</classname>&lt; typename <classname>as_feature</classname>&lt; Feature &gt;::type &gt;</type></typedef>
</struct-specialization><struct-specialization name="as_weighted_feature"><template>
      <template-type-parameter name="Feature"/>
    </template><specialization><template-arg>tag::error_of&lt; Feature &gt;</template-arg></specialization><typedef name="type"><type><classname>tag::error_of</classname>&lt; typename <classname>as_weighted_feature</classname>&lt; Feature &gt;::type &gt;</type></typedef>
</struct-specialization><namespace name="extract">
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
</namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/error_of_mean.hpp">
<namespace name="boost">
<namespace name="accumulators">
<namespace name="impl">

</namespace>
<namespace name="tag">
<struct-specialization name="error_of"><template>
    </template><specialization><template-arg>immediate_mean</template-arg></specialization><inherit access="public">boost::accumulators::depends_on&lt; variance, count &gt;</inherit></struct-specialization><struct-specialization name="error_of"><template>
    </template><specialization><template-arg>mean</template-arg></specialization><inherit access="public">boost::accumulators::depends_on&lt; lazy_variance, count &gt;</inherit></struct-specialization></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/extended_p_square.hpp">
<namespace name="boost">
<namespace name="accumulators">
<struct-specialization name="as_weighted_feature"><template>
    </template><specialization><template-arg>tag::extended_p_square</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_extended_p_square</classname></type></typedef>
</struct-specialization><struct-specialization name="feature_of"><template>
    </template><specialization><template-arg>tag::weighted_extended_p_square</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::extended_p_square &gt;</inherit></struct-specialization><namespace name="extract">
<data-member name="extended_p_square"><type><classname>extractor</classname>&lt; <classname>tag::extended_p_square</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
<struct name="extended_p_square"><inherit access="public">boost::accumulators::depends_on&lt; count &gt;</inherit><inherit access="public">extended_p_square_probabilities</inherit><typedef name="impl"><type><classname>accumulators::impl::extended_p_square_impl</classname>&lt; mpl::_1 &gt;</type></typedef>
<data-member name="probabilities" specifiers="static"><type>boost::parameter::keyword&lt; tag::probabilities &gt; const</type><purpose>tag::extended_p_square::probabilities named parameter </purpose></data-member>
</struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/extended_p_square_quantile.hpp">
<namespace name="boost">
<namespace name="accumulators">
<struct-specialization name="as_feature"><template>
    </template><specialization><template-arg>tag::extended_p_square_quantile(linear)</template-arg></specialization><typedef name="type"><type><classname>tag::extended_p_square_quantile</classname></type></typedef>
</struct-specialization><struct-specialization name="as_feature"><template>
    </template><specialization><template-arg>tag::extended_p_square_quantile(quadratic)</template-arg></specialization><typedef name="type"><type><classname>tag::extended_p_square_quantile_quadratic</classname></type></typedef>
</struct-specialization><struct-specialization name="as_feature"><template>
    </template><specialization><template-arg>tag::weighted_extended_p_square_quantile(linear)</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_extended_p_square_quantile</classname></type></typedef>
</struct-specialization><struct-specialization name="as_feature"><template>
    </template><specialization><template-arg>tag::weighted_extended_p_square_quantile(quadratic)</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_extended_p_square_quantile_quadratic</classname></type></typedef>
</struct-specialization><struct-specialization name="as_weighted_feature"><template>
    </template><specialization><template-arg>tag::extended_p_square_quantile</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_extended_p_square_quantile</classname></type></typedef>
</struct-specialization><struct-specialization name="as_weighted_feature"><template>
    </template><specialization><template-arg>tag::extended_p_square_quantile_quadratic</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_extended_p_square_quantile_quadratic</classname></type></typedef>
</struct-specialization><struct-specialization name="feature_of"><template>
    </template><specialization><template-arg>tag::extended_p_square_quantile</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::quantile &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
    </template><specialization><template-arg>tag::extended_p_square_quantile_quadratic</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::quantile &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
    </template><specialization><template-arg>tag::weighted_extended_p_square_quantile</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::extended_p_square_quantile &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
    </template><specialization><template-arg>tag::weighted_extended_p_square_quantile_quadratic</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::extended_p_square_quantile_quadratic &gt;</inherit></struct-specialization><namespace name="extract">
<data-member name="extended_p_square_quantile"><type><classname>extractor</classname>&lt; <classname>tag::extended_p_square_quantile</classname> &gt; const</type></data-member>
<data-member name="extended_p_square_quantile_quadratic"><type><classname>extractor</classname>&lt; <classname>tag::extended_p_square_quantile_quadratic</classname> &gt; const</type></data-member>
<data-member name="weighted_extended_p_square_quantile"><type><classname>extractor</classname>&lt; <classname>tag::weighted_extended_p_square_quantile</classname> &gt; const</type></data-member>
<data-member name="weighted_extended_p_square_quantile_quadratic"><type><classname>extractor</classname>&lt; <classname>tag::weighted_extended_p_square_quantile_quadratic</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
<struct name="extended_p_square_quantile"><inherit access="public">boost::accumulators::depends_on&lt; extended_p_square &gt;</inherit><typedef name="impl"><type><classname>accumulators::impl::extended_p_square_quantile_impl</classname>&lt; mpl::_1, <classname>unweighted</classname>, <classname>linear</classname> &gt;</type></typedef>
</struct><struct name="extended_p_square_quantile_quadratic"><inherit access="public">boost::accumulators::depends_on&lt; extended_p_square &gt;</inherit><typedef name="impl"><type><classname>accumulators::impl::extended_p_square_quantile_impl</classname>&lt; mpl::_1, <classname>unweighted</classname>, <classname>quadratic</classname> &gt;</type></typedef>
</struct><struct name="weighted_extended_p_square_quantile"><inherit access="public">boost::accumulators::depends_on&lt; weighted_extended_p_square &gt;</inherit><typedef name="impl"><type><classname>accumulators::impl::extended_p_square_quantile_impl</classname>&lt; mpl::_1, <classname>weighted</classname>, <classname>linear</classname> &gt;</type></typedef>
</struct><struct name="weighted_extended_p_square_quantile_quadratic"><inherit access="public">boost::accumulators::depends_on&lt; weighted_extended_p_square &gt;</inherit><typedef name="impl"><type><classname>accumulators::impl::extended_p_square_quantile_impl</classname>&lt; mpl::_1, <classname>weighted</classname>, <classname>quadratic</classname> &gt;</type></typedef>
</struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/kurtosis.hpp">
<namespace name="boost">
<namespace name="accumulators">
<struct-specialization name="as_weighted_feature"><template>
    </template><specialization><template-arg>tag::kurtosis</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_kurtosis</classname></type></typedef>
</struct-specialization><struct-specialization name="feature_of"><template>
    </template><specialization><template-arg>tag::weighted_kurtosis</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::kurtosis &gt;</inherit></struct-specialization><namespace name="extract">
<data-member name="kurtosis"><type><classname>extractor</classname>&lt; <classname>tag::kurtosis</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
<struct name="kurtosis"><inherit access="public">boost::accumulators::depends_on&lt; mean, moment&lt; 2 &gt;, moment&lt; 3 &gt;, moment&lt; 4 &gt; &gt;</inherit></struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/max.hpp">
<namespace name="boost">
<namespace name="accumulators">
<namespace name="extract">
<data-member name="max"><type><classname>extractor</classname>&lt; <classname>tag::max</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
<struct name="max"><inherit access="public">boost::accumulators::depends_on&lt;&gt;</inherit></struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/mean.hpp">
<namespace name="boost">
<namespace name="accumulators">
<struct-specialization name="as_feature"><template>
    </template><specialization><template-arg>tag::mean(immediate)</template-arg></specialization><typedef name="type"><type><classname>tag::immediate_mean</classname></type></typedef>
</struct-specialization><struct-specialization name="as_feature"><template>
    </template><specialization><template-arg>tag::mean(lazy)</template-arg></specialization><typedef name="type"><type><classname>tag::mean</classname></type></typedef>
</struct-specialization><struct-specialization name="as_feature"><template>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><specialization><template-arg>tag::mean_of_variates&lt; VariateType</template-arg><template-arg>VariateTag &gt;(immediate)</template-arg></specialization><typedef name="type"><type><classname>tag::immediate_mean_of_variates</classname>&lt; VariateType, VariateTag &gt;</type></typedef>
</struct-specialization><struct-specialization name="as_feature"><template>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><specialization><template-arg>tag::mean_of_variates&lt; VariateType</template-arg><template-arg>VariateTag &gt;(lazy)</template-arg></specialization><typedef name="type"><type><classname>tag::mean_of_variates</classname>&lt; VariateType, VariateTag &gt;</type></typedef>
</struct-specialization><struct-specialization name="as_feature"><template>
    </template><specialization><template-arg>tag::mean_of_weights(immediate)</template-arg></specialization><typedef name="type"><type><classname>tag::immediate_mean_of_weights</classname></type></typedef>
</struct-specialization><struct-specialization name="as_feature"><template>
    </template><specialization><template-arg>tag::mean_of_weights(lazy)</template-arg></specialization><typedef name="type"><type><classname>tag::mean_of_weights</classname></type></typedef>
</struct-specialization><struct-specialization name="as_weighted_feature"><template>
    </template><specialization><template-arg>tag::immediate_mean</template-arg></specialization><typedef name="type"><type><classname>tag::immediate_weighted_mean</classname></type></typedef>
</struct-specialization><struct-specialization name="as_weighted_feature"><template>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><specialization><template-arg>tag::immediate_mean_of_variates&lt; VariateType</template-arg><template-arg>VariateTag &gt;</template-arg></specialization><typedef name="type"><type><classname>tag::immediate_weighted_mean_of_variates</classname>&lt; VariateType, VariateTag &gt;</type></typedef>
</struct-specialization><struct-specialization name="as_weighted_feature"><template>
    </template><specialization><template-arg>tag::mean</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_mean</classname></type></typedef>
</struct-specialization><struct-specialization name="as_weighted_feature"><template>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><specialization><template-arg>tag::mean_of_variates&lt; VariateType</template-arg><template-arg>VariateTag &gt;</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_mean_of_variates</classname>&lt; VariateType, VariateTag &gt;</type></typedef>
</struct-specialization><struct-specialization name="feature_of"><template>
    </template><specialization><template-arg>tag::immediate_mean</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::mean &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><specialization><template-arg>tag::immediate_mean_of_variates&lt; VariateType</template-arg><template-arg>VariateTag &gt;</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::mean_of_variates&lt; VariateType, VariateTag &gt; &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
    </template><specialization><template-arg>tag::immediate_mean_of_weights</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::mean_of_weights &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
    </template><specialization><template-arg>tag::immediate_weighted_mean</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::immediate_mean &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><specialization><template-arg>tag::immediate_weighted_mean_of_variates&lt; VariateType</template-arg><template-arg>VariateTag &gt;</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::immediate_mean_of_variates&lt; VariateType, VariateTag &gt; &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
    </template><specialization><template-arg>tag::weighted_mean</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::mean &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><specialization><template-arg>tag::weighted_mean_of_variates&lt; VariateType</template-arg><template-arg>VariateTag &gt;</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::mean_of_variates&lt; VariateType, VariateTag &gt; &gt;</inherit></struct-specialization><namespace name="extract">
<data-member name="mean"><type><classname>extractor</classname>&lt; <classname>tag::mean</classname> &gt; const</type></data-member>
<data-member name="mean_of_weights"><type><classname>extractor</classname>&lt; <classname>tag::mean_of_weights</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
<struct name="immediate_mean"><inherit access="public">boost::accumulators::depends_on&lt; count &gt;</inherit></struct><struct name="immediate_mean_of_weights"><inherit access="public">boost::accumulators::depends_on&lt; count &gt;</inherit><typedef name="is_weight_accumulator"><type>mpl::true_</type></typedef>
</struct><struct name="mean"><inherit access="public">boost::accumulators::depends_on&lt; count, sum &gt;</inherit></struct><struct name="mean_of_weights"><inherit access="public">boost::accumulators::depends_on&lt; count, sum_of_weights &gt;</inherit><typedef name="is_weight_accumulator"><type>mpl::true_</type></typedef>
</struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/median.hpp">
<namespace name="boost">
<namespace name="accumulators">
<struct-specialization name="as_feature"><template>
    </template><specialization><template-arg>tag::median(with_density)</template-arg></specialization><typedef name="type"><type><classname>tag::with_density_median</classname></type></typedef>
</struct-specialization><struct-specialization name="as_feature"><template>
    </template><specialization><template-arg>tag::median(with_p_square_cumulative_distribution)</template-arg></specialization><typedef name="type"><type><classname>tag::with_p_square_cumulative_distribution_median</classname></type></typedef>
</struct-specialization><struct-specialization name="as_feature"><template>
    </template><specialization><template-arg>tag::median(with_p_square_quantile)</template-arg></specialization><typedef name="type"><type><classname>tag::median</classname></type></typedef>
</struct-specialization><struct-specialization name="as_weighted_feature"><template>
    </template><specialization><template-arg>tag::median</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_median</classname></type></typedef>
</struct-specialization><struct-specialization name="as_weighted_feature"><template>
    </template><specialization><template-arg>tag::with_density_median</template-arg></specialization><typedef name="type"><type><classname>tag::with_density_weighted_median</classname></type></typedef>
</struct-specialization><struct-specialization name="as_weighted_feature"><template>
    </template><specialization><template-arg>tag::with_p_square_cumulative_distribution_median</template-arg></specialization><typedef name="type"><type><classname>tag::with_p_square_cumulative_distribution_weighted_median</classname></type></typedef>
</struct-specialization><struct-specialization name="feature_of"><template>
    </template><specialization><template-arg>tag::weighted_median</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::median &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
    </template><specialization><template-arg>tag::with_density_median</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::median &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
    </template><specialization><template-arg>tag::with_density_weighted_median</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::with_density_median &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
    </template><specialization><template-arg>tag::with_p_square_cumulative_distribution_median</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::median &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
    </template><specialization><template-arg>tag::with_p_square_cumulative_distribution_weighted_median</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::with_p_square_cumulative_distribution_median &gt;</inherit></struct-specialization><namespace name="extract">
<data-member name="median"><type><classname>extractor</classname>&lt; <classname>tag::median</classname> &gt; const</type></data-member>
<data-member name="with_density_median"><type><classname>extractor</classname>&lt; <classname>tag::with_density_median</classname> &gt; const</type></data-member>
<data-member name="with_p_square_cumulative_distribution_median"><type><classname>extractor</classname>&lt; <classname>tag::with_p_square_cumulative_distribution_median</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
<struct name="median"><inherit access="public">boost::accumulators::depends_on&lt; p_square_quantile_for_median &gt;</inherit></struct><struct name="with_density_median"><inherit access="public">boost::accumulators::depends_on&lt; count, density &gt;</inherit></struct><struct name="with_p_square_cumulative_distribution_median"><inherit access="public">boost::accumulators::depends_on&lt; p_square_cumulative_distribution &gt;</inherit></struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/min.hpp">
<namespace name="boost">
<namespace name="accumulators">
<namespace name="extract">
<data-member name="min"><type><classname>extractor</classname>&lt; <classname>tag::min</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
<struct name="min"><inherit access="public">boost::accumulators::depends_on&lt;&gt;</inherit></struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/moment.hpp">
<namespace name="boost">
<namespace name="accumulators">
<struct-specialization name="as_weighted_feature"><template>
      <template-nontype-parameter name="N"><type>int</type></template-nontype-parameter>
    </template><specialization><template-arg>tag::moment&lt; N &gt;</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_moment</classname>&lt; N &gt;</type></typedef>
</struct-specialization><struct-specialization name="feature_of"><template>
      <template-nontype-parameter name="N"><type>int</type></template-nontype-parameter>
    </template><specialization><template-arg>tag::weighted_moment&lt; N &gt;</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::moment&lt; N &gt; &gt;</inherit></struct-specialization><namespace name="extract">
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
</namespace>
</namespace>
<namespace name="numeric">
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/p_square_cumul_dist.hpp">
<namespace name="boost">
<namespace name="accumulators">
<struct-specialization name="as_weighted_feature"><template>
    </template><specialization><template-arg>tag::p_square_cumulative_distribution</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_p_square_cumulative_distribution</classname></type></typedef>
</struct-specialization><struct-specialization name="feature_of"><template>
    </template><specialization><template-arg>tag::weighted_p_square_cumulative_distribution</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::p_square_cumulative_distribution &gt;</inherit></struct-specialization><namespace name="extract">
<data-member name="p_square_cumulative_distribution"><type><classname>extractor</classname>&lt; <classname>tag::p_square_cumulative_distribution</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
<struct name="p_square_cumulative_distribution"><inherit access="public">boost::accumulators::depends_on&lt; count &gt;</inherit><inherit access="public">p_square_cumulative_distribution_num_cells</inherit></struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/p_square_cumulative_distribution.hpp">
</header>
<header name="boost/accumulators/statistics/p_square_quantile.hpp">
<namespace name="boost">
<namespace name="accumulators">
<struct-specialization name="as_weighted_feature"><template>
    </template><specialization><template-arg>tag::p_square_quantile</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_p_square_quantile</classname></type></typedef>
</struct-specialization><struct-specialization name="feature_of"><template>
    </template><specialization><template-arg>tag::weighted_p_square_quantile</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::p_square_quantile &gt;</inherit></struct-specialization><namespace name="extract">
<data-member name="p_square_quantile"><type><classname>extractor</classname>&lt; <classname>tag::p_square_quantile</classname> &gt; const</type></data-member>
<data-member name="p_square_quantile_for_median"><type><classname>extractor</classname>&lt; <classname>tag::p_square_quantile_for_median</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
<struct name="p_square_quantile"><inherit access="public">boost::accumulators::depends_on&lt; count &gt;</inherit></struct><struct name="p_square_quantile_for_median"><inherit access="public">boost::accumulators::depends_on&lt; count &gt;</inherit></struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/peaks_over_threshold.hpp">
<namespace name="boost">
<namespace name="accumulators">
<struct-specialization name="as_feature"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::peaks_over_threshold&lt; LeftRight &gt;(with_threshold_probability)</template-arg></specialization><typedef name="type"><type><classname>tag::peaks_over_threshold_prob</classname>&lt; LeftRight &gt;</type></typedef>
</struct-specialization><struct-specialization name="as_feature"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::peaks_over_threshold&lt; LeftRight &gt;(with_threshold_value)</template-arg></specialization><typedef name="type"><type><classname>tag::peaks_over_threshold</classname>&lt; LeftRight &gt;</type></typedef>
</struct-specialization><struct-specialization name="as_weighted_feature"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::peaks_over_threshold&lt; LeftRight &gt;</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_peaks_over_threshold</classname>&lt; LeftRight &gt;</type></typedef>
</struct-specialization><struct-specialization name="as_weighted_feature"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::peaks_over_threshold_prob&lt; LeftRight &gt;</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_peaks_over_threshold_prob</classname>&lt; LeftRight &gt;</type></typedef>
</struct-specialization><struct-specialization name="feature_of"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::peaks_over_threshold&lt; LeftRight &gt;</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::abstract_peaks_over_threshold &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::peaks_over_threshold_prob&lt; LeftRight &gt;</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::abstract_peaks_over_threshold &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::weighted_peaks_over_threshold&lt; LeftRight &gt;</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::peaks_over_threshold&lt; LeftRight &gt; &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::weighted_peaks_over_threshold_prob&lt; LeftRight &gt;</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::peaks_over_threshold_prob&lt; LeftRight &gt; &gt;</inherit></struct-specialization><namespace name="extract">
<data-member name="peaks_over_threshold"><type><classname>extractor</classname>&lt; <classname>tag::abstract_peaks_over_threshold</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">
<struct name="peaks_over_threshold_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="LeftRight"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Peaks over Threshold Method for Quantile and Tail Mean Estimation. </purpose><description><para>According to the theorem of Pickands-Balkema-de Haan, the distribution function <inlineequation><alt>$F_u(x)$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_90.png"/></imageobject><textobject role="tex"><phrase>$F_u(x)$</phrase></textobject></inlinemediaobject></inlineequation> of the excesses <inlineequation><alt>$x$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_91.png"/></imageobject><textobject role="tex"><phrase>$x$</phrase></textobject></inlinemediaobject></inlineequation> over some sufficiently high threshold <inlineequation><alt>$u$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_92.png"/></imageobject><textobject role="tex"><phrase>$u$</phrase></textobject></inlinemediaobject></inlineequation> of a distribution function <inlineequation><alt>$F(x)$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_93.png"/></imageobject><textobject role="tex"><phrase>$F(x)$</phrase></textobject></inlinemediaobject></inlineequation> may be approximated by a generalized Pareto distribution <equation><title/><alt>\[ G_{\xi,\beta}(x) = \left\{ \begin{array}{ll} \beta^{-1}\left(1+\frac{\xi x}{\beta}\right)^{-1/\xi-1} &amp; \textrm{if }\xi\neq0\\ \beta^{-1}\exp\left(-\frac{x}{\beta}\right) &amp; \textrm{if }\xi=0, \end{array} \right. \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_94.png"/></imageobject><textobject role="tex"><phrase>\[ G_{\xi,\beta}(x) = \left\{ \begin{array}{ll} \beta^{-1}\left(1+\frac{\xi x}{\beta}\right)^{-1/\xi-1} &amp; \textrm{if }\xi\neq0\\ \beta^{-1}\exp\left(-\frac{x}{\beta}\right) &amp; \textrm{if }\xi=0, \end{array} \right. \]</phrase></textobject></mediaobject></equation> with suitable parameters <inlineequation><alt>$\xi$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_88.png"/></imageobject><textobject role="tex"><phrase>$\xi$</phrase></textobject></inlinemediaobject></inlineequation> and <inlineequation><alt>$\beta$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_95.png"/></imageobject><textobject role="tex"><phrase>$\beta$</phrase></textobject></inlinemediaobject></inlineequation> that can be estimated, e.g., with the method of moments, cf. Hosking and Wallis (1987), <equation><title/><alt>\[ \begin{array}{lll} \hat{\xi} &amp; = &amp; \frac{1}{2}\left[1-\frac{(\hat{\mu}-u)^2}{\hat{\sigma}^2}\right]\\ \hat{\beta} &amp; = &amp; \frac{\hat{\mu}-u}{2}\left[\frac{(\hat{\mu}-u)^2}{\hat{\sigma}^2}+1\right], \end{array} \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_96.png"/></imageobject><textobject role="tex"><phrase>\[ \begin{array}{lll} \hat{\xi} &amp; = &amp; \frac{1}{2}\left[1-\frac{(\hat{\mu}-u)^2}{\hat{\sigma}^2}\right]\\ \hat{\beta} &amp; = &amp; \frac{\hat{\mu}-u}{2}\left[\frac{(\hat{\mu}-u)^2}{\hat{\sigma}^2}+1\right], \end{array} \]</phrase></textobject></mediaobject></equation> <inlineequation><alt>$\hat{\mu}$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_97.png"/></imageobject><textobject role="tex"><phrase>$\hat{\mu}$</phrase></textobject></inlinemediaobject></inlineequation> and <inlineequation><alt>$\hat{\sigma}^2$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_98.png"/></imageobject><textobject role="tex"><phrase>$\hat{\sigma}^2$</phrase></textobject></inlinemediaobject></inlineequation> being the empirical mean and variance of the samples over the threshold <inlineequation><alt>$u$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_92.png"/></imageobject><textobject role="tex"><phrase>$u$</phrase></textobject></inlinemediaobject></inlineequation>. Equivalently, the distribution function <inlineequation><alt>$F_u(x-u)$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_99.png"/></imageobject><textobject role="tex"><phrase>$F_u(x-u)$</phrase></textobject></inlinemediaobject></inlineequation> of the exceedances <inlineequation><alt>$x-u$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_100.png"/></imageobject><textobject role="tex"><phrase>$x-u$</phrase></textobject></inlinemediaobject></inlineequation> can be approximated by <inlineequation><alt>$G_{\xi,\beta}(x-u)=G_{\xi,\beta,u}(x)$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_101.png"/></imageobject><textobject role="tex"><phrase>$G_{\xi,\beta}(x-u)=G_{\xi,\beta,u}(x)$</phrase></textobject></inlinemediaobject></inlineequation>. Since for <inlineequation><alt>$x\geq u$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_102.png"/></imageobject><textobject role="tex"><phrase>$x\geq u$</phrase></textobject></inlinemediaobject></inlineequation> the distribution function <inlineequation><alt>$F(x)$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_93.png"/></imageobject><textobject role="tex"><phrase>$F(x)$</phrase></textobject></inlinemediaobject></inlineequation> can be written as <equation><title/><alt>\[ F(x) = [1 - \P(X \leq u)]F_u(x - u) + \P(X \leq u) \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_103.png"/></imageobject><textobject role="tex"><phrase>\[ F(x) = [1 - \P(X \leq u)]F_u(x - u) + \P(X \leq u) \]</phrase></textobject></mediaobject></equation> and the probability <inlineequation><alt>$\P(X \leq u)$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_104.png"/></imageobject><textobject role="tex"><phrase>$\P(X \leq u)$</phrase></textobject></inlinemediaobject></inlineequation> can be approximated by the empirical distribution function <inlineequation><alt>$F_n(u)$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_105.png"/></imageobject><textobject role="tex"><phrase>$F_n(u)$</phrase></textobject></inlinemediaobject></inlineequation> evaluated at <inlineequation><alt>$u$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_92.png"/></imageobject><textobject role="tex"><phrase>$u$</phrase></textobject></inlinemediaobject></inlineequation>, an estimator of <inlineequation><alt>$F(x)$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_93.png"/></imageobject><textobject role="tex"><phrase>$F(x)$</phrase></textobject></inlinemediaobject></inlineequation> is given by <equation><title/><alt>\[ \widehat{F}(x) = [1 - F_n(u)]G_{\xi,\beta,u}(x) + F_n(u). \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_106.png"/></imageobject><textobject role="tex"><phrase>\[ \widehat{F}(x) = [1 - F_n(u)]G_{\xi,\beta,u}(x) + F_n(u). \]</phrase></textobject></mediaobject></equation> It can be shown that <inlineequation><alt>$\widehat{F}(x)$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_107.png"/></imageobject><textobject role="tex"><phrase>$\widehat{F}(x)$</phrase></textobject></inlinemediaobject></inlineequation> is a generalized Pareto distribution <inlineequation><alt>$G_{\xi,\bar{\beta},\bar{u}}(x)$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_108.png"/></imageobject><textobject role="tex"><phrase>$G_{\xi,\bar{\beta},\bar{u}}(x)$</phrase></textobject></inlinemediaobject></inlineequation> with <inlineequation><alt>$\bar{\beta}=\beta[1-F_n(u)]^{\xi}$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_109.png"/></imageobject><textobject role="tex"><phrase>$\bar{\beta}=\beta[1-F_n(u)]^{\xi}$</phrase></textobject></inlinemediaobject></inlineequation> and <inlineequation><alt>$\bar{u}=u-\bar{\beta}\left\{[1-F_n(u)]^{-\xi}-1\right\}/\xi$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_110.png"/></imageobject><textobject role="tex"><phrase>$\bar{u}=u-\bar{\beta}\left\{[1-F_n(u)]^{-\xi}-1\right\}/\xi$</phrase></textobject></inlinemediaobject></inlineequation>. By inverting <inlineequation><alt>$\widehat{F}(x)$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_107.png"/></imageobject><textobject role="tex"><phrase>$\widehat{F}(x)$</phrase></textobject></inlinemediaobject></inlineequation>, one obtains an estimator for the <inlineequation><alt>$\alpha$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_20.png"/></imageobject><textobject role="tex"><phrase>$\alpha$</phrase></textobject></inlinemediaobject></inlineequation>-quantile, <equation><title/><alt>\[ \hat{q}_{\alpha} = \bar{u} + \frac{\bar{\beta}}{\xi}\left[(1-\alpha)^{-\xi}-1\right], \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_111.png"/></imageobject><textobject role="tex"><phrase>\[ \hat{q}_{\alpha} = \bar{u} + \frac{\bar{\beta}}{\xi}\left[(1-\alpha)^{-\xi}-1\right], \]</phrase></textobject></mediaobject></equation> and similarly an estimator for the (coherent) tail mean, <equation><title/><alt>\[ \widehat{CTM}_{\alpha} = \hat{q}_{\alpha} - \frac{\bar{\beta}}{\xi-1}(1-\alpha)^{-\xi}, \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_85.png"/></imageobject><textobject role="tex"><phrase>\[ \widehat{CTM}_{\alpha} = \hat{q}_{\alpha} - \frac{\bar{\beta}}{\xi-1}(1-\alpha)^{-\xi}, \]</phrase></textobject></mediaobject></equation> cf. McNeil and Frey (2000).</para><para>Note that in case extreme values of the left tail are fitted, the distribution is mirrored with respect to the <inlineequation><alt>$y$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_112.png"/></imageobject><textobject role="tex"><phrase>$y$</phrase></textobject></inlinemediaobject></inlineequation> axis such that the left tail can be treated as a right tail. The computed fit parameters thus define the Pareto distribution that fits the mirrored left tail. When quantities like a quantile or a tail mean are computed using the fit parameters obtained from the mirrored data, the result is mirrored back, yielding the correct result.</para><para>For further details, see</para><para>J. R. M. Hosking and J. R. Wallis, Parameter and quantile estimation for the generalized Pareto distribution, Technometrics, Volume 29, 1987, p. 339-349</para><para>A. J. McNeil and R. Frey, Estimation of Tail-Related Risk Measures for Heteroscedastic Financial Time Series: an Extreme Value Approach, Journal of Empirical Finance, Volume 7, 2000, p. 271-300</para><para>
</para></description><typedef name="float_type"><type>numeric::functional::fdiv&lt; Sample, std::size_t &gt;::result_type</type></typedef>
<typedef name="result_type"><type>boost::tuple&lt; float_type, float_type, float_type &gt;</type></typedef>
<typedef name="sign"><type>mpl::int_&lt; is_same&lt; LeftRight, <classname>left</classname> &gt;::value ? -1 :1 &gt;</type></typedef>
<method-group name="public member functions">
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></constructor>
</struct>
</namespace>
<namespace name="tag">
<struct name="abstract_peaks_over_threshold"><inherit access="public">boost::accumulators::depends_on&lt;&gt;</inherit></struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/pot_quantile.hpp">
<namespace name="boost">
<namespace name="accumulators">
<struct-specialization name="as_feature"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::pot_quantile&lt; LeftRight &gt;(with_threshold_probability)</template-arg></specialization><typedef name="type"><type><classname>tag::pot_quantile_prob</classname>&lt; LeftRight &gt;</type></typedef>
</struct-specialization><struct-specialization name="as_feature"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::pot_quantile&lt; LeftRight &gt;(with_threshold_value)</template-arg></specialization><typedef name="type"><type><classname>tag::pot_quantile</classname>&lt; LeftRight &gt;</type></typedef>
</struct-specialization><struct-specialization name="as_feature"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::weighted_pot_quantile&lt; LeftRight &gt;(with_threshold_probability)</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_pot_quantile_prob</classname>&lt; LeftRight &gt;</type></typedef>
</struct-specialization><struct-specialization name="as_feature"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::weighted_pot_quantile&lt; LeftRight &gt;(with_threshold_value)</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_pot_quantile</classname>&lt; LeftRight &gt;</type></typedef>
</struct-specialization><struct-specialization name="as_weighted_feature"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::pot_quantile&lt; LeftRight &gt;</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_pot_quantile</classname>&lt; LeftRight &gt;</type></typedef>
</struct-specialization><struct-specialization name="as_weighted_feature"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::pot_quantile_prob&lt; LeftRight &gt;</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_pot_quantile_prob</classname>&lt; LeftRight &gt;</type></typedef>
</struct-specialization><struct-specialization name="feature_of"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::pot_quantile&lt; LeftRight &gt;</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::quantile &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::pot_quantile_prob&lt; LeftRight &gt;</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::quantile &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::weighted_pot_quantile&lt; LeftRight &gt;</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::pot_quantile&lt; LeftRight &gt; &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::weighted_pot_quantile_prob&lt; LeftRight &gt;</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::pot_quantile_prob&lt; LeftRight &gt; &gt;</inherit></struct-specialization><namespace name="impl">

</namespace>
<namespace name="tag">
</namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/pot_tail_mean.hpp">
<namespace name="boost">
<namespace name="accumulators">
<struct-specialization name="as_feature"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::pot_tail_mean&lt; LeftRight &gt;(with_threshold_probability)</template-arg></specialization><typedef name="type"><type><classname>tag::pot_tail_mean_prob</classname>&lt; LeftRight &gt;</type></typedef>
</struct-specialization><struct-specialization name="as_feature"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::pot_tail_mean&lt; LeftRight &gt;(with_threshold_value)</template-arg></specialization><typedef name="type"><type><classname>tag::pot_tail_mean</classname>&lt; LeftRight &gt;</type></typedef>
</struct-specialization><struct-specialization name="as_feature"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::weighted_pot_tail_mean&lt; LeftRight &gt;(with_threshold_probability)</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_pot_tail_mean_prob</classname>&lt; LeftRight &gt;</type></typedef>
</struct-specialization><struct-specialization name="as_feature"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::weighted_pot_tail_mean&lt; LeftRight &gt;(with_threshold_value)</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_pot_tail_mean</classname>&lt; LeftRight &gt;</type></typedef>
</struct-specialization><struct-specialization name="as_weighted_feature"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::pot_tail_mean&lt; LeftRight &gt;</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_pot_tail_mean</classname>&lt; LeftRight &gt;</type></typedef>
</struct-specialization><struct-specialization name="as_weighted_feature"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::pot_tail_mean_prob&lt; LeftRight &gt;</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_pot_tail_mean_prob</classname>&lt; LeftRight &gt;</type></typedef>
</struct-specialization><struct-specialization name="feature_of"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::pot_tail_mean&lt; LeftRight &gt;</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::tail_mean &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::pot_tail_mean_prob&lt; LeftRight &gt;</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::tail_mean &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::weighted_pot_tail_mean&lt; LeftRight &gt;</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::pot_tail_mean&lt; LeftRight &gt; &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::weighted_pot_tail_mean_prob&lt; LeftRight &gt;</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::pot_tail_mean_prob&lt; LeftRight &gt; &gt;</inherit></struct-specialization><namespace name="impl">

</namespace>
<namespace name="tag">
</namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/rolling_count.hpp">
<namespace name="boost">
<namespace name="accumulators">
<namespace name="extract">
<data-member name="rolling_count"><type><classname>extractor</classname>&lt; <classname>tag::rolling_count</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
<struct name="rolling_count"><inherit access="public">boost::accumulators::depends_on&lt; rolling_window_plus1 &gt;</inherit><data-member name="window_size" specifiers="static"><type>boost::parameter::keyword&lt; tag::rolling_window_size &gt; const</type><purpose>tag::rolling_window::window_size named parameter </purpose></data-member>
</struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/rolling_mean.hpp">
<namespace name="boost">
<namespace name="accumulators">
<struct-specialization name="as_feature"><template>
    </template><specialization><template-arg>tag::rolling_mean(immediate)</template-arg></specialization><typedef name="type"><type><classname>tag::immediate_rolling_mean</classname></type></typedef>
</struct-specialization><struct-specialization name="as_feature"><template>
    </template><specialization><template-arg>tag::rolling_mean(lazy)</template-arg></specialization><typedef name="type"><type><classname>tag::lazy_rolling_mean</classname></type></typedef>
</struct-specialization><struct-specialization name="feature_of"><template>
    </template><specialization><template-arg>tag::immediate_rolling_mean</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::rolling_mean &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
    </template><specialization><template-arg>tag::lazy_rolling_mean</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::rolling_mean &gt;</inherit></struct-specialization><namespace name="extract">
<data-member name="lazy_rolling_mean"><type><classname>extractor</classname>&lt; <classname>tag::lazy_rolling_mean</classname> &gt; const</type></data-member>
<data-member name="immediate_rolling_mean"><type><classname>extractor</classname>&lt; <classname>tag::immediate_rolling_mean</classname> &gt; const</type></data-member>
<data-member name="rolling_mean"><type><classname>extractor</classname>&lt; <classname>tag::rolling_mean</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">
<struct name="immediate_rolling_mean_impl"><template>
      <template-type-parameter name="Sample"/>
    </template><inherit access="public">accumulator_base</inherit><typedef name="result_type"><type>numeric::functional::fdiv&lt; Sample, std::size_t &gt;::result_type</type></typedef>
<method-group name="public member functions">
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name=""><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></constructor>
</struct><struct name="lazy_rolling_mean_impl"><template>
      <template-type-parameter name="Sample"/>
    </template><inherit access="public">accumulator_base</inherit><typedef name="result_type"><type>numeric::functional::fdiv&lt; Sample, std::size_t, void, void &gt;::result_type</type></typedef>
<method-group name="public member functions">
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><parameter name=""><paramtype>dont_care</paramtype></parameter></constructor>
</struct>
</namespace>
<namespace name="tag">
<struct name="immediate_rolling_mean"><inherit access="public">boost::accumulators::depends_on&lt; rolling_window_plus1, rolling_count &gt;</inherit><data-member name="window_size" specifiers="static"><type>boost::parameter::keyword&lt; tag::rolling_window_size &gt; const</type><purpose>tag::rolling_window::window_size named parameter </purpose></data-member>
</struct><struct name="lazy_rolling_mean"><inherit access="public">boost::accumulators::depends_on&lt; rolling_sum, rolling_count &gt;</inherit><data-member name="window_size" specifiers="static"><type>boost::parameter::keyword&lt; tag::rolling_window_size &gt; const</type><purpose>tag::rolling_window::window_size named parameter </purpose></data-member>
</struct><struct name="rolling_mean"><inherit access="public">boost::accumulators::tag::immediate_rolling_mean</inherit></struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/rolling_moment.hpp">
<namespace name="boost">
<namespace name="accumulators">
<namespace name="extract">
</namespace>
<namespace name="impl">
<struct name="rolling_moment_impl"><template>
      <template-type-parameter name="N"/>
      <template-type-parameter name="Sample"/>
    </template><inherit access="public">accumulator_base</inherit><typedef name="result_type"><type>numeric::functional::fdiv&lt; Sample, std::size_t, void, void &gt;::result_type</type></typedef>
<method-group name="public member functions">
<method name="BOOST_MPL_ASSERT_RELATION"><type/><parameter name=""><paramtype>N::value</paramtype></parameter><parameter name=""><paramtype>0</paramtype></parameter></method>
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></constructor>
</struct>
</namespace>
<namespace name="tag">
<struct name="rolling_moment"><template>
      <template-nontype-parameter name="N"><type>int</type></template-nontype-parameter>
    </template><inherit access="public">boost::accumulators::depends_on&lt; rolling_window_plus1, rolling_count &gt;</inherit><data-member name="window_size" specifiers="static"><type>boost::parameter::keyword&lt; tag::rolling_window_size &gt; const</type><purpose>tag::rolling_window::window_size named parameter </purpose></data-member>
</struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/rolling_sum.hpp">
<namespace name="boost">
<namespace name="accumulators">
<namespace name="extract">
<data-member name="rolling_sum"><type><classname>extractor</classname>&lt; <classname>tag::rolling_sum</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
<struct name="rolling_sum"><inherit access="public">boost::accumulators::depends_on&lt; rolling_window_plus1 &gt;</inherit><data-member name="window_size" specifiers="static"><type>boost::parameter::keyword&lt; tag::rolling_window_size &gt; const</type><purpose>tag::rolling_window::window_size named parameter </purpose></data-member>
</struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/rolling_variance.hpp">
<namespace name="boost">
<namespace name="accumulators">
<struct-specialization name="as_feature"><template>
    </template><specialization><template-arg>tag::rolling_variance(immediate)</template-arg></specialization><typedef name="type"><type><classname>tag::immediate_rolling_variance</classname></type></typedef>
</struct-specialization><struct-specialization name="as_feature"><template>
    </template><specialization><template-arg>tag::rolling_variance(lazy)</template-arg></specialization><typedef name="type"><type><classname>tag::lazy_rolling_variance</classname></type></typedef>
</struct-specialization><struct-specialization name="feature_of"><template>
    </template><specialization><template-arg>tag::immediate_rolling_variance</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::rolling_variance &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
    </template><specialization><template-arg>tag::lazy_rolling_variance</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::rolling_variance &gt;</inherit></struct-specialization><namespace name="extract">
<data-member name="lazy_rolling_variance"><type><classname>extractor</classname>&lt; <classname>tag::lazy_rolling_variance</classname> &gt; const</type></data-member>
<data-member name="immediate_rolling_variance"><type><classname>extractor</classname>&lt; <classname>tag::immediate_rolling_variance</classname> &gt; const</type></data-member>
<data-member name="rolling_variance"><type><classname>extractor</classname>&lt; <classname>tag::rolling_variance</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">
<struct name="immediate_rolling_variance_impl"><template>
      <template-type-parameter name="Sample"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Iterative calculation of the rolling variance. </purpose><description><para>Iterative calculation of sample variance <inlineequation><alt>$\sigma_n^2$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_55.png"/></imageobject><textobject role="tex"><phrase>$\sigma_n^2$</phrase></textobject></inlinemediaobject></inlineequation> is done as follows, see also <ulink url="http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance">http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance</ulink>. For a rolling window of size <inlineequation><alt>$N$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_72.png"/></imageobject><textobject role="tex"><phrase>$N$</phrase></textobject></inlinemediaobject></inlineequation>, for the first <inlineequation><alt>$N$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_72.png"/></imageobject><textobject role="tex"><phrase>$N$</phrase></textobject></inlinemediaobject></inlineequation> samples, the variance is computed according to the formula <equation><title/><alt>\[ \sigma_n^2 = \frac{1}{n-1} \sum_{i = 1}^n (x_i - \mu_n)^2 = \frac{1}{n-1}M_{2,n}, \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_77.png"/></imageobject><textobject role="tex"><phrase>\[ \sigma_n^2 = \frac{1}{n-1} \sum_{i = 1}^n (x_i - \mu_n)^2 = \frac{1}{n-1}M_{2,n}, \]</phrase></textobject></mediaobject></equation> where the sum of squares <inlineequation><alt>$M_{2,n}$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_78.png"/></imageobject><textobject role="tex"><phrase>$M_{2,n}$</phrase></textobject></inlinemediaobject></inlineequation> can be recursively computed as: <equation><title/><alt>\[ M_{2,n} = \sum_{i = 1}^n (x_i - \mu_n)^2 = M_{2,n-1} + (x_n - \mu_n)(x_n - \mu_{n-1}), \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_79.png"/></imageobject><textobject role="tex"><phrase>\[ M_{2,n} = \sum_{i = 1}^n (x_i - \mu_n)^2 = M_{2,n-1} + (x_n - \mu_n)(x_n - \mu_{n-1}), \]</phrase></textobject></mediaobject></equation> and the estimate of the sample mean as: <equation><title/><alt>\[ \mu_n = \frac{1}{n} \sum_{i = 1}^n x_i = \mu_{n-1} + \frac{1}{n}(x_n - \mu_{n-1}). \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_80.png"/></imageobject><textobject role="tex"><phrase>\[ \mu_n = \frac{1}{n} \sum_{i = 1}^n x_i = \mu_{n-1} + \frac{1}{n}(x_n - \mu_{n-1}). \]</phrase></textobject></mediaobject></equation> For further samples, when the rolling window is fully filled with data, one has to take into account that the oldest sample <inlineequation><alt>$x_{n-N}$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_81.png"/></imageobject><textobject role="tex"><phrase>$x_{n-N}$</phrase></textobject></inlinemediaobject></inlineequation> is dropped from the window. The sample variance over the window now becomes: <equation><title/><alt>\[ \sigma_n^2 = \frac{1}{N-1} \sum_{i = n-N+1}^n (x_i - \mu_n)^2 = \frac{1}{n-1}M_{2,n}, \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_82.png"/></imageobject><textobject role="tex"><phrase>\[ \sigma_n^2 = \frac{1}{N-1} \sum_{i = n-N+1}^n (x_i - \mu_n)^2 = \frac{1}{n-1}M_{2,n}, \]</phrase></textobject></mediaobject></equation> where the sum of squares <inlineequation><alt>$M_{2,n}$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_78.png"/></imageobject><textobject role="tex"><phrase>$M_{2,n}$</phrase></textobject></inlinemediaobject></inlineequation> now equals: <equation><title/><alt>\[ M_{2,n} = \sum_{i = n-N+1}^n (x_i - \mu_n)^2 = M_{2,n-1} + (x_n - \mu_n)(x_n - \mu_{n-1}) - (x_{n-N} - \mu_n)(x_{n-N} - \mu_{n-1}), \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_83.png"/></imageobject><textobject role="tex"><phrase>\[ M_{2,n} = \sum_{i = n-N+1}^n (x_i - \mu_n)^2 = M_{2,n-1} + (x_n - \mu_n)(x_n - \mu_{n-1}) - (x_{n-N} - \mu_n)(x_{n-N} - \mu_{n-1}), \]</phrase></textobject></mediaobject></equation> and the estimated mean is: <equation><title/><alt>\[ \mu_n = \frac{1}{N} \sum_{i = n-N+1}^n x_i = \mu_{n-1} + \frac{1}{n}(x_n - x_{n-N}). \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_84.png"/></imageobject><textobject role="tex"><phrase>\[ \mu_n = \frac{1}{N} \sum_{i = n-N+1}^n x_i = \mu_{n-1} + \frac{1}{n}(x_n - x_{n-N}). \]</phrase></textobject></mediaobject></equation></para><para>Note that the sample variance is not defined for <inlineequation><alt>$n &lt;= 1$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_8.png"/></imageobject><textobject role="tex"><phrase>$n &lt;= 1$</phrase></textobject></inlinemediaobject></inlineequation>. </para></description><typedef name="result_type"><type>numeric::functional::fdiv&lt; Sample, std::size_t &gt;::result_type</type></typedef>
<method-group name="public member functions">
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></constructor>
<method-group name="private member functions">
<method name="prevent_underflow"><type>void</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="non_negative_number"><paramtype>T &amp;</paramtype></parameter><parameter name=""><paramtype>typename boost::enable_if&lt; boost::is_arithmetic&lt; T &gt;, T &gt;::type *</paramtype><default>0</default></parameter></method>
<method name="prevent_underflow"><type>void</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="non_arithmetic_quantity"><paramtype>T &amp;</paramtype></parameter><parameter name=""><paramtype>typename boost::disable_if&lt; boost::is_arithmetic&lt; T &gt;, T &gt;::type *</paramtype><default>0</default></parameter></method>
</method-group>
</struct><struct name="lazy_rolling_variance_impl"><template>
      <template-type-parameter name="Sample"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Immediate (lazy) calculation of the rolling variance. </purpose><description><para>Calculation of sample variance <inlineequation><alt>$\sigma_n^2$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_55.png"/></imageobject><textobject role="tex"><phrase>$\sigma_n^2$</phrase></textobject></inlinemediaobject></inlineequation> is done as follows, see also <ulink url="http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance">http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance</ulink>. For a rolling window of size <inlineequation><alt>$N$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_72.png"/></imageobject><textobject role="tex"><phrase>$N$</phrase></textobject></inlinemediaobject></inlineequation>, when <inlineequation><alt>$n &lt;= N$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_73.png"/></imageobject><textobject role="tex"><phrase>$n &lt;= N$</phrase></textobject></inlinemediaobject></inlineequation>, the variance is computed according to the formula <equation><title/><alt>\[ \sigma_n^2 = \frac{1}{n-1} \sum_{i = 1}^n (x_i - \mu_n)^2. \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_74.png"/></imageobject><textobject role="tex"><phrase>\[ \sigma_n^2 = \frac{1}{n-1} \sum_{i = 1}^n (x_i - \mu_n)^2. \]</phrase></textobject></mediaobject></equation> When <inlineequation><alt>$n &gt; N$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_75.png"/></imageobject><textobject role="tex"><phrase>$n &gt; N$</phrase></textobject></inlinemediaobject></inlineequation>, the sample variance over the window becomes: <equation><title/><alt>\[ \sigma_n^2 = \frac{1}{N-1} \sum_{i = n-N+1}^n (x_i - \mu_n)^2. \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_76.png"/></imageobject><textobject role="tex"><phrase>\[ \sigma_n^2 = \frac{1}{N-1} \sum_{i = n-N+1}^n (x_i - \mu_n)^2. \]</phrase></textobject></mediaobject></equation> </para></description><typedef name="result_type"><type>numeric::functional::fdiv&lt; Sample, std::size_t, void, void &gt;::result_type</type></typedef>
<method-group name="public member functions">
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><parameter name=""><paramtype>dont_care</paramtype></parameter></constructor>
</struct>
</namespace>
<namespace name="tag">
<struct name="immediate_rolling_variance"><inherit access="public">boost::accumulators::depends_on&lt; rolling_window_plus1, rolling_count, immediate_rolling_mean &gt;</inherit><data-member name="window_size" specifiers="static"><type>boost::parameter::keyword&lt; tag::rolling_window_size &gt; const</type><purpose>tag::rolling_window::window_size named parameter </purpose></data-member>
</struct><struct name="lazy_rolling_variance"><inherit access="public">boost::accumulators::depends_on&lt; rolling_count, rolling_mean, rolling_moment&lt; 2 &gt; &gt;</inherit><data-member name="window_size" specifiers="static"><type>boost::parameter::keyword&lt; tag::rolling_window_size &gt; const</type><purpose>tag::rolling_window::window_size named parameter </purpose></data-member>
</struct><struct name="rolling_variance"><inherit access="public">boost::accumulators::tag::immediate_rolling_variance</inherit></struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/rolling_window.hpp">
<namespace name="boost">
<namespace name="accumulators">
<namespace name="extract">
<data-member name="rolling_window_plus1"><type><classname>extractor</classname>&lt; <classname>tag::rolling_window_plus1</classname> &gt; const</type></data-member>
<data-member name="rolling_window"><type><classname>extractor</classname>&lt; <classname>tag::rolling_window</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">
<function name="is_rolling_window_plus1_full"><type>bool</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></function>
</namespace>
<namespace name="tag">
<struct name="rolling_window"><inherit access="public">boost::accumulators::depends_on&lt; rolling_window_plus1 &gt;</inherit><data-member name="window_size" specifiers="static"><type>boost::parameter::keyword&lt; tag::rolling_window_size &gt; const</type><purpose>tag::rolling_window::size named parameter </purpose></data-member>
</struct><struct name="rolling_window_plus1"><inherit access="public">boost::accumulators::depends_on&lt;&gt;</inherit><inherit access="public">rolling_window_size</inherit><data-member name="window_size" specifiers="static"><type>boost::parameter::keyword&lt; tag::rolling_window_size &gt; const</type><purpose>tag::rolling_window::size named parameter </purpose></data-member>
</struct></namespace>
</namespace>
<namespace name="serialization">
<function name="save"><type>void</type><template>
          <template-type-parameter name="Archive"/>
          <template-type-parameter name="T"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="b"><paramtype>const circular_buffer&lt; T &gt; &amp;</paramtype></parameter><parameter name=""><paramtype>const unsigned int</paramtype></parameter></function>
<function name="load"><type>void</type><template>
          <template-type-parameter name="Archive"/>
          <template-type-parameter name="T"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="b"><paramtype>circular_buffer&lt; T &gt; &amp;</paramtype></parameter><parameter name=""><paramtype>const unsigned int</paramtype></parameter></function>
<function name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
          <template-type-parameter name="T"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="b"><paramtype>circular_buffer&lt; T &gt; &amp;</paramtype></parameter><parameter name="version"><paramtype>const unsigned int</paramtype></parameter></function>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/skewness.hpp">
<namespace name="boost">
<namespace name="accumulators">
<struct-specialization name="as_weighted_feature"><template>
    </template><specialization><template-arg>tag::skewness</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_skewness</classname></type></typedef>
</struct-specialization><struct-specialization name="feature_of"><template>
    </template><specialization><template-arg>tag::weighted_skewness</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::skewness &gt;</inherit></struct-specialization><namespace name="extract">
<data-member name="skewness"><type><classname>extractor</classname>&lt; <classname>tag::skewness</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
<struct name="skewness"><inherit access="public">boost::accumulators::depends_on&lt; mean, moment&lt; 2 &gt;, moment&lt; 3 &gt; &gt;</inherit></struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/stats.hpp">
<para>Contains the stats&lt;&gt; template. </para><namespace name="boost">
<namespace name="accumulators">
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/sum.hpp">
<namespace name="boost">
<namespace name="accumulators">
<struct-specialization name="as_weighted_feature"><template>
    </template><specialization><template-arg>tag::sum</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_sum</classname></type></typedef>
</struct-specialization><struct-specialization name="feature_of"><template>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><specialization><template-arg>tag::sum_of_variates&lt; VariateType</template-arg><template-arg>VariateTag &gt;</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::abstract_sum_of_variates &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
    </template><specialization><template-arg>tag::weighted_sum</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::sum &gt;</inherit></struct-specialization><namespace name="extract">
<data-member name="sum"><type><classname>extractor</classname>&lt; <classname>tag::sum</classname> &gt; const</type></data-member>
<data-member name="sum_of_weights"><type><classname>extractor</classname>&lt; <classname>tag::sum_of_weights</classname> &gt; const</type></data-member>
<data-member name="sum_of_variates"><type><classname>extractor</classname>&lt; <classname>tag::abstract_sum_of_variates</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
<struct name="abstract_sum_of_variates"><inherit access="public">boost::accumulators::depends_on&lt;&gt;</inherit></struct><struct name="sum"><inherit access="public">boost::accumulators::depends_on&lt;&gt;</inherit></struct><struct name="sum_of_weights"><inherit access="public">boost::accumulators::depends_on&lt;&gt;</inherit><typedef name="is_weight_accumulator"><type>mpl::true_</type></typedef>
</struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/sum_kahan.hpp">
<namespace name="boost">
<namespace name="accumulators">
<struct-specialization name="as_feature"><template>
    </template><specialization><template-arg>tag::sum(kahan)</template-arg></specialization><typedef name="type"><type><classname>tag::sum_kahan</classname></type></typedef>
</struct-specialization><struct-specialization name="as_feature"><template>
    </template><specialization><template-arg>tag::sum_of_weights(kahan)</template-arg></specialization><typedef name="type"><type><classname>tag::sum_of_weights_kahan</classname></type></typedef>
</struct-specialization><struct-specialization name="as_weighted_feature"><template>
    </template><specialization><template-arg>tag::sum_kahan</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_sum_kahan</classname></type></typedef>
</struct-specialization><struct-specialization name="feature_of"><template>
    </template><specialization><template-arg>tag::sum_kahan</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::sum &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><specialization><template-arg>tag::sum_of_variates_kahan&lt; VariateType</template-arg><template-arg>VariateTag &gt;</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::abstract_sum_of_variates &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
    </template><specialization><template-arg>tag::sum_of_weights_kahan</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::sum_of_weights &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
    </template><specialization><template-arg>tag::weighted_sum_kahan</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::sum &gt;</inherit></struct-specialization><namespace name="extract">
<data-member name="sum_kahan"><type><classname>extractor</classname>&lt; <classname>tag::sum_kahan</classname> &gt; const</type></data-member>
<data-member name="sum_of_weights_kahan"><type><classname>extractor</classname>&lt; <classname>tag::sum_of_weights_kahan</classname> &gt; const</type></data-member>
<data-member name="sum_of_variates_kahan"><type><classname>extractor</classname>&lt; <classname>tag::abstract_sum_of_variates</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
<struct name="sum_kahan"><inherit access="public">boost::accumulators::depends_on&lt;&gt;</inherit></struct><struct name="sum_of_weights_kahan"><inherit access="public">boost::accumulators::depends_on&lt;&gt;</inherit><typedef name="is_weight_accumulator"><type>mpl::true_</type></typedef>
</struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/tail.hpp">
<namespace name="boost">
<namespace name="accumulators">
<struct-specialization name="feature_of"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::tail&lt; LeftRight &gt;</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::abstract_tail &gt;</inherit></struct-specialization><struct name="tail_cache_size_named_arg"><template>
      <template-type-parameter name="T"/>
    </template></struct><struct-specialization name="tail_cache_size_named_arg"><template>
    </template><specialization><template-arg>left</template-arg></specialization><inherit access="public">left_tail_cache_size</inherit></struct-specialization><struct-specialization name="tail_cache_size_named_arg"><template>
    </template><specialization><template-arg>right</template-arg></specialization><inherit access="public">right_tail_cache_size</inherit></struct-specialization><namespace name="extract">
<data-member name="tail"><type><classname>extractor</classname>&lt; <classname>tag::abstract_tail</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
<struct name="abstract_tail"><inherit access="public">boost::accumulators::depends_on&lt;&gt;</inherit></struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/tail_mean.hpp">
<namespace name="boost">
<namespace name="accumulators">
<struct-specialization name="as_weighted_feature"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::non_coherent_tail_mean&lt; LeftRight &gt;</template-arg></specialization><typedef name="type"><type><classname>tag::non_coherent_weighted_tail_mean</classname>&lt; LeftRight &gt;</type></typedef>
</struct-specialization><struct-specialization name="feature_of"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::coherent_tail_mean&lt; LeftRight &gt;</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::tail_mean &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::non_coherent_tail_mean&lt; LeftRight &gt;</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::abstract_non_coherent_tail_mean &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::non_coherent_weighted_tail_mean&lt; LeftRight &gt;</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::non_coherent_tail_mean&lt; LeftRight &gt; &gt;</inherit></struct-specialization><namespace name="extract">
<data-member name="non_coherent_tail_mean"><type><classname>extractor</classname>&lt; <classname>tag::abstract_non_coherent_tail_mean</classname> &gt; const</type></data-member>
<data-member name="coherent_tail_mean"><type><classname>extractor</classname>&lt; <classname>tag::tail_mean</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
<struct name="abstract_non_coherent_tail_mean"><inherit access="public">boost::accumulators::depends_on&lt;&gt;</inherit></struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/tail_quantile.hpp">
<namespace name="boost">
<namespace name="accumulators">
<struct-specialization name="as_weighted_feature"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::tail_quantile&lt; LeftRight &gt;</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_tail_quantile</classname>&lt; LeftRight &gt;</type></typedef>
</struct-specialization><struct-specialization name="feature_of"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::tail_quantile&lt; LeftRight &gt;</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::quantile &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::weighted_tail_quantile&lt; LeftRight &gt;</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::tail_quantile&lt; LeftRight &gt; &gt;</inherit></struct-specialization><namespace name="extract">
<data-member name="tail_quantile"><type><classname>extractor</classname>&lt; <classname>tag::quantile</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
</namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/tail_variate.hpp">
<namespace name="boost">
<namespace name="accumulators">
<struct-specialization name="feature_of"><template>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::tail_variate&lt; VariateType</template-arg><template-arg>VariateTag</template-arg><template-arg>LeftRight &gt;</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::abstract_tail_variate &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::tail_weights&lt; LeftRight &gt;</template-arg></specialization><typedef name="type"><type><classname>tag::abstract_tail_weights</classname></type></typedef>
</struct-specialization><namespace name="extract">
<data-member name="tail_variate"><type><classname>extractor</classname>&lt; <classname>tag::abstract_tail_variate</classname> &gt; const</type></data-member>
<data-member name="tail_weights"><type><classname>extractor</classname>&lt; <classname>tag::abstract_tail_weights</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
<struct name="abstract_tail_variate"><inherit access="public">boost::accumulators::depends_on&lt;&gt;</inherit></struct><struct name="abstract_tail_weights"><inherit access="public">boost::accumulators::depends_on&lt;&gt;</inherit></struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/tail_variate_means.hpp">
<namespace name="boost">
<namespace name="accumulators">
<struct-specialization name="as_feature"><template>
      <template-type-parameter name="LeftRight"/>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><specialization><template-arg>tag::tail_variate_means&lt; LeftRight</template-arg><template-arg>VariateType</template-arg><template-arg>VariateTag &gt;(absolute)</template-arg></specialization><typedef name="type"><type><classname>tag::absolute_tail_variate_means</classname>&lt; LeftRight, VariateType, VariateTag &gt;</type></typedef>
</struct-specialization><struct-specialization name="as_feature"><template>
      <template-type-parameter name="LeftRight"/>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><specialization><template-arg>tag::tail_variate_means&lt; LeftRight</template-arg><template-arg>VariateType</template-arg><template-arg>VariateTag &gt;(relative)</template-arg></specialization><typedef name="type"><type><classname>tag::relative_tail_variate_means</classname>&lt; LeftRight, VariateType, VariateTag &gt;</type></typedef>
</struct-specialization><struct-specialization name="as_weighted_feature"><template>
      <template-type-parameter name="LeftRight"/>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><specialization><template-arg>tag::absolute_tail_variate_means&lt; LeftRight</template-arg><template-arg>VariateType</template-arg><template-arg>VariateTag &gt;</template-arg></specialization><typedef name="type"><type><classname>tag::absolute_weighted_tail_variate_means</classname>&lt; LeftRight, VariateType, VariateTag &gt;</type></typedef>
</struct-specialization><struct-specialization name="as_weighted_feature"><template>
      <template-type-parameter name="LeftRight"/>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><specialization><template-arg>tag::relative_tail_variate_means&lt; LeftRight</template-arg><template-arg>VariateType</template-arg><template-arg>VariateTag &gt;</template-arg></specialization><typedef name="type"><type><classname>tag::relative_weighted_tail_variate_means</classname>&lt; LeftRight, VariateType, VariateTag &gt;</type></typedef>
</struct-specialization><struct-specialization name="feature_of"><template>
      <template-type-parameter name="LeftRight"/>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><specialization><template-arg>tag::absolute_tail_variate_means&lt; LeftRight</template-arg><template-arg>VariateType</template-arg><template-arg>VariateTag &gt;</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::abstract_absolute_tail_variate_means &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
      <template-type-parameter name="LeftRight"/>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><specialization><template-arg>tag::absolute_weighted_tail_variate_means&lt; LeftRight</template-arg><template-arg>VariateType</template-arg><template-arg>VariateTag &gt;</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::absolute_tail_variate_means&lt; LeftRight, VariateType, VariateTag &gt; &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
      <template-type-parameter name="LeftRight"/>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><specialization><template-arg>tag::relative_tail_variate_means&lt; LeftRight</template-arg><template-arg>VariateType</template-arg><template-arg>VariateTag &gt;</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::abstract_relative_tail_variate_means &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
      <template-type-parameter name="LeftRight"/>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><specialization><template-arg>tag::relative_weighted_tail_variate_means&lt; LeftRight</template-arg><template-arg>VariateType</template-arg><template-arg>VariateTag &gt;</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::relative_tail_variate_means&lt; LeftRight, VariateType, VariateTag &gt; &gt;</inherit></struct-specialization><namespace name="extract">
<data-member name="tail_variate_means"><type><classname>extractor</classname>&lt; <classname>tag::abstract_absolute_tail_variate_means</classname> &gt; const</type></data-member>
<data-member name="relative_tail_variate_means"><type><classname>extractor</classname>&lt; <classname>tag::abstract_relative_tail_variate_means</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
<struct name="abstract_absolute_tail_variate_means"><inherit access="public">boost::accumulators::depends_on&lt;&gt;</inherit></struct><struct name="abstract_relative_tail_variate_means"><inherit access="public">boost::accumulators::depends_on&lt;&gt;</inherit></struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/times2_iterator.hpp">
<namespace name="boost">
<namespace name="accumulators">
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/variance.hpp">
<namespace name="boost">
<namespace name="accumulators">
<struct-specialization name="as_feature"><template>
    </template><specialization><template-arg>tag::variance(immediate)</template-arg></specialization><typedef name="type"><type><classname>tag::variance</classname></type></typedef>
</struct-specialization><struct-specialization name="as_feature"><template>
    </template><specialization><template-arg>tag::variance(lazy)</template-arg></specialization><typedef name="type"><type><classname>tag::lazy_variance</classname></type></typedef>
</struct-specialization><struct-specialization name="as_weighted_feature"><template>
    </template><specialization><template-arg>tag::lazy_variance</template-arg></specialization><typedef name="type"><type><classname>tag::lazy_weighted_variance</classname></type></typedef>
</struct-specialization><struct-specialization name="as_weighted_feature"><template>
    </template><specialization><template-arg>tag::variance</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_variance</classname></type></typedef>
</struct-specialization><struct-specialization name="feature_of"><template>
    </template><specialization><template-arg>tag::lazy_variance</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::variance &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
    </template><specialization><template-arg>tag::lazy_weighted_variance</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::lazy_variance &gt;</inherit></struct-specialization><struct-specialization name="feature_of"><template>
    </template><specialization><template-arg>tag::weighted_variance</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::variance &gt;</inherit></struct-specialization><namespace name="extract">
<data-member name="lazy_variance"><type><classname>extractor</classname>&lt; <classname>tag::lazy_variance</classname> &gt; const</type></data-member>
<data-member name="variance"><type><classname>extractor</classname>&lt; <classname>tag::variance</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
<struct name="lazy_variance"><inherit access="public">boost::accumulators::depends_on&lt; moment&lt; 2 &gt;, mean &gt;</inherit></struct><struct name="variance"><inherit access="public">boost::accumulators::depends_on&lt; count, immediate_mean &gt;</inherit></struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/variates/covariate.hpp">
<namespace name="boost">
<namespace name="accumulators">
<namespace name="tag">
<struct name="covariate1"/><struct name="covariate2"/></namespace>
<data-member name="covariate1"><type>boost::parameter::keyword&lt; tag ::covariate1 &gt; const</type></data-member>
<data-member name="covariate2"><type>boost::parameter::keyword&lt; tag ::covariate2 &gt; const</type></data-member>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/weighted_covariance.hpp">
<namespace name="boost">
<namespace name="accumulators">
<namespace name="extract">
<data-member name="weighted_covariance"><type><classname>extractor</classname>&lt; <classname>tag::abstract_covariance</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
</namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/weighted_density.hpp">
<namespace name="boost">
<namespace name="accumulators">
<namespace name="extract">
<data-member name="weighted_density"><type><classname>extractor</classname>&lt; <classname>tag::density</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
<struct name="weighted_density"><inherit access="public">boost::accumulators::depends_on&lt; count, sum_of_weights, min, max &gt;</inherit><inherit access="public">density_cache_size</inherit><inherit access="public">density_num_bins</inherit><data-member name="cache_size" specifiers="static"><type>boost::parameter::keyword&lt; density_cache_size &gt; const</type></data-member>
<data-member name="num_bins" specifiers="static"><type>boost::parameter::keyword&lt; density_num_bins &gt; const</type></data-member>
</struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/weighted_extended_p_square.hpp">
<namespace name="boost">
<namespace name="accumulators">
<namespace name="extract">
<data-member name="weighted_extended_p_square"><type><classname>extractor</classname>&lt; <classname>tag::weighted_extended_p_square</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
<struct name="weighted_extended_p_square"><inherit access="public">boost::accumulators::depends_on&lt; count, sum_of_weights &gt;</inherit><inherit access="public">extended_p_square_probabilities</inherit><typedef name="impl"><type><classname>accumulators::impl::weighted_extended_p_square_impl</classname>&lt; mpl::_1, mpl::_2 &gt;</type></typedef>
</struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/weighted_kurtosis.hpp">
<namespace name="boost">
<namespace name="accumulators">
<namespace name="extract">
<data-member name="weighted_kurtosis"><type><classname>extractor</classname>&lt; <classname>tag::weighted_kurtosis</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
<struct name="weighted_kurtosis"><inherit access="public">boost::accumulators::depends_on&lt; weighted_mean, weighted_moment&lt; 2 &gt;, weighted_moment&lt; 3 &gt;, weighted_moment&lt; 4 &gt; &gt;</inherit></struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/weighted_mean.hpp">
<namespace name="boost">
<namespace name="accumulators">
<struct-specialization name="as_feature"><template>
    </template><specialization><template-arg>tag::weighted_mean(immediate)</template-arg></specialization><typedef name="type"><type><classname>tag::immediate_weighted_mean</classname></type></typedef>
</struct-specialization><struct-specialization name="as_feature"><template>
    </template><specialization><template-arg>tag::weighted_mean(lazy)</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_mean</classname></type></typedef>
</struct-specialization><struct-specialization name="as_feature"><template>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><specialization><template-arg>tag::weighted_mean_of_variates&lt; VariateType</template-arg><template-arg>VariateTag &gt;(immediate)</template-arg></specialization><typedef name="type"><type><classname>tag::immediate_weighted_mean_of_variates</classname>&lt; VariateType, VariateTag &gt;</type></typedef>
</struct-specialization><struct-specialization name="as_feature"><template>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><specialization><template-arg>tag::weighted_mean_of_variates&lt; VariateType</template-arg><template-arg>VariateTag &gt;(lazy)</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_mean_of_variates</classname>&lt; VariateType, VariateTag &gt;</type></typedef>
</struct-specialization><namespace name="extract">
<data-member name="weighted_mean"><type><classname>extractor</classname>&lt; <classname>tag::mean</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
<struct name="immediate_weighted_mean"><inherit access="public">boost::accumulators::depends_on&lt; sum_of_weights &gt;</inherit></struct><struct name="weighted_mean"><inherit access="public">boost::accumulators::depends_on&lt; sum_of_weights, weighted_sum &gt;</inherit></struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/weighted_median.hpp">
<namespace name="boost">
<namespace name="accumulators">
<struct-specialization name="as_feature"><template>
    </template><specialization><template-arg>tag::weighted_median(with_density)</template-arg></specialization><typedef name="type"><type><classname>tag::with_density_weighted_median</classname></type></typedef>
</struct-specialization><struct-specialization name="as_feature"><template>
    </template><specialization><template-arg>tag::weighted_median(with_p_square_cumulative_distribution)</template-arg></specialization><typedef name="type"><type><classname>tag::with_p_square_cumulative_distribution_weighted_median</classname></type></typedef>
</struct-specialization><struct-specialization name="as_feature"><template>
    </template><specialization><template-arg>tag::weighted_median(with_p_square_quantile)</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_median</classname></type></typedef>
</struct-specialization><namespace name="extract">
<data-member name="weighted_median"><type><classname>extractor</classname>&lt; <classname>tag::median</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
<struct name="weighted_median"><inherit access="public">boost::accumulators::depends_on&lt; weighted_p_square_quantile_for_median &gt;</inherit></struct><struct name="with_density_weighted_median"><inherit access="public">boost::accumulators::depends_on&lt; count, weighted_density &gt;</inherit></struct><struct name="with_p_square_cumulative_distribution_weighted_median"><inherit access="public">boost::accumulators::depends_on&lt; weighted_p_square_cumulative_distribution &gt;</inherit></struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/weighted_moment.hpp">
<namespace name="boost">
<namespace name="accumulators">
<namespace name="extract">
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
</namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/weighted_p_square_cumul_dist.hpp">
<namespace name="boost">
<namespace name="accumulators">
<namespace name="extract">
<data-member name="weighted_p_square_cumulative_distribution"><type><classname>extractor</classname>&lt; <classname>tag::weighted_p_square_cumulative_distribution</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
<struct name="weighted_p_square_cumulative_distribution"><inherit access="public">boost::accumulators::depends_on&lt; count, sum_of_weights &gt;</inherit><inherit access="public">p_square_cumulative_distribution_num_cells</inherit><typedef name="impl"><type><classname>accumulators::impl::weighted_p_square_cumulative_distribution_impl</classname>&lt; mpl::_1, mpl::_2 &gt;</type></typedef>
</struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/weighted_p_square_cumulative_distribution.hpp">
</header>
<header name="boost/accumulators/statistics/weighted_p_square_quantile.hpp">
<namespace name="boost">
<namespace name="accumulators">
<namespace name="extract">
<data-member name="weighted_p_square_quantile"><type><classname>extractor</classname>&lt; <classname>tag::weighted_p_square_quantile</classname> &gt; const</type></data-member>
<data-member name="weighted_p_square_quantile_for_median"><type><classname>extractor</classname>&lt; <classname>tag::weighted_p_square_quantile_for_median</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
<struct name="weighted_p_square_quantile"><inherit access="public">boost::accumulators::depends_on&lt; count, sum_of_weights &gt;</inherit><typedef name="impl"><type><classname>accumulators::impl::weighted_p_square_quantile_impl</classname>&lt; mpl::_1, mpl::_2, <classname>regular</classname> &gt;</type></typedef>
</struct><struct name="weighted_p_square_quantile_for_median"><inherit access="public">boost::accumulators::depends_on&lt; count, sum_of_weights &gt;</inherit><typedef name="impl"><type><classname>accumulators::impl::weighted_p_square_quantile_impl</classname>&lt; mpl::_1, mpl::_2, <classname>for_median</classname> &gt;</type></typedef>
</struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/weighted_peaks_over_threshold.hpp">
<namespace name="boost">
<namespace name="accumulators">
<struct-specialization name="as_feature"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::weighted_peaks_over_threshold&lt; LeftRight &gt;(with_threshold_probability)</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_peaks_over_threshold_prob</classname>&lt; LeftRight &gt;</type></typedef>
</struct-specialization><struct-specialization name="as_feature"><template>
      <template-type-parameter name="LeftRight"/>
    </template><specialization><template-arg>tag::weighted_peaks_over_threshold&lt; LeftRight &gt;(with_threshold_value)</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_peaks_over_threshold</classname>&lt; LeftRight &gt;</type></typedef>
</struct-specialization><namespace name="extract">
<data-member name="weighted_peaks_over_threshold"><type><classname>extractor</classname>&lt; <classname>tag::abstract_peaks_over_threshold</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
</namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/weighted_skewness.hpp">
<namespace name="boost">
<namespace name="accumulators">
<namespace name="extract">
<data-member name="weighted_skewness"><type><classname>extractor</classname>&lt; <classname>tag::weighted_skewness</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
<struct name="weighted_skewness"><inherit access="public">boost::accumulators::depends_on&lt; weighted_mean, weighted_moment&lt; 2 &gt;, weighted_moment&lt; 3 &gt; &gt;</inherit></struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/weighted_sum.hpp">
<namespace name="boost">
<namespace name="accumulators">
<struct-specialization name="feature_of"><template>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><specialization><template-arg>tag::weighted_sum_of_variates&lt; VariateType</template-arg><template-arg>VariateTag &gt;</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::abstract_weighted_sum_of_variates &gt;</inherit></struct-specialization><namespace name="extract">
<data-member name="weighted_sum"><type><classname>extractor</classname>&lt; <classname>tag::weighted_sum</classname> &gt; const</type></data-member>
<data-member name="weighted_sum_of_variates"><type><classname>extractor</classname>&lt; <classname>tag::abstract_weighted_sum_of_variates</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
<struct name="abstract_weighted_sum_of_variates"><inherit access="public">boost::accumulators::depends_on&lt;&gt;</inherit></struct><struct name="weighted_sum"><inherit access="public">boost::accumulators::depends_on&lt;&gt;</inherit></struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/weighted_sum_kahan.hpp">
<namespace name="boost">
<namespace name="accumulators">
<struct-specialization name="as_feature"><template>
    </template><specialization><template-arg>tag::weighted_sum(kahan)</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_sum_kahan</classname></type></typedef>
</struct-specialization><struct-specialization name="feature_of"><template>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><specialization><template-arg>tag::weighted_sum_of_variates_kahan&lt; VariateType</template-arg><template-arg>VariateTag &gt;</template-arg></specialization><inherit access="public">boost::accumulators::feature_of&lt; tag::abstract_weighted_sum_of_variates &gt;</inherit></struct-specialization><namespace name="extract">
<data-member name="weighted_sum_kahan"><type><classname>extractor</classname>&lt; <classname>tag::weighted_sum_kahan</classname> &gt; const</type></data-member>
<data-member name="weighted_sum_of_variates_kahan"><type><classname>extractor</classname>&lt; <classname>tag::abstract_weighted_sum_of_variates</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
<struct name="weighted_sum_kahan"><inherit access="public">boost::accumulators::depends_on&lt;&gt;</inherit></struct><struct name="weighted_sum_of_variates_kahan"><template>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><inherit access="public">boost::accumulators::depends_on&lt;&gt;</inherit></struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/weighted_tail_mean.hpp">
<namespace name="boost">
<namespace name="accumulators">
<namespace name="extract">
<data-member name="non_coherent_weighted_tail_mean"><type><classname>extractor</classname>&lt; <classname>tag::abstract_non_coherent_tail_mean</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
</namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/weighted_tail_quantile.hpp">
<namespace name="boost">
<namespace name="accumulators">
<namespace name="extract">
<data-member name="weighted_tail_quantile"><type><classname>extractor</classname>&lt; <classname>tag::quantile</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
</namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/weighted_tail_variate_means.hpp">
<namespace name="boost">
<namespace name="accumulators">
<struct-specialization name="as_feature"><template>
      <template-type-parameter name="LeftRight"/>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><specialization><template-arg>tag::weighted_tail_variate_means&lt; LeftRight</template-arg><template-arg>VariateType</template-arg><template-arg>VariateTag &gt;(absolute)</template-arg></specialization><typedef name="type"><type><classname>tag::absolute_weighted_tail_variate_means</classname>&lt; LeftRight, VariateType, VariateTag &gt;</type></typedef>
</struct-specialization><struct-specialization name="as_feature"><template>
      <template-type-parameter name="LeftRight"/>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><specialization><template-arg>tag::weighted_tail_variate_means&lt; LeftRight</template-arg><template-arg>VariateType</template-arg><template-arg>VariateTag &gt;(relative)</template-arg></specialization><typedef name="type"><type><classname>tag::relative_weighted_tail_variate_means</classname>&lt; LeftRight, VariateType, VariateTag &gt;</type></typedef>
</struct-specialization><namespace name="extract">
<data-member name="weighted_tail_variate_means"><type><classname>extractor</classname>&lt; <classname>tag::abstract_absolute_tail_variate_means</classname> &gt; const</type></data-member>
<data-member name="relative_weighted_tail_variate_means"><type><classname>extractor</classname>&lt; <classname>tag::abstract_relative_tail_variate_means</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
</namespace>
</namespace>
<namespace name="numeric">
<namespace name="functional">
<struct name="multiply_and_promote_to_double"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">functional::multiplies&lt; T, double const &gt;</inherit></struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/weighted_variance.hpp">
<namespace name="boost">
<namespace name="accumulators">
<struct-specialization name="as_feature"><template>
    </template><specialization><template-arg>tag::weighted_variance(immediate)</template-arg></specialization><typedef name="type"><type><classname>tag::weighted_variance</classname></type></typedef>
</struct-specialization><struct-specialization name="as_feature"><template>
    </template><specialization><template-arg>tag::weighted_variance(lazy)</template-arg></specialization><typedef name="type"><type><classname>tag::lazy_weighted_variance</classname></type></typedef>
</struct-specialization><namespace name="extract">
<data-member name="lazy_weighted_variance"><type><classname>extractor</classname>&lt; <classname>tag::lazy_weighted_variance</classname> &gt; const</type></data-member>
<data-member name="weighted_variance"><type><classname>extractor</classname>&lt; <classname>tag::weighted_variance</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">

</namespace>
<namespace name="tag">
<struct name="lazy_weighted_variance"><inherit access="public">boost::accumulators::depends_on&lt; weighted_moment&lt; 2 &gt;, weighted_mean &gt;</inherit></struct><struct name="weighted_variance"><inherit access="public">boost::accumulators::depends_on&lt; count, immediate_weighted_mean &gt;</inherit></struct></namespace>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics/with_error.hpp">
<namespace name="boost">
<namespace name="accumulators">
</namespace>
</namespace>
</header>
<header name="boost/accumulators/statistics_fwd.hpp">
<namespace name="boost">
<namespace name="accumulators">
<struct name="absolute"/><struct name="for_median"/><struct name="immediate"/><struct name="kahan"/><struct name="lazy"/><struct name="left"/><struct name="linear"/><struct name="quadratic"/><struct name="regular"/><struct name="relative"/><struct name="right"/><struct name="stats"><template>
      <template-type-parameter name="Stat1"/>
      <template-type-parameter name="Stat2"/>
      <template-nontype-parameter name=""><type>...</type></template-nontype-parameter>
    </template><inherit access="public">mpl::vector&lt; Stat1, Stat2,... &gt;</inherit><purpose>An MPL sequence of statistics. </purpose></struct><struct name="unweighted"/><struct name="weighted"/><struct name="with_density"/><struct name="with_error"><template>
      <template-type-parameter name="Feature1"/>
      <template-type-parameter name="Feature2"/>
      <template-nontype-parameter name=""><type>...</type></template-nontype-parameter>
    </template></struct><struct name="with_p_square_cumulative_distribution"/><struct name="with_p_square_quantile"/><struct name="with_threshold_probability"/><struct name="with_threshold_value"/><namespace name="extract">
<data-member name="quantile"><type><classname>extractor</classname>&lt; <classname>tag::quantile</classname> &gt; const</type></data-member>
<data-member name="tail_mean"><type><classname>extractor</classname>&lt; <classname>tag::tail_mean</classname> &gt; const</type></data-member>
</namespace>
<namespace name="impl">
<struct name="coherent_tail_mean_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="LeftRight"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Estimation of the coherent tail mean based on order statistics (for both left and right tails) </purpose><description><para>The coherent tail mean <inlineequation><alt>$\widehat{CTM}_{n,\alpha}(X)$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_67.png"/></imageobject><textobject role="tex"><phrase>$\widehat{CTM}_{n,\alpha}(X)$</phrase></textobject></inlinemediaobject></inlineequation> is equal to the non-coherent tail mean <inlineequation><alt>$\widehat{NCTM}_{n,\alpha}(X)$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_14.png"/></imageobject><textobject role="tex"><phrase>$\widehat{NCTM}_{n,\alpha}(X)$</phrase></textobject></inlinemediaobject></inlineequation> plus a correction term that ensures coherence in case of non-continuous distributions.</para><para><equation><title/><alt>\[ \widehat{CTM}_{n,\alpha}^{\mathrm{right}}(X) = \widehat{NCTM}_{n,\alpha}^{\mathrm{right}}(X) + \frac{1}{\lceil n(1-\alpha)\rceil}\hat{q}_{n,\alpha}(X)\left(1 - \alpha - \frac{1}{n}\lceil n(1-\alpha)\rceil \right) \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_68.png"/></imageobject><textobject role="tex"><phrase>\[ \widehat{CTM}_{n,\alpha}^{\mathrm{right}}(X) = \widehat{NCTM}_{n,\alpha}^{\mathrm{right}}(X) + \frac{1}{\lceil n(1-\alpha)\rceil}\hat{q}_{n,\alpha}(X)\left(1 - \alpha - \frac{1}{n}\lceil n(1-\alpha)\rceil \right) \]</phrase></textobject></mediaobject></equation></para><para><equation><title/><alt>\[ \widehat{CTM}_{n,\alpha}^{\mathrm{left}}(X) = \widehat{NCTM}_{n,\alpha}^{\mathrm{left}}(X) + \frac{1}{\lceil n\alpha\rceil}\hat{q}_{n,\alpha}(X)\left(\alpha - \frac{1}{n}\lceil n\alpha\rceil \right) \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_69.png"/></imageobject><textobject role="tex"><phrase>\[ \widehat{CTM}_{n,\alpha}^{\mathrm{left}}(X) = \widehat{NCTM}_{n,\alpha}^{\mathrm{left}}(X) + \frac{1}{\lceil n\alpha\rceil}\hat{q}_{n,\alpha}(X)\left(\alpha - \frac{1}{n}\lceil n\alpha\rceil \right) \]</phrase></textobject></mediaobject></equation> </para></description><method-group name="public member functions">
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><parameter name=""><paramtype>dont_care</paramtype></parameter></constructor>
</struct><struct name="covariance_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Covariance Estimator. </purpose><description><para>An iterative Monte Carlo estimator for the covariance <inlineequation><alt>$\mathrm{Cov}(X,X')$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_47.png"/></imageobject><textobject role="tex"><phrase>$\mathrm{Cov}(X,X')$</phrase></textobject></inlinemediaobject></inlineequation>, where <inlineequation><alt>$X$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_48.png"/></imageobject><textobject role="tex"><phrase>$X$</phrase></textobject></inlinemediaobject></inlineequation> is a sample and <inlineequation><alt>$X'$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_49.png"/></imageobject><textobject role="tex"><phrase>$X'$</phrase></textobject></inlinemediaobject></inlineequation> is a variate, is given by:</para><para><equation><title/><alt>\[ \hat{c}_n = \frac{n-1}{n} \hat{c}_{n-1} + \frac{1}{n-1}(X_n - \hat{\mu}_n)(X_n' - \hat{\mu}_n'),\quad n\ge2,\quad\hat{c}_1 = 0, \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_113.png"/></imageobject><textobject role="tex"><phrase>\[ \hat{c}_n = \frac{n-1}{n} \hat{c}_{n-1} + \frac{1}{n-1}(X_n - \hat{\mu}_n)(X_n' - \hat{\mu}_n'),\quad n\ge2,\quad\hat{c}_1 = 0, \]</phrase></textobject></mediaobject></equation></para><para><inlineequation><alt>$\hat{\mu}_n$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_7.png"/></imageobject><textobject role="tex"><phrase>$\hat{\mu}_n$</phrase></textobject></inlinemediaobject></inlineequation> and <inlineequation><alt>$\hat{\mu}_n'$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_51.png"/></imageobject><textobject role="tex"><phrase>$\hat{\mu}_n'$</phrase></textobject></inlinemediaobject></inlineequation> being the means of the samples and variates. </para></description><method-group name="public member functions">
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><parameter name=""><paramtype>dont_care</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></constructor>
</struct><struct name="density_impl"><template>
      <template-type-parameter name="Sample"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Histogram density estimator. </purpose><description><para>The histogram density estimator returns a histogram of the sample distribution. The positions and sizes of the bins are determined using a specifiable number of cached samples (cache_size). The range between the minimum and the maximum of the cached samples is subdivided into a specifiable number of bins (num_bins) of same size. Additionally, an under- and an overflow bin is added to capture future under- and overflow samples. Once the bins are determined, the cached samples and all subsequent samples are added to the correct bins. At the end, a range of std::pair is return, where each pair contains the position of the bin (lower bound) and the samples count (normalized with the total number of samples).</para><para>
</para></description><method-group name="public member functions">
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter><description><para>
</para></description><requires><para>The number of samples must meet or exceed the cache size </para>
</requires></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></constructor>
</struct><struct name="error_of_mean_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="Variance"/>
    </template><inherit access="public">accumulator_base</inherit><method-group name="public member functions">
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
</method-group>
<constructor><parameter name=""><paramtype>dont_care</paramtype></parameter></constructor>
</struct><struct name="extended_p_square_impl"><template>
      <template-type-parameter name="Sample"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Multiple quantile estimation with the extended <inlineequation><alt>$P^2$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_34.png"/></imageobject><textobject role="tex"><phrase>$P^2$</phrase></textobject></inlinemediaobject></inlineequation> algorithm. </purpose><description><para>Extended <inlineequation><alt>$P^2$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_34.png"/></imageobject><textobject role="tex"><phrase>$P^2$</phrase></textobject></inlinemediaobject></inlineequation> algorithm for estimation of several quantiles without storing samples. Assume that <inlineequation><alt>$m$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_43.png"/></imageobject><textobject role="tex"><phrase>$m$</phrase></textobject></inlinemediaobject></inlineequation> quantiles <inlineequation><alt>$\xi_{p_1}, \ldots, \xi_{p_m}$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_44.png"/></imageobject><textobject role="tex"><phrase>$\xi_{p_1}, \ldots, \xi_{p_m}$</phrase></textobject></inlinemediaobject></inlineequation> are to be estimated. Instead of storing the whole sample cumulative distribution, the algorithm maintains only <inlineequation><alt>$m+2$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_45.png"/></imageobject><textobject role="tex"><phrase>$m+2$</phrase></textobject></inlinemediaobject></inlineequation> principal markers and <inlineequation><alt>$m+1$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_46.png"/></imageobject><textobject role="tex"><phrase>$m+1$</phrase></textobject></inlinemediaobject></inlineequation> middle markers, whose positions are updated with each sample and whose heights are adjusted (if necessary) using a piecewise-parablic formula. The heights of these central markers are the current estimates of the quantiles and returned as an iterator range.</para><para>For further details, see</para><para>K. E. E. Raatikainen, Simultaneous estimation of several quantiles, Simulation, Volume 49, Number 4 (October), 1986, p. 159-164.</para><para>The extended <inlineequation><alt>$ P^2 $</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_38.png"/></imageobject><textobject role="tex"><phrase>$ P^2 $</phrase></textobject></inlinemediaobject></inlineequation> algorithm generalizes the <inlineequation><alt>$ P^2 $</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_38.png"/></imageobject><textobject role="tex"><phrase>$ P^2 $</phrase></textobject></inlinemediaobject></inlineequation> algorithm of</para><para>R. Jain and I. Chlamtac, The P^2 algorithm for dynamic calculation of quantiles and histograms without storing observations, Communications of the ACM, Volume 28 (October), Number 10, 1985, p. 1076-1085.</para><para>
</para></description><method-group name="public member functions">
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><parameter name=""><paramtype>dont_care</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></constructor>
</struct><struct name="extended_p_square_quantile_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="Impl1"/>
      <template-type-parameter name="Impl2"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Quantile estimation using the extended <inlineequation><alt>$P^2$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_34.png"/></imageobject><textobject role="tex"><phrase>$P^2$</phrase></textobject></inlinemediaobject></inlineequation> algorithm for weighted and unweighted samples. </purpose><description><para>Uses the quantile estimates calculated by the extended <inlineequation><alt>$P^2$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_34.png"/></imageobject><textobject role="tex"><phrase>$P^2$</phrase></textobject></inlinemediaobject></inlineequation> algorithm to compute intermediate quantile estimates by means of quadratic interpolation.</para><para>
</para></description><method-group name="public member functions">
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></constructor>
</struct><struct name="immediate_mean_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="Tag"/>
    </template><inherit access="public">accumulator_base</inherit><method-group name="public member functions">
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><parameter name=""><paramtype>dont_care</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></constructor>
</struct><struct name="immediate_weighted_mean_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="Weight"/>
      <template-type-parameter name="Tag"/>
    </template><inherit access="public">accumulator_base</inherit><method-group name="public member functions">
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><parameter name=""><paramtype>dont_care</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></constructor>
</struct><struct name="kurtosis_impl"><template>
      <template-type-parameter name="Sample"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Kurtosis estimation. </purpose><description><para>The kurtosis of a sample distribution is defined as the ratio of the 4th central moment and the square of the 2nd central moment (the variance) of the samples, minus 3. The term <inlineequation><alt>$ -3 $</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_41.png"/></imageobject><textobject role="tex"><phrase>$ -3 $</phrase></textobject></inlinemediaobject></inlineequation> is added in order to ensure that the normal distribution has zero kurtosis. The kurtosis can also be expressed by the simple moments:</para><para><equation><title/><alt>\[ \hat{g}_2 = \frac {\widehat{m}_n^{(4)}-4\widehat{m}_n^{(3)}\hat{\mu}_n+6\widehat{m}_n^{(2)}\hat{\mu}_n^2-3\hat{\mu}_n^4} {\left(\widehat{m}_n^{(2)} - \hat{\mu}_n^{2}\right)^2} - 3, \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_42.png"/></imageobject><textobject role="tex"><phrase>\[ \hat{g}_2 = \frac {\widehat{m}_n^{(4)}-4\widehat{m}_n^{(3)}\hat{\mu}_n+6\widehat{m}_n^{(2)}\hat{\mu}_n^2-3\hat{\mu}_n^4} {\left(\widehat{m}_n^{(2)} - \hat{\mu}_n^{2}\right)^2} - 3, \]</phrase></textobject></mediaobject></equation></para><para>where <inlineequation><alt>$ \widehat{m}_n^{(i)} $</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_30.png"/></imageobject><textobject role="tex"><phrase>$ \widehat{m}_n^{(i)} $</phrase></textobject></inlinemediaobject></inlineequation> are the <inlineequation><alt>$ i $</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_31.png"/></imageobject><textobject role="tex"><phrase>$ i $</phrase></textobject></inlinemediaobject></inlineequation>-th moment and <inlineequation><alt>$ \hat{\mu}_n $</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_32.png"/></imageobject><textobject role="tex"><phrase>$ \hat{\mu}_n $</phrase></textobject></inlinemediaobject></inlineequation> the mean (first moment) of the <inlineequation><alt>$ n $</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_33.png"/></imageobject><textobject role="tex"><phrase>$ n $</phrase></textobject></inlinemediaobject></inlineequation> samples. </para></description><method-group name="public member functions">
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><parameter name=""><paramtype>dont_care</paramtype></parameter></constructor>
</struct><struct name="lazy_variance_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="MeanFeature"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Lazy calculation of variance. </purpose><description><para>Default sample variance implementation based on the second moment <inlineequation><alt>$ M_n^{(2)} $</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_52.png"/></imageobject><textobject role="tex"><phrase>$ M_n^{(2)} $</phrase></textobject></inlinemediaobject></inlineequation> moment&lt;2&gt;, mean and count. <equation><title/><alt>\[ \sigma_n^2 = M_n^{(2)} - \mu_n^2. \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_53.png"/></imageobject><textobject role="tex"><phrase>\[ \sigma_n^2 = M_n^{(2)} - \mu_n^2. \]</phrase></textobject></mediaobject></equation> where <equation><title/><alt>\[ \mu_n = \frac{1}{n} \sum_{i = 1}^n x_i. \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_54.png"/></imageobject><textobject role="tex"><phrase>\[ \mu_n = \frac{1}{n} \sum_{i = 1}^n x_i. \]</phrase></textobject></mediaobject></equation> is the estimate of the sample mean and <inlineequation><alt>$n$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_3.png"/></imageobject><textobject role="tex"><phrase>$n$</phrase></textobject></inlinemediaobject></inlineequation> is the number of samples. </para></description><method-group name="public member functions">
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><parameter name=""><paramtype>dont_care</paramtype></parameter></constructor>
</struct><struct name="lazy_weighted_variance_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="Weight"/>
      <template-type-parameter name="MeanFeature"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Lazy calculation of variance of weighted samples. </purpose><description><para>The default implementation of the variance of weighted samples is based on the second moment <inlineequation><alt>$\widehat{m}_n^{(2)}$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_0.png"/></imageobject><textobject role="tex"><phrase>$\widehat{m}_n^{(2)}$</phrase></textobject></inlinemediaobject></inlineequation> (weighted_moment&lt;2&gt;) and the mean <inlineequation><alt>$ \hat{\mu}_n$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_1.png"/></imageobject><textobject role="tex"><phrase>$ \hat{\mu}_n$</phrase></textobject></inlinemediaobject></inlineequation> (weighted_mean): <equation><title/><alt>\[ \hat{\sigma}_n^2 = \widehat{m}_n^{(2)}-\hat{\mu}_n^2, \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_2.png"/></imageobject><textobject role="tex"><phrase>\[ \hat{\sigma}_n^2 = \widehat{m}_n^{(2)}-\hat{\mu}_n^2, \]</phrase></textobject></mediaobject></equation> where <inlineequation><alt>$n$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_3.png"/></imageobject><textobject role="tex"><phrase>$n$</phrase></textobject></inlinemediaobject></inlineequation> is the number of samples. </para></description><method-group name="public member functions">
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
</method-group>
<constructor><parameter name=""><paramtype>dont_care</paramtype></parameter></constructor>
</struct><struct name="max_impl"><template>
      <template-type-parameter name="Sample"/>
    </template><inherit access="public">accumulator_base</inherit><method-group name="public member functions">
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><parameter name=""><paramtype>dont_care</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></constructor>
</struct><struct name="mean_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="SumFeature"/>
    </template><inherit access="public">accumulator_base</inherit><method-group name="public member functions">
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><parameter name=""><paramtype>dont_care</paramtype></parameter></constructor>
</struct><struct name="median_impl"><template>
      <template-type-parameter name="Sample"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Median estimation based on the <inlineequation><alt>$P^2$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_34.png"/></imageobject><textobject role="tex"><phrase>$P^2$</phrase></textobject></inlinemediaobject></inlineequation> quantile estimator. </purpose><description><para>The <inlineequation><alt>$P^2$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_34.png"/></imageobject><textobject role="tex"><phrase>$P^2$</phrase></textobject></inlinemediaobject></inlineequation> algorithm is invoked with a quantile probability of 0.5. </para></description><method-group name="public member functions">
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><parameter name=""><paramtype>dont_care</paramtype></parameter></constructor>
</struct><struct name="min_impl"><template>
      <template-type-parameter name="Sample"/>
    </template><inherit access="public">accumulator_base</inherit><method-group name="public member functions">
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><parameter name=""><paramtype>dont_care</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></constructor>
</struct><struct name="moment_impl"><template>
      <template-type-parameter name="N"/>
      <template-type-parameter name="Sample"/>
    </template><inherit access="public">accumulator_base</inherit><method-group name="public member functions">
<method name="BOOST_MPL_ASSERT_RELATION"><type/><parameter name=""><paramtype>N::value</paramtype></parameter><parameter name=""><paramtype>0</paramtype></parameter></method>
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></constructor>
</struct><struct name="non_coherent_tail_mean_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="LeftRight"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Estimation of the (non-coherent) tail mean based on order statistics (for both left and right tails) </purpose><description><para>An estimation of the non-coherent tail mean <inlineequation><alt>$\widehat{NCTM}_{n,\alpha}(X)$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_14.png"/></imageobject><textobject role="tex"><phrase>$\widehat{NCTM}_{n,\alpha}(X)$</phrase></textobject></inlinemediaobject></inlineequation> is given by the mean of the <inlineequation><alt>$\lceil n\alpha\rceil$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_65.png"/></imageobject><textobject role="tex"><phrase>$\lceil n\alpha\rceil$</phrase></textobject></inlinemediaobject></inlineequation> smallest samples (left tail) or the mean of the <inlineequation><alt>$\lceil n(1-\alpha)\rceil$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_60.png"/></imageobject><textobject role="tex"><phrase>$\lceil n(1-\alpha)\rceil$</phrase></textobject></inlinemediaobject></inlineequation> largest samples (right tail), <inlineequation><alt>$n$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_3.png"/></imageobject><textobject role="tex"><phrase>$n$</phrase></textobject></inlinemediaobject></inlineequation> being the total number of samples and <inlineequation><alt>$\alpha$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_20.png"/></imageobject><textobject role="tex"><phrase>$\alpha$</phrase></textobject></inlinemediaobject></inlineequation> the quantile level:</para><para><equation><title/><alt>\[ \widehat{NCTM}_{n,\alpha}^{\mathrm{right}}(X) = \frac{1}{\lceil n(1-\alpha)\rceil} \sum_{i=\lceil \alpha n \rceil}^n X_{i:n} \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_70.png"/></imageobject><textobject role="tex"><phrase>\[ \widehat{NCTM}_{n,\alpha}^{\mathrm{right}}(X) = \frac{1}{\lceil n(1-\alpha)\rceil} \sum_{i=\lceil \alpha n \rceil}^n X_{i:n} \]</phrase></textobject></mediaobject></equation></para><para><equation><title/><alt>\[ \widehat{NCTM}_{n,\alpha}^{\mathrm{left}}(X) = \frac{1}{\lceil n\alpha\rceil} \sum_{i=1}^{\lceil \alpha n \rceil} X_{i:n} \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_71.png"/></imageobject><textobject role="tex"><phrase>\[ \widehat{NCTM}_{n,\alpha}^{\mathrm{left}}(X) = \frac{1}{\lceil n\alpha\rceil} \sum_{i=1}^{\lceil \alpha n \rceil} X_{i:n} \]</phrase></textobject></mediaobject></equation></para><para>It thus requires the caching of at least the <inlineequation><alt>$\lceil n\alpha\rceil$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_65.png"/></imageobject><textobject role="tex"><phrase>$\lceil n\alpha\rceil$</phrase></textobject></inlinemediaobject></inlineequation> smallest or the <inlineequation><alt>$\lceil n(1-\alpha)\rceil$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_60.png"/></imageobject><textobject role="tex"><phrase>$\lceil n(1-\alpha)\rceil$</phrase></textobject></inlinemediaobject></inlineequation> largest samples.</para><para>
</para></description><method-group name="public member functions">
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><parameter name=""><paramtype>dont_care</paramtype></parameter></constructor>
</struct><struct name="non_coherent_weighted_tail_mean_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="Weight"/>
      <template-type-parameter name="LeftRight"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Estimation of the (non-coherent) weighted tail mean based on order statistics (for both left and right tails) </purpose><description><para>An estimation of the non-coherent, weighted tail mean <inlineequation><alt>$\widehat{NCTM}_{n,\alpha}(X)$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_14.png"/></imageobject><textobject role="tex"><phrase>$\widehat{NCTM}_{n,\alpha}(X)$</phrase></textobject></inlinemediaobject></inlineequation> is given by the weighted mean of the</para><para><equation><title/><alt>\[ \lambda = \inf\left\{ l \left| \frac{1}{\bar{w}_n}\sum_{i=1}^{l} w_i \geq \alpha \right. \right\} \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_10.png"/></imageobject><textobject role="tex"><phrase>\[ \lambda = \inf\left\{ l \left| \frac{1}{\bar{w}_n}\sum_{i=1}^{l} w_i \geq \alpha \right. \right\} \]</phrase></textobject></mediaobject></equation></para><para>smallest samples (left tail) or the weighted mean of the</para><para><equation><title/><alt>\[ n + 1 - \rho = n + 1 - \sup\left\{ r \left| \frac{1}{\bar{w}_n}\sum_{i=r}^{n} w_i \geq (1 - \alpha) \right. \right\} \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_11.png"/></imageobject><textobject role="tex"><phrase>\[ n + 1 - \rho = n + 1 - \sup\left\{ r \left| \frac{1}{\bar{w}_n}\sum_{i=r}^{n} w_i \geq (1 - \alpha) \right. \right\} \]</phrase></textobject></mediaobject></equation></para><para>largest samples (right tail) above a quantile <inlineequation><alt>$\hat{q}_{\alpha}$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_25.png"/></imageobject><textobject role="tex"><phrase>$\hat{q}_{\alpha}$</phrase></textobject></inlinemediaobject></inlineequation> of level <inlineequation><alt>$\alpha$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_20.png"/></imageobject><textobject role="tex"><phrase>$\alpha$</phrase></textobject></inlinemediaobject></inlineequation>, <inlineequation><alt>$n$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_3.png"/></imageobject><textobject role="tex"><phrase>$n$</phrase></textobject></inlinemediaobject></inlineequation> being the total number of sample and <inlineequation><alt>$\bar{w}_n$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_5.png"/></imageobject><textobject role="tex"><phrase>$\bar{w}_n$</phrase></textobject></inlinemediaobject></inlineequation> the sum of all <inlineequation><alt>$n$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_3.png"/></imageobject><textobject role="tex"><phrase>$n$</phrase></textobject></inlinemediaobject></inlineequation> weights:</para><para><equation><title/><alt>\[ \widehat{NCTM}_{n,\alpha}^{\mathrm{left}}(X) = \frac{\sum_{i=1}^{\lambda} w_i X_{i:n}}{\sum_{i=1}^{\lambda} w_i}, \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_26.png"/></imageobject><textobject role="tex"><phrase>\[ \widehat{NCTM}_{n,\alpha}^{\mathrm{left}}(X) = \frac{\sum_{i=1}^{\lambda} w_i X_{i:n}}{\sum_{i=1}^{\lambda} w_i}, \]</phrase></textobject></mediaobject></equation></para><para><equation><title/><alt>\[ \widehat{NCTM}_{n,\alpha}^{\mathrm{right}}(X) = \frac{\sum_{i=\rho}^n w_i X_{i:n}}{\sum_{i=\rho}^n w_i}. \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_27.png"/></imageobject><textobject role="tex"><phrase>\[ \widehat{NCTM}_{n,\alpha}^{\mathrm{right}}(X) = \frac{\sum_{i=\rho}^n w_i X_{i:n}}{\sum_{i=\rho}^n w_i}. \]</phrase></textobject></mediaobject></equation></para><para>
</para></description><method-group name="public member functions">
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
</method-group>
<constructor><parameter name=""><paramtype>dont_care</paramtype></parameter></constructor>
</struct><struct name="p_square_cumulative_distribution_impl"><template>
      <template-type-parameter name="Sample"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Histogram calculation of the cumulative distribution with the <inlineequation><alt>$P^2$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_34.png"/></imageobject><textobject role="tex"><phrase>$P^2$</phrase></textobject></inlinemediaobject></inlineequation> algorithm. </purpose><description><para>A histogram of the sample cumulative distribution is computed dynamically without storing samples based on the <inlineequation><alt>$ P^2 $</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_38.png"/></imageobject><textobject role="tex"><phrase>$ P^2 $</phrase></textobject></inlinemediaobject></inlineequation> algorithm. The returned histogram has a specifiable amount (num_cells) equiprobable (and not equal-sized) cells.</para><para>For further details, see</para><para>R. Jain and I. Chlamtac, The P^2 algorithm for dynamic calculation of quantiles and histograms without storing observations, Communications of the ACM, Volume 28 (October), Number 10, 1985, p. 1076-1085.</para><para>
</para></description><method-group name="public member functions">
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></constructor>
</struct><struct name="p_square_quantile_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="Impl"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Single quantile estimation with the <inlineequation><alt>$P^2$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_34.png"/></imageobject><textobject role="tex"><phrase>$P^2$</phrase></textobject></inlinemediaobject></inlineequation> algorithm. </purpose><description><para>The <inlineequation><alt>$P^2$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_34.png"/></imageobject><textobject role="tex"><phrase>$P^2$</phrase></textobject></inlinemediaobject></inlineequation> algorithm estimates a quantile dynamically without storing samples. Instead of storing the whole sample cumulative distribution, only five points (markers) are stored. The heights of these markers are the minimum and the maximum of the samples and the current estimates of the <inlineequation><alt>$(p/2)$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_35.png"/></imageobject><textobject role="tex"><phrase>$(p/2)$</phrase></textobject></inlinemediaobject></inlineequation>-, <inlineequation><alt>$p$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_36.png"/></imageobject><textobject role="tex"><phrase>$p$</phrase></textobject></inlinemediaobject></inlineequation>- and <inlineequation><alt>$(1+p)/2$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_37.png"/></imageobject><textobject role="tex"><phrase>$(1+p)/2$</phrase></textobject></inlinemediaobject></inlineequation>-quantiles. Their positions are equal to the number of samples that are smaller or equal to the markers. Each time a new samples is recorded, the positions of the markers are updated and if necessary their heights are adjusted using a piecewise- parabolic formula.</para><para>For further details, see</para><para>R. Jain and I. Chlamtac, The P^2 algorithm for dynamic calculation of quantiles and histograms without storing observations, Communications of the ACM, Volume 28 (October), Number 10, 1985, p. 1076-1085.</para><para>
</para></description><method-group name="public member functions">
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><parameter name=""><paramtype>dont_care</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></constructor>
</struct><struct name="peaks_over_threshold_prob_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="LeftRight"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Peaks over Threshold Method for Quantile and Tail Mean Estimation. </purpose><description><para><para><emphasis role="bold">See Also:</emphasis><para><classname alt="boost::accumulators::impl::peaks_over_threshold_impl">peaks_over_threshold_impl</classname></para>
</para>

</para></description><method-group name="public member functions">
<method name="operator()"><type>void</type><parameter name=""><paramtype>dont_care</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></constructor>
</struct><struct name="pot_quantile_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="Impl"/>
      <template-type-parameter name="LeftRight"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Quantile Estimation based on Peaks over Threshold Method (for both left and right tails) </purpose><description><para>Computes an estimate <equation><title/><alt>\[ \hat{q}_{\alpha} = \bar{u} + \frac{\bar{\beta}}{\xi}\left[(1-\alpha)^{-\xi}-1\right] \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_89.png"/></imageobject><textobject role="tex"><phrase>\[ \hat{q}_{\alpha} = \bar{u} + \frac{\bar{\beta}}{\xi}\left[(1-\alpha)^{-\xi}-1\right] \]</phrase></textobject></mediaobject></equation> for a right or left extreme quantile, <inlineequation><alt>$\bar[u]$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_86.png"/></imageobject><textobject role="tex"><phrase>$\bar[u]$</phrase></textobject></inlinemediaobject></inlineequation>, <inlineequation><alt>$\bar{\beta}$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_87.png"/></imageobject><textobject role="tex"><phrase>$\bar{\beta}$</phrase></textobject></inlinemediaobject></inlineequation> and <inlineequation><alt>$\xi$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_88.png"/></imageobject><textobject role="tex"><phrase>$\xi$</phrase></textobject></inlinemediaobject></inlineequation> being the parameters of the generalized Pareto distribution that approximates the right tail of the distribution (or the mirrored left tail, in case the left tail is used). In the latter case, the result is mirrored back, yielding the correct result. </para></description><method-group name="public member functions">
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><parameter name=""><paramtype>dont_care</paramtype></parameter></constructor>
</struct><struct name="pot_tail_mean_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="Impl"/>
      <template-type-parameter name="LeftRight"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Estimation of the (coherent) tail mean based on the peaks over threshold method (for both left and right tails) </purpose><description><para>Computes an estimate for the (coherent) tail mean <equation><title/><alt>\[ \widehat{CTM}_{\alpha} = \hat{q}_{\alpha} - \frac{\bar{\beta}}{\xi-1}(1-\alpha)^{-\xi}, \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_85.png"/></imageobject><textobject role="tex"><phrase>\[ \widehat{CTM}_{\alpha} = \hat{q}_{\alpha} - \frac{\bar{\beta}}{\xi-1}(1-\alpha)^{-\xi}, \]</phrase></textobject></mediaobject></equation> where <inlineequation><alt>$\bar[u]$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_86.png"/></imageobject><textobject role="tex"><phrase>$\bar[u]$</phrase></textobject></inlinemediaobject></inlineequation>, <inlineequation><alt>$\bar{\beta}$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_87.png"/></imageobject><textobject role="tex"><phrase>$\bar{\beta}$</phrase></textobject></inlinemediaobject></inlineequation> and <inlineequation><alt>$\xi$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_88.png"/></imageobject><textobject role="tex"><phrase>$\xi$</phrase></textobject></inlinemediaobject></inlineequation> are the parameters of the generalized Pareto distribution that approximates the right tail of the distribution (or the mirrored left tail, in case the left tail is used). In the latter case, the result is mirrored back, yielding the correct result. </para></description><method-group name="public member functions">
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><parameter name=""><paramtype>dont_care</paramtype></parameter></constructor>
</struct><struct name="rolling_count_impl"><template>
      <template-type-parameter name="Sample"/>
    </template><inherit access="public">accumulator_base</inherit><method-group name="public member functions">
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><parameter name=""><paramtype>dont_care</paramtype></parameter></constructor>
</struct><struct name="rolling_mean_impl"><template>
      <template-type-parameter name="Sample"/>
    </template></struct><struct name="rolling_sum_impl"><template>
      <template-type-parameter name="Sample"/>
    </template><inherit access="public">accumulator_base</inherit><method-group name="public member functions">
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name=""><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></constructor>
</struct><struct name="rolling_window_impl"><template>
      <template-type-parameter name="Sample"/>
    </template><inherit access="public">accumulator_base</inherit><method-group name="public member functions">
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><parameter name=""><paramtype>dont_care</paramtype></parameter></constructor>
</struct><struct name="rolling_window_plus1_impl"><template>
      <template-type-parameter name="Sample"/>
    </template><inherit access="public">accumulator_base</inherit><method-group name="public member functions">
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="full" cv="const"><type>bool</type></method>
<method name="result" cv="const"><type>result_type</type><parameter name=""><paramtype>dont_care</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></constructor>
<constructor><parameter name="that"><paramtype><classname>rolling_window_plus1_impl</classname> const &amp;</paramtype></parameter></constructor>
<copy-assignment><type><classname>rolling_window_plus1_impl</classname> &amp;</type><parameter name="that"><paramtype><classname>rolling_window_plus1_impl</classname> const &amp;</paramtype></parameter></copy-assignment>
</struct><struct name="skewness_impl"><template>
      <template-type-parameter name="Sample"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Skewness estimation. </purpose><description><para>The skewness of a sample distribution is defined as the ratio of the 3rd central moment and the <inlineequation><alt>$ 3/2 $</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_28.png"/></imageobject><textobject role="tex"><phrase>$ 3/2 $</phrase></textobject></inlinemediaobject></inlineequation>-th power of the 2nd central moment (the variance) of the samples 3. The skewness can also be expressed by the simple moments:</para><para><equation><title/><alt>\[ \hat{g}_1 = \frac {\widehat{m}_n^{(3)}-3\widehat{m}_n^{(2)}\hat{\mu}_n+2\hat{\mu}_n^3} {\left(\widehat{m}_n^{(2)} - \hat{\mu}_n^{2}\right)^{3/2}} \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_29.png"/></imageobject><textobject role="tex"><phrase>\[ \hat{g}_1 = \frac {\widehat{m}_n^{(3)}-3\widehat{m}_n^{(2)}\hat{\mu}_n+2\hat{\mu}_n^3} {\left(\widehat{m}_n^{(2)} - \hat{\mu}_n^{2}\right)^{3/2}} \]</phrase></textobject></mediaobject></equation></para><para>where <inlineequation><alt>$ \widehat{m}_n^{(i)} $</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_30.png"/></imageobject><textobject role="tex"><phrase>$ \widehat{m}_n^{(i)} $</phrase></textobject></inlinemediaobject></inlineequation> are the <inlineequation><alt>$ i $</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_31.png"/></imageobject><textobject role="tex"><phrase>$ i $</phrase></textobject></inlinemediaobject></inlineequation>-th moment and <inlineequation><alt>$ \hat{\mu}_n $</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_32.png"/></imageobject><textobject role="tex"><phrase>$ \hat{\mu}_n $</phrase></textobject></inlinemediaobject></inlineequation> the mean (first moment) of the <inlineequation><alt>$ n $</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_33.png"/></imageobject><textobject role="tex"><phrase>$ n $</phrase></textobject></inlinemediaobject></inlineequation> samples. </para></description><method-group name="public member functions">
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><parameter name=""><paramtype>dont_care</paramtype></parameter></constructor>
</struct><struct name="sum_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="Tag"/>
    </template><inherit access="public">accumulator_base</inherit><method-group name="public member functions">
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><parameter name=""><paramtype>dont_care</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></constructor>
</struct><struct name="sum_kahan_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="Tag"/>
    </template><inherit access="public">accumulator_base</inherit><method-group name="public member functions">
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><parameter name=""><paramtype>dont_care</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter><purpose>Kahan summation algorithm. </purpose><description><para>The Kahan summation algorithm reduces the numerical error obtained with standard sequential sum. </para></description></constructor>
</struct><struct name="tail_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="LeftRight"/>
    </template><inherit access="public">accumulator_base</inherit><method-group name="public member functions">
<method name="BOOST_MPL_ASSERT"><type/><parameter name=""><paramtype>(mpl::or_&lt; is_same&lt; LeftRight, <classname>right</classname> &gt;, is_same&lt; LeftRight, <classname>left</classname> &gt; &gt;)</paramtype></parameter></method>
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><parameter name=""><paramtype>dont_care</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></constructor>
<constructor><parameter name="that"><paramtype><classname>tail_impl</classname> const &amp;</paramtype></parameter></constructor>
<method-group name="private member functions">
<method name="assign"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter><parameter name="index"><paramtype>std::size_t</paramtype></parameter></method>
</method-group>
</struct><struct name="tail_quantile_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="LeftRight"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Tail quantile estimation based on order statistics (for both left and right tails) </purpose><description><para>The estimation of a tail quantile <inlineequation><alt>$\hat{q}$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_19.png"/></imageobject><textobject role="tex"><phrase>$\hat{q}$</phrase></textobject></inlinemediaobject></inlineequation> with level <inlineequation><alt>$\alpha$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_20.png"/></imageobject><textobject role="tex"><phrase>$\alpha$</phrase></textobject></inlinemediaobject></inlineequation> based on order statistics requires the caching of at least the <inlineequation><alt>$\lceil n\alpha\rceil$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_65.png"/></imageobject><textobject role="tex"><phrase>$\lceil n\alpha\rceil$</phrase></textobject></inlinemediaobject></inlineequation> smallest or the <inlineequation><alt>$\lceil n(1-\alpha)\rceil$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_60.png"/></imageobject><textobject role="tex"><phrase>$\lceil n(1-\alpha)\rceil$</phrase></textobject></inlinemediaobject></inlineequation> largest samples, <inlineequation><alt>$n$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_3.png"/></imageobject><textobject role="tex"><phrase>$n$</phrase></textobject></inlinemediaobject></inlineequation> being the total number of samples. The largest of the <inlineequation><alt>$\lceil n\alpha\rceil$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_65.png"/></imageobject><textobject role="tex"><phrase>$\lceil n\alpha\rceil$</phrase></textobject></inlinemediaobject></inlineequation> smallest samples or the smallest of the <inlineequation><alt>$\lceil n(1-\alpha)\rceil$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_60.png"/></imageobject><textobject role="tex"><phrase>$\lceil n(1-\alpha)\rceil$</phrase></textobject></inlinemediaobject></inlineequation> largest samples provides an estimate for the quantile:</para><para><equation><title/><alt>\[ \hat{q}_{n,\alpha} = X_{\lceil \alpha n \rceil:n} \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_66.png"/></imageobject><textobject role="tex"><phrase>\[ \hat{q}_{n,\alpha} = X_{\lceil \alpha n \rceil:n} \]</phrase></textobject></mediaobject></equation></para><para>
</para></description><method-group name="public member functions">
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><parameter name=""><paramtype>dont_care</paramtype></parameter></constructor>
</struct><struct name="tail_variate_impl"><template>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
      <template-type-parameter name="LeftRight"/>
    </template><inherit access="public">accumulator_base</inherit><method-group name="public member functions">
<method name="assign"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter><parameter name="index"><paramtype>std::size_t</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></constructor>
<method-group name="private member functions">
<method name="do_result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="TailRng"/>
        </template><parameter name="rng"><paramtype>TailRng const &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
</struct><struct name="tail_variate_means_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="Impl"/>
      <template-type-parameter name="LeftRight"/>
      <template-type-parameter name="VariateTag"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Estimation of the absolute and relative tail variate means (for both left and right tails) </purpose><description><para>For all <inlineequation><alt>$j$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_9.png"/></imageobject><textobject role="tex"><phrase>$j$</phrase></textobject></inlinemediaobject></inlineequation>-th variates associated to the <inlineequation><alt>$\lceil n(1-\alpha)\rceil$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_60.png"/></imageobject><textobject role="tex"><phrase>$\lceil n(1-\alpha)\rceil$</phrase></textobject></inlinemediaobject></inlineequation> largest samples (or the <inlineequation><alt>$\lceil n(1-\alpha)\rceil$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_60.png"/></imageobject><textobject role="tex"><phrase>$\lceil n(1-\alpha)\rceil$</phrase></textobject></inlinemediaobject></inlineequation> smallest samples in case of the left tail), the absolute tail means <inlineequation><alt>$\widehat{ATM}_{n,\alpha}(X, j)$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_12.png"/></imageobject><textobject role="tex"><phrase>$\widehat{ATM}_{n,\alpha}(X, j)$</phrase></textobject></inlinemediaobject></inlineequation> are computed and returned as an iterator range. Alternatively, the relative tail means <inlineequation><alt>$\widehat{RTM}_{n,\alpha}(X, j)$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_13.png"/></imageobject><textobject role="tex"><phrase>$\widehat{RTM}_{n,\alpha}(X, j)$</phrase></textobject></inlinemediaobject></inlineequation> are returned, which are the absolute tail means normalized with the (non-coherent) sample tail mean <inlineequation><alt>$\widehat{NCTM}_{n,\alpha}(X)$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_14.png"/></imageobject><textobject role="tex"><phrase>$\widehat{NCTM}_{n,\alpha}(X)$</phrase></textobject></inlinemediaobject></inlineequation>.</para><para><equation><title/><alt>\[ \widehat{ATM}_{n,\alpha}^{\mathrm{right}}(X, j) = \frac{1}{\lceil n(1-\alpha) \rceil} \sum_{i=\lceil \alpha n \rceil}^n \xi_{j,i} \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_61.png"/></imageobject><textobject role="tex"><phrase>\[ \widehat{ATM}_{n,\alpha}^{\mathrm{right}}(X, j) = \frac{1}{\lceil n(1-\alpha) \rceil} \sum_{i=\lceil \alpha n \rceil}^n \xi_{j,i} \]</phrase></textobject></mediaobject></equation></para><para><equation><title/><alt>\[ \widehat{ATM}_{n,\alpha}^{\mathrm{left}}(X, j) = \frac{1}{\lceil n\alpha \rceil} \sum_{i=1}^{\lceil n\alpha \rceil} \xi_{j,i} \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_62.png"/></imageobject><textobject role="tex"><phrase>\[ \widehat{ATM}_{n,\alpha}^{\mathrm{left}}(X, j) = \frac{1}{\lceil n\alpha \rceil} \sum_{i=1}^{\lceil n\alpha \rceil} \xi_{j,i} \]</phrase></textobject></mediaobject></equation></para><para><equation><title/><alt>\[ \widehat{RTM}_{n,\alpha}^{\mathrm{right}}(X, j) = \frac{\sum_{i=\lceil n\alpha \rceil}^n \xi_{j,i}} {\lceil n(1-\alpha)\rceil\widehat{NCTM}_{n,\alpha}^{\mathrm{right}}(X)} \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_63.png"/></imageobject><textobject role="tex"><phrase>\[ \widehat{RTM}_{n,\alpha}^{\mathrm{right}}(X, j) = \frac{\sum_{i=\lceil n\alpha \rceil}^n \xi_{j,i}} {\lceil n(1-\alpha)\rceil\widehat{NCTM}_{n,\alpha}^{\mathrm{right}}(X)} \]</phrase></textobject></mediaobject></equation></para><para><equation><title/><alt>\[ \widehat{RTM}_{n,\alpha}^{\mathrm{left}}(X, j) = \frac{\sum_{i=1}^{\lceil n\alpha \rceil} \xi_{j,i}} {\lceil n\alpha\rceil\widehat{NCTM}_{n,\alpha}^{\mathrm{left}}(X)} \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_64.png"/></imageobject><textobject role="tex"><phrase>\[ \widehat{RTM}_{n,\alpha}^{\mathrm{left}}(X, j) = \frac{\sum_{i=1}^{\lceil n\alpha \rceil} \xi_{j,i}} {\lceil n\alpha\rceil\widehat{NCTM}_{n,\alpha}^{\mathrm{left}}(X)} \]</phrase></textobject></mediaobject></equation> </para></description><method-group name="public member functions">
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><parameter name=""><paramtype>dont_care</paramtype></parameter></constructor>
</struct><struct name="variance_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="MeanFeature"/>
      <template-type-parameter name="Tag"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Iterative calculation of variance. </purpose><description><para>Iterative calculation of sample variance <inlineequation><alt>$\sigma_n^2$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_55.png"/></imageobject><textobject role="tex"><phrase>$\sigma_n^2$</phrase></textobject></inlinemediaobject></inlineequation> according to the formula <equation><title/><alt>\[ \sigma_n^2 = \frac{1}{n} \sum_{i = 1}^n (x_i - \mu_n)^2 = \frac{n-1}{n} \sigma_{n-1}^2 + \frac{1}{n-1}(x_n - \mu_n)^2. \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_56.png"/></imageobject><textobject role="tex"><phrase>\[ \sigma_n^2 = \frac{1}{n} \sum_{i = 1}^n (x_i - \mu_n)^2 = \frac{n-1}{n} \sigma_{n-1}^2 + \frac{1}{n-1}(x_n - \mu_n)^2. \]</phrase></textobject></mediaobject></equation> where <equation><title/><alt>\[ \mu_n = \frac{1}{n} \sum_{i = 1}^n x_i. \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_54.png"/></imageobject><textobject role="tex"><phrase>\[ \mu_n = \frac{1}{n} \sum_{i = 1}^n x_i. \]</phrase></textobject></mediaobject></equation> is the estimate of the sample mean and <inlineequation><alt>$n$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_3.png"/></imageobject><textobject role="tex"><phrase>$n$</phrase></textobject></inlinemediaobject></inlineequation> is the number of samples.</para><para>Note that the sample variance is not defined for <inlineequation><alt>$n &lt;= 1$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_8.png"/></imageobject><textobject role="tex"><phrase>$n &lt;= 1$</phrase></textobject></inlinemediaobject></inlineequation>.</para><para>A simplification can be obtained by the approximate recursion <equation><title/><alt>\[ \sigma_n^2 \approx \frac{n-1}{n} \sigma_{n-1}^2 + \frac{1}{n}(x_n - \mu_n)^2. \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_57.png"/></imageobject><textobject role="tex"><phrase>\[ \sigma_n^2 \approx \frac{n-1}{n} \sigma_{n-1}^2 + \frac{1}{n}(x_n - \mu_n)^2. \]</phrase></textobject></mediaobject></equation> because the difference <equation><title/><alt>\[ \left(\frac{1}{n-1} - \frac{1}{n}\right)(x_n - \mu_n)^2 = \frac{1}{n(n-1)}(x_n - \mu_n)^2. \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_58.png"/></imageobject><textobject role="tex"><phrase>\[ \left(\frac{1}{n-1} - \frac{1}{n}\right)(x_n - \mu_n)^2 = \frac{1}{n(n-1)}(x_n - \mu_n)^2. \]</phrase></textobject></mediaobject></equation> converges to zero as <inlineequation><alt>$n \rightarrow \infty$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_59.png"/></imageobject><textobject role="tex"><phrase>$n \rightarrow \infty$</phrase></textobject></inlinemediaobject></inlineequation>. However, for small <inlineequation><alt>$ n $</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_33.png"/></imageobject><textobject role="tex"><phrase>$ n $</phrase></textobject></inlinemediaobject></inlineequation> the difference can be non-negligible. </para></description><method-group name="public member functions">
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><parameter name=""><paramtype>dont_care</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></constructor>
</struct><struct name="weighted_covariance_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="Weight"/>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Weighted Covariance Estimator. </purpose><description><para>An iterative Monte Carlo estimator for the weighted covariance <inlineequation><alt>$\mathrm{Cov}(X,X')$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_47.png"/></imageobject><textobject role="tex"><phrase>$\mathrm{Cov}(X,X')$</phrase></textobject></inlinemediaobject></inlineequation>, where <inlineequation><alt>$X$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_48.png"/></imageobject><textobject role="tex"><phrase>$X$</phrase></textobject></inlinemediaobject></inlineequation> is a sample and <inlineequation><alt>$X'$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_49.png"/></imageobject><textobject role="tex"><phrase>$X'$</phrase></textobject></inlinemediaobject></inlineequation> a variate, is given by:</para><para><equation><title/><alt>\[ \hat{c}_n = \frac{\bar{w}_n-w_n}{\bar{w}_n} \hat{c}_{n-1} + \frac{w_n}{\bar{w}_n-w_n}(X_n - \hat{\mu}_n)(X_n' - \hat{\mu}_n'), \quad n\ge2,\quad\hat{c}_1 = 0, \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_50.png"/></imageobject><textobject role="tex"><phrase>\[ \hat{c}_n = \frac{\bar{w}_n-w_n}{\bar{w}_n} \hat{c}_{n-1} + \frac{w_n}{\bar{w}_n-w_n}(X_n - \hat{\mu}_n)(X_n' - \hat{\mu}_n'), \quad n\ge2,\quad\hat{c}_1 = 0, \]</phrase></textobject></mediaobject></equation></para><para><inlineequation><alt>$\hat{\mu}_n$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_7.png"/></imageobject><textobject role="tex"><phrase>$\hat{\mu}_n$</phrase></textobject></inlinemediaobject></inlineequation> and <inlineequation><alt>$\hat{\mu}_n'$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_51.png"/></imageobject><textobject role="tex"><phrase>$\hat{\mu}_n'$</phrase></textobject></inlinemediaobject></inlineequation> being the weighted means of the samples and variates and <inlineequation><alt>$\bar{w}_n$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_5.png"/></imageobject><textobject role="tex"><phrase>$\bar{w}_n$</phrase></textobject></inlinemediaobject></inlineequation> the sum of the <inlineequation><alt>$n$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_3.png"/></imageobject><textobject role="tex"><phrase>$n$</phrase></textobject></inlinemediaobject></inlineequation> first weights <inlineequation><alt>$w_i$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_6.png"/></imageobject><textobject role="tex"><phrase>$w_i$</phrase></textobject></inlinemediaobject></inlineequation>. </para></description><method-group name="public member functions">
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><parameter name=""><paramtype>dont_care</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></constructor>
</struct><struct name="weighted_density_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="Weight"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Histogram density estimator for weighted samples. </purpose><description><para>The histogram density estimator returns a histogram of the sample distribution. The positions and sizes of the bins are determined using a specifiable number of cached samples (cache_size). The range between the minimum and the maximum of the cached samples is subdivided into a specifiable number of bins (num_bins) of same size. Additionally, an under- and an overflow bin is added to capture future under- and overflow samples. Once the bins are determined, the cached samples and all subsequent samples are added to the correct bins. At the end, a range of std::pair is returned, where each pair contains the position of the bin (lower bound) and the sum of the weights (normalized with the sum of all weights).</para><para>
</para></description><method-group name="public member functions">
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></constructor>
</struct><struct name="weighted_extended_p_square_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="Weight"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Multiple quantile estimation with the extended <inlineequation><alt>$P^2$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_34.png"/></imageobject><textobject role="tex"><phrase>$P^2$</phrase></textobject></inlinemediaobject></inlineequation> algorithm for weighted samples. </purpose><description><para>This version of the extended <inlineequation><alt>$P^2$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_34.png"/></imageobject><textobject role="tex"><phrase>$P^2$</phrase></textobject></inlinemediaobject></inlineequation> algorithm extends the extended <inlineequation><alt>$P^2$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_34.png"/></imageobject><textobject role="tex"><phrase>$P^2$</phrase></textobject></inlinemediaobject></inlineequation> algorithm to support weighted samples. The extended <inlineequation><alt>$P^2$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_34.png"/></imageobject><textobject role="tex"><phrase>$P^2$</phrase></textobject></inlinemediaobject></inlineequation> algorithm dynamically estimates several quantiles without storing samples. Assume that <inlineequation><alt>$m$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_43.png"/></imageobject><textobject role="tex"><phrase>$m$</phrase></textobject></inlinemediaobject></inlineequation> quantiles <inlineequation><alt>$\xi_{p_1}, \ldots, \xi_{p_m}$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_44.png"/></imageobject><textobject role="tex"><phrase>$\xi_{p_1}, \ldots, \xi_{p_m}$</phrase></textobject></inlinemediaobject></inlineequation> are to be estimated. Instead of storing the whole sample cumulative distribution, the algorithm maintains only <inlineequation><alt>$m+2$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_45.png"/></imageobject><textobject role="tex"><phrase>$m+2$</phrase></textobject></inlinemediaobject></inlineequation> principal markers and <inlineequation><alt>$m+1$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_46.png"/></imageobject><textobject role="tex"><phrase>$m+1$</phrase></textobject></inlinemediaobject></inlineequation> middle markers, whose positions are updated with each sample and whose heights are adjusted (if necessary) using a piecewise-parablic formula. The heights of the principal markers are the current estimates of the quantiles and are returned as an iterator range.</para><para>For further details, see</para><para>K. E. E. Raatikainen, Simultaneous estimation of several quantiles, Simulation, Volume 49, Number 4 (October), 1986, p. 159-164.</para><para>The extended <inlineequation><alt>$ P^2 $</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_38.png"/></imageobject><textobject role="tex"><phrase>$ P^2 $</phrase></textobject></inlinemediaobject></inlineequation> algorithm generalizes the <inlineequation><alt>$ P^2 $</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_38.png"/></imageobject><textobject role="tex"><phrase>$ P^2 $</phrase></textobject></inlinemediaobject></inlineequation> algorithm of</para><para>R. Jain and I. Chlamtac, The P^2 algorithm for dynamic calculation of quantiles and histograms without storing observations, Communications of the ACM, Volume 28 (October), Number 10, 1985, p. 1076-1085.</para><para>
</para></description><method-group name="public member functions">
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><parameter name=""><paramtype>dont_care</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></constructor>
</struct><struct name="weighted_kurtosis_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="Weight"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Kurtosis estimation for weighted samples. </purpose><description><para>The kurtosis of a sample distribution is defined as the ratio of the 4th central moment and the square of the 2nd central moment (the variance) of the samples, minus 3. The term <inlineequation><alt>$ -3 $</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_41.png"/></imageobject><textobject role="tex"><phrase>$ -3 $</phrase></textobject></inlinemediaobject></inlineequation> is added in order to ensure that the normal distribution has zero kurtosis. The kurtosis can also be expressed by the simple moments:</para><para><equation><title/><alt>\[ \hat{g}_2 = \frac {\widehat{m}_n^{(4)}-4\widehat{m}_n^{(3)}\hat{\mu}_n+6\widehat{m}_n^{(2)}\hat{\mu}_n^2-3\hat{\mu}_n^4} {\left(\widehat{m}_n^{(2)} - \hat{\mu}_n^{2}\right)^2} - 3, \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_42.png"/></imageobject><textobject role="tex"><phrase>\[ \hat{g}_2 = \frac {\widehat{m}_n^{(4)}-4\widehat{m}_n^{(3)}\hat{\mu}_n+6\widehat{m}_n^{(2)}\hat{\mu}_n^2-3\hat{\mu}_n^4} {\left(\widehat{m}_n^{(2)} - \hat{\mu}_n^{2}\right)^2} - 3, \]</phrase></textobject></mediaobject></equation></para><para>where <inlineequation><alt>$ \widehat{m}_n^{(i)} $</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_30.png"/></imageobject><textobject role="tex"><phrase>$ \widehat{m}_n^{(i)} $</phrase></textobject></inlinemediaobject></inlineequation> are the <inlineequation><alt>$ i $</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_31.png"/></imageobject><textobject role="tex"><phrase>$ i $</phrase></textobject></inlinemediaobject></inlineequation>-th moment and <inlineequation><alt>$ \hat{\mu}_n $</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_32.png"/></imageobject><textobject role="tex"><phrase>$ \hat{\mu}_n $</phrase></textobject></inlinemediaobject></inlineequation> the mean (first moment) of the <inlineequation><alt>$ n $</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_33.png"/></imageobject><textobject role="tex"><phrase>$ n $</phrase></textobject></inlinemediaobject></inlineequation> samples.</para><para>The kurtosis estimator for weighted samples is formally identical to the estimator for unweighted samples, except that the weighted counterparts of all measures it depends on are to be taken. </para></description><method-group name="public member functions">
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
</method-group>
<constructor><parameter name=""><paramtype>dont_care</paramtype></parameter></constructor>
</struct><struct name="weighted_mean_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="Weight"/>
      <template-type-parameter name="Tag"/>
    </template><inherit access="public">accumulator_base</inherit><method-group name="public member functions">
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
</method-group>
<constructor><parameter name=""><paramtype>dont_care</paramtype></parameter></constructor>
</struct><struct name="weighted_median_impl"><template>
      <template-type-parameter name="Sample"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Median estimation for weighted samples based on the <inlineequation><alt>$P^2$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_34.png"/></imageobject><textobject role="tex"><phrase>$P^2$</phrase></textobject></inlinemediaobject></inlineequation> quantile estimator. </purpose><description><para>The <inlineequation><alt>$P^2$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_34.png"/></imageobject><textobject role="tex"><phrase>$P^2$</phrase></textobject></inlinemediaobject></inlineequation> algorithm for weighted samples is invoked with a quantile probability of 0.5. </para></description><method-group name="public member functions">
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
</method-group>
<constructor><parameter name=""><paramtype>dont_care</paramtype></parameter></constructor>
</struct><struct name="weighted_moment_impl"><template>
      <template-type-parameter name="N"/>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="Weight"/>
    </template><inherit access="public">accumulator_base</inherit><method-group name="public member functions">
<method name="BOOST_MPL_ASSERT_RELATION"><type/><parameter name=""><paramtype>N::value</paramtype></parameter><parameter name=""><paramtype>0</paramtype></parameter></method>
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></constructor>
</struct><struct name="weighted_p_square_cumulative_distribution_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="Weight"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Histogram calculation of the cumulative distribution with the <inlineequation><alt>$P^2$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_34.png"/></imageobject><textobject role="tex"><phrase>$P^2$</phrase></textobject></inlinemediaobject></inlineequation> algorithm for weighted samples. </purpose><description><para>A histogram of the sample cumulative distribution is computed dynamically without storing samples based on the <inlineequation><alt>$ P^2 $</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_38.png"/></imageobject><textobject role="tex"><phrase>$ P^2 $</phrase></textobject></inlinemediaobject></inlineequation> algorithm for weighted samples. The returned histogram has a specifiable amount (num_cells) equiprobable (and not equal-sized) cells.</para><para>Note that applying importance sampling results in regions to be more and other regions to be less accurately estimated than without importance sampling, i.e., with unweighted samples.</para><para>For further details, see</para><para>R. Jain and I. Chlamtac, The P^2 algorithm for dynamic calculation of quantiles and histograms without storing observations, Communications of the ACM, Volume 28 (October), Number 10, 1985, p. 1076-1085.</para><para>
</para></description><method-group name="public member functions">
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></constructor>
</struct><struct name="weighted_p_square_quantile_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="Weight"/>
      <template-type-parameter name="Impl"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Single quantile estimation with the <inlineequation><alt>$P^2$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_34.png"/></imageobject><textobject role="tex"><phrase>$P^2$</phrase></textobject></inlinemediaobject></inlineequation> algorithm for weighted samples. </purpose><description><para>This version of the <inlineequation><alt>$P^2$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_34.png"/></imageobject><textobject role="tex"><phrase>$P^2$</phrase></textobject></inlinemediaobject></inlineequation> algorithm extends the <inlineequation><alt>$P^2$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_34.png"/></imageobject><textobject role="tex"><phrase>$P^2$</phrase></textobject></inlinemediaobject></inlineequation> algorithm to support weighted samples. The <inlineequation><alt>$P^2$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_34.png"/></imageobject><textobject role="tex"><phrase>$P^2$</phrase></textobject></inlinemediaobject></inlineequation> algorithm estimates a quantile dynamically without storing samples. Instead of storing the whole sample cumulative distribution, only five points (markers) are stored. The heights of these markers are the minimum and the maximum of the samples and the current estimates of the <inlineequation><alt>$(p/2)$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_35.png"/></imageobject><textobject role="tex"><phrase>$(p/2)$</phrase></textobject></inlinemediaobject></inlineequation>-, <inlineequation><alt>$p$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_36.png"/></imageobject><textobject role="tex"><phrase>$p$</phrase></textobject></inlinemediaobject></inlineequation> - and <inlineequation><alt>$(1+p)/2$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_37.png"/></imageobject><textobject role="tex"><phrase>$(1+p)/2$</phrase></textobject></inlinemediaobject></inlineequation> -quantiles. Their positions are equal to the number of samples that are smaller or equal to the markers. Each time a new sample is added, the positions of the markers are updated and if necessary their heights are adjusted using a piecewise- parabolic formula.</para><para>For further details, see</para><para>R. Jain and I. Chlamtac, The P^2 algorithm for dynamic calculation of quantiles and histograms without storing observations, Communications of the ACM, Volume 28 (October), Number 10, 1985, p. 1076-1085.</para><para>
</para></description><method-group name="public member functions">
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><parameter name=""><paramtype>dont_care</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></constructor>
</struct><struct name="weighted_peaks_over_threshold_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="Weight"/>
      <template-type-parameter name="LeftRight"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Weighted Peaks over Threshold Method for Weighted Quantile and Weighted Tail Mean Estimation. </purpose><description><para><para><emphasis role="bold">See Also:</emphasis><para><classname alt="boost::accumulators::impl::peaks_over_threshold_impl">peaks_over_threshold_impl</classname></para>
</para>

</para></description><method-group name="public member functions">
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></constructor>
</struct><struct name="weighted_peaks_over_threshold_prob_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="Weight"/>
      <template-type-parameter name="LeftRight"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Peaks over Threshold Method for Quantile and Tail Mean Estimation. </purpose><description><para><para><emphasis role="bold">See Also:</emphasis><para><classname alt="boost::accumulators::impl::weighted_peaks_over_threshold_impl">weighted_peaks_over_threshold_impl</classname></para>
</para>

</para></description><method-group name="public member functions">
<method name="operator()"><type>void</type><parameter name=""><paramtype>dont_care</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></constructor>
</struct><struct name="weighted_skewness_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="Weight"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Skewness estimation for weighted samples. </purpose><description><para>The skewness of a sample distribution is defined as the ratio of the 3rd central moment and the <inlineequation><alt>$ 3/2 $</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_28.png"/></imageobject><textobject role="tex"><phrase>$ 3/2 $</phrase></textobject></inlinemediaobject></inlineequation>-th power $ of the 2nd central moment (the variance) of the samples. The skewness can also be expressed by the simple moments:</para><para><equation><title/><alt>\[ \hat{g}_1 = \frac {\widehat{m}_n^{(3)}-3\widehat{m}_n^{(2)}\hat{\mu}_n+2\hat{\mu}_n^3} {\left(\widehat{m}_n^{(2)} - \hat{\mu}_n^{2}\right)^{3/2}} \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_29.png"/></imageobject><textobject role="tex"><phrase>\[ \hat{g}_1 = \frac {\widehat{m}_n^{(3)}-3\widehat{m}_n^{(2)}\hat{\mu}_n+2\hat{\mu}_n^3} {\left(\widehat{m}_n^{(2)} - \hat{\mu}_n^{2}\right)^{3/2}} \]</phrase></textobject></mediaobject></equation></para><para>where <inlineequation><alt>$ \widehat{m}_n^{(i)} $</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_30.png"/></imageobject><textobject role="tex"><phrase>$ \widehat{m}_n^{(i)} $</phrase></textobject></inlinemediaobject></inlineequation> are the <inlineequation><alt>$ i $</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_31.png"/></imageobject><textobject role="tex"><phrase>$ i $</phrase></textobject></inlinemediaobject></inlineequation>-th moment and <inlineequation><alt>$ \hat{\mu}_n $</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_32.png"/></imageobject><textobject role="tex"><phrase>$ \hat{\mu}_n $</phrase></textobject></inlinemediaobject></inlineequation> the mean (first moment) of the <inlineequation><alt>$ n $</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_33.png"/></imageobject><textobject role="tex"><phrase>$ n $</phrase></textobject></inlinemediaobject></inlineequation> samples.</para><para>The skewness estimator for weighted samples is formally identical to the estimator for unweighted samples, except that the weighted counterparts of all measures it depends on are to be taken. </para></description><method-group name="public member functions">
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
</method-group>
<constructor><parameter name=""><paramtype>dont_care</paramtype></parameter></constructor>
</struct><struct name="weighted_sum_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="Weight"/>
      <template-type-parameter name="Tag"/>
    </template><inherit access="public">accumulator_base</inherit><method-group name="public member functions">
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><parameter name=""><paramtype>dont_care</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></constructor>
</struct><struct name="weighted_sum_kahan_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="Weight"/>
      <template-type-parameter name="Tag"/>
    </template><inherit access="public">accumulator_base</inherit><method-group name="public member functions">
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><parameter name=""><paramtype>dont_care</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></constructor>
</struct><struct name="weighted_tail_quantile_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="Weight"/>
      <template-type-parameter name="LeftRight"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Tail quantile estimation based on order statistics of weighted samples (for both left and right tails) </purpose><description><para>An estimator <inlineequation><alt>$\hat{q}$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_19.png"/></imageobject><textobject role="tex"><phrase>$\hat{q}$</phrase></textobject></inlinemediaobject></inlineequation> of tail quantiles with level <inlineequation><alt>$\alpha$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_20.png"/></imageobject><textobject role="tex"><phrase>$\alpha$</phrase></textobject></inlinemediaobject></inlineequation> based on order statistics <inlineequation><alt>$X_{1:n} \leq X_{2:n} \leq\dots\leq X_{n:n}$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_21.png"/></imageobject><textobject role="tex"><phrase>$X_{1:n} \leq X_{2:n} \leq\dots\leq X_{n:n}$</phrase></textobject></inlinemediaobject></inlineequation> of weighted samples are given by <inlineequation><alt>$X_{\lambda:n}$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_22.png"/></imageobject><textobject role="tex"><phrase>$X_{\lambda:n}$</phrase></textobject></inlinemediaobject></inlineequation> (left tail) and <inlineequation><alt>$X_{\rho:n}$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_23.png"/></imageobject><textobject role="tex"><phrase>$X_{\rho:n}$</phrase></textobject></inlinemediaobject></inlineequation> (right tail), where</para><para><equation><title/><alt>\[ \lambda = \inf\left\{ l \left| \frac{1}{\bar{w}_n}\sum_{i=1}^{l} w_i \geq \alpha \right. \right\} \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_10.png"/></imageobject><textobject role="tex"><phrase>\[ \lambda = \inf\left\{ l \left| \frac{1}{\bar{w}_n}\sum_{i=1}^{l} w_i \geq \alpha \right. \right\} \]</phrase></textobject></mediaobject></equation></para><para>and</para><para><equation><title/><alt>\[ \rho = \sup\left\{ r \left| \frac{1}{\bar{w}_n}\sum_{i=r}^{n} w_i \geq (1 - \alpha) \right. \right\}, \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_24.png"/></imageobject><textobject role="tex"><phrase>\[ \rho = \sup\left\{ r \left| \frac{1}{\bar{w}_n}\sum_{i=r}^{n} w_i \geq (1 - \alpha) \right. \right\}, \]</phrase></textobject></mediaobject></equation></para><para><inlineequation><alt>$n$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_3.png"/></imageobject><textobject role="tex"><phrase>$n$</phrase></textobject></inlinemediaobject></inlineequation> being the number of samples and <inlineequation><alt>$\bar{w}_n$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_5.png"/></imageobject><textobject role="tex"><phrase>$\bar{w}_n$</phrase></textobject></inlinemediaobject></inlineequation> the sum of all weights.</para><para>
</para></description><method-group name="public member functions">
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
</method-group>
<constructor><parameter name=""><paramtype>dont_care</paramtype></parameter></constructor>
</struct><struct name="weighted_tail_variate_means_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="Weight"/>
      <template-type-parameter name="Impl"/>
      <template-type-parameter name="LeftRight"/>
      <template-type-parameter name="VariateType"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Estimation of the absolute and relative weighted tail variate means (for both left and right tails) </purpose><description><para>For all <inlineequation><alt>$j$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_9.png"/></imageobject><textobject role="tex"><phrase>$j$</phrase></textobject></inlinemediaobject></inlineequation>-th variates associated to the</para><para><equation><title/><alt>\[ \lambda = \inf\left\{ l \left| \frac{1}{\bar{w}_n}\sum_{i=1}^{l} w_i \geq \alpha \right. \right\} \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_10.png"/></imageobject><textobject role="tex"><phrase>\[ \lambda = \inf\left\{ l \left| \frac{1}{\bar{w}_n}\sum_{i=1}^{l} w_i \geq \alpha \right. \right\} \]</phrase></textobject></mediaobject></equation></para><para>smallest samples (left tail) or the weighted mean of the</para><para><equation><title/><alt>\[ n + 1 - \rho = n + 1 - \sup\left\{ r \left| \frac{1}{\bar{w}_n}\sum_{i=r}^{n} w_i \geq (1 - \alpha) \right. \right\} \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_11.png"/></imageobject><textobject role="tex"><phrase>\[ n + 1 - \rho = n + 1 - \sup\left\{ r \left| \frac{1}{\bar{w}_n}\sum_{i=r}^{n} w_i \geq (1 - \alpha) \right. \right\} \]</phrase></textobject></mediaobject></equation></para><para>largest samples (right tail), the absolute weighted tail means <inlineequation><alt>$\widehat{ATM}_{n,\alpha}(X, j)$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_12.png"/></imageobject><textobject role="tex"><phrase>$\widehat{ATM}_{n,\alpha}(X, j)$</phrase></textobject></inlinemediaobject></inlineequation> are computed and returned as an iterator range. Alternatively, the relative weighted tail means <inlineequation><alt>$\widehat{RTM}_{n,\alpha}(X, j)$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_13.png"/></imageobject><textobject role="tex"><phrase>$\widehat{RTM}_{n,\alpha}(X, j)$</phrase></textobject></inlinemediaobject></inlineequation> are returned, which are the absolute weighted tail means normalized with the weighted (non-coherent) sample tail mean <inlineequation><alt>$\widehat{NCTM}_{n,\alpha}(X)$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_14.png"/></imageobject><textobject role="tex"><phrase>$\widehat{NCTM}_{n,\alpha}(X)$</phrase></textobject></inlinemediaobject></inlineequation>.</para><para><equation><title/><alt>\[ \widehat{ATM}_{n,\alpha}^{\mathrm{right}}(X, j) = \frac{1}{\sum_{i=\rho}^n w_i} \sum_{i=\rho}^n w_i \xi_{j,i} \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_15.png"/></imageobject><textobject role="tex"><phrase>\[ \widehat{ATM}_{n,\alpha}^{\mathrm{right}}(X, j) = \frac{1}{\sum_{i=\rho}^n w_i} \sum_{i=\rho}^n w_i \xi_{j,i} \]</phrase></textobject></mediaobject></equation></para><para><equation><title/><alt>\[ \widehat{ATM}_{n,\alpha}^{\mathrm{left}}(X, j) = \frac{1}{\sum_{i=1}^{\lambda}} \sum_{i=1}^{\lambda} w_i \xi_{j,i} \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_16.png"/></imageobject><textobject role="tex"><phrase>\[ \widehat{ATM}_{n,\alpha}^{\mathrm{left}}(X, j) = \frac{1}{\sum_{i=1}^{\lambda}} \sum_{i=1}^{\lambda} w_i \xi_{j,i} \]</phrase></textobject></mediaobject></equation></para><para><equation><title/><alt>\[ \widehat{RTM}_{n,\alpha}^{\mathrm{right}}(X, j) = \frac{\sum_{i=\rho}^n w_i \xi_{j,i}} {\sum_{i=\rho}^n w_i \widehat{NCTM}_{n,\alpha}^{\mathrm{right}}(X)} \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_17.png"/></imageobject><textobject role="tex"><phrase>\[ \widehat{RTM}_{n,\alpha}^{\mathrm{right}}(X, j) = \frac{\sum_{i=\rho}^n w_i \xi_{j,i}} {\sum_{i=\rho}^n w_i \widehat{NCTM}_{n,\alpha}^{\mathrm{right}}(X)} \]</phrase></textobject></mediaobject></equation></para><para><equation><title/><alt>\[ \widehat{RTM}_{n,\alpha}^{\mathrm{left}}(X, j) = \frac{\sum_{i=1}^{\lambda} w_i \xi_{j,i}} {\sum_{i=1}^{\lambda} w_i \widehat{NCTM}_{n,\alpha}^{\mathrm{left}}(X)} \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_18.png"/></imageobject><textobject role="tex"><phrase>\[ \widehat{RTM}_{n,\alpha}^{\mathrm{left}}(X, j) = \frac{\sum_{i=1}^{\lambda} w_i \xi_{j,i}} {\sum_{i=1}^{\lambda} w_i \widehat{NCTM}_{n,\alpha}^{\mathrm{left}}(X)} \]</phrase></textobject></mediaobject></equation> </para></description><method-group name="public member functions">
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><parameter name=""><paramtype>dont_care</paramtype></parameter></constructor>
</struct><struct name="weighted_variance_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="Weight"/>
      <template-type-parameter name="MeanFeature"/>
      <template-type-parameter name="Tag"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Iterative calculation of variance of weighted samples. </purpose><description><para>Iterative calculation of variance of weighted samples: <equation><title/><alt>\[ \hat{\sigma}_n^2 = \frac{\bar{w}_n - w_n}{\bar{w}_n}\hat{\sigma}_{n - 1}^2 + \frac{w_n}{\bar{w}_n - w_n}\left(X_n - \hat{\mu}_n\right)^2 ,\quad n\ge2,\quad\hat{\sigma}_0^2 = 0. \]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/accumulators//form_4.png"/></imageobject><textobject role="tex"><phrase>\[ \hat{\sigma}_n^2 = \frac{\bar{w}_n - w_n}{\bar{w}_n}\hat{\sigma}_{n - 1}^2 + \frac{w_n}{\bar{w}_n - w_n}\left(X_n - \hat{\mu}_n\right)^2 ,\quad n\ge2,\quad\hat{\sigma}_0^2 = 0. \]</phrase></textobject></mediaobject></equation> where <inlineequation><alt>$\bar{w}_n$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_5.png"/></imageobject><textobject role="tex"><phrase>$\bar{w}_n$</phrase></textobject></inlinemediaobject></inlineequation> is the sum of the <inlineequation><alt>$n$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_3.png"/></imageobject><textobject role="tex"><phrase>$n$</phrase></textobject></inlinemediaobject></inlineequation> weights <inlineequation><alt>$w_i$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_6.png"/></imageobject><textobject role="tex"><phrase>$w_i$</phrase></textobject></inlinemediaobject></inlineequation> and <inlineequation><alt>$\hat{\mu}_n$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_7.png"/></imageobject><textobject role="tex"><phrase>$\hat{\mu}_n$</phrase></textobject></inlinemediaobject></inlineequation> the estimate of the mean of the weighted samples. Note that the sample variance is not defined for <inlineequation><alt>$n &lt;= 1$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_8.png"/></imageobject><textobject role="tex"><phrase>$n &lt;= 1$</phrase></textobject></inlinemediaobject></inlineequation>. </para></description><method-group name="public member functions">
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><parameter name=""><paramtype>dont_care</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></constructor>
</struct><struct name="with_density_median_impl"><template>
      <template-type-parameter name="Sample"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Median estimation based on the density estimator. </purpose><description><para>The algorithm determines the bin in which the <inlineequation><alt>$0.5*cnt$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_39.png"/></imageobject><textobject role="tex"><phrase>$0.5*cnt$</phrase></textobject></inlinemediaobject></inlineequation>-th sample lies, <inlineequation><alt>$cnt$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_40.png"/></imageobject><textobject role="tex"><phrase>$cnt$</phrase></textobject></inlinemediaobject></inlineequation> being the total number of samples. It returns the approximate horizontal position of this sample, based on a linear interpolation inside the bin. </para></description><method-group name="public member functions">
<method name="operator()"><type>void</type><parameter name=""><paramtype>dont_care</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></constructor>
</struct><struct name="with_density_weighted_median_impl"><template>
      <template-type-parameter name="Sample"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Median estimation for weighted samples based on the density estimator. </purpose><description><para>The algorithm determines the bin in which the <inlineequation><alt>$0.5*cnt$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_39.png"/></imageobject><textobject role="tex"><phrase>$0.5*cnt$</phrase></textobject></inlinemediaobject></inlineequation>-th sample lies, <inlineequation><alt>$cnt$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_40.png"/></imageobject><textobject role="tex"><phrase>$cnt$</phrase></textobject></inlinemediaobject></inlineequation> being the total number of samples. It returns the approximate horizontal position of this sample, based on a linear interpolation inside the bin. </para></description><method-group name="public member functions">
<method name="operator()"><type>void</type><parameter name=""><paramtype>dont_care</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></constructor>
</struct><struct name="with_p_square_cumulative_distribution_median_impl"><template>
      <template-type-parameter name="Sample"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Median estimation based on the <inlineequation><alt>$P^2$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_34.png"/></imageobject><textobject role="tex"><phrase>$P^2$</phrase></textobject></inlinemediaobject></inlineequation> cumulative distribution estimator. </purpose><description><para>The algorithm determines the first (leftmost) bin with a height exceeding 0.5. It returns the approximate horizontal position of where the cumulative distribution equals 0.5, based on a linear interpolation inside the bin. </para></description><method-group name="public member functions">
<method name="operator()"><type>void</type><parameter name=""><paramtype>dont_care</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><parameter name=""><paramtype>dont_care</paramtype></parameter></constructor>
</struct><struct name="with_p_square_cumulative_distribution_weighted_median_impl"><template>
      <template-type-parameter name="Sample"/>
      <template-type-parameter name="Weight"/>
    </template><inherit access="public">accumulator_base</inherit><purpose>Median estimation for weighted samples based on the <inlineequation><alt>$P^2$</alt><inlinemediaobject><imageobject role="html"><imagedata format="PNG" fileref="images/accumulators//form_34.png"/></imageobject><textobject role="tex"><phrase>$P^2$</phrase></textobject></inlinemediaobject></inlineequation> cumulative distribution estimator. </purpose><description><para>The algorithm determines the first (leftmost) bin with a height exceeding 0.5. It returns the approximate horizontal position of where the cumulative distribution equals 0.5, based on a linear interpolation inside the bin. </para></description><method-group name="public member functions">
<method name="operator()"><type>void</type><parameter name=""><paramtype>dont_care</paramtype></parameter></method>
<method name="result" cv="const"><type>result_type</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args const &amp;</paramtype></parameter></method>
<method name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype></parameter></method>
</method-group>
<constructor><parameter name=""><paramtype>dont_care</paramtype></parameter></constructor>
</struct>
</namespace>
<namespace name="tag">
<struct name="absolute_tail_variate_means"><template>
      <template-type-parameter name="LeftRight"/>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><inherit access="public">boost::accumulators::depends_on&lt; count, non_coherent_tail_mean&lt; LeftRight &gt;, tail_variate&lt; VariateType, VariateTag, LeftRight &gt; &gt;</inherit></struct><struct name="absolute_weighted_tail_variate_means"><template>
      <template-type-parameter name="LeftRight"/>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><inherit access="public">boost::accumulators::depends_on&lt; non_coherent_weighted_tail_mean&lt; LeftRight &gt;, tail_variate&lt; VariateType, VariateTag, LeftRight &gt;, tail_weights&lt; LeftRight &gt; &gt;</inherit></struct><struct name="coherent_tail_mean"><template>
      <template-type-parameter name="LeftRight"/>
    </template><inherit access="public">boost::accumulators::depends_on&lt; count, quantile, non_coherent_tail_mean&lt; LeftRight &gt; &gt;</inherit></struct><struct name="covariance"><template>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><inherit access="public">boost::accumulators::depends_on&lt; count, mean, mean_of_variates&lt; VariateType, VariateTag &gt; &gt;</inherit></struct><struct name="error_of"><template>
      <template-type-parameter name="Feature"/>
    </template><inherit access="public">boost::accumulators::depends_on&lt; Feature &gt;</inherit></struct><struct name="immediate_mean_of_variates"><template>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><inherit access="public">boost::accumulators::depends_on&lt; count &gt;</inherit></struct><struct name="immediate_weighted_mean_of_variates"><template>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><inherit access="public">boost::accumulators::depends_on&lt; sum_of_weights &gt;</inherit></struct><struct name="left_tail_variate"><template>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
      <template-type-parameter name="LeftRight"/>
    </template></struct><struct name="mean_of_variates"><template>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><inherit access="public">boost::accumulators::depends_on&lt; count, sum_of_variates&lt; VariateType, VariateTag &gt; &gt;</inherit></struct><struct name="moment"><template>
      <template-nontype-parameter name="N"><type>int</type></template-nontype-parameter>
    </template><inherit access="public">boost::accumulators::depends_on&lt; count &gt;</inherit></struct><struct name="non_coherent_tail_mean"><template>
      <template-type-parameter name="LeftRight"/>
    </template><inherit access="public">boost::accumulators::depends_on&lt; count, tail&lt; LeftRight &gt; &gt;</inherit></struct><struct name="non_coherent_weighted_tail_mean"><template>
      <template-type-parameter name="LeftRight"/>
    </template><inherit access="public">boost::accumulators::depends_on&lt; sum_of_weights, tail_weights&lt; LeftRight &gt; &gt;</inherit></struct><struct name="peaks_over_threshold"><template>
      <template-type-parameter name="LeftRight"/>
    </template><inherit access="public">boost::accumulators::depends_on&lt; count &gt;</inherit><inherit access="public">pot_threshold_value</inherit></struct><struct name="peaks_over_threshold_prob"><template>
      <template-type-parameter name="LeftRight"/>
    </template><inherit access="public">boost::accumulators::depends_on&lt; count, tail&lt; LeftRight &gt; &gt;</inherit><inherit access="public">pot_threshold_probability</inherit></struct><struct name="pot_quantile"><template>
      <template-type-parameter name="LeftRight"/>
    </template><inherit access="public">boost::accumulators::depends_on&lt; peaks_over_threshold&lt; LeftRight &gt; &gt;</inherit></struct><struct name="pot_quantile_prob"><template>
      <template-type-parameter name="LeftRight"/>
    </template><inherit access="public">boost::accumulators::depends_on&lt; peaks_over_threshold_prob&lt; LeftRight &gt; &gt;</inherit></struct><struct name="pot_tail_mean"><template>
      <template-type-parameter name="LeftRight"/>
    </template><inherit access="public">boost::accumulators::depends_on&lt; peaks_over_threshold&lt; LeftRight &gt;, pot_quantile&lt; LeftRight &gt; &gt;</inherit></struct><struct name="pot_tail_mean_prob"><template>
      <template-type-parameter name="LeftRight"/>
    </template><inherit access="public">boost::accumulators::depends_on&lt; peaks_over_threshold_prob&lt; LeftRight &gt;, pot_quantile_prob&lt; LeftRight &gt; &gt;</inherit></struct><struct name="quantile"><inherit access="public">boost::accumulators::depends_on&lt;&gt;</inherit><typedef name="impl"><type>mpl::print&lt; class ____MISSING_SPECIFIC_QUANTILE_FEATURE_IN_ACCUMULATOR_SET____ &gt;</type></typedef>
</struct><struct name="relative_tail_variate_means"><template>
      <template-type-parameter name="LeftRight"/>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><inherit access="public">boost::accumulators::depends_on&lt; count, non_coherent_tail_mean&lt; LeftRight &gt;, tail_variate&lt; VariateType, VariateTag, LeftRight &gt; &gt;</inherit></struct><struct name="relative_weighted_tail_variate_means"><template>
      <template-type-parameter name="LeftRight"/>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><inherit access="public">boost::accumulators::depends_on&lt; non_coherent_weighted_tail_mean&lt; LeftRight &gt;, tail_variate&lt; VariateType, VariateTag, LeftRight &gt;, tail_weights&lt; LeftRight &gt; &gt;</inherit></struct><struct name="right_tail_variate"><template>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
      <template-type-parameter name="LeftRight"/>
    </template></struct><struct name="sum_of_variates"><template>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><inherit access="public">boost::accumulators::depends_on&lt;&gt;</inherit></struct><struct name="sum_of_variates_kahan"><template>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><inherit access="public">boost::accumulators::depends_on&lt;&gt;</inherit></struct><struct name="tail"><template>
      <template-type-parameter name="LeftRight"/>
    </template><inherit access="public">boost::accumulators::depends_on&lt;&gt;</inherit><inherit access="public">boost::accumulators::tail_cache_size_named_arg&lt; LeftRight &gt;</inherit></struct><struct name="tail_mean"><inherit access="public">boost::accumulators::depends_on&lt;&gt;</inherit><typedef name="impl"><type>mpl::print&lt; class ____MISSING_SPECIFIC_TAIL_MEAN_FEATURE_IN_ACCUMULATOR_SET____ &gt;</type></typedef>
</struct><struct name="tail_quantile"><template>
      <template-type-parameter name="LeftRight"/>
    </template><inherit access="public">boost::accumulators::depends_on&lt; count, tail&lt; LeftRight &gt; &gt;</inherit></struct><struct name="tail_variate"><template>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
      <template-type-parameter name="LeftRight"/>
    </template><inherit access="public">boost::accumulators::depends_on&lt; tail&lt; LeftRight &gt; &gt;</inherit></struct><struct name="tail_variate_means"><template>
      <template-type-parameter name="LeftRight"/>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template></struct><struct name="tail_weights"><template>
      <template-type-parameter name="LeftRight"/>
    </template><inherit access="public">boost::accumulators::depends_on&lt; tail&lt; LeftRight &gt; &gt;</inherit></struct><struct name="weighted_covariance"><template>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><inherit access="public">boost::accumulators::depends_on&lt; count, sum_of_weights, weighted_mean, weighted_mean_of_variates&lt; VariateType, VariateTag &gt; &gt;</inherit></struct><struct name="weighted_mean_of_variates"><template>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><inherit access="public">boost::accumulators::depends_on&lt; sum_of_weights, weighted_sum_of_variates&lt; VariateType, VariateTag &gt; &gt;</inherit></struct><struct name="weighted_moment"><template>
      <template-nontype-parameter name="N"><type>int</type></template-nontype-parameter>
    </template><inherit access="public">boost::accumulators::depends_on&lt; count, sum_of_weights &gt;</inherit></struct><struct name="weighted_peaks_over_threshold"><template>
      <template-type-parameter name="LeftRight"/>
    </template><inherit access="public">boost::accumulators::depends_on&lt; sum_of_weights &gt;</inherit><inherit access="public">pot_threshold_value</inherit></struct><struct name="weighted_peaks_over_threshold_prob"><template>
      <template-type-parameter name="LeftRight"/>
    </template><inherit access="public">boost::accumulators::depends_on&lt; sum_of_weights, tail_weights&lt; LeftRight &gt; &gt;</inherit><inherit access="public">pot_threshold_probability</inherit></struct><struct name="weighted_pot_quantile"><template>
      <template-type-parameter name="LeftRight"/>
    </template><inherit access="public">boost::accumulators::depends_on&lt; weighted_peaks_over_threshold&lt; LeftRight &gt; &gt;</inherit></struct><struct name="weighted_pot_quantile_prob"><template>
      <template-type-parameter name="LeftRight"/>
    </template><inherit access="public">boost::accumulators::depends_on&lt; weighted_peaks_over_threshold_prob&lt; LeftRight &gt; &gt;</inherit></struct><struct name="weighted_pot_tail_mean"><template>
      <template-type-parameter name="LeftRight"/>
    </template><inherit access="public">boost::accumulators::depends_on&lt; weighted_peaks_over_threshold&lt; LeftRight &gt;, weighted_pot_quantile&lt; LeftRight &gt; &gt;</inherit></struct><struct name="weighted_pot_tail_mean_prob"><template>
      <template-type-parameter name="LeftRight"/>
    </template><inherit access="public">boost::accumulators::depends_on&lt; weighted_peaks_over_threshold_prob&lt; LeftRight &gt;, weighted_pot_quantile_prob&lt; LeftRight &gt; &gt;</inherit></struct><struct name="weighted_sum_of_variates"><template>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template><inherit access="public">boost::accumulators::depends_on&lt;&gt;</inherit></struct><struct name="weighted_tail_quantile"><template>
      <template-type-parameter name="LeftRight"/>
    </template><inherit access="public">boost::accumulators::depends_on&lt; sum_of_weights, tail_weights&lt; LeftRight &gt; &gt;</inherit></struct><struct name="weighted_tail_variate_means"><template>
      <template-type-parameter name="LeftRight"/>
      <template-type-parameter name="VariateType"/>
      <template-type-parameter name="VariateTag"/>
    </template></struct></namespace>
</namespace>
</namespace>
</header>
</library-reference>