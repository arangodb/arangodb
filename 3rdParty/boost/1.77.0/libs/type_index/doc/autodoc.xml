<?xml version="1.0" standalone="yes"?>
<library-reference id="boost_typeindex_header_reference"><title>Boost.TypeIndex Header Reference</title><header name="boost/type_index.hpp">
<para>Includes minimal set of headers required to use the Boost.TypeIndex library. </para><para>By inclusion of this file most optimal type index classes will be included and used as a boost::typeindex::type_index and boost::typeindex::type_info. </para><namespace name="boost">
<namespace name="typeindex">
<typedef name="type_index"><description><para>Depending on a compiler flags, optimal implementation of type_index will be used as a default boost::typeindex::type_index.</para><para>Could be a <classname alt="boost::typeindex::stl_type_index">boost::typeindex::stl_type_index</classname>, <classname alt="boost::typeindex::ctti_type_index">boost::typeindex::ctti_type_index</classname> or user defined type_index class.</para><para><emphasis role="bold">See</emphasis> <classname alt="boost::typeindex::type_index_facade">boost::typeindex::type_index_facade</classname> for a full description of type_index functions. </para></description><type>platform_specific</type></typedef>
<typedef name="type_info"><description><para>Depending on a compiler flags, optimal implementation of type_info will be used as a default boost::typeindex::type_info.</para><para>Could be a std::type_info, <classname alt="boost::typeindex::detail::ctti_data">boost::typeindex::detail::ctti_data</classname> or some user defined class.</para><para>type_info <emphasis role="bold">is</emphasis> <emphasis role="bold">not</emphasis> copyable or default constructible. It is <emphasis role="bold">not</emphasis> assignable too! </para></description><type>type_index::type_info_t</type></typedef>
<function name="type_id"><type>type_index</type><template>
          <template-type-parameter name="T"><purpose><para>Type for which type_index must be created. </para></purpose></template-type-parameter>
        </template><description><para>Function to get boost::typeindex::type_index for a type T. Removes const, volatile &amp;&amp; and &amp; modifiers from T.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">type_index ti = type_id&lt;int&amp;&gt;();
std::cout &lt;&lt; ti.pretty_name();  // Outputs 'int'
</programlisting></para><para>


</para></description><returns><para>boost::typeindex::type_index with information about the specified type T. </para>
</returns><throws><simpara><classname>Nothing.</classname> </simpara></throws></function>
<function name="type_id_with_cvr"><type>type_index</type><template>
          <template-type-parameter name="T"><purpose><para>Type for which type_index must be created. </para></purpose></template-type-parameter>
        </template><description><para>Function for constructing boost::typeindex::type_index instance for type T. Does not remove const, volatile, &amp; and &amp;&amp; modifiers from T.</para><para>If T has no const, volatile, &amp; and &amp;&amp; modifiers, then returns exactly the same result as in case of calling <computeroutput>type_id&lt;T&gt;()</computeroutput>.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">type_index ti = type_id_with_cvr&lt;int&amp;&gt;();
std::cout &lt;&lt; ti.pretty_name();  // Outputs 'int&amp;'
</programlisting></para><para>


</para></description><returns><para>boost::typeindex::type_index with information about the specified type T. </para>
</returns><throws><simpara><classname>Nothing.</classname> </simpara></throws></function>
<function name="type_id_runtime"><type>type_index</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="runtime_val"><paramtype>const T &amp;</paramtype><description><para>Variable which runtime type must be returned. </para></description></parameter><description><para>Function that works exactly like C++ typeid(rtti_val) call, but returns boost::type_index.</para><para>Returns runtime information about specified type.</para><para><emphasis role="bold">Requirements:</emphasis> RTTI available or Base and Derived classes must be marked with BOOST_TYPE_INDEX_REGISTER_CLASS.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">struct Base { virtual ~Base(){} };
struct Derived: public Base  {};
...
Derived d;
Base&amp; b = d;
type_index ti = type_id_runtime(b);
std::cout &lt;&lt; ti.pretty_name();  // Outputs 'Derived'
</programlisting></para><para>


</para></description><returns><para>boost::typeindex::type_index with information about the specified variable. </para>
</returns><throws><simpara><classname>Nothing.</classname> </simpara></throws></function>














</namespace>
</namespace>
<macro name="BOOST_TYPE_INDEX_REGISTER_CLASS"><description><para>BOOST_TYPE_INDEX_REGISTER_CLASS is used to help to emulate RTTI. Put this macro into the public section of polymorphic class to allow runtime type detection.</para><para>Depending on the typeid() availability this macro will expand to nothing or to virtual helper function <computeroutput>virtual const type_info&amp; boost_type_info_type_id_runtime_() const noexcept</computeroutput>.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">class A {
public:
    BOOST_TYPE_INDEX_REGISTER_CLASS
    virtual ~A(){}
};

struct B: public A {
    BOOST_TYPE_INDEX_REGISTER_CLASS
};

struct C: public B {
    BOOST_TYPE_INDEX_REGISTER_CLASS
};

...

C c1;
A* pc1 = &amp;c1;
assert(boost::typeindex::type_id&lt;C&gt;() == boost::typeindex::type_id_runtime(*pc1));
</programlisting> </para></description></macro>
<macro name="BOOST_TYPE_INDEX_FUNCTION_SIGNATURE"><description><para>BOOST_TYPE_INDEX_FUNCTION_SIGNATURE is used by <classname alt="boost::typeindex::ctti_type_index">boost::typeindex::ctti_type_index</classname> class to deduce the name of a type. If your compiler is not recognized by the TypeIndex library and you wish to work with <classname alt="boost::typeindex::ctti_type_index">boost::typeindex::ctti_type_index</classname>, you may define this macro by yourself.</para><para>BOOST_TYPE_INDEX_FUNCTION_SIGNATURE must be defined to a compiler specific macro that outputs the <emphasis role="bold">whole</emphasis> function signature <emphasis role="bold">including</emphasis> <emphasis role="bold">template</emphasis> <emphasis role="bold">parameters</emphasis>.</para><para>If your compiler is not recognised and BOOST_TYPE_INDEX_FUNCTION_SIGNATURE is not defined, then a compile-time error will arise at any attempt to use <classname alt="boost::typeindex::ctti_type_index">boost::typeindex::ctti_type_index</classname> classes.</para><para>See BOOST_TYPE_INDEX_REGISTER_CTTI_PARSING_PARAMS and BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING for an information of how to tune the implementation to make a nice pretty_name() output. </para></description></macro>
<macro name="BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING"><description><para>This is a helper macro for making correct pretty_names() with RTTI off.</para><para>BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING macro may be defined to '(begin_skip, end_skip, runtime_skip, runtime_skip_until)' with parameters for adding a support for compilers, that by default are not recognized by TypeIndex library.</para><para><emphasis role="bold">Example:</emphasis> </para><para>Imagine the situation when <programlisting language="c++">boost::typeindex::ctti_type_index::type_id&lt;int&gt;().pretty_name() 
</programlisting> returns the following string: <programlisting language="c++">"static const char *boost::detail::ctti&lt;int&gt;::n() [T = int]" 
</programlisting> and<programlisting language="c++">boost::typeindex::ctti_type_index::type_id&lt;short&gt;().pretty_name() 
</programlisting> returns the following: <programlisting language="c++">"static const char *boost::detail::ctti&lt;short&gt;::n() [T = short]" 
</programlisting></para><para>As we may see first 39 characters are "static const char *boost::detail::ctti&lt;" and they do not depend on the type T. After first 39 characters we have a human readable type name which is duplicated at the end of a string. String always ends on ']', which consumes 1 character.</para><para>Now if we define <computeroutput>BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING</computeroutput> to <computeroutput>(39, 1, false, "")</computeroutput> we'll be getting<programlisting language="c++">"int&gt;::n() [T = int" 
</programlisting> for <computeroutput>boost::typeindex::ctti_type_index::type_id&lt;int&gt;().pretty_name()</computeroutput> and<programlisting language="c++">"short&gt;::n() [T = short" 
</programlisting> for <computeroutput>boost::typeindex::ctti_type_index::type_id&lt;short&gt;().pretty_name()</computeroutput>.</para><para>Now we need to take additional care of the characters that go before the last mention of our type. We'll do that by telling the macro that we need to cut off everything that goes before the "T = " including the "T = " itself:</para><para><programlisting language="c++">(39, 1, true, "T = ") 
</programlisting></para><para>In case of GCC or Clang command line we need to add the following line while compiling all the sources:</para><para><programlisting language="c++">-DBOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING='(39, 1, true, "T = ")'
</programlisting> 
See <ulink url="boost_typeindex/rtti_emulation_limitations.html">RTTI emulation limitations</ulink> for more info. </para></description></macro>
<macro name="BOOST_TYPE_INDEX_USER_TYPEINDEX"><description><para>BOOST_TYPE_INDEX_USER_TYPEINDEX can be defined to the path to header file with user provided implementation of type_index.</para><para>See <ulink url="boost_typeindex/making_a_custom_type_index.html">Making a custom type_index</ulink> section of documentation for usage example. </para></description></macro>
<macro name="BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY"><description><para>BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY is a helper macro that must be defined if mixing RTTI on/off modules. See <ulink url="boost_typeindex/mixing_sources_with_rtti_on_and_.html">Mixing sources with RTTI on and RTTI off</ulink> section of documentation for more info. </para></description></macro>
</header>
<header name="boost/type_index/ctti_type_index.hpp">
<para>Contains <classname alt="boost::typeindex::ctti_type_index">boost::typeindex::ctti_type_index</classname> class that is constexpr if C++14 constexpr is supported by compiler. </para><para><classname alt="boost::typeindex::ctti_type_index">boost::typeindex::ctti_type_index</classname> class can be used as a drop-in replacement for std::type_index.</para><para>It is used in situations when typeid() method is not available or BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY macro is defined. </para><namespace name="boost">
<namespace name="typeindex">
<class name="ctti_type_index"><description><para>This class is a wrapper that pretends to work exactly like <classname alt="boost::typeindex::stl_type_index">stl_type_index</classname>, but does not require RTTI support. <emphasis role="bold">For</emphasis> <emphasis role="bold">description</emphasis> <emphasis role="bold">of</emphasis> <emphasis role="bold">functions</emphasis> <emphasis role="bold">see</emphasis> <classname alt="boost::typeindex::type_index_facade">type_index_facade</classname>.</para><para>This class on C++14 compatible compilers has following functions marked as constexpr:<itemizedlist>
<listitem><para>default constructor</para>
</listitem><listitem><para>copy constructors and assignemnt operations</para>
</listitem><listitem><para>class methods: name(), before(const ctti_type_index&amp; rhs), equal(const ctti_type_index&amp; rhs)</para>
</listitem><listitem><para>static methods type_id&lt;T&gt;(), type_id_with_cvr&lt;T&gt;()</para>
</listitem><listitem><para>comparison operators</para>
</listitem></itemizedlist>
</para><para>This class produces slightly longer type names, so consider using <classname alt="boost::typeindex::stl_type_index">stl_type_index</classname> in situations when typeid() is working. </para></description><typedef name="type_info_t"><type><emphasis>unspecified</emphasis></type></typedef>
<method-group name="private member functions">
<method name="get_raw_name_length" cv="const noexcept"><type>std::size_t</type></method>
</method-group>
<constructor specifiers="explicit" cv="noexcept"><parameter name="data"><paramtype>const char *</paramtype></parameter></constructor>
<method-group name="public member functions">
<method name="type_info" cv="const noexcept"><type>const <classname>type_info_t</classname> &amp;</type></method>
<method name="raw_name" cv="const noexcept"><type>constexpr const char *</type></method>
<method name="name" cv="const noexcept"><type>constexpr const char *</type></method>
<method name="pretty_name" cv="const"><type>std::string</type></method>
<method name="hash_code" cv="const noexcept"><type>std::size_t</type></method>
<method name="equal" cv="const noexcept"><type>constexpr bool</type><parameter name="rhs"><paramtype>const <classname>ctti_type_index</classname> &amp;</paramtype></parameter></method>
<method name="before" cv="const noexcept"><type>constexpr bool</type><parameter name="rhs"><paramtype>const <classname>ctti_type_index</classname> &amp;</paramtype></parameter></method>
</method-group>
<constructor cv="noexcept"/>
<constructor cv="noexcept"><parameter name="data"><paramtype>const <classname>type_info_t</classname> &amp;</paramtype></parameter></constructor>
<method-group name="public static functions">
<method name="type_id" cv="noexcept" specifiers="static"><type>constexpr <classname>ctti_type_index</classname></type><template>
          <template-type-parameter name="T"/>
        </template></method>
<method name="type_id_with_cvr" cv="noexcept" specifiers="static"><type>constexpr <classname>ctti_type_index</classname></type><template>
          <template-type-parameter name="T"/>
        </template></method>
<method name="type_id_runtime" cv="noexcept" specifiers="static"><type><classname>ctti_type_index</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="variable"><paramtype>const T &amp;</paramtype></parameter></method>
</method-group>
</class>







<function name="ctti_construct"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
        </template><purpose>Helper method for getting <classname alt="boost::typeindex::detail::ctti_data">detail::ctti_data</classname> of a template parameter T. </purpose></function>








</namespace>
</namespace>
</header>
<header name="boost/type_index/runtime_cast.hpp">
<para>Contains the basic utilities necessary to fully emulate dynamic_cast for language level constructs (raw pointers and references). </para><para>boost::typeindex::runtime_cast is a drop in replacement for dynamic_cast that can be used in situations where traditional rtti is either unavailable or undesirable. </para></header>
<header name="boost/type_index/runtime_cast/boost_shared_ptr_cast.hpp">
<para>Contains the overload of boost::typeindex::runtime_pointer_cast for <classname alt="boost::shared_ptr">boost::shared_ptr</classname> types. </para><namespace name="boost">
<class name="shared_ptr"><template>
      <template-type-parameter name="T"/>
    </template></class><namespace name="typeindex">
















<function name="runtime_pointer_cast"><type><classname>boost::shared_ptr</classname>&lt; T &gt;</type><template>
          <template-type-parameter name="T"><purpose><para>The desired target type to return a pointer of. </para></purpose></template-type-parameter>
          <template-type-parameter name="U"><purpose><para>A complete class type of the source instance pointed to from u. </para></purpose></template-type-parameter>
        </template><parameter name="u"><paramtype><classname>boost::shared_ptr</classname>&lt; U &gt; const &amp;</paramtype></parameter><purpose>Creates a new instance of std::shared_ptr whose stored pointer is obtained from u's stored pointer using a runtime_cast. </purpose><description><para>The new <classname alt="boost::shared_ptr">shared_ptr</classname> will share ownership with u, except that it is empty if the runtime_cast performed by runtime_pointer_cast returns a null pointer. 

</para></description><returns><para>If there exists a valid conversion from U* to T*, returns a boost::shared_ptr&lt;T&gt; that points to an address suitably offset from u. If no such conversion exists, returns boost::shared_ptr&lt;T&gt;(); </para>
</returns></function>
</namespace>
</namespace>
</header>
<header name="boost/type_index/runtime_cast/pointer_cast.hpp">
<namespace name="boost">
<namespace name="typeindex">












<function name="runtime_cast"><type>T</type><template>
          <template-type-parameter name="T"><purpose><para>The desired target type. Like dynamic_cast, must be a pointer to complete class type. </para></purpose></template-type-parameter>
          <template-type-parameter name="U"><purpose><para>A complete class type of the source instance, u. </para></purpose></template-type-parameter>
        </template><parameter name="u"><paramtype>U *</paramtype></parameter><purpose>Safely converts pointers to classes up, down, and sideways along the inheritance hierarchy. </purpose><description><para>

</para></description><returns><para>If there exists a valid conversion from U* to T, returns a T that points to an address suitably offset from u. If no such conversion exists, returns NULL. </para>
</returns></function>
<function name="runtime_cast"><type>T</type><template>
          <template-type-parameter name="T"><purpose><para>The desired target type. Like dynamic_cast, must be a pointer to complete class type. </para></purpose></template-type-parameter>
          <template-type-parameter name="U"><purpose><para>A complete class type of the source instance, u. </para></purpose></template-type-parameter>
        </template><parameter name="u"><paramtype>U const *</paramtype></parameter><purpose>Safely converts pointers to classes up, down, and sideways along the inheritance hierarchy. </purpose><description><para>

</para></description><returns><para>If there exists a valid conversion from U* to T, returns a T that points to an address suitably offset from u. If no such conversion exists, returns NULL. </para>
</returns></function>
<function name="runtime_pointer_cast"><type>T *</type><template>
          <template-type-parameter name="T"><purpose><para>The desired target type to return a pointer to. </para></purpose></template-type-parameter>
          <template-type-parameter name="U"><purpose><para>A complete class type of the source instance, u. </para></purpose></template-type-parameter>
        </template><parameter name="u"><paramtype>U *</paramtype></parameter><purpose>Safely converts pointers to classes up, down, and sideways along the inheritance hierarchy. </purpose><description><para>

</para></description><returns><para>If there exists a valid conversion from U const* to T*, returns a T* that points to an address suitably offset from u. If no such conversion exists, returns NULL. </para>
</returns></function>
<function name="runtime_pointer_cast"><type>T const  *</type><template>
          <template-type-parameter name="T"><purpose><para>The desired target type to return a pointer to. </para></purpose></template-type-parameter>
          <template-type-parameter name="U"><purpose><para>A complete class type of the source instance, u. </para></purpose></template-type-parameter>
        </template><parameter name="u"><paramtype>U const *</paramtype></parameter><purpose>Safely converts pointers to classes up, down, and sideways along the inheritance hierarchy. </purpose><description><para>

</para></description><returns><para>If there exists a valid conversion from U const* to T const*, returns a T const* that points to an address suitably offset from u. If no such conversion exists, returns NULL. </para>
</returns></function>

</namespace>
</namespace>
</header>
<header name="boost/type_index/runtime_cast/reference_cast.hpp">
<para>Contains the overload of boost::typeindex::runtime_cast for reference types. </para><namespace name="boost">
<namespace name="typeindex">
<struct name="bad_runtime_cast"><inherit access="public">exception</inherit><purpose>Indicates that runtime_cast was unable to perform the desired cast operation because the source instance was not also an instance of the target type. </purpose></struct>









<function name="runtime_cast"><type>boost::add_reference&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"><purpose><para>The desired target type. Like dynamic_cast, must be a pointer to complete class type. </para></purpose></template-type-parameter>
          <template-type-parameter name="U"><purpose><para>A complete class type of the source instance, u. </para></purpose></template-type-parameter>
        </template><parameter name="u"><paramtype>U &amp;</paramtype></parameter><purpose>Safely converts references to classes up, down, and sideways along the inheritance hierarchy. </purpose><description><para>

</para></description><returns><para>If there exists a valid conversion from U&amp; to T, returns a T that references an address suitably offset from u. If no such conversion exists, throws <classname alt="boost::typeindex::bad_runtime_cast">boost::typeindex::bad_runtime_cast</classname>. </para>
</returns></function>
<function name="runtime_cast"><type>boost::add_reference&lt; const T &gt;::type</type><template>
          <template-type-parameter name="T"><purpose><para>The desired target type. Like dynamic_cast, must be a pointer to complete class type. </para></purpose></template-type-parameter>
          <template-type-parameter name="U"><purpose><para>A complete class type of the source instance, u. </para></purpose></template-type-parameter>
        </template><parameter name="u"><paramtype>U const &amp;</paramtype></parameter><purpose>Safely converts references to classes up, down, and sideways along the inheritance hierarchy. </purpose><description><para>

</para></description><returns><para>If there exists a valid conversion from U const&amp; to T const, returns a T const that references an address suitably offset from u. If no such conversion exists, throws <classname alt="boost::typeindex::bad_runtime_cast">boost::typeindex::bad_runtime_cast</classname>. </para>
</returns></function>





</namespace>
</namespace>
</header>
<header name="boost/type_index/runtime_cast/register_runtime_class.hpp">
<para>Contains the macros BOOST_TYPE_INDEX_IMPLEMENT_RUNTIME_CAST and BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS. </para><namespace name="boost">
<namespace name="typeindex">

















</namespace>
</namespace>
<macro name="BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS" kind="functionlike"><macro-parameter name="base_class_seq"><description><para>A Boost.Preprocessor sequence of the current class' direct bases, or BOOST_TYPE_INDEX_NO_BASE_CLASS if this class has no direct base classes. </para></description></macro-parameter><purpose>Macro used to make a class compatible with boost::typeindex::runtime_cast. </purpose><description><para>BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS generates a virtual function in the current class that, when combined with the supplied base class information, allows boost::typeindex::runtime_cast to accurately convert between dynamic types of instances of the current class.</para><para>BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS also adds support for boost::typeindex::type_id_runtime by including BOOST_TYPE_INDEX_REGISTER_CLASS. It is typical that these features are used together, but in the event that BOOST_TYPE_INDEX_REGISTER_CLASS is undesirable in the current class, BOOST_TYPE_INDEX_IMPLEMENT_RUNTIME_CAST is provided.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">struct base1 {
    BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS(BOOST_TYPE_INDEX_NO_BASE_CLASS)
    virtual ~base1();
};

struct base2 {
    BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS(BOOST_TYPE_INDEX_NO_BASE_CLASS)
    virtual ~base2();
};

struct derived1 : base1 {
    BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS((base1))
};

struct derived2 : base1, base2 {
    BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS((base1)(base2))
};

...

base1* pb1 = get_object();
if(derived2* pb2 = boost::typeindex::runtime_cast&lt;derived2*&gt;(pb1)) {
    assert(boost::typeindex::type_id_runtime(*pb1)) == boost::typeindex::type_id&lt;derived2&gt;());
}
</programlisting></para><para>
</para></description></macro>
<macro name="BOOST_TYPE_INDEX_IMPLEMENT_RUNTIME_CAST" kind="functionlike"><macro-parameter name="base_class_seq"><description><para>A Boost.Preprocessor sequence of the current class' direct bases, or BOOST_TYPE_INDEX_NO_BASE_CLASS if this class has no direct base classes. </para></description></macro-parameter><purpose>Macro used to make a class compatible with boost::typeindex::runtime_cast without including support for boost::typeindex::type_id_runtime. </purpose><description><para>BOOST_TYPE_INDEX_IMPLEMENT_RUNTIME_CAST is provided as an alternative to BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS in the event that support for boost::typeindex::type_id_runtime is undesirable.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">struct base1 {
    BOOST_TYPE_INDEX_IMPLEMENT_RUNTIME_CAST(BOOST_TYPE_INDEX_NO_BASE_CLASS)
    virtual ~base1();
};

struct base2 {
    BOOST_TYPE_INDEX_IMPLEMENT_RUNTIME_CAST(BOOST_TYPE_INDEX_NO_BASE_CLASS)
    virtual ~base2();
};

struct derived1 : base1 {
    BOOST_TYPE_INDEX_IMPLEMENT_RUNTIME_CAST((base1))
};

struct derived2 : base1, base2 {
    BOOST_TYPE_INDEX_IMPLEMENT_RUNTIME_CAST((base1)(base2))
};

...

base1* pb1 = get_object();
if(derived2* pb2 = boost::typeindex::runtime_cast&lt;derived2*&gt;(pb1))
{ /* can't call boost::typeindex::type_id_runtime(*pb1) here */ }
</programlisting></para><para>
</para></description></macro>
<macro name="BOOST_TYPE_INDEX_NO_BASE_CLASS"><purpose>Instructs BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS and BOOST_TYPE_INDEX_IMPLEMENT_RUNTIME_CAST that this class has no base classes. </purpose></macro>
</header>
<header name="boost/type_index/runtime_cast/std_shared_ptr_cast.hpp">
<para>Contains the overload of boost::typeindex::runtime_pointer_cast for std::shared_ptr types. </para><namespace name="boost">
<namespace name="typeindex">









<function name="runtime_pointer_cast"><type>std::shared_ptr&lt; T &gt;</type><template>
          <template-type-parameter name="T"><purpose><para>The desired target type to return a pointer of. </para></purpose></template-type-parameter>
          <template-type-parameter name="U"><purpose><para>A complete class type of the source instance pointed to from u. </para></purpose></template-type-parameter>
        </template><parameter name="u"><paramtype>std::shared_ptr&lt; U &gt; const &amp;</paramtype></parameter><purpose>Creates a new instance of std::shared_ptr whose stored pointer is obtained from u's stored pointer using a runtime_cast. </purpose><description><para>The new <classname alt="boost::shared_ptr">shared_ptr</classname> will share ownership with u, except that it is empty if the runtime_cast performed by runtime_pointer_cast returns a null pointer. 

</para></description><returns><para>If there exists a valid conversion from U* to T*, returns a std::shared_ptr&lt;T&gt; that points to an address suitably offset from u. If no such conversion exists, returns std::shared_ptr&lt;T&gt;(); </para>
</returns></function>







</namespace>
</namespace>
</header>
<header name="boost/type_index/stl_type_index.hpp">
<para>Contains <classname alt="boost::typeindex::stl_type_index">boost::typeindex::stl_type_index</classname> class. </para><para><classname alt="boost::typeindex::stl_type_index">boost::typeindex::stl_type_index</classname> class can be used as a drop-in replacement for std::type_index.</para><para>It is used in situations when RTTI is enabled or typeid() method is available. When typeid() is disabled or BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY macro is defined boost::typeindex::ctti is usually used instead of <classname alt="boost::typeindex::stl_type_index">boost::typeindex::stl_type_index</classname>. </para><namespace name="boost">
<namespace name="typeindex">
<class name="stl_type_index"><inherit access="public">boost::typeindex::type_index_facade&lt; stl_type_index, std::type_info &gt;</inherit><description><para>This class is a wrapper around std::type_info, that workarounds issues and provides much more rich interface. <emphasis role="bold">For</emphasis> <emphasis role="bold">description</emphasis> <emphasis role="bold">of</emphasis> <emphasis role="bold">functions</emphasis> <emphasis role="bold">see</emphasis> <classname alt="boost::typeindex::type_index_facade">type_index_facade</classname>.</para><para>This class requires typeid() to work. For cases when RTTI is disabled see <classname alt="boost::typeindex::ctti_type_index">ctti_type_index</classname>. </para></description><typedef name="type_info_t"><type>std::type_info</type></typedef>
<method-group name="public member functions">
<method name="type_info" cv="const noexcept"><type>const type_info_t &amp;</type></method>
<method name="raw_name" cv="const noexcept"><type>const char *</type></method>
<method name="name" cv="const noexcept"><type>const char *</type></method>
<method name="pretty_name" cv="const"><type>std::string</type></method>
<method name="hash_code" cv="const noexcept"><type>std::size_t</type></method>
<method name="equal" cv="const noexcept"><type>bool</type><parameter name="rhs"><paramtype>const <classname>stl_type_index</classname> &amp;</paramtype></parameter></method>
<method name="before" cv="const noexcept"><type>bool</type><parameter name="rhs"><paramtype>const <classname>stl_type_index</classname> &amp;</paramtype></parameter></method>
</method-group>
<constructor cv="noexcept"/>
<constructor cv="noexcept"><parameter name="data"><paramtype>const type_info_t &amp;</paramtype></parameter></constructor>
<method-group name="public static functions">
<method name="type_id" cv="noexcept" specifiers="static"><type><classname>stl_type_index</classname></type><template>
          <template-type-parameter name="T"/>
        </template></method>
<method name="type_id_with_cvr" cv="noexcept" specifiers="static"><type><classname>stl_type_index</classname></type><template>
          <template-type-parameter name="T"/>
        </template></method>
<method name="type_id_runtime" cv="noexcept" specifiers="static"><type><classname>stl_type_index</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="value"><paramtype>const T &amp;</paramtype></parameter></method>
</method-group>
</class>
















</namespace>
</namespace>
</header>
<header name="boost/type_index/type_index_facade.hpp">
<namespace name="boost">
<namespace name="typeindex">
<class name="type_index_facade"><template>
      <template-type-parameter name="Derived"><purpose><para>Class derived from <classname alt="boost::typeindex::type_index_facade">type_index_facade</classname>. </para></purpose></template-type-parameter>
      <template-type-parameter name="TypeInfo"><purpose><para>Class that will be used as a base type_info class. </para></purpose></template-type-parameter>
    </template><description><para>This class takes care about the comparison operators, hash functions and ostream operators. Use this class as a public base class for defining new type_info-conforming classes.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">class stl_type_index: public type_index_facade&lt;stl_type_index, std::type_info&gt; 
{
public:
    typedef std::type_info type_info_t;
private:
    const type_info_t* data_;

public:
    stl_type_index(const type_info_t&amp; data) noexcept
        : data_(&amp;data)
    {}
// ...
};
</programlisting></para><para>
<note><para>Take a look at the protected methods. They are <emphasis role="bold">not</emphasis> <emphasis role="bold">defined</emphasis> in <classname alt="boost::typeindex::type_index_facade">type_index_facade</classname>. Protected member functions raw_name() <emphasis role="bold">must</emphasis> be defined in Derived class. All the other methods are mandatory. </para>
</note>
<para><emphasis role="bold">See Also:</emphasis><para>'Making a custom type_index' section for more information about creating your own type_index using <classname alt="boost::typeindex::type_index_facade">type_index_facade</classname>. </para>
</para>
</para></description><typedef name="type_info_t"><type>TypeInfo</type></typedef>
<method-group name="public member functions">
<method name="name" cv="const noexcept"><type>const char *</type><description><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. 
</para></description><returns><para>Name of a type. By default returns Derived::raw_name(). </para>
</returns></method>
<method name="pretty_name" cv="const"><type>std::string</type><description><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined in Derived class. Overrides may throw. 
</para></description><returns><para>Human readable type name. By default returns Derived::name(). </para>
</returns></method>
<method name="equal" cv="const noexcept"><type>bool</type><parameter name="rhs"><paramtype>const Derived &amp;</paramtype></parameter><description><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. 
</para></description><returns><para>True if two types are equal. By default compares types by raw_name(). </para>
</returns></method>
<method name="before" cv="const noexcept"><type>bool</type><parameter name="rhs"><paramtype>const Derived &amp;</paramtype></parameter><description><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. 
</para></description><returns><para>True if rhs is greater than this. By default compares types by raw_name(). </para>
</returns></method>
<method name="hash_code" cv="const noexcept"><type>std::size_t</type><description><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. 
<note><para>Derived class header <emphasis role="bold">must</emphasis> include &lt;boost/container_hash/hash.hpp&gt;, <emphasis role="bold">unless</emphasis> this function is redefined in Derived class to not use boost::hash_range(). </para>
</note>
</para></description><returns><para>Hash code of a type. By default hashes types by raw_name(). </para>
</returns></method>
</method-group>
<method-group name="protected member functions">
<method name="raw_name" cv="const noexcept"><type>const char *</type><description><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">must</emphasis> be redefined in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. 
</para></description><returns><para>Pointer to unredable/raw type name. </para>
</returns></method>
<method name="type_info" cv="const noexcept"><type>const type_info_t &amp;</type><description><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. 
</para></description><returns><para>Const reference to underlying low level type_info_t. </para>
</returns></method>
</method-group>
<method-group name="protected static functions">
<method name="type_id" cv="noexcept" specifiers="static"><type>Derived</type><template>
          <template-type-parameter name="T"><purpose><para>Type for which type_index must be created. </para></purpose></template-type-parameter>
        </template><description><para>This is a factory method that is used to create instances of Derived classes. boost::typeindex::type_id() will call this method, if Derived has same type as boost::typeindex::type_index.</para><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined and made public in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. Overrides <emphasis role="bold">must</emphasis> remove const, volatile &amp;&amp; and &amp; modifiers from T. 

</para></description><returns><para>type_index for type T. </para>
</returns></method>
<method name="type_id_with_cvr" cv="noexcept" specifiers="static"><type>Derived</type><template>
          <template-type-parameter name="T"><purpose><para>Type for which type_index must be created. </para></purpose></template-type-parameter>
        </template><description><para>This is a factory method that is used to create instances of Derived classes. boost::typeindex::type_id_with_cvr() will call this method, if Derived has same type as boost::typeindex::type_index.</para><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined and made public in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. Overrides <emphasis role="bold">must</emphasis> <emphasis role="bold">not</emphasis> remove const, volatile &amp;&amp; and &amp; modifiers from T. 

</para></description><returns><para>type_index for type T. </para>
</returns></method>
<method name="type_id_runtime" cv="noexcept" specifiers="static"><type>Derived</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="variable"><paramtype>const T &amp;</paramtype><description><para>Variable which runtime type will be stored in type_index. </para></description></parameter><description><para>This is a factory method that is used to create instances of Derived classes. boost::typeindex::type_id_runtime(const T&amp;) will call this method, if Derived has same type as boost::typeindex::type_index.</para><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined and made public in Derived class. 

</para></description><returns><para>type_index with runtime type of variable. </para>
</returns></method>
</method-group>
</class>


<function name="operator==,!=,&lt;,..."><type>bool</type><parameter name="lhs"><paramtype>const <classname>type_index_facade</classname> &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const <classname>type_index_facade</classname> &amp;</paramtype></parameter><purpose>noexcept comparison operators for <classname alt="boost::typeindex::type_index_facade">type_index_facade</classname> classes. </purpose></function>
<function name="operator==,!=,&lt;,..."><type>bool</type><parameter name="lhs"><paramtype>const <classname>type_index_facade</classname> &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const TypeInfo &amp;</paramtype></parameter><purpose>noexcept comparison operators for <classname alt="boost::typeindex::type_index_facade">type_index_facade</classname> and it's TypeInfo classes. </purpose></function>
<function name="operator==,!=,&lt;,..."><type>bool</type><parameter name="lhs"><paramtype>const TypeInfo &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const <classname>type_index_facade</classname> &amp;</paramtype></parameter><purpose>noexcept comparison operators for <classname alt="boost::typeindex::type_index_facade">type_index_facade</classname>'s TypeInfo and <classname alt="boost::typeindex::type_index_facade">type_index_facade</classname> classes. </purpose></function>
<function name="operator&lt;&lt;"><type>std::basic_ostream&lt; CharT, TriatT &gt; &amp;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="TriatT"/>
          <template-type-parameter name="Derived"/>
          <template-type-parameter name="TypeInfo"/>
        </template><parameter name="ostr"><paramtype>std::basic_ostream&lt; CharT, TriatT &gt; &amp;</paramtype></parameter><parameter name="ind"><paramtype>const <classname>type_index_facade</classname>&lt; Derived, TypeInfo &gt; &amp;</paramtype></parameter><purpose>Ostream operator that will output demangled name. </purpose></function>
<function name="hash_value"><type>std::size_t</type><template>
          <template-type-parameter name="Derived"/>
          <template-type-parameter name="TypeInfo"/>
        </template><parameter name="lhs"><paramtype>const <classname>type_index_facade</classname>&lt; Derived, TypeInfo &gt; &amp;</paramtype></parameter><description><para>This free function is used by Boost's unordered containers. <note><para>&lt;boost/container_hash/hash.hpp&gt; has to be included if this function is used. </para>
</note>
</para></description></function>









</namespace>
</namespace>
</header>
</library-reference>