<?xml version="1.0" standalone="yes"?>
<library-reference><header name="boost/process/args.hpp">
<para>This header provides the <globalname alt="boost::process::args">args</globalname> property. It also provides the alternative name <globalname alt="boost::process::argv">argv</globalname> .</para><para> 
<programlisting language="c++">
namespace boost {
  namespace process {
    <emphasis>unspecified</emphasis> <globalname alt="boost::process::args">args</globalname>;
    <emphasis>unspecified</emphasis> <globalname alt="boost::process::argv">argv</globalname>;
  }
}
</programlisting>
 </para><namespace name="boost">
<namespace name="process">
<data-member name="args"><type><emphasis>unspecified</emphasis></type><description><para>The <computeroutput>args</computeroutput> property allows to explicitly set arguments for the execution. The name of the executable will always be the first element in the arg-vector.</para><sect1 id="namespaceboost_1_1process_1args_details">
<title>Details</title>
<sect2 id="namespaceboost_1_1process_1args_operations">
<title>Operations</title>
<sect3 id="namespaceboost_1_1process_1args_set_var">
<title>Setting values</title>
<para>To set a the argument vector the following syntax can be used.</para>
<para><programlisting language="c++">args = value;
args(value);
</programlisting></para>
<para><computeroutput>std::initializer_list</computeroutput> is among the allowed types, so the following syntax is also possible.</para>
<para><programlisting language="c++">args = {value1, value2};
args({value1, value2});
</programlisting></para>
<para>Below the possible types for <computeroutput>value</computeroutput> are listed, with <computeroutput>char_type</computeroutput> being either <computeroutput>char</computeroutput> or <computeroutput>wchar_t</computeroutput>.</para>
<sect4 id="namespaceboost_1_1process_1args_set_var_value">
<title>value</title>
<para><itemizedlist>
<listitem><para><computeroutput>std::basic_string&lt;char_type&gt;</computeroutput></para>
</listitem><listitem><para><computeroutput>const char_type *</computeroutput></para>
</listitem><listitem><para><computeroutput>std::initializer_list&lt;const char_type *&gt;</computeroutput></para>
</listitem><listitem><para><computeroutput>std::vector&lt;std::basic_string&lt;char_type&gt;&gt;</computeroutput></para>
</listitem></itemizedlist>
</para>
<para>Additionally any range of <computeroutput>std::basic_string&lt;char_type&gt;</computeroutput> can be passed.</para>
</sect4>
</sect3>
<sect3 id="namespaceboost_1_1process_1args_append_var">
<title>Appending values</title>
<para>To append a the argument vector the following syntax can be used.</para>
<para><programlisting language="c++">args += value;
</programlisting></para>
<para><computeroutput>std::initializer_list</computeroutput> is among the allowed types, so the following syntax is also possible.</para>
<para><programlisting language="c++">args += {value1, value2};
</programlisting></para>
<para>Below the possible types for <computeroutput>value</computeroutput> are listed, with <computeroutput>char_type</computeroutput> being either <computeroutput>char</computeroutput> or <computeroutput>wchar_t</computeroutput>.</para>
<sect4 id="namespaceboost_1_1process_1args_append_var_value">
<title>value</title>
<para><itemizedlist>
<listitem><para><computeroutput>std::basic_string&lt;char_type&gt;</computeroutput></para>
</listitem><listitem><para><computeroutput>const char_type *</computeroutput></para>
</listitem><listitem><para><computeroutput>std::initializer_list&lt;const char_type *&gt;</computeroutput></para>
</listitem><listitem><para><computeroutput>std::vector&lt;std::basic_string&lt;char_type&gt;&gt;</computeroutput></para>
</listitem></itemizedlist>
</para>
<para>Additionally any range of <computeroutput>std::basic_string&lt;char_type&gt;</computeroutput> can be passed.</para>
</sect4>
</sect3>
</sect2>
<sect2 id="namespaceboost_1_1process_1args_example">
<title>Example</title>
<para>The overload form is used when more than one string is passed, from the second one forward. I.e. the following expressions have the same results:</para>
<para><programlisting language="c++">spawn("gcc", "--version");
spawn("gcc", args ="--version");
spawn("gcc", args+="--version");
spawn("gcc", args ={"--version"});
spawn("gcc", args+={"--version"});
</programlisting></para>
<para><note><para>A string will be parsed and set in quotes if it has none and contains spaces. </para>
</note>
</para>
</sect2>
</sect1></description></data-member>
<data-member name="argv"><type><emphasis>unspecified</emphasis></type><purpose>Alias for <globalname alt="boost::process::args">args</globalname>  . </purpose></data-member>







</namespace>
</namespace>
</header>
<header name="boost/process/async.hpp">
<para>The header which provides the basic asynchrounous features. It provides the on_exit property, which allows callbacks when the process exits. It also implements the necessary traits for passing an boost::asio::io_context, which is needed for asynchronous communication.</para><para>It also pulls the <ulink url="http://www.boost.org/doc/libs/release/doc/html/boost_asio/reference/buffer.html">boost::asio::buffer</ulink> into the boost::process namespace for convenience.</para><para> 
<programlisting language="c++">
namespace boost {
  namespace process {
    <emphasis>unspecified</emphasis> <ulink url="http://www.boost.org/doc/libs/1_61_0/doc/html/boost_asio/reference/buffer.html">buffer</ulink>;
    <emphasis>unspecified</emphasis> <globalname alt="boost::process::on_exit">on_exit</globalname>;
  }
}
</programlisting>

 </para><namespace name="boost">
<namespace name="process">
<data-member name="on_exit" specifiers="static"><type><emphasis>unspecified</emphasis></type><description><para>When an io_context is passed, the on_exit property can be used, to be notified when the child process exits.</para><para>The following syntax is valid</para><para><programlisting language="c++">on_exit=function;
on_exit(function);
</programlisting></para><para>with <computeroutput>function</computeroutput> being a callable object with the signature <computeroutput>(int, const std::error_code&amp;)</computeroutput> or an <computeroutput>std::future&lt;int&gt;</computeroutput>.</para><para><formalpara><title>Example</title><para/>
</formalpara>
<programlisting language="c++">io_context ios;

child c("ls", ios, on_exit=[](int exit, const std::error_code&amp; ec_in){});

std::future&lt;int&gt; exit_code;
chlid c2("ls", ios, on_exit=exit_code);
</programlisting></para><para><note><para>The handler is not invoked when the launch fails. </para>
</note>
<warning><para>When used ignore_error it might get invoked on error. </para>
</warning>
<warning><para><computeroutput>on_exit</computeroutput> uses <computeroutput>boost::asio::signal_set</computeroutput> to listen for <computeroutput>SIGCHLD</computeroutput> on posix, and so has the same restrictions as that class (do not register a handler for <computeroutput>SIGCHLD</computeroutput> except by using <computeroutput>boost::asio::signal_set</computeroutput>). </para>
</warning>
</para></description></data-member>







</namespace>
</namespace>
</header>
<header name="boost/process/async_pipe.hpp">
<namespace name="boost">
<namespace name="process">
<class name="async_pipe"><description><para>Class implementing and asnychronous I/O-Object for use with boost.asio. It is based on the corresponding I/O Object, that is either boost::asio::windows::stream_handle or boost::asio::posix::stream_descriptor.</para><para>It can be used directly with boost::asio::async_read or async_write.</para><para><note><para>The object is copyable, but that does invoke a handle duplicate. </para>
</note>
</para></description><typedef name="native_handle_type"><description><para>Typedef for the native handle representation. <note><para>This is the handle on the system, not the boost.asio class. </para>
</note>
</para></description><type>platform_specific</type></typedef>
<typedef name="handle_type"><description><para>Typedef for the handle representation of boost.asio. </para></description><type>platform_specific</type></typedef>
<typedef name="executor_type"><type>handle_type::executor_type</type></typedef>
<method-group name="public member functions">
<method name="conversion-operator" cv="const" specifiers="explicit"><type>basic_pipe&lt; CharT, Traits &gt;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"><default>std::char_traits&lt;CharT&gt;</default></template-type-parameter>
        </template><description><para>Explicit cast to <classname alt="boost::process::basic_pipe">basic_pipe</classname>. </para></description></method>
<method name="cancel"><type>void</type><description><para>Cancel the current asynchronous operations. </para></description></method>
<method name="close"><type>void</type><description><para>Close the pipe handles. </para></description></method>
<method name="close"><type>void</type><parameter name="ec"><paramtype>std::error_code &amp;</paramtype></parameter><description><para>Close the pipe handles. While passing an error_code </para></description></method>
<method name="is_open" cv="const"><type>bool</type><description><para>Check if the pipes are open. </para></description></method>
<method name="async_close"><type>void</type><description><para>Async close, i.e. close after current operation is completed.</para><para><note><para>There is no guarantee that this will indeed read the entire pipe-buffer </para>
</note>
</para></description></method>
<method name="read_some"><type>std::size_t</type><template>
          <template-type-parameter name="MutableBufferSequence"/>
        </template><parameter name="buffers"><paramtype>const MutableBufferSequence &amp;</paramtype></parameter><description><para>Read some data from the handle.</para><para>See the boost.asio documentation for more details. </para></description></method>
<method name="write_some"><type>std::size_t</type><template>
          <template-type-parameter name="MutableBufferSequence"/>
        </template><parameter name="buffers"><paramtype>const MutableBufferSequence &amp;</paramtype></parameter><description><para>Write some data to the handle.</para><para>See the boost.asio documentation for more details. </para></description></method>
<method name="native_source" cv="const"><type>native_handle</type><description><para>Get the native handle of the source. </para></description></method>
<method name="native_sink" cv="const"><type>native_handle</type><description><para>Get the native handle of the sink. </para></description></method>
<method name="async_read_some"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="MutableBufferSequence"/>
          <template-type-parameter name="ReadHandler"/>
        </template><parameter name="buffers"><paramtype>const MutableBufferSequence &amp;</paramtype></parameter><parameter name="handler"><paramtype>ReadHandler &amp;&amp;</paramtype></parameter><description><para>Start an asynchronous read.</para><para>See the <ulink url="http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/AsyncReadStream.html">boost.asio documentation</ulink> for more details. </para></description></method>
<method name="async_write_some"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="ConstBufferSequence"/>
          <template-type-parameter name="WriteHandler"/>
        </template><parameter name="buffers"><paramtype>const ConstBufferSequence &amp;</paramtype></parameter><parameter name="handler"><paramtype>WriteHandler &amp;&amp;</paramtype></parameter><description><para>Start an asynchronous write.</para><para>See the <ulink url="http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/AsyncWriteStream.html">boost.asio documentation</ulink> for more details. </para></description></method>
<method name="sink" cv="const"><type>const handle_type &amp;</type><purpose>Get the asio handle of the pipe sink. </purpose></method>
<method name="source" cv="const"><type>const handle_type &amp;</type><purpose>Get the asio handle of the pipe source. </purpose></method>
<method name="sink"><type>handle_type &amp;&amp;</type><purpose>Get the asio handle of the pipe sink. Qualified as rvalue. </purpose></method>
<method name="source"><type>handle_type &amp;&amp;</type><purpose>Get the asio handle of the pipe source. Qualified as rvalue. </purpose></method>
<method name="source"><type>handle_type</type><parameter name="ios"><paramtype>::boost::asio::io_context &amp;</paramtype></parameter><purpose>Move the source out of this class and change the io_context. Qualified as rvalue. </purpose><description><para><note><para>Will always move. </para>
</note>
</para></description></method>
<method name="sink"><type>handle_type</type><parameter name="ios"><paramtype>::boost::asio::io_context &amp;</paramtype></parameter><purpose>Move the sink out of this class and change the io_context. Qualified as rvalue. </purpose><description><para><note><para>Will always move </para>
</note>
</para></description></method>
<method name="source" cv="const"><type>handle_type</type><parameter name="ios"><paramtype>::boost::asio::io_context &amp;</paramtype></parameter><purpose>Copy the source out of this class and change the io_context. </purpose><description><para><note><para>Will always copy. </para>
</note>
</para></description></method>
<method name="sink" cv="const"><type>handle_type</type><parameter name="ios"><paramtype>::boost::asio::io_context &amp;</paramtype></parameter><purpose>Copy the sink out of this class and change the io_context. </purpose><description><para><note><para>Will always copy </para>
</note>
</para></description></method>
</method-group>
<constructor><parameter name="ios"><paramtype>boost::asio::io_context &amp;</paramtype></parameter><description><para>Construct a new <classname alt="boost::process::async_pipe">async_pipe</classname>, does automatically open the pipe. Initializes source and sink with the same io_context. <note><para>Windows creates a named pipe here, where the name is automatically generated. </para>
</note>
</para></description></constructor>
<constructor><parameter name="ios_source"><paramtype>boost::asio::io_context &amp;</paramtype></parameter><parameter name="ios_sink"><paramtype>boost::asio::io_context &amp;</paramtype></parameter><description><para>Construct a new <classname alt="boost::process::async_pipe">async_pipe</classname>, does automatically open the pipe. <note><para>Windows creates a named pipe here, where the name is automatically generated. </para>
</note>
</para></description></constructor>
<constructor><parameter name="ios"><paramtype>boost::asio::io_context &amp;</paramtype></parameter><parameter name="name"><paramtype>const std::string &amp;</paramtype></parameter><description><para>Construct a new <classname alt="boost::process::async_pipe">async_pipe</classname>, does automatically open. Initializes source and sink with the same io_context.</para><para><note><para>Windows restricts possible names. </para>
</note>
</para></description></constructor>
<constructor><parameter name="ios_source"><paramtype>boost::asio::io_context &amp;</paramtype></parameter><parameter name="ios_sink"><paramtype>boost::asio::io_context &amp;</paramtype></parameter><parameter name="name"><paramtype>const std::string &amp;</paramtype></parameter><description><para>Construct a new <classname alt="boost::process::async_pipe">async_pipe</classname>, does automatically open.</para><para><note><para>Windows restricts possible names. </para>
</note>
</para></description></constructor>
<constructor><parameter name="lhs"><paramtype>const <classname>async_pipe</classname> &amp;</paramtype></parameter><description><para>Copy-Constructor of the async pipe. <note><para>Windows requires a named pipe for this, if a the wrong type is used an exception is thrown. </para>
</note>
</para></description></constructor>
<constructor><parameter name="lhs"><paramtype><classname>async_pipe</classname> &amp;&amp;</paramtype></parameter><description><para>Move-Constructor of the async pipe. </para></description></constructor>
<constructor specifiers="explicit"><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"><default>std::char_traits&lt;CharT&gt;</default></template-type-parameter>
        </template><parameter name="ios"><paramtype>boost::asio::io_context &amp;</paramtype></parameter><parameter name="p"><paramtype>const <classname>basic_pipe</classname>&lt; CharT, Traits &gt; &amp;</paramtype></parameter><description><para>Construct the async-pipe from a pipe. <note><para>Windows requires a named pipe for this, if a the wrong type is used an exception is thrown. </para>
</note>
</para></description></constructor>
<constructor specifiers="explicit"><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"><default>std::char_traits&lt;CharT&gt;</default></template-type-parameter>
        </template><parameter name="ios_source"><paramtype>boost::asio::io_context &amp;</paramtype></parameter><parameter name="ios_sink"><paramtype>boost::asio::io_context &amp;</paramtype></parameter><parameter name="p"><paramtype>const <classname>basic_pipe</classname>&lt; CharT, Traits &gt; &amp;</paramtype></parameter><description><para>Construct the async-pipe from a pipe, with two different io_context objects. <note><para>Windows requires a named pipe for this, if a the wrong type is used an exception is thrown. </para>
</note>
</para></description></constructor>
<copy-assignment><type><classname>async_pipe</classname> &amp;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"><default>std::char_traits&lt;CharT&gt;</default></template-type-parameter>
        </template><parameter name="p"><paramtype>const <classname>basic_pipe</classname>&lt; CharT, Traits &gt; &amp;</paramtype></parameter><description><para>Assign a <classname alt="boost::process::basic_pipe">basic_pipe</classname>. <note><para>Windows requires a named pipe for this, if a the wrong type is used an exception is thrown. </para>
</note>
</para></description></copy-assignment>
<copy-assignment><type><classname>async_pipe</classname> &amp;</type><parameter name="lhs"><paramtype>const <classname>async_pipe</classname> &amp;</paramtype></parameter><description><para>Copy Assign a pipe. <note><para>Duplicates the handles. </para>
</note>
</para></description></copy-assignment>
<copy-assignment><type><classname>async_pipe</classname> &amp;</type><parameter name="lhs"><paramtype><classname>async_pipe</classname> &amp;&amp;</paramtype></parameter><description><para>Move assign a pipe </para></description></copy-assignment>
<destructor><description><para>Destructor. Closes the pipe handles. </para></description></destructor>
</class>






</namespace>
</namespace>
</header>
<header name="boost/process/async_system.hpp">
<para>Defines the asynchrounous version of the system function. </para><namespace name="boost">
<namespace name="process">






<function name="async_system"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="ExitHandler"/>
          <template-nontype-parameter name="Args"><type>typename ...</type></template-nontype-parameter>
        </template><parameter name="ios"><paramtype>boost::asio::io_context &amp;</paramtype><description><para>A reference to an <ulink url="http://www.boost.org/doc/libs/release/doc/html/boost_asio/reference.html">io_context</ulink> </para></description></parameter><parameter name="exit_handler"><paramtype>ExitHandler &amp;&amp;</paramtype><description><para>The exit-handler for the signature <computeroutput>void(boost::system::error_code, int)</computeroutput></para></description></parameter><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para>This function provides an asynchronous interface to process launching.</para><para>It uses the same properties and parameters as the other launching function, but is similar to the asynchronous functions in <ulink url="http://www.boost.org/doc/libs/release/doc/html/boost_asio.html">boost.asio</ulink></para><para>It uses <ulink url="http://www.boost.org/doc/libs/release/doc/html/boost_asio/reference/async_result.html">asio::async_result</ulink> to determine the return value (from the second parameter, <computeroutput>exit_handler</computeroutput>).</para><para>
<note><para>This function does not allow custom error handling, since those are done through the <computeroutput>exit_handler</computeroutput>. </para>
</note>
</para></description></function>
</namespace>
</namespace>
</header>
<header name="boost/process/child.hpp">
<para>Defines a child process class. </para><namespace name="boost">
<namespace name="process">
<class name="child"><description><para>The main class to hold a child process. It is simliar to <ulink url="http://en.cppreference.com/w/cpp/thread/thread">std::thread</ulink>, in that it has a join and detach function.</para><para><note><para>The destructor will call terminate on the process if not joined or detached without any warning. </para>
</note>
</para></description><method-group name="private member functions">
<method name="detach"><type>void</type><description><para>Detach the child, i.e. let it run after this handle dies. </para></description></method>
<method name="join"><type>void</type><description><para>Join the child. This just calls wait, but that way the naming is similar to std::thread </para></description></method>
<method name="joinable"><type>bool</type><description><para>Check if the child is joinable. </para></description></method>
<method name="native_handle" cv="const"><type>native_handle_t</type><description><para>Get the native handle for the child process. </para></description></method>
<method name="exit_code" cv="const"><type>int</type><description><para>Get the exit_code. The return value is without any meaning if the child wasn't waited for or if it was terminated. </para></description></method>
<method name="id" cv="const"><type>pid_t</type><description><para>Get the Process Identifier. </para></description></method>
<method name="native_exit_code" cv="const"><type>int</type><description><para>Get the native, uninterpreted exit code. The return value is without any meaning if the child wasn't waited for or if it was terminated. </para></description></method>
<method name="running"><type>bool</type><description><para>Check if the child process is running. </para></description></method>
<method name="running" cv="noexcept"><type>bool</type><parameter name="ec"><paramtype>std::error_code &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="wait"><type>void</type><description><para>Wait for the child process to exit. </para></description></method>
<method name="wait" cv="noexcept"><type>void</type><parameter name="ec"><paramtype>std::error_code &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="wait_for"><type>bool</type><template>
          <template-type-parameter name="Rep"/>
          <template-type-parameter name="Period"/>
        </template><parameter name="rel_time"><paramtype>const std::chrono::duration&lt; Rep, Period &gt; &amp;</paramtype></parameter><description><para>Wait for the child process to exit for a period of time. 
</para></description><returns><para>True if child exited while waiting. </para>
</returns></method>
<method name="wait_for" cv="noexcept"><type>bool</type><parameter name="rel_time"><paramtype>const std::chrono::duration&lt; Rep, Period &gt; &amp;</paramtype></parameter><parameter name="ec"><paramtype>std::error_code &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="wait_until"><type>bool</type><template>
          <template-type-parameter name="Clock"/>
          <template-type-parameter name="Duration"/>
        </template><parameter name="timeout_time"><paramtype>const std::chrono::time_point&lt; Clock, Duration &gt; &amp;</paramtype></parameter><description><para>Wait for the child process to exit until a point in time. 
</para></description><returns><para>True if child exited while waiting. </para>
</returns></method>
<method name="wait_until" cv="noexcept"><type>bool</type><parameter name="timeout_time"><paramtype>const std::chrono::time_point&lt; Clock, Duration &gt; &amp;</paramtype></parameter><parameter name="ec"><paramtype>std::error_code &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="valid" cv="const"><type>bool</type><description><para>Check if this handle holds a child process. <note><para>That does not mean, that the process is still running. It only means, that the handle does or did exist. </para>
</note>
</para></description></method>
<method name="conversion-operator" cv="const" specifiers="explicit"><type>bool</type><description><para>Same as valid, for convenience. </para></description></method>
<method name="in_group" cv="const"><type>bool</type><description><para>Check if the the chlid process is in any process group. </para></description></method>
<method name="in_group" cv="const noexcept"><type>bool</type><parameter name="ec"><paramtype>std::error_code &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="terminate"><type>void</type><description><para>Terminate the child process.</para><para>This function will cause the child process to unconditionally and immediately exit. It is implement with <ulink url="http://pubs.opengroup.org/onlinepubs/009695399/functions/kill.html">SIGKILL</ulink> on posix and <ulink url="https://technet.microsoft.com/en-us/library/ms686714.aspx">TerminateProcess</ulink> on windows. </para></description></method>
<method name="terminate" cv="noexcept"><type>void</type><parameter name="ec"><paramtype>std::error_code &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
</method-group>
<constructor specifiers="explicit"><parameter name="pid"><paramtype>pid_t &amp;</paramtype></parameter><description><para>Construct the child from a pid.</para><para><note><para>There is no guarantee that this will work. The process need the right access rights, which are very platform specific. </para>
</note>
</para></description></constructor>
<constructor><parameter name="lhs"><paramtype><classname>child</classname> &amp;&amp;</paramtype></parameter><description><para>Move-Constructor. </para></description></constructor>
<constructor specifiers="explicit"><template>
          <template-nontype-parameter name="Args"><type>typename ...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para>Construct a child from a property list and launch it The standard version is to create a subprocess, which will spawn the process. </para></description></constructor>
<constructor cv="= default"><description><para>Construct an empty child. </para></description></constructor>
<copy-assignment><type><classname>child</classname> &amp;</type><parameter name="lhs"><paramtype><classname>child</classname> &amp;&amp;</paramtype></parameter><description><para>Move assign. </para></description></copy-assignment>
<destructor><description><para>Destructor. <note><para>Will call terminate (without warning) when the child was neither joined nor detached. </para>
</note>
</para></description></destructor>
</class><typedef name="pid_t"><purpose>Typedef for the type of an pid_t. </purpose><type><emphasis>unspecified</emphasis></type></typedef>







</namespace>
</namespace>
</header>
<header name="boost/process/cmd.hpp">
<para>This header provides the <globalname alt="boost::process::cmd">cmd</globalname> property.</para><para> 
<programlisting language="c++">
namespace boost {
  namespace process {
    <emphasis>unspecified</emphasis> <globalname alt="boost::process::cmd">cmd</globalname>;
  }
}
</programlisting>
 </para><namespace name="boost">
<namespace name="process">
<data-member name="cmd" specifiers="static"><type><emphasis>unspecified</emphasis></type><description><para>The cmd property allows to explicitly set commands for the execution.</para><para>The overload form applies when only one string is passed to a launching function. The string will be internally parsed and split at spaces.</para><para>The following expressions are valid, with <computeroutput>value</computeroutput> being either a C-String or a <computeroutput>std::basic_string</computeroutput> with <computeroutput>char</computeroutput> or <computeroutput>wchar_t</computeroutput>.</para><para><programlisting language="c++">cmd="value";
cmd(value);
</programlisting></para><para>The property can only be used for assignments. </para></description></data-member>







</namespace>
</namespace>
</header>
<header name="boost/process/env.hpp">
<para>This header which provides the <computeroutput>env</computeroutput> property. It allows the modification of the environment the child process will run in, in a functional style.</para><para> 
<programlisting language="c++">
namespace boost {
  namespace process {
    <emphasis>unspecified</emphasis> <globalname alt="boost::process::env">env</globalname>;
  }
}
</programlisting>
    </para><para>For additional information see the platform documentations:</para><para><itemizedlist>
<listitem><para><ulink url="https://msdn.microsoft.com/en-US/library/windows/desktop/ms682653.aspx">windows</ulink></para>
</listitem><listitem><para><ulink url="http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html">posix</ulink> </para>
</listitem></itemizedlist>
</para><namespace name="boost">
<namespace name="process">
<data-member name="env"><type><emphasis>unspecified</emphasis></type><description><para>The <computeroutput>env</computeroutput> property provides a functional way to modify the environment used by the child process. If none is passed the environment is inherited from the father process. Appending means that the environment will be interpreted as a ';' or ':' separated list as used in <computeroutput>PATH</computeroutput>.</para><para>On both <computeroutput>posix</computeroutput> and <computeroutput>windows</computeroutput> the environment variables can be lists of strings, separated by ';'. This is typically used for the <computeroutput>PATH</computeroutput> variable.</para><para>By default the environment will be inherited from the launching process, which is also true if environment are modified with this initializer.</para><sect1 id="namespaceboost_1_1process_1env_details">
<title>Details</title>
<sect2 id="namespaceboost_1_1process_1env_operations">
<title>Operations</title>
<sect3 id="namespaceboost_1_1process_1env_set_var">
<title>Setting variables</title>
<para>To set a variable <computeroutput>id</computeroutput> the value <computeroutput>value</computeroutput> the following syntax can be used.</para>
<para><programlisting language="c++">env[id] = value;
env(id, value);
</programlisting></para>
<para><computeroutput>std::initializer_list</computeroutput> is among the allowed types, so the following syntax is also possible.</para>
<para><programlisting language="c++">env[id] = {value1, value2};
env(id, {value1, value2});
</programlisting></para>
<para><note><para>Creates the variable if it does not exist.</para>
</note>
The following lists contain possible value types, with <computeroutput>char_type</computeroutput> being either <computeroutput>char</computeroutput> or <computeroutput>wchar_t</computeroutput> for both <computeroutput>id</computeroutput> and <computeroutput>value</computeroutput>.</para>
<sect4 id="namespaceboost_1_1process_1id">
<title>id</title>
<para><itemizedlist>
<listitem><para><computeroutput>std::basic_string&lt;char_type&gt;</computeroutput></para>
</listitem><listitem><para><computeroutput>const char_type *</computeroutput></para>
</listitem></itemizedlist>
</para>
</sect4>
<sect4 id="namespaceboost_1_1process_1env_set_var_value">
<title>value</title>
<para><itemizedlist>
<listitem><para><computeroutput>std::basic_string&lt;char_type&gt;</computeroutput></para>
</listitem><listitem><para><computeroutput>const char_type *</computeroutput></para>
</listitem><listitem><para><computeroutput>std::initializer_list&lt;const char_type *&gt;</computeroutput></para>
</listitem><listitem><para><computeroutput>std::vector&lt;std::basic_string&lt;char_type&gt;&gt;</computeroutput></para>
</listitem></itemizedlist>
</para>
<para><note><para>Using <computeroutput>std::vector</computeroutput> or <computeroutput>std::initializer_list</computeroutput></para>
</note>
</para>
</sect4>
</sect3>
<sect3 id="namespaceboost_1_1process_1env_append_var">
<title>Append variables</title>
<para>Appending means, that a variable will be interpreted as a To append a variable <computeroutput>id</computeroutput> the value <computeroutput>value</computeroutput> the following syntax can be used:</para>
<para><programlisting language="c++">env[id] += value;
</programlisting></para>
<para><computeroutput>std::initializer_list</computeroutput> is among the allowed types, so the following syntax is also possible.</para>
<para><programlisting language="c++">env[id] += {value1, value2};
</programlisting></para>
<para><note><para>Creates the variable if it does not exist.</para>
</note>
The following lists contain possible value types, with <computeroutput>char_type</computeroutput> being either <computeroutput>char</computeroutput> or <computeroutput>wchar_t</computeroutput> for both <computeroutput>id</computeroutput> and <computeroutput>value</computeroutput>.</para>
<sect4 id="namespaceboost_1_1process_1env_append_var_id">
<title>id</title>
<para><itemizedlist>
<listitem><para><computeroutput>std::basic_string&lt;char_type&gt;</computeroutput></para>
</listitem><listitem><para><computeroutput>const char_type *</computeroutput></para>
</listitem></itemizedlist>
</para>
</sect4>
<sect4 id="namespaceboost_1_1process_1env_append_var_value">
<title>value</title>
<para><itemizedlist>
<listitem><para><computeroutput>std::basic_string&lt;char_type&gt;</computeroutput></para>
</listitem><listitem><para><computeroutput>const char_type *</computeroutput></para>
</listitem><listitem><para><computeroutput>std::initializer_list&lt;const char_type *&gt;</computeroutput></para>
</listitem><listitem><para><computeroutput>std::vector&lt;std::basic_string&lt;char_type&gt;&gt;</computeroutput></para>
</listitem></itemizedlist>
</para>
</sect4>
</sect3>
<sect3 id="namespaceboost_1_1process_1env_reset">
<title>Reset variables</title>
<para>Reseting signle variables can be done in the following way:</para>
<para><programlisting language="c++">env[id] = boost::none;
env(id, boost::none);
</programlisting></para>
<para><note><para>This does not set the value empty, but removes it from the list.</para>
</note>
The following lists contain possible value types, with <computeroutput>char_type</computeroutput> being either <computeroutput>char</computeroutput> or <computeroutput>wchar_t</computeroutput>:</para>
<sect4 id="namespaceboost_1_1process_1env_reset_var_id">
<title>id</title>
<para><itemizedlist>
<listitem><para><computeroutput>std::basic_string&lt;char_type&gt;</computeroutput></para>
</listitem><listitem><para><computeroutput>const char_type *</computeroutput></para>
</listitem></itemizedlist>
</para>
</sect4>
</sect3>
<sect3 id="namespaceboost_1_1process_1env_init">
<title>Initialize the environment</title>
<para>The whole environment can be initialized from an object of type  <classname>boost::process::environment</classname> </para>
<para><programlisting language="c++">env=env;
env(env);
</programlisting></para>
<para><note><para>The passed <computeroutput>environment</computeroutput> can also be default-constructed to get an empty environment.</para>
</note>
</para>
<sect4 id="namespaceboost_1_1process_1env_init_var_id">
<title>id</title>
<para><itemizedlist>
<listitem><para><computeroutput>std::basic_string&lt;char_type&gt;</computeroutput></para>
</listitem><listitem><para><computeroutput>const char_type *</computeroutput></para>
</listitem></itemizedlist>
</para>
</sect4>
<sect4 id="namespaceboost_1_1process_1env_init_var_value">
<title>value</title>
<para><itemizedlist>
<listitem><para><computeroutput><classname alt="boost::process::basic_environment">boost::process::basic_environment</classname>&lt;char_type&gt;</computeroutput></para>
</listitem></itemizedlist>
</para>
</sect4>
</sect3>
</sect2>
<sect2 id="namespaceboost_1_1process_1env_example">
<title>Example</title>
<para><programlisting language="c++">spawn("b2", env["PATH"]+="F:/boost", env["SOME_VAR"]=boost::none, env["NEW_VAR"]="VALUE");
</programlisting></para>
<para>If the overload style should be done by passing an instance of  <classname>boost::process::environment</classname>  the above example would look like this.</para>
<para><programlisting language="c++">environment e = this_process::environment();
e["PATH"]   += "F:/boost";
e.erase("SOME_VAR");
e["NEW_VAR"] = "VALUE";
spawn("b2", e);
</programlisting></para>
<para><warning><para>Passing an empty environment will cause undefined behaviour. </para>
</warning>
</para>
</sect2>
</sect1></description></data-member>







</namespace>
</namespace>
</header>
<header name="boost/process/environment.hpp">
<namespace name="boost">
<namespace name="process">
<class name="basic_environment"><template>
      <template-type-parameter name="Char"/>
    </template><purpose>Type definition to hold a seperate environment. </purpose><description><para>Template representation of environments. It takes a character type (<computeroutput>char</computeroutput> or <computeroutput>wchar_t</computeroutput>) as template parameter to implement the environment </para></description><struct name="const_entry_type"><template>
      <template-type-parameter name="Char"/>
      <template-type-parameter name="Environment"/>
    </template><description><para>Proxy class used for read access to members by [] or .at() <note><para>Holds a reference to the environment it was created from. </para>
</note>
</para></description><typedef name="value_type"><type>Char</type></typedef>
<typedef name="pointer"><type>const value_type *</type></typedef>
<typedef name="string_type"><type>std::basic_string&lt; value_type &gt;</type></typedef>
<typedef name="range"><type>boost::iterator_range&lt; pointer &gt;</type></typedef>
<typedef name="environment_t"><type>Environment</type></typedef>
<method-group name="public member functions">
<method name="to_vector" cv="const"><type>std::vector&lt; string_type &gt;</type><purpose>Split the entry by ";" or ":" and return it as a vector. Used by PATH. </purpose><description><para>Get the value as string. Get the name of this entry. </para></description></method>
<method name="const_entry" cv="= default"><type/><parameter name=""><paramtype>const const_entry &amp;</paramtype></parameter><purpose>Copy Constructor. </purpose></method>
<method name="empty" cv="const"><type>bool</type><purpose>Check if the entry is empty. </purpose></method>
</method-group>
<copy-assignment cv="= default"><type>const_entry &amp;</type><parameter name=""><paramtype>const const_entry &amp;</paramtype></parameter><purpose>Move Constructor. </purpose></copy-assignment>
</struct><struct name="entry_type"><template>
      <template-type-parameter name="Char"/>
      <template-type-parameter name="Environment"/>
    </template><description><para>Proxy class used for read and write access to members by [] or .at() <note><para>Holds a reference to the environment it was created from. </para>
</note>
</para></description><typedef name="value_type"><type>Char</type></typedef>
<typedef name="pointer"><type>const value_type *</type></typedef>
<typedef name="string_type"><type>std::basic_string&lt; value_type &gt;</type></typedef>
<typedef name="range"><type>boost::iterator_range&lt; pointer &gt;</type></typedef>
<typedef name="environment_t"><type>Environment</type></typedef>
<method-group name="public member functions">
<method name="to_vector" cv="const"><type>std::vector&lt; string_type &gt;</type><purpose>Split the entry by ";" or ":" and return it as a vector. Used by PATH. </purpose><description><para>Get the value as string. Get the name of this entry. </para></description></method>
<method name="entry" cv="= default"><type/><parameter name=""><paramtype>const entry &amp;</paramtype></parameter><purpose>Copy Constructor. </purpose></method>
<method name="empty" cv="const"><type>bool</type><purpose>Check if the entry is empty. </purpose></method>
<method name="assign"><type>void</type><parameter name="value"><paramtype>const string_type &amp;</paramtype></parameter><purpose>Assign a string to the value. </purpose></method>
<method name="assign"><type>void</type><parameter name="value"><paramtype>const std::vector&lt; string_type &gt; &amp;</paramtype></parameter><purpose>Assign a set of strings to the entry; they will be separated by ';' or ':'. </purpose></method>
<method name="append"><type>void</type><parameter name="value"><paramtype>const string_type &amp;</paramtype></parameter><purpose>Append a string to the end of the entry, it will separated by ';' or ':'. </purpose></method>
<method name="clear"><type>void</type><purpose>Reset the value. </purpose></method>
<method name="operator+="><type>entry &amp;</type><parameter name="value"><paramtype>const string_type &amp;</paramtype></parameter><purpose>Append a string to the end of the entry, it will separated by ';' or ':'. </purpose></method>
</method-group>
<copy-assignment cv="= default"><type>entry &amp;</type><parameter name=""><paramtype>const entry &amp;</paramtype></parameter><purpose>Move Constructor. </purpose></copy-assignment>
<copy-assignment><type>entry &amp;</type><parameter name="value"><paramtype>const string_type &amp;</paramtype></parameter><purpose>Assign a string to the entry. </purpose></copy-assignment>
<copy-assignment><type>entry &amp;</type><parameter name="value"><paramtype>const std::vector&lt; string_type &gt; &amp;</paramtype></parameter><purpose>Assign a set of strings to the entry; they will be separated by ';' or ':'. </purpose></copy-assignment>
</struct><typedef name="string_type"><type>std::basic_string&lt; Char &gt;</type></typedef>
<typedef name="iterator"><type>boost::transform_iterator&lt; entry_maker, Char ** &gt;</type></typedef>
<typedef name="const_iterator"><type>boost::transform_iterator&lt; const_entry_maker, Char ** &gt;</type></typedef>
<typedef name="size_type"><type>std::size_t</type></typedef>
<typedef name="native_handle"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="base_type"><type><emphasis>unspecified</emphasis></type></typedef>
<method-group name="public member functions">
<method name="begin"><type>iterator</type><purpose>Returns an iterator to the beginning. </purpose></method>
<method name="begin" cv="const"><type>const_iterator</type><purpose>Returns an iterator to the beginning. </purpose></method>
<method name="cbegin" cv="const"><type>const_iterator</type><purpose>Returns an iterator to the beginning. </purpose></method>
<method name="end"><type>iterator</type><purpose>Returns an iterator to the end. </purpose></method>
<method name="end" cv="const"><type>const_iterator</type><purpose>Returns an iterator to the end. </purpose></method>
<method name="cend" cv="const"><type>const_iterator</type><purpose>Returns an iterator to the end. </purpose></method>
<method name="find"><type>iterator</type><parameter name="key"><paramtype>const string_type &amp;</paramtype></parameter><purpose>Find a variable by its name. </purpose></method>
<method name="find" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const string_type &amp;</paramtype></parameter><purpose>Find a variable by its name. </purpose></method>
<method name="count" cv="const"><type>std::size_t</type><parameter name="st"><paramtype>const string_type &amp;</paramtype></parameter><purpose>Number of variables. </purpose></method>
<method name="erase"><type>void</type><parameter name="id"><paramtype>const string_type &amp;</paramtype></parameter><description><para>Erase variable by id. </para></description></method>
<method name="emplace"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="id"><paramtype>const string_type &amp;</paramtype></parameter><parameter name="value"><paramtype>const string_type &amp;</paramtype></parameter><purpose>Emplace an environment variable. </purpose></method>
<method name="empty"><type>bool</type><purpose>Check if environment has entries. </purpose></method>
<method name="size" cv="const"><type>std::size_t</type><purpose>Get the number of variables. </purpose></method>
<method name="clear"><type>void</type><purpose>Clear the environment. </purpose><description><para><note><para>Use with care, passed environment cannot be empty. </para>
</note>
</para></description></method>
<method name="at"><type><classname>entry_type</classname></type><parameter name="key"><paramtype>const string_type &amp;</paramtype></parameter><purpose>Get the entry with the key. Throws if it does not exist. </purpose></method>
<method name="at" cv="const"><type><classname>const_entry_type</classname></type><parameter name="key"><paramtype>const string_type &amp;</paramtype></parameter><purpose>Get the entry with the key. Throws if it does not exist. </purpose></method>
<method name="operator[]"><type><classname>entry_type</classname></type><parameter name="key"><paramtype>const string_type &amp;</paramtype></parameter><purpose>Get the entry with the given key. It creates the entry if it doesn't exist. </purpose></method>
</method-group>
<constructor><purpose>Default constructor. </purpose></constructor>
<constructor><parameter name=""><paramtype>const <classname>basic_environment</classname> &amp;</paramtype></parameter><purpose>Copy constructor. </purpose></constructor>
<constructor><parameter name=""><paramtype><classname>basic_environment</classname> &amp;&amp;</paramtype></parameter><purpose>Move constructor. </purpose></constructor>
<copy-assignment><type><classname>basic_environment</classname> &amp;</type><parameter name=""><paramtype>const <classname>basic_environment</classname> &amp;</paramtype></parameter><purpose>Copy assignment. </purpose></copy-assignment>
<copy-assignment><type><classname>basic_environment</classname> &amp;</type><parameter name=""><paramtype><classname>basic_environment</classname> &amp;&amp;</paramtype></parameter><purpose>Move assignment. </purpose></copy-assignment>
</class><class name="basic_native_environment"><template>
      <template-type-parameter name="Char"/>
    </template><purpose>Definition of the environment for the current process. </purpose><description><para>Template representation of the environment of this process. It takes a template as template parameter to implement the environment. All instances of this class refer to the same environment, but might not get updated if another one makes changes. </para></description><struct name="const_entry_type"><template>
      <template-type-parameter name="Char"/>
      <template-type-parameter name="Environment"/>
    </template><description><para>Proxy class used for read access to members by [] or .at() <note><para>Holds a reference to the environment it was created from. </para>
</note>
</para></description><typedef name="value_type"><type>Char</type></typedef>
<typedef name="pointer"><type>const value_type *</type></typedef>
<typedef name="string_type"><type>std::basic_string&lt; value_type &gt;</type></typedef>
<typedef name="range"><type>boost::iterator_range&lt; pointer &gt;</type></typedef>
<typedef name="environment_t"><type>Environment</type></typedef>
<method-group name="public member functions">
<method name="to_vector" cv="const"><type>std::vector&lt; string_type &gt;</type><purpose>Split the entry by ";" or ":" and return it as a vector. Used by PATH. </purpose><description><para>Get the value as string. Get the name of this entry. </para></description></method>
<method name="const_entry" cv="= default"><type/><parameter name=""><paramtype>const const_entry &amp;</paramtype></parameter><purpose>Copy Constructor. </purpose></method>
<method name="empty" cv="const"><type>bool</type><purpose>Check if the entry is empty. </purpose></method>
</method-group>
<copy-assignment cv="= default"><type>const_entry &amp;</type><parameter name=""><paramtype>const const_entry &amp;</paramtype></parameter><purpose>Move Constructor. </purpose></copy-assignment>
</struct><struct name="entry_type"><template>
      <template-type-parameter name="Char"/>
      <template-type-parameter name="Environment"/>
    </template><description><para>Proxy class used for read and write access to members by [] or .at() <note><para>Holds a reference to the environment it was created from. </para>
</note>
</para></description><typedef name="value_type"><type>Char</type></typedef>
<typedef name="pointer"><type>const value_type *</type></typedef>
<typedef name="string_type"><type>std::basic_string&lt; value_type &gt;</type></typedef>
<typedef name="range"><type>boost::iterator_range&lt; pointer &gt;</type></typedef>
<typedef name="environment_t"><type>Environment</type></typedef>
<method-group name="public member functions">
<method name="to_vector" cv="const"><type>std::vector&lt; string_type &gt;</type><purpose>Split the entry by ";" or ":" and return it as a vector. Used by PATH. </purpose><description><para>Get the value as string. Get the name of this entry. </para></description></method>
<method name="entry" cv="= default"><type/><parameter name=""><paramtype>const entry &amp;</paramtype></parameter><purpose>Copy Constructor. </purpose></method>
<method name="empty" cv="const"><type>bool</type><purpose>Check if the entry is empty. </purpose></method>
<method name="assign"><type>void</type><parameter name="value"><paramtype>const string_type &amp;</paramtype></parameter><purpose>Assign a string to the value. </purpose></method>
<method name="assign"><type>void</type><parameter name="value"><paramtype>const std::vector&lt; string_type &gt; &amp;</paramtype></parameter><purpose>Assign a set of strings to the entry; they will be separated by ';' or ':'. </purpose></method>
<method name="append"><type>void</type><parameter name="value"><paramtype>const string_type &amp;</paramtype></parameter><purpose>Append a string to the end of the entry, it will separated by ';' or ':'. </purpose></method>
<method name="clear"><type>void</type><purpose>Reset the value. </purpose></method>
<method name="operator+="><type>entry &amp;</type><parameter name="value"><paramtype>const string_type &amp;</paramtype></parameter><purpose>Append a string to the end of the entry, it will separated by ';' or ':'. </purpose></method>
</method-group>
<copy-assignment cv="= default"><type>entry &amp;</type><parameter name=""><paramtype>const entry &amp;</paramtype></parameter><purpose>Move Constructor. </purpose></copy-assignment>
<copy-assignment><type>entry &amp;</type><parameter name="value"><paramtype>const string_type &amp;</paramtype></parameter><purpose>Assign a string to the entry. </purpose></copy-assignment>
<copy-assignment><type>entry &amp;</type><parameter name="value"><paramtype>const std::vector&lt; string_type &gt; &amp;</paramtype></parameter><purpose>Assign a set of strings to the entry; they will be separated by ';' or ':'. </purpose></copy-assignment>
</struct><typedef name="string_type"><type>std::basic_string&lt; Char &gt;</type></typedef>
<typedef name="iterator"><type>boost::transform_iterator&lt; entry_maker, Char ** &gt;</type></typedef>
<typedef name="const_iterator"><type>boost::transform_iterator&lt; const_entry_maker, Char ** &gt;</type></typedef>
<typedef name="size_type"><type>std::size_t</type></typedef>
<typedef name="native_handle"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="base_type"><type><emphasis>unspecified</emphasis></type></typedef>
<method-group name="public member functions">
<method name="begin"><type>iterator</type><purpose>Returns an iterator to the beginning. </purpose></method>
<method name="begin" cv="const"><type>const_iterator</type><purpose>Returns an iterator to the beginning. </purpose></method>
<method name="cbegin" cv="const"><type>const_iterator</type><purpose>Returns an iterator to the beginning. </purpose></method>
<method name="end"><type>iterator</type><purpose>Returns an iterator to the end. </purpose></method>
<method name="end" cv="const"><type>const_iterator</type><purpose>Returns an iterator to the end. </purpose></method>
<method name="cend" cv="const"><type>const_iterator</type><purpose>Returns an iterator to the end. </purpose></method>
<method name="find"><type>iterator</type><parameter name="key"><paramtype>const string_type &amp;</paramtype></parameter><purpose>Find a variable by its name. </purpose></method>
<method name="find" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const string_type &amp;</paramtype></parameter><purpose>Find a variable by its name. </purpose></method>
<method name="count" cv="const"><type>std::size_t</type><parameter name="st"><paramtype>const string_type &amp;</paramtype></parameter><purpose>Number of variables. </purpose></method>
<method name="erase"><type>void</type><parameter name="id"><paramtype>const string_type &amp;</paramtype></parameter><description><para>Erase variable by id. </para></description></method>
<method name="emplace"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="id"><paramtype>const string_type &amp;</paramtype></parameter><parameter name="value"><paramtype>const string_type &amp;</paramtype></parameter><purpose>Emplace an environment variable. </purpose></method>
<method name="empty"><type>bool</type><purpose>Check if environment has entries. </purpose></method>
<method name="size" cv="const"><type>std::size_t</type><purpose>Get the number of variables. </purpose></method>
<method name="at"><type><classname>entry_type</classname></type><parameter name="key"><paramtype>const string_type &amp;</paramtype></parameter><purpose>Get the entry with the key. Throws if it does not exist. </purpose></method>
<method name="at" cv="const"><type><classname>const_entry_type</classname></type><parameter name="key"><paramtype>const string_type &amp;</paramtype></parameter><purpose>Get the entry with the key. Throws if it does not exist. </purpose></method>
<method name="operator[]"><type><classname>entry_type</classname></type><parameter name="key"><paramtype>const string_type &amp;</paramtype></parameter><purpose>Get the entry with the given key. It creates the entry if it doesn't exist. </purpose></method>
</method-group>
<constructor><purpose>Default constructor. </purpose></constructor>
<constructor><parameter name=""><paramtype><classname>basic_native_environment</classname> &amp;&amp;</paramtype></parameter><purpose>Move constructor. </purpose></constructor>
<copy-assignment><type><classname>basic_native_environment</classname> &amp;</type><parameter name=""><paramtype><classname>basic_native_environment</classname> &amp;&amp;</paramtype></parameter><purpose>Move assignment. </purpose></copy-assignment>
</class><typedef name="native_environment"><purpose>Definition of the environment for the current process. </purpose><type><classname>basic_native_environment</classname>&lt; char &gt;</type></typedef>
<typedef name="wnative_environment"><purpose>Definition of the environment for the current process. </purpose><type><classname>basic_native_environment</classname>&lt; wchar_t &gt;</type></typedef>
<typedef name="environment"><purpose>Type definition to hold a seperate environment. </purpose><type><classname>basic_environment</classname>&lt; char &gt;</type></typedef>
<typedef name="wenvironment"><purpose>Type definition to hold a seperate environment. </purpose><type><classname>basic_environment</classname>&lt; wchar_t &gt;</type></typedef>







</namespace>
<namespace name="this_process">




<function name="get_id"><type>int</type><purpose>Get the process id of the current process. </purpose></function>
<function name="native_handle"><type>native_handle_type</type><purpose>Get the native handle of the current process. </purpose></function>
<function name="environment"><type>native_environment</type><purpose>Get the enviroment of the current process. </purpose></function>
<function name="wenvironment"><type>wnative_environment</type><purpose>Get the enviroment of the current process. </purpose></function>
<function name="path"><type>std::vector&lt; boost::filesystem::path &gt;</type><purpose>Get the path environment variable of the current process runs. </purpose></function>
</namespace>
</namespace>
</header>
<header name="boost/process/error.hpp">
<para>Header which provides the error properties. It allows to explicitly set the error handling, the properties are:</para><para> 
<programlisting language="c++">
namespace boost {
  namespace process {
    <emphasis>unspecified</emphasis> <globalname alt="boost::process::ignore_error">ignore_error</globalname>;
    <emphasis>unspecified</emphasis> <globalname alt="boost::process::throw_on_error">throw_on_error</globalname>;
    <emphasis>unspecified</emphasis> <globalname alt="boost::process::error">error</globalname>;
    <emphasis>unspecified</emphasis> <globalname alt="boost::process::error_ref">error_ref</globalname>;
    <emphasis>unspecified</emphasis> <globalname alt="boost::process::error_code">error_code</globalname>;
  }
}
</programlisting>
 For error there are two aliases: error_ref and error_code </para><namespace name="boost">
<namespace name="process">
<data-member name="ignore_error"><type><emphasis>unspecified</emphasis></type><description><para>The ignore_error property will disable any error handling. This can be useful on linux, where error handling will require a pipe. </para></description></data-member>
<data-member name="throw_on_error"><type><emphasis>unspecified</emphasis></type><description><para>The throw_on_error property will enable the exception when launching a process. It is unnecessary by default, but may be used, when an additional error_code is provided. </para></description></data-member>
<data-member name="error"><type><emphasis>unspecified</emphasis></type><description><para>The error property will set the executor to handle any errors by setting an <ulink url="http://en.cppreference.com/w/cpp/error/error_code">std::error_code</ulink>.</para><para><programlisting language="c++">std::error_code ec;
system("gcc", error(ec));
</programlisting></para><para>The following syntax is valid:</para><para><programlisting language="c++">error(ec);
error=ec;
</programlisting></para><para>The overload version is achieved by just passing an object of <ulink url="http://en.cppreference.com/w/cpp/error/error_code">std::error_code</ulink> to the function. </para></description></data-member>
<data-member name="error_ref"><type><emphasis>unspecified</emphasis></type><purpose>Alias for <globalname alt="boost::process::error">error</globalname>  . </purpose></data-member>
<data-member name="error_code"><type><emphasis>unspecified</emphasis></type><purpose>Alias for <globalname alt="boost::process::error">error</globalname>  . </purpose></data-member>







</namespace>
</namespace>
</header>
<header name="boost/process/exception.hpp">
<namespace name="boost">
<namespace name="process">
<struct name="process_error"><inherit access="public">system_error</inherit><purpose>The exception usually thrown by boost.process. </purpose><description><para>It merely inherits <ulink url="http://en.cppreference.com/w/cpp/error/system_error">std::system_error</ulink> but can then be distinguished in the catch-block from other system errors. </para></description></struct>






</namespace>
</namespace>
</header>
<header name="boost/process/exe.hpp">
<para>Header which provides the exe property.  
<programlisting language="c++">
namespace boost {
  namespace process {
    <emphasis>unspecified</emphasis> <globalname alt="boost::process::exe">exe</globalname>;
  }
}
</programlisting>
 </para><namespace name="boost">
<namespace name="filesystem">
</namespace>
<namespace name="process">
<data-member name="exe"><type><emphasis>unspecified</emphasis></type><description><para>The exe property allows to explicitly set the executable.</para><para>The overload form applies when to the first, when several strings are passed to a launching function.</para><para>The following expressions are valid, with <computeroutput>value</computeroutput> being either a C-String or a <computeroutput>std::basic_string</computeroutput> with <computeroutput>char</computeroutput> or <computeroutput>wchar_t</computeroutput> or a <computeroutput>boost::filesystem::path</computeroutput>.</para><para><programlisting language="c++">exe="value";
exe(value);
</programlisting></para><para>The property can only be used for assignments. </para></description></data-member>







</namespace>
</namespace>
</header>
<header name="boost/process/extend.hpp">
<para>This header which provides the types and functions provided for custom extensions.</para><para> 
Please refer to the <link linkend="boost_process.extend">tutorial</link> for more details.
 </para><namespace name="boost">
<namespace name="process">
<namespace name="extend">
<struct name="async_handler"><inherit access="public">boost::process::extend::handler</inherit><inherit access="public">boost::process::extend::require_io_context</inherit><description><para>Inheriting this class will tell the launching function, that an event handler shall be invoked when the process exits. This automatically does also inherit <classname alt="boost::process::extend::require_io_context">require_io_context</classname>.</para><para>You must add the following function to your implementation:</para><para><programlisting language="c++">template&lt;typename Executor&gt;
std::function&lt;void(int, const std::error_code&amp;)&gt; on_exit_handler(Executor &amp; exec)
{
    auto handler_ = this-&gt;handler;
    return [handler_](int exit_code, const std::error_code &amp; ec)
           {
                handler_(static_cast&lt;int&gt;(exit_code), ec);
           };

}
</programlisting></para><para>The callback will be obtained by calling this function on setup and it will be invoked when the process exits.</para><para><warning><para>Cannot be used with boost::process::spawn </para>
</warning>
</para></description></struct><struct name="handler"><description><para>This class is the base for every initializer, to be used for extensions.</para><para>The usage is done through compile-time polymorphism, so that the required functions can be overloaded.</para><para><note><para>None of the function need to be <computeroutput>const</computeroutput>. </para>
</note>
</para></description><method-group name="public member functions">
<method name="on_setup" cv="const"><type>void</type><template>
          <template-type-parameter name="Executor"/>
        </template><parameter name=""><paramtype>Executor &amp;</paramtype></parameter><purpose>This function is invoked before the process launch. </purpose><description><para><note><para>It is not required to be const. </para>
</note>
</para></description></method>
<method name="on_error" cv="const"><type>void</type><template>
          <template-type-parameter name="Executor"/>
        </template><parameter name=""><paramtype>Executor &amp;</paramtype></parameter><parameter name=""><paramtype>const std::error_code &amp;</paramtype></parameter><description><para>This function is invoked if an error occured while trying to launch the process. <note><para>It is not required to be const. </para>
</note>
</para></description></method>
<method name="on_success" cv="const"><type>void</type><template>
          <template-type-parameter name="Executor"/>
        </template><parameter name=""><paramtype>Executor &amp;</paramtype></parameter><description><para>This function is invoked if the process was successfully launched. <note><para>It is not required to be const. </para>
</note>
</para></description></method>
<method name="on_fork_error" cv="const"><type>void</type><template>
          <template-type-parameter name="Executor"/>
        </template><parameter name=""><paramtype>Executor &amp;</paramtype></parameter><parameter name=""><paramtype>const std::error_code &amp;</paramtype></parameter><description><para>This function is invoked if an error occured during the call of <computeroutput>fork</computeroutput>. <note><para>This function will only be called on posix. </para>
</note>
</para></description></method>
<method name="on_exec_setup" cv="const"><type>void</type><template>
          <template-type-parameter name="Executor"/>
        </template><parameter name=""><paramtype>Executor &amp;</paramtype></parameter><description><para>This function is invoked if the call of <computeroutput>fork</computeroutput> was successful, before calling <computeroutput>execve</computeroutput>. <note><para>This function will only be called on posix. </para>
</note>
<note><para>It will be invoked from the new process. </para>
</note>
</para></description></method>
<method name="on_exec_error" cv="const"><type>void</type><template>
          <template-type-parameter name="Executor"/>
        </template><parameter name=""><paramtype>Executor &amp;</paramtype></parameter><parameter name=""><paramtype>const std::error_code &amp;</paramtype></parameter><description><para>This function is invoked if the call of <computeroutput>execve</computeroutput> failed. <note><para>This function will only be called on posix. </para>
</note>
<note><para>It will be invoked from the new process. </para>
</note>
</para></description></method>
</method-group>
</struct><struct name="posix_executor"><template>
      <template-type-parameter name="Sequence"><purpose><para>The used initializer-sequence, it is fulfills the boost.fusion <ulink url="http://www.boost.org/doc/libs/master/libs/fusion/doc/html/fusion/sequence.html">sequence</ulink> concept.</para></purpose></template-type-parameter>
    </template><purpose>The posix executor type. </purpose><description><para>This type represents the posix executor and can be used for overloading in a custom handler. <note><para>It is an alias for the implementation on posix, and a forward-declaration on windows.</para>
</note>

 
As information for extension development, here is the structure of the process launching (in pseudo-code and uml)
<programlisting language="c++">
for (auto &amp; s : seq)
    s.<methodname alt="boost::process::extend::handler::on_setup">on_setup</methodname>(*this);

if (<methodname alt="boost::process::extend::posix_executor::error">error</methodname>())
{
    for (auto &amp; s : seq)
       s.<methodname alt="boost::process::extend::handler::on_error">on_error</methodname>(*this, <methodname alt="boost::process::extend::posix_executor::error">error</methodname>());
    return <classname alt="boost::process::child">child</classname>();
}

pid = <ulink url="http://pubs.opengroup.org/onlinepubs/009695399/functions/fork.html">fork()</ulink>
<methodname alt="boost::process::extend::handler::on_setup">on_setup</methodname>(*this);

if (pid == -1) //fork error 
{
    <methodname alt="boost::process::extend::posix_executor::set_error">set_error</methodname>(<functionname alt="boost::process::extend::get_last_error">get_last_error</functionname>());
    for (auto &amp; s : seq)
        s.<methodname alt="boost::process::extend::handler::on_fork_error">on_fork_error</methodname>(*this, <methodname alt="boost::process::extend::posix_executor::error">error</methodname>());
    for (auto &amp; s : seq)
        s.<methodname alt="boost::process::extend::handler::on_error">on_error</methodname>(*this, <methodname alt="boost::process::extend::posix_executor::error">error</methodname>());
    return <classname alt="boost::process::child">child</classname>()
}
else if (pid == 0) //child process
{
    for (auto &amp; s : seq)
        s.<methodname alt="boost::process::extend::handler::on_exec_setup">on_exec_setup</methodname>(*this);
    <ulink url="http://pubs.opengroup.org/onlinepubs/009695399/functions/exec.html">execve</ulink>(exe, cmd_line, env);
    auto ec = <functionname alt="boost::process::extend::get_last_error">get_last_error</functionname>();
    for (auto &amp; s : seq)
        s.<methodname alt="boost::process::extend::handler::on_exec_error">on_exec_error</methodname>(*this);

    <emphasis>unspecified();</emphasis>//here the error is send to the father process interally

    <ulink url="http://en.cppreference.com/w/cpp/utility/program/exit">std::exit</ulink>(<ulink url="http://en.cppreference.com/w/c/program/EXIT_status">EXIT_FAILURE</ulink>);
    return <classname alt="boost::process::child">child</classname>(); //for C++ compliance
}

<classname alt="boost::process::child">child</classname> c(pid, exit_code);

<emphasis>unspecified();</emphasis>//here, we read the the error from the child process

if (<methodname alt="boost::process::extend::posix_executor::error">error</methodname>())
    for (auto &amp; s : seq)
        s.<methodname alt="boost::process::extend::handler::on_error">on_error</methodname>(*this, <methodname alt="boost::process::extend::posix_executor::error">error</methodname>());
else
    for (auto &amp; s : seq)
        s.<methodname alt="boost::process::extend::handler::on_error">on_success</methodname>(*this);

//now we check again, because a on_success handler might've errored.
if (<methodname alt="boost::process::extend::posix_executor::error">error</methodname>())
{
    for (auto &amp; s : seq)
        s.<methodname alt="boost::process::extend::handler::on_error">on_error</methodname>(*this, <methodname alt="boost::process::extend::posix_executor::error">error</methodname>());
    return <classname alt="boost::process::child">child</classname>();
}
else
    return c;
</programlisting>

<mediaobject>
<caption>
<para>The sequence if when no error occurs.</para>
</caption>
<imageobject>
<imagedata fileref="boost_process/posix_success.svg"/>
</imageobject>
</mediaobject>

<mediaobject>
<caption>
<para>The sequence if the execution fails.</para>
</caption>
<imageobject>
<imagedata fileref="boost_process/posix_exec_err.svg"/>
</imageobject>
</mediaobject>

<mediaobject>
<caption>
<para>The sequence if the fork fails.</para>
</caption>
<imageobject>
<imagedata fileref="boost_process/posix_fork_err.svg"/>
</imageobject>
</mediaobject>

</para><para><note><para>Error handling if execve fails is done through a pipe, unless ignore_error is used. </para>
</note>
</para></description><data-member name="seq"><type>Sequence &amp;</type><purpose>A reference to the actual initializer-sequence. </purpose></data-member>
<data-member name="exe"><type>const char *</type><purpose>A pointer to the name of the executable. </purpose></data-member>
<data-member name="cmd_line"><type>char *const  *</type><purpose>A pointer to the argument-vector. </purpose></data-member>
<data-member name="env"><type>char **</type><purpose>A pointer to the environment variables, as default it is set to <ulink url="http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html">environ</ulink> </purpose></data-member>
<data-member name="pid"><type>pid_t</type><purpose>The pid of the process - it will be -1 before invoking <ulink url="http://pubs.opengroup.org/onlinepubs/009695399/functions/fork.html">fork</ulink>, and after forking either 0 for the new process or a positive value if in the current process. */. </purpose></data-member>
<data-member name="exit_status"><type>std::shared_ptr&lt; std::atomic&lt; int &gt; &gt;</type><purpose>This shared-pointer holds the exit code. It's done this way, so it can be shared between an <computeroutput>asio::io_context</computeroutput> and <classname alt="boost::process::child">child</classname>. </purpose></data-member>
<method-group name="public member functions">
<method name="error" cv="const"><type>const std::error_code &amp;</type><purpose>This function returns a const reference to the error state of the executor. </purpose></method>
<method name="set_error"><type>void</type><parameter name="ec"><paramtype>const std::error_code &amp;</paramtype></parameter><parameter name="msg"><paramtype>const std::string &amp;</paramtype></parameter><description><para>This function can be used to report an error to the executor. This will be handled according to the configuration of the executor, i.e. it might throw an exception. <note><para>This is the required way to handle errors in initializers. </para>
</note>
</para></description></method>
<method name="set_error"><type>void</type><parameter name="ec"><paramtype>const std::error_code &amp;</paramtype></parameter><parameter name="msg"><paramtype>const char *</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
</method-group>
</struct><struct name="require_io_context"><description><para>Inheriting the class will tell the launching process that an <computeroutput>io_context</computeroutput> is needed. This should always be used when get_io_context is used. </para></description></struct><struct name="windows_executor"><template>
      <template-type-parameter name="Char"><purpose><para>The used char-type, either <computeroutput>char</computeroutput> or <computeroutput>wchar_t</computeroutput>.</para></purpose></template-type-parameter>
      <template-type-parameter name="Sequence"><purpose><para>The used initializer-sequence, it is fulfills the boost.fusion <ulink url="http://www.boost.org/doc/libs/master/libs/fusion/doc/html/fusion/sequence.html">sequence</ulink> concept. </para></purpose></template-type-parameter>
    </template><purpose>The windows executor type. </purpose><description><para>This type represents the posix executor and can be used for overloading in a custom handler.</para><para><note><para>It is an alias for the implementation on posix, and a forward-declaration on windows. </para>
</note>

 
As information for extension development, here is the structure of the process launching (in pseudo-code and uml)<programlisting language="c++">
for (auto &amp; s : seq)
    s.<methodname alt="boost::process::extend::handler::on_setup">on_setup</methodname>(*this);

if (<methodname alt="boost::process::extend::windows_executor::error">error</methodname>())
{
    for (auto &amp; s : seq)
       s.<methodname alt="boost::process::extend::handler::on_error">on_error</methodname>(*this, <methodname alt="boost::process::extend::windows_executor::error">error</methodname>());
    return <classname alt="boost::process::child">child</classname>();
}
int err_code = <ulink url="https://msdn.microsoft.com/en-us/library/windows/desktop/ms682425.aspx">CreateProcess</ulink>(
         exe,
         cmd_line,
         proc_attrs,
         thread_attrs,
         creation_flags,
         env,
         work_dir,
         startup_info,
         proc_info);

<classname alt="boost::process::child">child</classname> c(proc_info, exit_code);

if (<methodname alt="boost::process::extend::windows_executor::error">error</methodname>())
    for (auto &amp; s : seq)
        s.<methodname alt="boost::process::extend::handler::on_error">on_error</methodname>(*this, <methodname alt="boost::process::extend::windows_executor::error">error</methodname>());
else
    for (auto &amp; s : seq)
        s.<methodname alt="boost::process::extend::handler::on_error">on_success</methodname>(*this);

//now we check again, because a on_success handler might've errored.
if (<methodname alt="boost::process::extend::windows_executor::error">error</methodname>())
{
    for (auto &amp; s : seq)
        s.<methodname alt="boost::process::extend::handler::on_error">on_error</methodname>(*this, <methodname alt="boost::process::extend::windows_executor::error">error</methodname>());
    return <classname alt="boost::process::child">child</classname>();
}
else
    return c;

</programlisting>
<mediaobject>
<caption>
<para>The sequence for windows process creation.</para>
</caption>
<imageobject>
<imagedata fileref="boost_process/windows_exec.svg"/>
</imageobject>
</mediaobject>
 </para></description><typedef name="startup_info_t"><purpose>The type of the <ulink url="https://msdn.microsoft.com/en-us/library/windows/desktop/ms686331.aspx">startup-info</ulink>, depending on the char-type. </purpose><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="startup_info_ex_t"><purpose>The type of the <ulink url="https://msdn.microsoft.com/de-de/library/windows/desktop/ms686329.aspx">extended startup-info</ulink>, depending the char-type; only defined with winapi-version equal or higher than 6. </purpose><type><emphasis>unspecified</emphasis></type></typedef>
<data-member name="seq"><type>Sequence &amp;</type><purpose>A reference to the actual initializer-sequence. </purpose></data-member>
<data-member name="exe"><type>const Char *</type><purpose>A pointer to the name of the executable. It's null by default. </purpose></data-member>
<data-member name="cmd_line"><type>char Char *</type><purpose>A pointer to the argument-vector. Must be set by some initializer. </purpose></data-member>
<data-member name="env"><type>char Char *</type><purpose>A pointer to the environment variables. It's null by default. </purpose></data-member>
<data-member name="work_dir"><type>const Char *</type><purpose>A pointer to the working directory. It's null by default. </purpose></data-member>
<data-member name="proc_attrs"><type><emphasis>unspecified</emphasis></type><purpose>A pointer to the process-attributes of type <ulink url="https://msdn.microsoft.com/en-us/library/windows/desktop/aa379560.aspx">SECURITY_ATTRIBUTES</ulink>. It's null by default. </purpose></data-member>
<data-member name="thread_attrs"><type><emphasis>unspecified</emphasis></type><purpose>A pointer to the thread-attributes of type <ulink url="https://msdn.microsoft.com/en-us/library/windows/desktop/aa379560.aspx">SECURITY_ATTRIBUTES</ulink>. It' null by default. </purpose></data-member>
<data-member name="inherit_handles"><type><emphasis>unspecified</emphasis></type><purpose>A logical bool value setting whether handles shall be inherited or not. </purpose></data-member>
<data-member name="proc_info"><type><emphasis>unspecified</emphasis></type><purpose>The element holding the process-information after process creation. The type is <ulink url="https://msdn.microsoft.com/en-us/library/windows/desktop/ms684873.aspx">PROCESS_INFORMATION</ulink> </purpose></data-member>
<data-member name="exit_status"><type>std::shared_ptr&lt; std::atomic&lt; int &gt; &gt;</type><purpose>This shared-pointer holds the exit code. It's done this way, so it can be shared between an <computeroutput>asio::io_context</computeroutput> and <classname alt="boost::process::child">child</classname>. </purpose></data-member>
<data-member name="creation_flags"><type><emphasis>unspecified</emphasis></type><purpose>The creation flags of the process. </purpose></data-member>
<data-member name="startup_info"><type>startup_info_t</type><purpose>This element is an instance or a reference (if startup_info_ex exists) to the <ulink url="https://msdn.microsoft.com/en-us/library/windows/desktop/ms686331.aspx">startup-info</ulink> for the process. </purpose></data-member>
<data-member name="startup_info_ex"><type>startup_info_ex_t</type><purpose>This element is the instance of the <ulink url="https://msdn.microsoft.com/de-de/library/windows/desktop/ms686329.aspx">extended startup-info</ulink>. It is only available with a winapi-version equal or highter than 6. </purpose></data-member>
<method-group name="public member functions">
<method name="error" cv="const"><type>const std::error_code &amp;</type><purpose>This function returns a const reference to the error state of the executor. </purpose></method>
<method name="set_error"><type>void</type><parameter name="ec"><paramtype>const std::error_code &amp;</paramtype></parameter><parameter name="msg"><paramtype>const std::string &amp;</paramtype></parameter><description><para>This function can be used to report an error to the executor. This will be handled according to the configuration of the executor, i.e. it might throw an exception. <note><para>This is the required way to handle errors in initializers. </para>
</note>
</para></description></method>
<method name="set_error"><type>void</type><parameter name="ec"><paramtype>const std::error_code &amp;</paramtype></parameter><parameter name="msg"><paramtype>const char *</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="set_startup_info_ex"><type>void</type><purpose>This function switches the information, so that the extended structure is used. </purpose><description><para><note><para>It's only defined with winapi-version equal or higher than 6. </para>
</note>
</para></description></method>
</method-group>
</struct><data-member name="on_setup"><type><emphasis>unspecified</emphasis></type><purpose>This handler is invoked before the process in launched, to setup parameters. The required signature is <computeroutput>void(Exec &amp;)</computeroutput>, where <computeroutput>Exec</computeroutput> is a template parameter. </purpose></data-member>
<data-member name="on_error"><type><emphasis>unspecified</emphasis></type><purpose>This handler is invoked if an error occured. The required signature is <computeroutput>void(auto &amp; exec, const std::error_code&amp;)</computeroutput>, where <computeroutput>Exec</computeroutput> is a template parameter. </purpose></data-member>
<data-member name="on_success"><type><emphasis>unspecified</emphasis></type><purpose>This handler is invoked if launching the process has succeeded. The required signature is <computeroutput>void(auto &amp; exec)</computeroutput>, where <computeroutput>Exec</computeroutput> is a template parameter. </purpose></data-member>
<data-member name="on_fork_error"><type><emphasis>unspecified</emphasis></type><purpose>This handler is invoked if the fork failed. The required signature is <computeroutput>void(auto &amp; exec)</computeroutput>, where <computeroutput>Exec</computeroutput> is a template parameter. </purpose><description><para><note><para>Only available on posix. </para>
</note>
</para></description></data-member>
<data-member name="on_exec_setup"><type><emphasis>unspecified</emphasis></type><purpose>This handler is invoked if the fork succeeded. The required signature is <computeroutput>void(Exec &amp;)</computeroutput>, where <computeroutput>Exec</computeroutput> is a template parameter. </purpose><description><para><note><para>Only available on posix. </para>
</note>
</para></description></data-member>
<data-member name="on_exec_error"><type><emphasis>unspecified</emphasis></type><purpose>This handler is invoked if the exec call errored. The required signature is <computeroutput>void(auto &amp; exec)</computeroutput>, where <computeroutput>Exec</computeroutput> is a template parameter. </purpose><description><para><note><para>Only available on posix. </para>
</note>
</para></description></data-member>
<function name="get_last_error"><type>std::error_code</type><purpose>Helper function to get the last error code system-independent. </purpose></function>
<overloaded-function name="throw_last_error"><signature><type>void</type><parameter name="msg"><paramtype>const std::string &amp;</paramtype><description><para>A message to add to the error code. </para></description></parameter></signature><signature><type>void</type></signature><description><para>Helper function to get and throw the last system error. 

</para></description><throws><simpara><classname>boost::process::process_error</classname> </simpara></throws></overloaded-function>

<function name="get_io_context"><type>asio::io_context &amp;</type><template>
          <template-type-parameter name="Sequence"/>
        </template><parameter name="seq"><paramtype>const Sequence &amp;</paramtype><description><para>The Sequence of the initializer. </para></description></parameter><description><para>This function gets the io_context from the initializer sequence.</para><para><note><para>Yields a compile-time error if no <computeroutput>io_context</computeroutput> is provided. </para>
</note>

</para></description></function>
</namespace>







</namespace>
</namespace>
</header>
<header name="boost/process/group.hpp">
<para>Defines a group process class. For additional information see the platform specific implementations:</para><para><itemizedlist>
<listitem><para><ulink url="https://msdn.microsoft.com/en-us/library/windows/desktop/ms684161.aspx">windows - job object</ulink></para>
</listitem><listitem><para><ulink url="http://pubs.opengroup.org/onlinepubs/009695399/functions/setpgid.html">posix - process group</ulink> </para>
</listitem></itemizedlist>
</para><namespace name="boost">
<namespace name="process">
<class name="group"><description><para>Represents a process group.</para><para>Groups are movable but non-copyable. The destructor automatically closes handles to the group process.</para><para>The group will have the same interface as std::thread.</para><para><note><para>If the destructor is called without a previous detach or wait, the group will be terminated.</para>
</note>
<note><para>If a default-constructed group is used before being used in a process launch, the behaviour is undefined.</para>
</note>
<note><para>Waiting for groups is currently broken on windows and will most likely result in a dead-lock. </para>
</note>
</para></description><typedef name="group_handle"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="native_handle_t"><purpose>Native representation of the handle. </purpose><type>group_handle::handle_t</type></typedef>
<method-group name="public member functions">
<method name="detach"><type>void</type><purpose>Detach the group. </purpose></method>
<method name="join"><type>void</type><description><para>Join the child. This just calls wait, but that way the naming is similar to std::thread </para></description></method>
<method name="joinable"><type>bool</type><description><para>Check if the child is joinable. </para></description></method>
<method name="native_handle" cv="const"><type>native_handle_t</type><purpose>Obtain the native handle of the group. </purpose></method>
<method name="wait"><type>void</type><purpose>Wait for the process group to exit. </purpose></method>
<method name="wait" cv="noexcept"><type>void</type><parameter name="ec"><paramtype>std::error_code &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="wait_for"><type>bool</type><template>
          <template-type-parameter name="Rep"/>
          <template-type-parameter name="Period"/>
        </template><parameter name="rel_time"><paramtype>const std::chrono::duration&lt; Rep, Period &gt; &amp;</paramtype></parameter><description><para>Wait for the process group to exit for period of time. 
</para></description><returns><para>True if all child processes exited while waiting. </para>
</returns></method>
<method name="wait_for" cv="noexcept"><type>bool</type><template>
          <template-type-parameter name="Rep"/>
          <template-type-parameter name="Period"/>
        </template><parameter name="rel_time"><paramtype>const std::chrono::duration&lt; Rep, Period &gt; &amp;</paramtype></parameter><parameter name="ec"><paramtype>std::error_code &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="wait_until"><type>bool</type><template>
          <template-type-parameter name="Clock"/>
          <template-type-parameter name="Duration"/>
        </template><parameter name="timeout_time"><paramtype>const std::chrono::time_point&lt; Clock, Duration &gt; &amp;</paramtype></parameter><description><para>Wait for the process group to exit until a point in time. 
</para></description><returns><para>True if all child processes exited while waiting. </para>
</returns></method>
<method name="wait_until" cv="noexcept"><type>bool</type><template>
          <template-type-parameter name="Clock"/>
          <template-type-parameter name="Duration"/>
        </template><parameter name="timeout_time"><paramtype>const std::chrono::time_point&lt; Clock, Duration &gt; &amp;</paramtype></parameter><parameter name="ec"><paramtype>std::error_code &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="valid" cv="const"><type>bool</type><purpose>Check if the group has a valid handle. </purpose></method>
<method name="conversion-operator" cv="const" specifiers="explicit"><type>bool</type><purpose>Convenience to call valid. </purpose></method>
<method name="terminate"><type>void</type><purpose>Terminate the process group, i.e. all processes in the group. </purpose></method>
<method name="terminate" cv="noexcept"><type>void</type><parameter name="ec"><paramtype>std::error_code &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="add"><type>void</type><parameter name="c"><paramtype>const <classname>child</classname> &amp;</paramtype></parameter><purpose>Assign a child process to the group. </purpose></method>
<method name="add" cv="noexcept"><type>void</type><parameter name="c"><paramtype>const <classname>child</classname> &amp;</paramtype></parameter><parameter name="ec"><paramtype>std::error_code &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="has"><type>bool</type><parameter name="c"><paramtype>const <classname>child</classname> &amp;</paramtype></parameter><purpose>Check if the child process is in the group. </purpose></method>
<method name="has" cv="noexcept"><type>bool</type><parameter name="c"><paramtype>const <classname>child</classname> &amp;</paramtype></parameter><parameter name="ec"><paramtype>std::error_code &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
</method-group>
<constructor specifiers="explicit"><parameter name="ch"><paramtype>group_handle &amp;&amp;</paramtype></parameter></constructor>
<constructor specifiers="explicit"><parameter name="handle"><paramtype>native_handle_t &amp;</paramtype></parameter><purpose>Construct the group from a native_handle. </purpose></constructor>
<constructor cv="= delete"><parameter name=""><paramtype>const <classname>group</classname> &amp;</paramtype></parameter></constructor>
<constructor><parameter name="lhs"><paramtype><classname>group</classname> &amp;&amp;</paramtype></parameter><purpose>Move constructor. </purpose></constructor>
<constructor cv="= default"><purpose>Default constructor. </purpose></constructor>
<copy-assignment cv="= delete"><type><classname>group</classname> &amp;</type><parameter name=""><paramtype>const <classname>group</classname> &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>group</classname> &amp;</type><parameter name="lhs"><paramtype><classname>group</classname> &amp;&amp;</paramtype></parameter><purpose>Move assign. </purpose></copy-assignment>
<destructor><description><para>Destructor</para><para><note><para>If the destructor is called without a previous detach or wait, the group will be terminated. </para>
</note>
</para></description></destructor>
</class>






</namespace>
</namespace>
</header>
<header name="boost/process/handles.hpp">
<para>Defines functions to obtain handles of the current process and limit the amount for inherited ones. </para><namespace name="boost">
<namespace name="process">
<data-member name="limit_handles" specifiers="static"><type><emphasis>unspecified</emphasis></type><description><para>The limit_handles property sets all properties to be inherited only expcitly. It closes all unused file-descriptors on posix after the fork and removes the inherit flags on windows.</para><para><note><para>This is executed after the fork on posix.</para>
</note>
<programlisting language="c++">system("gcc", limit_handles);
</programlisting></para><para>Since limit also closes the standard handles unless they are explicitly redirected they can be ignored by <computeroutput>limit_handles</computeroutput> in the following way.</para><para><programlisting language="c++">system("gcc", limit_handles.allowStd())
</programlisting> </para></description></data-member>







</namespace>
<namespace name="this_process">
<typedef name="native_handle_type"><purpose>The native type for handles. </purpose><description><para>Definition of the native handle type. </para></description><type><emphasis>unspecified</emphasis></type></typedef>
<overloaded-function name="get_handles"><signature><type>std::vector&lt; native_handle_type &gt;</type></signature><signature><type>std::vector&lt; native_handle_type &gt;</type><parameter name="ec"><paramtype>std::error_code &amp;</paramtype></parameter></signature><description><para>Get a snapshot of all handles of the process (i.e. file descriptors on posix and handles on windows) of the current process.</para><para><note><para>This function might not work on certain posix systems.</para>
</note>
<note><para>On Windows version older than windows 8 this function will iterate all the system handles, meaning it might be quite slow.</para>
</note>
<warning><para>This functionality is utterly prone to race conditions, since other threads might open or close handles.</para>
</warning>

</para></description><returns><para>The list of all open handles of the current process </para>
</returns></overloaded-function>

<overloaded-function name="is_stream_handle"><signature><type>bool</type><parameter name="handle"><paramtype>native_handle_type</paramtype></parameter></signature><signature><type>bool</type><parameter name="handle"><paramtype>native_handle_type</paramtype></parameter><parameter name="ec"><paramtype>std::error_code &amp;</paramtype></parameter></signature><description><para>Determines if a given handle is a a stream-handle, i.e. any handle that can be used with read and write functions. Stream handles include pipes, regular files and sockets.</para><para>
</para></description><returns><para>Indicates if it's a stream handle. </para>
</returns></overloaded-function>






</namespace>
</namespace>
</header>
<header name="boost/process/io.hpp">
<para>Header which provides the io properties. It provides the following properties:</para><para> 
<programlisting language="c++">
namespace boost {
  namespace process {
    <emphasis>unspecified</emphasis> <globalname alt="boost::process::close">close</globalname>;
    <emphasis>unspecified</emphasis> <globalname alt="boost::process::null">null</globalname>;
    <emphasis>unspecified</emphasis> <globalname alt="boost::process::std_in">std_in</globalname>;
    <emphasis>unspecified</emphasis> <globalname alt="boost::process::std_out">std_out</globalname>;
    <emphasis>unspecified</emphasis> <globalname alt="boost::process::std_err">std_err</globalname>;
  }
}
</programlisting>
</para><para><formalpara><title>File I/O</title><para/>
</formalpara>
The library allows full redirection of streams to files as shown below.</para><para><programlisting language="c++">boost::filesystem::path log    = "my_log_file.txt";
boost::filesystem::path input  = "input.txt";
boost::filesystem::path output = "output.txt";
system("my_prog", std_out&gt;output, std_in&lt;input, std_err&gt;log);
</programlisting></para><para><formalpara><title>Synchronous Pipe I/O</title><para/>
</formalpara>
Another way is to communicate through pipes.</para><para><programlisting language="c++">pstream str;
child c("my_prog", std_out &gt; str);

int i;
str &gt;&gt; i;
</programlisting></para><para>Note that the pipe may also be used between several processes, like this:</para><para><programlisting language="c++">pipe p;
child c1("nm", "a.out", std_out&gt;p);
child c2("c++filt", std_in&lt;p);
</programlisting></para><para><formalpara><title>Asynchronous I/O</title><para/>
</formalpara>
Utilizing <computeroutput>boost.asio</computeroutput> asynchronous I/O is provided.</para><para><programlisting language="c++">boost::asio::io_context ios;
std::future&lt;std::string&gt; output;
system("ls", std_out &gt; output, ios);

auto res = fut.get();
</programlisting></para><para><note><para><computeroutput>boost/process/async.hpp</computeroutput> must also be included for this to work.</para>
</note>
<formalpara><title>Closing</title><para/>
</formalpara>
Stream can be closed, so nothing can be read or written.</para><para><programlisting language="c++">system("foo", std_in.close());
</programlisting></para><para><formalpara><title>Null</title><para/>
</formalpara>
Streams can be redirected to null, which means, that written date will be discarded and read data will only contain <computeroutput>EOF</computeroutput>.</para><para><programlisting language="c++">system("b2", std_out &gt; null);
</programlisting> </para><namespace name="boost">
<namespace name="process">
<data-member name="close"><type><emphasis>unspecified</emphasis></type><purpose>This constant is a utility to allow syntax like <computeroutput>std_out &gt; close</computeroutput> for closing I/O streams. </purpose></data-member>
<data-member name="null"><type><emphasis>unspecified</emphasis></type><purpose>This constant is a utility to redirect streams to the null-device. </purpose></data-member>
<data-member name="std_in"><type><emphasis>unspecified</emphasis></type><description><para>This property allows to set the input stream for the child process.</para><sect1 id="namespaceboost_1_1process_1stdin_details">
<title>Details</title>
<sect2 id="namespaceboost_1_1process_1stdin_file">
<title>File Input</title>
<para>The file I/O simple redirects the stream to a file, for which the possible types are</para>
<para><itemizedlist>
<listitem><para><computeroutput>boost::filesystem::path</computeroutput></para>
</listitem><listitem><para><computeroutput>std::basic_string&lt;char_type&gt;</computeroutput></para>
</listitem><listitem><para><computeroutput>const char_type*</computeroutput></para>
</listitem><listitem><para><computeroutput>FILE*</computeroutput></para>
</listitem></itemizedlist>
</para>
<para>with <computeroutput>char_type</computeroutput> being either <computeroutput>char</computeroutput> or <computeroutput>wchar_t</computeroutput>.</para>
<para>FILE* is explicitly added, so the process can easily redirect the output stream of the child to another output stream of the process. That is:</para>
<para><programlisting language="c++">system("ls", std_in &lt; stdin);
</programlisting></para>
<para><warning><para>If the launching and the child process use the input, this leads to undefined behaviour.</para>
</warning>
A syntax like <computeroutput>system("ls", std_out &gt; std::cerr)</computeroutput> is not possible, due to the C++ implementation not providing access to the handle.</para>
<para>The valid expressions for this property are</para>
<para><programlisting language="c++">std_in &lt; file;
std_in = file;
</programlisting></para>
</sect2>
<sect2 id="namespaceboost_1_1process_1stdin_pipe">
<title>Pipe Input</title>
<para>As explained in the corresponding section, the boost.process library provides a <classname alt="boost::process::async_pipe">async_pipe</classname> class which can be used to communicate with child processes.</para>
<para><note><para>Technically the <classname alt="boost::process::async_pipe">async_pipe</classname> works synchronous here, since no asio implementation is used by the library here. The async-operation will then however not end if the process is finished, since the pipe remains open. You can use the async_close function with on_exit to fix that.</para>
</note>
Valid expressions with pipes are these:</para>
<para><programlisting language="c++">std_in &lt; pipe;
std_in = pipe;
</programlisting></para>
<para>Where the valid types for <computeroutput>pipe</computeroutput> are the following:</para>
<para><itemizedlist>
<listitem><para><computeroutput><classname alt="boost::process::basic_pipe">basic_pipe</classname></computeroutput></para>
</listitem><listitem><para><computeroutput><classname alt="boost::process::async_pipe">async_pipe</classname></computeroutput></para>
</listitem><listitem><para><computeroutput><classname alt="boost::process::basic_opstream">basic_opstream</classname></computeroutput></para>
</listitem><listitem><para><computeroutput><classname alt="boost::process::basic_pstream">basic_pstream</classname></computeroutput></para>
</listitem></itemizedlist>
</para>
<para>Note that the pipe may also be used between several processes, like this:</para>
<para><programlisting language="c++">pipe p;
child c1("nm", "a.out", std_out&gt;p);
child c2("c++filt", std_in&lt;p);
</programlisting></para>
</sect2>
<sect2 id="namespaceboost_1_1process_1stdin_async_pipe">
<title>Asynchronous Pipe Input</title>
<para>Asynchronous Pipe I/O classifies communication which has automatically handling of the asynchronous operations by the process library. This means, that a pipe will be constructed, the async_read/-write will be automatically started, and that the end of the child process will also close the pipe.</para>
<para>Valid types for pipe I/O are the following:</para>
<para><itemizedlist>
<listitem><para><computeroutput>boost::asio::const_buffer</computeroutput> <footnote><para> Constructed with <code>boost::asio::buffer</code></para></footnote> </para>
</listitem><listitem><para><computeroutput>boost::asio::mutable_buffer</computeroutput> <footnote><para> Constructed with <code>boost::asio::buffer</code></para></footnote> </para>
</listitem><listitem><para><computeroutput>boost::asio::streambuf</computeroutput></para>
</listitem></itemizedlist>
</para>
<para>Valid expressions with pipes are these:</para>
<para><programlisting language="c++">std_in &lt; buffer;
std_in = buffer;
std_out &gt; buffer;
std_out = buffer;
std_err &gt; buffer;
std_err = buffer;
(std_out &amp; std_err) &gt; buffer;
(std_out &amp; std_err) = buffer;
</programlisting></para>
<para><note><para>It is also possible to get a future for std_in, by chaining another <computeroutput>std::future&lt;void&gt;</computeroutput> onto it, so you can wait for the input to be completed. It looks like this: <programlisting language="c++">std::future&lt;void&gt; fut;
boost::asio::io_context ios;
std::string data;
child c("prog", std_in &lt; buffer(data) &gt;  fut, ios);
fut.get();
</programlisting></para>
</note>
<note><para><computeroutput>boost::asio::buffer</computeroutput> is also available in the <computeroutput>boost::process</computeroutput> namespace.</para>
</note>
<warning><para>This feature requires <computeroutput>boost/process/async.hpp</computeroutput> to be included and a reference to <computeroutput>boost::asio::io_context</computeroutput> to be passed to the launching function.</para>
</warning>
</para>
</sect2>
<sect2 id="namespaceboost_1_1process_1stdin_close">
<title>Close</title>
<para>The input stream can be closed, so it cannot be read from. This will lead to an error when attempted.</para>
<para>This can be achieved by the following syntax.</para>
<para><programlisting language="c++">std_in &lt; close;
std_in = close;
std_in.close();
</programlisting></para>
</sect2>
<sect2 id="namespaceboost_1_1process_1stdin_null">
<title>Null</title>
<para>The input stream can be redirected to read from the null-device, which means that only <computeroutput>EOF</computeroutput> is read.</para>
<para>The syntax to achieve that has the following variants:</para>
<para><programlisting language="c++">std_in &lt; null;
std_in = null;
std_in.null();
</programlisting> </para>
</sect2>
</sect1></description></data-member>
<data-member name="std_out"><type><emphasis>unspecified</emphasis></type><description><para>This property allows to set the output stream for the child process.</para><para><note><para>The Semantic is the same as for <globalname alt="boost::process::std_err">std_err</globalname> </para>
</note>
<note><para><computeroutput>std_err</computeroutput> and <computeroutput>std_out</computeroutput> can be combined into one stream, with the <computeroutput>operator &amp;</computeroutput>, i.e. <computeroutput>std_out &amp; std_err</computeroutput>.</para>
</note>
</para><sect1 id="namespaceboost_1_1process_1stdout_details">
<title>Details</title>
<sect2 id="namespaceboost_1_1process_1stdout_file">
<title>File Input</title>
<para>The file I/O simple redirects the stream to a file, for which the possible types are</para>
<para><itemizedlist>
<listitem><para><computeroutput>boost::filesystem::path</computeroutput></para>
</listitem><listitem><para><computeroutput>std::basic_string&lt;char_type&gt;</computeroutput></para>
</listitem><listitem><para><computeroutput>const char_type*</computeroutput></para>
</listitem><listitem><para><computeroutput>FILE*</computeroutput></para>
</listitem></itemizedlist>
</para>
<para>with <computeroutput>char_type</computeroutput> being either <computeroutput>char</computeroutput> or <computeroutput>wchar_t</computeroutput>.</para>
<para>FILE* is explicitly added, so the process can easily redirect the output stream of the child to another output stream of the process. That is:</para>
<para><programlisting language="c++">system("ls", std_out &lt; stdin);
</programlisting></para>
<para><warning><para>If the launching and the child process use the input, this leads to undefined behaviour.</para>
</warning>
A syntax like <computeroutput>system("ls", std_out &gt; std::cerr)</computeroutput> is not possible, due to the C++ implementation not providing access to the handle.</para>
<para>The valid expressions for this property are</para>
<para><programlisting language="c++">std_out &lt; file;
std_out = file;
</programlisting></para>
</sect2>
<sect2 id="namespaceboost_1_1process_1stdout_pipe">
<title>Pipe Output</title>
<para>As explained in the corresponding section, the boost.process library provides a <classname alt="boost::process::async_pipe">async_pipe</classname> class which can be used to communicate with child processes.</para>
<para><note><para>Technically the <classname alt="boost::process::async_pipe">async_pipe</classname> works like a synchronous pipe here, since no asio implementation is used by the library here. The asynchronous operation will then however not end if the process is finished, since the pipe remains open. You can use the async_close function with on_exit to fix that.</para>
</note>
Valid expressions with pipes are these:</para>
<para><programlisting language="c++">std_out &gt; pipe;
std_out = pipe;
</programlisting></para>
<para>Where the valid types for <computeroutput>pipe</computeroutput> are the following:</para>
<para><itemizedlist>
<listitem><para><computeroutput><classname alt="boost::process::basic_pipe">basic_pipe</classname></computeroutput></para>
</listitem><listitem><para><computeroutput><classname alt="boost::process::async_pipe">async_pipe</classname></computeroutput></para>
</listitem><listitem><para><computeroutput><classname alt="boost::process::basic_ipstream">basic_ipstream</classname></computeroutput></para>
</listitem><listitem><para><computeroutput><classname alt="boost::process::basic_pstream">basic_pstream</classname></computeroutput></para>
</listitem></itemizedlist>
</para>
<para>Note that the pipe may also be used between several processes, like this:</para>
<para><programlisting language="c++">pipe p;
child c1("nm", "a.out", std_out&gt;p);
child c2("c++filt", std_in&lt;p);
</programlisting></para>
</sect2>
<sect2 id="namespaceboost_1_1process_1stdout_async_pipe">
<title>Asynchronous Pipe Output</title>
<para>Asynchronous Pipe I/O classifies communication which has automatically handling of the async operations by the process library. This means, that a pipe will be constructed, the async_read/-write will be automatically started, and that the end of the child process will also close the pipe.</para>
<para>Valid types for pipe I/O are the following:</para>
<para><itemizedlist>
<listitem><para><computeroutput>boost::asio::mutable_buffer</computeroutput> <footnote><para> Constructed with <code>boost::asio::buffer</code></para></footnote> </para>
</listitem><listitem><para><computeroutput>boost::asio::streambuf</computeroutput></para>
</listitem><listitem><para><computeroutput>std::future&lt;std::vector&lt;char&gt;&gt;</computeroutput></para>
</listitem><listitem><para><computeroutput>std::future&lt;std::string&gt;</computeroutput></para>
</listitem></itemizedlist>
</para>
<para>Valid expressions with pipes are these:</para>
<para><programlisting language="c++">std_out &gt; buffer;
std_out = buffer;
std_err &gt; buffer;
std_err = buffer;
(std_out &amp; std_err) &gt; buffer;
(std_out &amp; std_err) = buffer;
</programlisting></para>
<para><note><para><computeroutput>boost::asio::buffer</computeroutput> is also available in the <computeroutput>boost::process</computeroutput> namespace.</para>
</note>
<warning><para>This feature requires <computeroutput>boost/process/async.hpp</computeroutput> to be included and a reference to <computeroutput>boost::asio::io_context</computeroutput> to be passed to the launching function.</para>
</warning>
</para>
</sect2>
<sect2 id="namespaceboost_1_1process_1stdout_close">
<title>Close</title>
<para>The out stream can be closed, so it cannot be write from. This will lead to an error when attempted.</para>
<para>This can be achieved by the following syntax.</para>
<para><programlisting language="c++">std_out &gt; close;
std_out = close;
std_out.close();
</programlisting></para>
</sect2>
<sect2 id="namespaceboost_1_1process_1stdout_null">
<title>Null</title>
<para>The output stream can be redirected to write to the null-device, which means that all output is discarded.</para>
<para>The syntax to achieve that has the following variants:</para>
<para><programlisting language="c++">std_out &gt; null;
std_out = null;
std_out.null();
</programlisting> </para>
</sect2>
</sect1></description></data-member>
<data-member name="std_err"><type><emphasis>unspecified</emphasis></type><description><para>This property allows setting the <computeroutput>stderr</computeroutput> stream. The semantic and syntax is the same as for  <globalname alt="boost::process::std_out">std_out</globalname>  . </para></description></data-member>







</namespace>
</namespace>
</header>
<header name="boost/process/locale.hpp">
<namespace name="boost">
<namespace name="process">
<typedef name="codecvt_type"><purpose>The internally used type for code conversion. </purpose><type>std::codecvt&lt; wchar_t, char, std::mbstate_t &gt;</type></typedef>



<function name="codecvt_category"><type>const std::error_category &amp;</type><purpose>Internally used error cateory for code conversion. </purpose></function>
<function name="codecvt"><type>const codecvt_type &amp;</type><purpose>Get a reference to the currently used code converter. </purpose></function>
<function name="imbue"><type>std::locale</type><parameter name="loc"><paramtype>const std::locale &amp;</paramtype></parameter><purpose>Set the locale of the library. </purpose></function>

</namespace>
</namespace>
</header>
<header name="boost/process/pipe.hpp">
<namespace name="boost">
<namespace name="process">
<class name="basic_ipstream"><template>
      <template-type-parameter name="CharT"/>
      <template-type-parameter name="Traits"><default>std::char_traits&lt;CharT&gt;</default></template-type-parameter>
    </template><inherit access="public">std::basic_istream&lt; CharT, Traits &gt;</inherit><description><para>Implementation of a reading pipe stream. </para></description><typedef name="pipe_type"><type><classname>basic_pipe</classname>&lt; CharT, Traits &gt;</type></typedef>
<typedef name="char_type"><type>CharT</type></typedef>
<typedef name="traits_type"><type>Traits</type></typedef>
<typedef name="int_type"><type>Traits::int_type</type></typedef>
<typedef name="pos_type"><type>Traits::pos_type</type></typedef>
<typedef name="off_type"><type>Traits::off_type</type></typedef>
<method-group name="public member functions">
<method name="rdbuf" cv="const"><type><classname>basic_pipebuf</classname>&lt; CharT, Traits &gt; *</type><purpose>Get access to the underlying stream_buf. </purpose></method>
<method name="pipe"><type>void</type><parameter name="p"><paramtype><classname>pipe_type</classname> &amp;&amp;</paramtype></parameter><purpose>Set the pipe of the streambuf. </purpose></method>
<method name="pipe"><type>void</type><parameter name="p"><paramtype>const <classname>pipe_type</classname> &amp;</paramtype></parameter><purpose>Set the pipe of the streambuf. </purpose></method>
<method name="pipe"><type><classname>pipe_type</classname> &amp;</type><purpose>Get a reference to the pipe. </purpose></method>
<method name="pipe" cv="const"><type>const <classname>pipe_type</classname> &amp;</type><purpose>Get a const reference to the pipe. </purpose></method>
<method name="pipe"><type><classname>pipe_type</classname> &amp;&amp;</type><purpose>Get a rvalue reference to the pipe. Qualified as rvalue. </purpose></method>
<method name="is_open" cv="const"><type>bool</type><purpose>Check if the pipe is open. </purpose></method>
<method name="open"><type>void</type><purpose>Open a new pipe. </purpose></method>
<method name="open"><type>void</type><parameter name="name"><paramtype>const std::string &amp;</paramtype></parameter><purpose>Open a new named pipe. </purpose></method>
<method name="close"><type>void</type><purpose>Flush the buffer &amp; close the pipe. </purpose></method>
</method-group>
<constructor><purpose>Default constructor. </purpose></constructor>
<constructor cv="= delete"><parameter name=""><paramtype>const <classname>basic_ipstream</classname> &amp;</paramtype></parameter><purpose>Copy constructor. </purpose></constructor>
<constructor><parameter name="lhs"><paramtype><classname>basic_ipstream</classname> &amp;&amp;</paramtype></parameter><purpose>Move constructor. </purpose></constructor>
<constructor><parameter name="p"><paramtype><classname>pipe_type</classname> &amp;&amp;</paramtype></parameter><purpose>Move construct from a pipe. </purpose></constructor>
<constructor><parameter name="p"><paramtype>const <classname>pipe_type</classname> &amp;</paramtype></parameter><purpose>Copy construct from a pipe. </purpose></constructor>
<copy-assignment cv="= delete"><type><classname>basic_ipstream</classname> &amp;</type><parameter name=""><paramtype>const <classname>basic_ipstream</classname> &amp;</paramtype></parameter><purpose>Copy assignment. </purpose></copy-assignment>
<copy-assignment><type><classname>basic_ipstream</classname> &amp;</type><parameter name="lhs"><paramtype><classname>basic_ipstream</classname> &amp;&amp;</paramtype></parameter><purpose>Move assignment. </purpose></copy-assignment>
<copy-assignment><type><classname>basic_ipstream</classname> &amp;</type><parameter name="p"><paramtype><classname>pipe_type</classname> &amp;&amp;</paramtype></parameter><purpose>Move assignment of a pipe. </purpose></copy-assignment>
<copy-assignment><type><classname>basic_ipstream</classname> &amp;</type><parameter name="p"><paramtype>const <classname>pipe_type</classname> &amp;</paramtype></parameter><purpose>Copy assignment of a pipe. </purpose></copy-assignment>
</class><class name="basic_opstream"><template>
      <template-type-parameter name="CharT"/>
      <template-type-parameter name="Traits"><default>std::char_traits&lt;CharT&gt;</default></template-type-parameter>
    </template><inherit access="public">std::basic_ostream&lt; CharT, Traits &gt;</inherit><description><para>Implementation of a write pipe stream. </para></description><typedef name="pipe_type"><type><classname>basic_pipe</classname>&lt; CharT, Traits &gt;</type></typedef>
<typedef name="char_type"><type>CharT</type></typedef>
<typedef name="traits_type"><type>Traits</type></typedef>
<typedef name="int_type"><type>Traits::int_type</type></typedef>
<typedef name="pos_type"><type>Traits::pos_type</type></typedef>
<typedef name="off_type"><type>Traits::off_type</type></typedef>
<method-group name="public member functions">
<method name="rdbuf" cv="const"><type><classname>basic_pipebuf</classname>&lt; CharT, Traits &gt; *</type><purpose>Get access to the underlying stream_buf. </purpose></method>
<method name="pipe"><type>void</type><parameter name="p"><paramtype><classname>pipe_type</classname> &amp;&amp;</paramtype></parameter><purpose>Set the pipe of the streambuf. </purpose></method>
<method name="pipe"><type>void</type><parameter name="p"><paramtype>const <classname>pipe_type</classname> &amp;</paramtype></parameter><purpose>Set the pipe of the streambuf. </purpose></method>
<method name="pipe"><type><classname>pipe_type</classname> &amp;</type><purpose>Get a reference to the pipe. </purpose></method>
<method name="pipe" cv="const"><type>const <classname>pipe_type</classname> &amp;</type><purpose>Get a const reference to the pipe. </purpose></method>
<method name="pipe"><type><classname>pipe_type</classname> &amp;&amp;</type><purpose>Get a rvalue reference to the pipe. Qualified as rvalue. </purpose></method>
<method name="open"><type>void</type><purpose>Open a new pipe. </purpose></method>
<method name="open"><type>void</type><parameter name="name"><paramtype>const std::string &amp;</paramtype></parameter><purpose>Open a new named pipe. </purpose></method>
<method name="close"><type>void</type><purpose>Flush the buffer &amp; close the pipe. </purpose></method>
</method-group>
<constructor><purpose>Default constructor. </purpose></constructor>
<constructor cv="= delete"><parameter name=""><paramtype>const <classname>basic_opstream</classname> &amp;</paramtype></parameter><purpose>Copy constructor. </purpose></constructor>
<constructor><parameter name="lhs"><paramtype><classname>basic_opstream</classname> &amp;&amp;</paramtype></parameter><purpose>Move constructor. </purpose></constructor>
<constructor><parameter name="p"><paramtype><classname>pipe_type</classname> &amp;&amp;</paramtype></parameter><purpose>Move construct from a pipe. </purpose></constructor>
<constructor><parameter name="p"><paramtype>const <classname>pipe_type</classname> &amp;</paramtype></parameter><purpose>Copy construct from a pipe. </purpose></constructor>
<copy-assignment cv="= delete"><type><classname>basic_opstream</classname> &amp;</type><parameter name=""><paramtype>const <classname>basic_opstream</classname> &amp;</paramtype></parameter><purpose>Copy assignment. </purpose></copy-assignment>
<copy-assignment><type><classname>basic_opstream</classname> &amp;</type><parameter name="lhs"><paramtype><classname>basic_opstream</classname> &amp;&amp;</paramtype></parameter><purpose>Move assignment. </purpose></copy-assignment>
<copy-assignment><type><classname>basic_opstream</classname> &amp;</type><parameter name="p"><paramtype><classname>pipe_type</classname> &amp;&amp;</paramtype></parameter><purpose>Move assignment of a pipe. </purpose></copy-assignment>
<copy-assignment><type><classname>basic_opstream</classname> &amp;</type><parameter name="p"><paramtype>const <classname>pipe_type</classname> &amp;</paramtype></parameter><purpose>Copy assignment of a pipe. </purpose></copy-assignment>
</class><class name="basic_pipe"><template>
      <template-type-parameter name="CharT"/>
      <template-type-parameter name="Traits"><default>std::char_traits&lt;CharT&gt;</default></template-type-parameter>
    </template><description><para>Class implementation of a pipe. </para></description><typedef name="char_type"><type>CharT</type></typedef>
<typedef name="traits_type"><type>Traits</type></typedef>
<typedef name="int_type"><type>Traits::int_type</type></typedef>
<typedef name="pos_type"><type>Traits::pos_type</type></typedef>
<typedef name="off_type"><type>Traits::off_type</type></typedef>
<typedef name="native_handle"><type><emphasis>unspecified</emphasis></type></typedef>
<method-group name="public member functions">
<method name="native_source" cv="const"><type>native_handle</type><description><para>Get the native handle of the source. </para></description></method>
<method name="native_sink" cv="const"><type>native_handle</type><description><para>Get the native handle of the sink. </para></description></method>
<method name="assign_source"><type>void</type><parameter name="h"><paramtype>native_handle</paramtype></parameter><description><para>Assign a new value to the source </para></description></method>
<method name="assign_sink"><type>void</type><parameter name="h"><paramtype>native_handle</paramtype></parameter><description><para>Assign a new value to the sink </para></description></method>
<method name="write"><type>int_type</type><parameter name="data"><paramtype>const char_type *</paramtype></parameter><parameter name="count"><paramtype>int_type</paramtype></parameter><purpose>Write data to the pipe. </purpose></method>
<method name="read"><type>int_type</type><parameter name="data"><paramtype>char_type *</paramtype></parameter><parameter name="count"><paramtype>int_type</paramtype></parameter><purpose>Read data from the pipe. </purpose></method>
<method name="is_open"><type>bool</type><purpose>Check if the pipe is open. </purpose></method>
<method name="close"><type>void</type><purpose>Close the pipe. </purpose></method>
</method-group>
<constructor><purpose>Default construct the pipe. Will be opened. </purpose></constructor>
<constructor specifiers="explicit"><parameter name="name"><paramtype>const std::string &amp;</paramtype></parameter><purpose>Construct a named pipe. </purpose></constructor>
<constructor><parameter name="p"><paramtype>const <classname>basic_pipe</classname> &amp;</paramtype></parameter><description><para>Copy construct the pipe. <note><para>Duplicated the handles. </para>
</note>
</para></description></constructor>
<constructor><parameter name="lhs"><paramtype><classname>basic_pipe</classname> &amp;&amp;</paramtype></parameter><description><para>Move construct the pipe. </para></description></constructor>
<copy-assignment><type><classname>basic_pipe</classname> &amp;</type><parameter name="p"><paramtype>const <classname>basic_pipe</classname> &amp;</paramtype></parameter><description><para>Copy assign the pipe. <note><para>Duplicated the handles. </para>
</note>
</para></description></copy-assignment>
<copy-assignment><type><classname>basic_pipe</classname> &amp;</type><parameter name="lhs"><paramtype><classname>basic_pipe</classname> &amp;&amp;</paramtype></parameter><description><para>Move assign the pipe. </para></description></copy-assignment>
<destructor><description><para>Destructor closes the handles. </para></description></destructor>
</class><struct name="basic_pipebuf"><template>
      <template-type-parameter name="CharT"/>
      <template-type-parameter name="Traits"><default>std::char_traits&lt;CharT&gt;</default></template-type-parameter>
    </template><inherit access="public">std::basic_streambuf&lt; CharT, Traits &gt;</inherit><description><para>Implementation of the stream buffer for a pipe. </para></description><typedef name="pipe_type"><type><classname>basic_pipe</classname>&lt; CharT, Traits &gt;</type></typedef>
<typedef name="char_type"><type>CharT</type></typedef>
<typedef name="traits_type"><type>Traits</type></typedef>
<typedef name="int_type"><type>Traits::int_type</type></typedef>
<typedef name="pos_type"><type>Traits::pos_type</type></typedef>
<typedef name="off_type"><type>Traits::off_type</type></typedef>
<data-member name="default_buffer_size" specifiers="static"><type>constexpr int</type></data-member>
<method-group name="public member functions">
<method name="overflow"><type>int_type</type><parameter name="ch"><paramtype>int_type</paramtype><default>traits_type::eof()</default></parameter><purpose>Writes characters to the associated output sequence from the put area. </purpose></method>
<method name="sync"><type>int</type><purpose>Synchronizes the buffers with the associated character sequence. </purpose></method>
<method name="underflow"><type>int_type</type><purpose>Reads characters from the associated input sequence to the get area. </purpose></method>
<method name="pipe"><type>void</type><parameter name="p"><paramtype><classname>pipe_type</classname> &amp;&amp;</paramtype></parameter><purpose>Set the pipe of the streambuf. </purpose></method>
<method name="pipe"><type>void</type><parameter name="p"><paramtype>const <classname>pipe_type</classname> &amp;</paramtype></parameter><purpose>Set the pipe of the streambuf. </purpose></method>
<method name="pipe"><type><classname>pipe_type</classname> &amp;</type><purpose>Get a reference to the pipe. </purpose></method>
<method name="pipe" cv="const"><type>const <classname>pipe_type</classname> &amp;</type><purpose>Get a const reference to the pipe. </purpose></method>
<method name="pipe"><type><classname>pipe_type</classname> &amp;&amp;</type><purpose>Get a rvalue reference to the pipe. Qualified as rvalue. </purpose></method>
<method name="is_open" cv="const"><type>bool</type><purpose>Check if the pipe is open. </purpose></method>
<method name="open"><type><classname>basic_pipebuf</classname>&lt; CharT, Traits &gt; *</type><purpose>Open a new pipe. </purpose></method>
<method name="open"><type><classname>basic_pipebuf</classname>&lt; CharT, Traits &gt; *</type><parameter name="name"><paramtype>const std::string &amp;</paramtype></parameter><purpose>Open a new named pipe. </purpose></method>
<method name="close"><type><classname>basic_pipebuf</classname>&lt; CharT, Traits &gt; *</type><purpose>Flush the buffer &amp; close the pipe. </purpose></method>
</method-group>
<constructor><purpose>Default constructor, will also construct the pipe. </purpose></constructor>
<constructor cv="= default"><parameter name=""><paramtype>const <classname>basic_pipebuf</classname> &amp;</paramtype></parameter><purpose>Copy Constructor. </purpose></constructor>
<constructor cv="= default"><parameter name=""><paramtype><classname>basic_pipebuf</classname> &amp;&amp;</paramtype></parameter><purpose>Move Constructor. </purpose></constructor>
<destructor><purpose>Destructor -&gt; writes the frest of the data. </purpose></destructor>
<constructor><parameter name="p"><paramtype><classname>pipe_type</classname> &amp;&amp;</paramtype></parameter><purpose>Move construct from a pipe. </purpose></constructor>
<constructor><parameter name="p"><paramtype>const <classname>pipe_type</classname> &amp;</paramtype></parameter><purpose>Construct from a pipe. </purpose></constructor>
<copy-assignment cv="= delete"><type><classname>basic_pipebuf</classname> &amp;</type><parameter name=""><paramtype>const <classname>basic_pipebuf</classname> &amp;</paramtype></parameter><purpose>Copy assign. </purpose></copy-assignment>
<copy-assignment cv="= default"><type><classname>basic_pipebuf</classname> &amp;</type><parameter name=""><paramtype><classname>basic_pipebuf</classname> &amp;&amp;</paramtype></parameter><purpose>Move assign. </purpose></copy-assignment>
<copy-assignment><type><classname>basic_pipebuf</classname> &amp;</type><parameter name="p"><paramtype><classname>pipe_type</classname> &amp;&amp;</paramtype></parameter><purpose>Move assign a pipe. </purpose></copy-assignment>
<copy-assignment><type><classname>basic_pipebuf</classname> &amp;</type><parameter name="p"><paramtype>const <classname>pipe_type</classname> &amp;</paramtype></parameter><purpose>Copy assign a pipe. </purpose></copy-assignment>
<method-group name="private member functions">
<method name="_write_impl"><type>bool</type></method>
</method-group>
</struct><class name="basic_pstream"><template>
      <template-type-parameter name="CharT"/>
      <template-type-parameter name="Traits"><default>std::char_traits&lt;CharT&gt;</default></template-type-parameter>
    </template><inherit access="public">std::basic_iostream&lt; CharT, Traits &gt;</inherit><description><para>Implementation of a read-write pipe stream. </para></description><typedef name="pipe_type"><type><classname>basic_pipe</classname>&lt; CharT, Traits &gt;</type></typedef>
<typedef name="char_type"><type>CharT</type></typedef>
<typedef name="traits_type"><type>Traits</type></typedef>
<typedef name="int_type"><type>Traits::int_type</type></typedef>
<typedef name="pos_type"><type>Traits::pos_type</type></typedef>
<typedef name="off_type"><type>Traits::off_type</type></typedef>
<method-group name="public member functions">
<method name="rdbuf" cv="const"><type><classname>basic_pipebuf</classname>&lt; CharT, Traits &gt; *</type><purpose>Get access to the underlying stream_buf. </purpose></method>
<method name="pipe"><type>void</type><parameter name="p"><paramtype><classname>pipe_type</classname> &amp;&amp;</paramtype></parameter><purpose>Set the pipe of the streambuf. </purpose></method>
<method name="pipe"><type>void</type><parameter name="p"><paramtype>const <classname>pipe_type</classname> &amp;</paramtype></parameter><purpose>Set the pipe of the streambuf. </purpose></method>
<method name="pipe"><type><classname>pipe_type</classname> &amp;</type><purpose>Get a reference to the pipe. </purpose></method>
<method name="pipe" cv="const"><type>const <classname>pipe_type</classname> &amp;</type><purpose>Get a const reference to the pipe. </purpose></method>
<method name="pipe"><type><classname>pipe_type</classname> &amp;&amp;</type><purpose>Get a rvalue reference to the pipe. Qualified as rvalue. </purpose></method>
<method name="open"><type>void</type><purpose>Open a new pipe. </purpose></method>
<method name="open"><type>void</type><parameter name="name"><paramtype>const std::string &amp;</paramtype></parameter><purpose>Open a new named pipe. </purpose></method>
<method name="close"><type>void</type><purpose>Flush the buffer &amp; close the pipe. </purpose></method>
</method-group>
<constructor><purpose>Default constructor. </purpose></constructor>
<constructor cv="= delete"><parameter name=""><paramtype>const <classname>basic_pstream</classname> &amp;</paramtype></parameter><purpose>Copy constructor. </purpose></constructor>
<constructor><parameter name="lhs"><paramtype><classname>basic_pstream</classname> &amp;&amp;</paramtype></parameter><purpose>Move constructor. </purpose></constructor>
<constructor><parameter name="p"><paramtype><classname>pipe_type</classname> &amp;&amp;</paramtype></parameter><purpose>Move construct from a pipe. </purpose></constructor>
<constructor><parameter name="p"><paramtype>const <classname>pipe_type</classname> &amp;</paramtype></parameter><purpose>Copy construct from a pipe. </purpose></constructor>
<copy-assignment cv="= delete"><type><classname>basic_pstream</classname> &amp;</type><parameter name=""><paramtype>const <classname>basic_pstream</classname> &amp;</paramtype></parameter><purpose>Copy assignment. </purpose></copy-assignment>
<copy-assignment><type><classname>basic_pstream</classname> &amp;</type><parameter name="lhs"><paramtype><classname>basic_pstream</classname> &amp;&amp;</paramtype></parameter><purpose>Move assignment. </purpose></copy-assignment>
<copy-assignment><type><classname>basic_pstream</classname> &amp;</type><parameter name="p"><paramtype><classname>pipe_type</classname> &amp;&amp;</paramtype></parameter><purpose>Move assignment of a pipe. </purpose></copy-assignment>
<copy-assignment><type><classname>basic_pstream</classname> &amp;</type><parameter name="p"><paramtype>const <classname>pipe_type</classname> &amp;</paramtype></parameter><purpose>Copy assignment of a pipe. </purpose></copy-assignment>
</class><typedef name="pipe"><type><classname>basic_pipe</classname>&lt; char &gt;</type></typedef>
<typedef name="wpipe"><type><classname>basic_pipe</classname>&lt; wchar_t &gt;</type></typedef>
<typedef name="pipebuf"><type><classname>basic_pipebuf</classname>&lt; char &gt;</type></typedef>
<typedef name="wpipebuf"><type><classname>basic_pipebuf</classname>&lt; wchar_t &gt;</type></typedef>
<typedef name="ipstream"><type><classname>basic_ipstream</classname>&lt; char &gt;</type></typedef>
<typedef name="wipstream"><type><classname>basic_ipstream</classname>&lt; wchar_t &gt;</type></typedef>
<typedef name="opstream"><type><classname>basic_opstream</classname>&lt; char &gt;</type></typedef>
<typedef name="wopstream"><type><classname>basic_opstream</classname>&lt; wchar_t &gt;</type></typedef>
<typedef name="pstream"><type><classname>basic_pstream</classname>&lt; char &gt;</type></typedef>
<typedef name="wpstream"><type><classname>basic_pstream</classname>&lt; wchar_t &gt;</type></typedef>







</namespace>
</namespace>
</header>
<header name="boost/process/posix.hpp">
<para>Header which provides the posix extensions.  
<programlisting language="c++">
namespace boost {
  namespace process {
    namespace posix {
      <emphasis>unspecified</emphasis> <globalname alt="boost::process::posix::fd">fd</globalname>;
      <emphasis>unspecified</emphasis> <globalname alt="boost::process::posix::sig">sig</globalname>;
      <emphasis>unspecified</emphasis> <globalname alt="boost::process::posix::use_vfork">use_vfork</globalname>;
    }
  }
}
</programlisting>
     <warning><para>Only available on posix. See the documentation of <ulink url="http://pubs.opengroup.org/onlinepubs/009695399/functions/fork.html">fork</ulink>, <ulink url="http://pubs.opengroup.org/onlinepubs/009695399/functions/execve.html">execve</ulink> and <ulink url="http://pubs.opengroup.org/onlinepubs/009695399/functions/vfork.html">vfork</ulink>. </para>
</warning>
</para><namespace name="boost">
<namespace name="process">
<namespace name="posix">
<data-member name="fd"><type><emphasis>unspecified</emphasis></type><description><para>This property lets you modify file-descriptors other than the standard ones (0,1,2).</para><para>It provides the functions <computeroutput>bind</computeroutput>, which implements <ulink url="http://pubs.opengroup.org/onlinepubs/9699919799/functions/dup.html">dup2</ulink> and <ulink url="http://pubs.opengroup.org/onlinepubs/9699919799/functions/close.html">close</ulink>.</para><para>Close can also be called with a range of file-descriptors to be closed. </para></description></data-member>
<data-member name="sig"><type><emphasis>unspecified</emphasis></type><description><para>This property lets you modify the handling of <computeroutput>SIGCHLD</computeroutput> for this call. It will be reset afterwards.</para><para>It can be set to default, by the expression <computeroutput>sig.dfl()</computeroutput>, set to ignore with <computeroutput>sig.ign()</computeroutput> or assigned a custom handler. A custom handler must have the type <computeroutput>sighandler_t</computeroutput>and can be assigned with the following syntax:</para><para><programlisting language="c++">sig = handler;
sig(handler);
</programlisting></para><para><warning><para>spawn will automatically use <computeroutput>sig.ign()</computeroutput>, which will override if you pass a custom handler. </para>
</warning>
</para></description></data-member>
<data-member name="use_vfork"><type><emphasis>unspecified</emphasis></type><description><para>This property will replace the usage of <ulink url="http://pubs.opengroup.org/onlinepubs/9699919799/functions/fork.html">fork</ulink> by <ulink url="http://pubs.opengroup.org/onlinepubs/009695399/functions/vfork.html">vfork</ulink>. <note><para><computeroutput>vfork</computeroutput> is no longer an official part of the posix standard. </para>
</note>
</para></description></data-member>
</namespace>







</namespace>
</namespace>
</header>
<header name="boost/process/search_path.hpp">
<para>Defines a function to search for an executable in path. </para><namespace name="boost">
<namespace name="process">


<function name="search_path"><type>boost::filesystem::path</type><parameter name="filename"><paramtype>const boost::filesystem::path &amp;</paramtype><description><para>The base of the filename to find</para></description></parameter><parameter name="path"><paramtype>const std::vector&lt; boost::filesystem::path &gt;</paramtype><default>::boost::this_process::path()</default><description><para>the set of paths to search, defaults to the "PATH" environment variable.</para></description></parameter><description><para>Searches for an executable in path.</para><para>filename must be a basename including the file extension. It must not include any directory separators (like a slash). On Windows the file extension may be omitted. The function will then try the various file extensions for executables on Windows to find filename.</para><para>

</para></description><returns><para>the absolute path to the executable filename or an empty string if filename isn't found </para>
</returns></function>




</namespace>
</namespace>
</header>
<header name="boost/process/shell.hpp">
<para>Header which provides the shell property. This provides the property to launch a process through the system shell. It also allows the user to obtain the shell-path via shell().  
<programlisting language="c++">
namespace boost {
  namespace process {
    <emphasis>unspecified</emphasis> <globalname alt="boost::process::shell">shell</globalname>;
  }
}
</programlisting>
 </para><namespace name="boost">
<namespace name="process">
<data-member name="shell"><type><emphasis>unspecified</emphasis></type><description><para>The shell property enables to launch a program through the shell of the system.</para><para><programlisting language="c++">system("gcc", shell);
</programlisting></para><para>The shell argument goes without any expression. The operator() is overloaded, to obtain the path of the system shell.</para><para><programlisting language="c++">auto shell_cmd = shell();
//avoid exceptions
std::error_code ec;
shell_cmd = shell(ec);
</programlisting></para><para><note><para>Launching through the shell will NOT provide proper error handling, i.e. you will get an error via the return code.</para>
</note>
<note><para>Executing shell commands that incorporate unsanitized input from an untrusted source makes a program vulnerable to shell injection, a serious security flaw which can result in arbitrary command execution. For this reason, the use of <computeroutput>shell</computeroutput> is strongly discouraged in cases where the command string is constructed from external input: </para>
</note>
</para></description></data-member>







</namespace>
</namespace>
</header>
<header name="boost/process/spawn.hpp">
<para>Defines the spawn function. </para><namespace name="boost">
<namespace name="process">

<function name="spawn"><type>void</type><template>
          <template-nontype-parameter name="Args"><type>typename ...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para>Launch a process and detach it. Returns no handle.</para><para>This function starts a process and immediately detaches it. It thereby prevents the system from creating a zombie process, but will also cause the system to be unable to wait for the child to exit.</para><para><note><para>This will set <computeroutput>SIGCHLD</computeroutput> to <computeroutput>SIGIGN</computeroutput> on posix.</para>
</note>
<warning><para>This function does not allow asynchronous operations, since it cannot wait for the end of the process. It will fail to compile if a reference to <computeroutput>boost::asio::io_context</computeroutput> is passed. </para>
</warning>
</para></description></function>





</namespace>
</namespace>
</header>
<header name="boost/process/start_dir.hpp">
<para>Header which provides the start_dir property, which allows to set the directory the process shall be started in.  
<programlisting language="c++">
namespace boost {
  namespace process {
    <emphasis>unspecified</emphasis> <globalname alt="boost::process::start_dir">start_dir</globalname>;
  }
}
</programlisting>
 </para><namespace name="boost">
<namespace name="process">
<data-member name="start_dir"><type><emphasis>unspecified</emphasis></type><description><para>To set the start dir, the <computeroutput>start_dir</computeroutput> property is provided.</para><para>The valid operations are the following:</para><para><programlisting language="c++">start_dir=path
start_dir(path)
</programlisting></para><para>It can be used with <computeroutput>std::string</computeroutput>, <computeroutput>std::wstring</computeroutput> and <computeroutput>boost::filesystem::path</computeroutput>. </para></description></data-member>







</namespace>
</namespace>
</header>
<header name="boost/process/system.hpp">
<para>Defines a system function. </para><namespace name="boost">
<namespace name="process">
<function name="system"><type>int</type><template>
          <template-nontype-parameter name="Args"><type>typename ...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para>Launches a process and waits for its exit. It works as std::system, though it allows all the properties boost.process provides. It will execute the process and wait for it's exit; then return the exit_code.</para><para><programlisting language="c++">int ret = system("ls");
</programlisting></para><para><note><para>Using this function with synchronous pipes leads to many potential deadlocks.</para>
</note>
When using this function with an asynchronous properties and NOT passing an io_context object, the system function will create one and run it. When the io_context is passed to the function, the system function will check if it is active, and call the io_context::run function if not. </para></description></function>






</namespace>
</namespace>
</header>
<header name="boost/process/windows.hpp">
<para>Header which provides the windows extensions.</para><para> 
<programlisting language="c++">
namespace boost {
  namespace process {
    namespace windows {
      <emphasis>unspecified</emphasis> <globalname alt="boost::process::windows::hide">hide</globalname>;
      <emphasis>unspecified</emphasis> <globalname alt="boost::process::windows::maximized">maximized</globalname>;
      <emphasis>unspecified</emphasis> <globalname alt="boost::process::windows::minimized">minimized</globalname>;
      <emphasis>unspecified</emphasis> <globalname alt="boost::process::windows::minimized_not_active">minimized_not_active</globalname>;
      <emphasis>unspecified</emphasis> <globalname alt="boost::process::windows::not_active">not_active</globalname>;
      <emphasis>unspecified</emphasis> <globalname alt="boost::process::windows::show">show</globalname>;
      <emphasis>unspecified</emphasis> <globalname alt="boost::process::windows::show_normal">show_normal</globalname>;
      <emphasis>unspecified</emphasis> <globalname alt="boost::process::windows::create_no_window">create_no_window</globalname>;
    }
  }
}
</programlisting>
     <warning><para>Only available on windows. See the parameter documentation of <ulink url="https://msdn.microsoft.com/en-us/library/windows/desktop/ms633548.aspx">ShowWindow</ulink> for more details. </para>
</warning>
</para><namespace name="boost">
<namespace name="process">
<namespace name="windows">
<data-member name="hide"><type><emphasis>unspecified</emphasis></type><purpose>Hides the window and activates another window. </purpose></data-member>
<data-member name="maximized"><type><emphasis>unspecified</emphasis></type><purpose>Activates the window and displays it as a maximized window. </purpose></data-member>
<data-member name="minimized"><type><emphasis>unspecified</emphasis></type><purpose>Activates the window and displays it as a minimized window. </purpose></data-member>
<data-member name="minimized_not_active"><type><emphasis>unspecified</emphasis></type><purpose>Displays the window as a minimized window. This value is similar to <computeroutput>minimized</computeroutput>, except the window is not activated. </purpose></data-member>
<data-member name="not_active"><type><emphasis>unspecified</emphasis></type><purpose>Displays a window in its most recent size and position. This value is similar to show_normal`, except that the window is not activated. </purpose></data-member>
<data-member name="show"><type><emphasis>unspecified</emphasis></type><purpose>Activates and displays a window. If the window is minimized or maximized, the system restores it to its original size and position. An application should specify this flag when displaying the window for the first time. </purpose></data-member>
<data-member name="show_normal"><type><emphasis>unspecified</emphasis></type><purpose>Activates and displays a window. If the window is minimized or maximized, the system restores it to its original size and position. An application should specify this flag when displaying the window for the first time. </purpose></data-member>
<data-member name="create_no_window"><type><emphasis>unspecified</emphasis></type><purpose>Adds the <ulink url="https://msdn.microsoft.com/en-us/library/windows/desktop/ms684863(v=vs.85).aspx">CREATE_NO_WINDOW</ulink> flag. </purpose></data-member>
</namespace>







</namespace>
</namespace>
</header>
</library-reference>