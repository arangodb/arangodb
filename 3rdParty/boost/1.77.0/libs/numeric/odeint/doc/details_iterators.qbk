[/============================================================================
  Boost.odeint

  Copyright 2012-2013 Karsten Ahnert
  Copyright 2012-2013 Mario Mulansky
  Copyright 2012 Sylwester Arabas

  Use, modification and distribution is subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]


[section Iterators and Ranges]

[section Examples]

odeint supports iterators that iterate along an approximate solution of an ordinary differential equation. Iterators offer you an alternative to the integrate functions. Furthermore, many of the standard algorithms in the C++ standard library and Boost.Range can be used with the odeint's iterators.

[import ../examples/const_step_iterator.cpp]

Several iterator types are provided, in consistence with the
__integrate_functions. Hence there are `const_step_iterator`,
`adaptive_step_iterator`, `n_step_iterator` and `times_iterator` -- each of
them in two versions: either with only the `state` or with a
`std::pair<state,time>` as value type.  They are all single pass iterators. In
the following, we show a few examples of how to use those iterators together
with std algorithms.

[const_step_iterator_accumulate]

In this example all x-values of the solution are accumulated. Note, how
dereferencing the iterator gives the current state `x` of the ODE (the second
argument of the accumulate lambda). The iterator
itself does not occur directly in this example but it is generated by the
factory functions `make_const_step_iterator_begin` and
`make_const_step_iterator_end`. odeint also supports Boost.Range, that allows
to write the above example in a more compact form with the factory function
`make_const_step_range`, but now using `boost::accumulate` from __bost_range:

[const_step_iterator_accumulate_range]

The second iterator type is also a iterator with const step size. But the value type of this iterator consists here of a pair of the time and the state of the solution of the ODE. An example is

[const_step_time_iterator_accumulate_range]

The factory functions are now `make_const_step_time_iterator_begin`,
`make_const_step_time_iterator_end` and `make_const_step_time_range`.
Note, how the lambda now expects a `std::pair` as this is the value type of
the `const_step_time_iterator`'s.


[import ../examples/adaptive_iterator.cpp]

Next, we discuss the adaptive iterators which are completely
analogous to the const step iterators, but are based on adaptive stepper
routines and thus adjust the step size during the iteration. Examples are

[adaptive_iterator_accumulate_range]

[adaptive_time_iterator_accumulate_range]

[note 'adaptive_iterator` and `adaptive_time_iterator' can only be used with
__controlled_stepper or __dense_output_stepper.]

In general one can say that iterating over a range of a `const_step_iterator`
behaves like an `integrate_const` function call, and similarly for
`adaptive_iterator` and `integrate_adaptive`, `n_step_iterator` and
`integrate_n_steps`, and finally `times_iterator` and `integrate_times`.

Below we list the most important properties of the exisiting iterators:

[endsect]

[section const_step_iterator]

* Definition: `const_step_iterator< Stepper , System , State >`
* `value_type` is `State`
* `reference_type` is `State const&`
* Factory functions
  * `make_const_step_iterator_begin( stepper , system , state , t_start , t_end , dt )`
  * `make_const_step_iterator_end( stepper , system , state )`
  * `make_const_step_range( stepper , system , state , t_start , t_end , dt )`
* This stepper works with all steppers fulfilling the Stepper concept or the DenseOutputStepper concept.
* The value of `state` is the current state of the ODE during the iteration.

[endsect]

[section const_step_time_iterator]

* Definition: `const_step_time_iterator< Stepper , System , State >`
* `value_type` is `std::pair< State , Stepper::time_type >`
* `reference_type` is `std::pair< State const& , Stepper::time_type > const&`
* Factory functions
  * `make_const_step_time_iterator_begin( stepper , system , state , t_start , t_end , dt )`
  * `make_const_step_time_iterator_end( stepper , system , state )`
  * `make_const_step_time_range( stepper , system , state , t_start , t_end , dt )`
* This stepper works with all steppers fulfilling the Stepper concept or the DenseOutputStepper concept.
* This stepper updates the value of `state`. The value of `state` is the current state of the ODE during the iteration.


[endsect]


[section adaptive_step_iterator]

* Definition: `adaptive_iterator< Stepper , System , State >`
* `value_type` is `State`
* `reference_type` is `State const&`
* Factory functions
  * `make_adaptive_iterator_begin( stepper , system , state , t_start , t_end , dt )`
  * `make_adaptive_iterator_end( stepper , system , state )`
  * `make_adaptive_range( stepper , system , state , t_start , t_end , dt )`
* This stepper works with all steppers fulfilling the ControlledStepper concept or the DenseOutputStepper concept.
* For steppers fulfilling the ControlledStepper concept `state` is modified according to the current state of the ODE. For DenseOutputStepper the state is not modified due to performance optimizations, but the steppers itself.


[endsect]

[section adaptive_step_time_iterator]

* Definition: `adaptive_iterator< Stepper , System , State >`
* `value_type` is `std::pair< State , Stepper::time_type >`
* `reference_type` is `std::pair< State const& , Stepper::time_type > const&`
* Factory functions
  * `make_adaptive_time_iterator_begin( stepper , system , state , t_start , t_end , dt )`
  * `make_adaptive_time_iterator_end( stepper , system , state )`
  * `make_adaptive_time_range( stepper , system , state , t_start , t_end , dt )`
* This stepper works with all steppers fulfilling the ControlledStepper concept or the DenseOutputStepper concept.
* For steppers fulfilling the ControlledStepper concept `state` is modified according to the current state of the ODE. For DenseOutputStepper the state is not modified due to performance optimizations, but the stepper itself.


[endsect]


[section n_step_iterator]

* Definition: `n_step_iterator< Stepper , System , State >`
* `value_type` is `State`
* `reference_type` is `State const&`
* Factory functions
  * `make_n_step_iterator_begin( stepper , system , state , t_start , dt , num_of_steps )`
  * `make_n_step_iterator_end( stepper , system , state )`
  * `make_n_step_range( stepper , system , state , t_start , dt , num_of_steps )`
* This stepper works with all steppers fulfilling the Stepper concept or the DenseOutputStepper concept.
* The value of `state` is the current state of the ODE during the iteration.

[endsect]

[section n_step_time_iterator]

* Definition: `n_step_time_iterator< Stepper , System , State >`
* `value_type` is `std::pair< State , Stepper::time_type >`
* `reference_type` is `std::pair< State const& , Stepper::time_type > const&`
* Factory functions
  * `make_n_step_time_iterator_begin( stepper , system , state , t_start , dt , num_of_steps )`
  * `make_n_step_time_iterator_end( stepper , system , state )`
  * `make_n_step_time_range( stepper , system , state , t_start , dt , num_of_steps )`
* This stepper works with all steppers fulfilling the Stepper concept or the DenseOutputStepper concept.
* This stepper updates the value of `state`. The value of `state` is the current state of the ODE during the iteration.


[endsect]


[section times_iterator]

* Definition: `times_iterator< Stepper , System , State , TimeIterator >`
* `value_type` is `State`
* `reference_type` is `State const&`
* Factory functions
  * `make_times_iterator_begin( stepper , system , state , t_start , t_end , dt )`
  * `make_times_iterator_end( stepper , system , state )`
  * `make_times_range( stepper , system , state , t_start , t_end , dt )`
* This stepper works with all steppers fulfilling the Stepper concept, the ControlledStepper concept or the DenseOutputStepper concept.
* The value of `state` is the current state of the ODE during the iteration.

[endsect]

[section times_time_iterator]

* Definition: `times_time_iterator< Stepper , System , State , TimeIterator>`
* `value_type` is `std::pair< State , Stepper::time_type >`
* `reference_type` is `std::pair< State const& , Stepper::time_type > const&`
* Factory functions
  * `make_times_time_iterator_begin( stepper , system , state , t_start , t_end , dt )`
  * `make_times_time_step_iterator_end( stepper , system , state )`
  * `make_times_time_range( stepper , system , state , t_start , t_end , dt )`
* This stepper works with all steppers fulfilling the Stepper concept, the ControlledStepper concept or the DenseOutputStepper concept.
* This stepper updates the value of `state`. The value of `state` is the current state of the ODE during the iteration.

[endsect]


[endsect]
