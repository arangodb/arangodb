////////////////////////////////////////////////////////////////////////////////
/// @brief simple http client
///
/// @file
///
/// DISCLAIMER
///
/// Copyright 2014 ArangoDB GmbH, Cologne, Germany
/// Copyright 2004-2014 triAGENS GmbH, Cologne, Germany
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///
///     http://www.apache.org/licenses/LICENSE-2.0
///
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// Copyright holder is ArangoDB GmbH, Cologne, Germany
///
/// @author Dr. Frank Celler
/// @author Achim Brandt
/// @author Copyright 2014, ArangoDB GmbH, Cologne, Germany
/// @author Copyright 2009-2013, triAGENS GmbH, Cologne, Germany
////////////////////////////////////////////////////////////////////////////////

#ifndef ARANGODB_SIMPLE_HTTP_CLIENT_SIMPLE_HTTP_CLIENT_H
#define ARANGODB_SIMPLE_HTTP_CLIENT_SIMPLE_HTTP_CLIENT_H 1

#include "Basics/Common.h"

#include "Basics/StringBuffer.h"
#include "Basics/logging.h"
#include "Rest/HttpRequest.h"

namespace triagens {
  namespace httpclient {

    class SimpleHttpResult;
    class GeneralClientConnection;

////////////////////////////////////////////////////////////////////////////////
/// @brief simple http client
////////////////////////////////////////////////////////////////////////////////

    class SimpleHttpClient {

    private:
      SimpleHttpClient (SimpleHttpClient const&);
      SimpleHttpClient& operator= (SimpleHttpClient const&);

    public:

////////////////////////////////////////////////////////////////////////////////
/// @brief state of the connection
////////////////////////////////////////////////////////////////////////////////

      enum request_state {
        IN_CONNECT,
        IN_WRITE,
        IN_READ_HEADER,
        IN_READ_BODY,
        IN_READ_CHUNKED_HEADER,
        IN_READ_CHUNKED_BODY,
        FINISHED,
        DEAD
      };

////////////////////////////////////////////////////////////////////////////////
/// @brief constructs a new http client
////////////////////////////////////////////////////////////////////////////////

      SimpleHttpClient (GeneralClientConnection*,
                        double,
                        bool);

////////////////////////////////////////////////////////////////////////////////
/// @brief destructs a http client
////////////////////////////////////////////////////////////////////////////////

      ~SimpleHttpClient ();

////////////////////////////////////////////////////////////////////////////////
/// @brief invalidates the connection used by the client
/// this may be called from other objects that are responsible for managing
/// connections. after this method has been called, the client must not be
/// used for any further HTTP operations, but should be destroyed instantly.
////////////////////////////////////////////////////////////////////////////////

      void invalidateConnection () {
        _connection = nullptr;
      }

////////////////////////////////////////////////////////////////////////////////
/// @brief close connection
////////////////////////////////////////////////////////////////////////////////

      bool close ();

////////////////////////////////////////////////////////////////////////////////
/// @brief leave connection open on destruction
////////////////////////////////////////////////////////////////////////////////

      void keepConnectionOnDestruction (bool b) {
        _keepConnectionOnDestruction = b;
      }

////////////////////////////////////////////////////////////////////////////////
/// @brief make a http request, creating a new HttpResult object
/// the caller has to delete the result object
////////////////////////////////////////////////////////////////////////////////

      SimpleHttpResult* request (rest::HttpRequest::HttpRequestType,
                                 std::string const&,
                                 char const*,
                                 size_t,
                                 std::map<std::string, std::string> const&);

////////////////////////////////////////////////////////////////////////////////
/// @brief sets username and password
///
/// @param prefix                         prefix for sending username and password
/// @param username                       username
/// @param password                       password
////////////////////////////////////////////////////////////////////////////////

      void setUserNamePassword (const std::string& prefix,
                                const std::string& username,
                                const std::string& password);

////////////////////////////////////////////////////////////////////////////////
/// @brief allows rewriting locations
////////////////////////////////////////////////////////////////////////////////

      void setLocationRewriter (void* data,
                                std::string (*func)(void*, const std::string&)) {
        _locationRewriter.data = data;
        _locationRewriter.func = func;
      }

////////////////////////////////////////////////////////////////////////////////
/// @brief enable or disable keep-alive
////////////////////////////////////////////////////////////////////////////////

      void setKeepAlive (bool value) {
        _keepAlive = value;
      }

////////////////////////////////////////////////////////////////////////////////
/// @brief returns the current error message
////////////////////////////////////////////////////////////////////////////////

      const std::string& getErrorMessage () const {
        return _errorMessage;
      }

////////////////////////////////////////////////////////////////////////////////
/// @brief register and dump an error message
////////////////////////////////////////////////////////////////////////////////

      void setErrorMessage (const std::string& message,
                            bool forceWarn = false) {
        _errorMessage = message;

        if (_warn || forceWarn) {
          LOG_WARNING("%s", _errorMessage.c_str());
        }
      }

////////////////////////////////////////////////////////////////////////////////
/// @brief register an error message
////////////////////////////////////////////////////////////////////////////////

      void setErrorMessage (const std::string& message,
                            int error) {
        if (error != TRI_ERROR_NO_ERROR) {
          _errorMessage = message + ": " + strerror(error);
        }
        else {
          setErrorMessage(message);
        }
      }

    private:

////////////////////////////////////////////////////////////////////////////////
/// @brief returns true if the request is in progress
////////////////////////////////////////////////////////////////////////////////

      inline bool isWorking () const {
        return _state < FINISHED;
      }

////////////////////////////////////////////////////////////////////////////////
/// @brief initialise the connection
////////////////////////////////////////////////////////////////////////////////

      void handleConnect ();

////////////////////////////////////////////////////////////////////////////////
/// @brief get timestamp
////////////////////////////////////////////////////////////////////////////////

      static double now () {
        struct timeval tv;
        gettimeofday(&tv, 0);

        double sec = (double) tv.tv_sec; // seconds
        double usc = (double) tv.tv_usec; // microseconds

        return sec + usc / 1000000.0;
      }

////////////////////////////////////////////////////////////////////////////////
/// @brief reset state
////////////////////////////////////////////////////////////////////////////////

      void reset ();

////////////////////////////////////////////////////////////////////////////////
/// @brief rewrite a location URL
////////////////////////////////////////////////////////////////////////////////

      std::string rewriteLocation (std::string const& location) {
        if (_locationRewriter.func != nullptr) {
          return _locationRewriter.func(_locationRewriter.data, location);
        }

        return location;
      }

////////////////////////////////////////////////////////////////////////////////
/// @brief get the result
/// the caller has to delete the result object
////////////////////////////////////////////////////////////////////////////////

      SimpleHttpResult* getResult ();

////////////////////////////////////////////////////////////////////////////////
/// @brief set the request
///
/// @param method                         request method
/// @param location                       request uri
/// @param body                           request body
/// @param bodyLength                     size of body
/// @param headerFields                   list of header fields
////////////////////////////////////////////////////////////////////////////////

      void setRequest (rest::HttpRequest::HttpRequestType method,
                       std::string const& location,
                       char const* body,
                       size_t bodyLength,
                       std::map<std::string, std::string> const& headerFields);

////////////////////////////////////////////////////////////////////////////////
/// @brief read the http header
////////////////////////////////////////////////////////////////////////////////

      void readHeader ();

////////////////////////////////////////////////////////////////////////////////
/// @brief read the http body by content length
////////////////////////////////////////////////////////////////////////////////

      void readBody ();

////////////////////////////////////////////////////////////////////////////////
/// @brief read the chunk size
////////////////////////////////////////////////////////////////////////////////

      void readChunkedHeader ();

////////////////////////////////////////////////////////////////////////////////
/// @brief read the net chunk
////////////////////////////////////////////////////////////////////////////////

      void readChunkedBody ();

    private:

////////////////////////////////////////////////////////////////////////////////
/// @brief connection used (TCP or SSL connection)
////////////////////////////////////////////////////////////////////////////////

      GeneralClientConnection* _connection;

////////////////////////////////////////////////////////////////////////////////
/// @brief flag whether or not we keep the connection on destruction
////////////////////////////////////////////////////////////////////////////////

      bool _keepConnectionOnDestruction;

////////////////////////////////////////////////////////////////////////////////
/// @brief write buffer
////////////////////////////////////////////////////////////////////////////////

      triagens::basics::StringBuffer _writeBuffer;

////////////////////////////////////////////////////////////////////////////////
/// @brief read buffer
////////////////////////////////////////////////////////////////////////////////

      triagens::basics::StringBuffer _readBuffer;

////////////////////////////////////////////////////////////////////////////////
/// @brief read buffer offset
///
/// _state == IN_READ_BODY:
///     points to the beginning of the body
///
/// _state == IN_READ_HEADER:
///     points to the beginning of the next header line
///
/// _state == FINISHED:
///     points to the beginning of the next request
///
/// _state == IN_READ_CHUNKED_HEADER:
///     points to the beginning of the next size line
///
/// _state == IN_READ_CHUNKED_BODY:
///     points to the beginning of the next body
////////////////////////////////////////////////////////////////////////////////

      size_t _readBufferOffset;

      double _requestTimeout;

      bool _warn;

      request_state _state;

      size_t _written;

      std::string _errorMessage;

////////////////////////////////////////////////////////////////////////////////
/// @brief struct for rewriting location URLs
////////////////////////////////////////////////////////////////////////////////

      struct {
        void* data;
        std::string (*func)(void*, const std::string&);
      }
      _locationRewriter;

      uint32_t _nextChunkedSize;

      SimpleHttpResult* _result;

      std::vector<std::pair<std::string, std::string> >_pathToBasicAuth;

      const size_t _maxPacketSize;

      bool _keepAlive;

      rest::HttpRequest::HttpRequestType _method;

    };
  }
}

#endif
// -----------------------------------------------------------------------------
// --SECTION--                                                       END-OF-FILE
// -----------------------------------------------------------------------------

// Local Variables:
// mode: outline-minor
// outline-regexp: "/// @brief\\|/// {@inheritDoc}\\|/// @page\\|// --SECTION--\\|/// @\\}"
// End:
