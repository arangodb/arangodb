{"version":3,"sources":["../../frontend/js/lib/sigma.renderers.halo.js"],"names":["undefined","sigma","Error","intersection","args","argsIndex","argsLength","arguments","length","value","push","array","index","result","outer","indexOf","drawCircles","circles","context","onlyStroke","i","beginPath","arc","x","y","radius","Math","PI","closePath","stroke","fill","halo","params","this","domElements","initDOM","width","container","offsetWidth","height","offsetHeight","insertBefore","firstChild","source","target","cp","sSize","sX","sY","tX","tY","margin","self","contexts","background","webgl","renderers","ePrefix","options","prefix","nPrefix","substr","nHaloClustering","nodeHaloClustering","settings","nHaloClusteringMaxRadius","nodeHaloClusteringMaxRadius","nHaloColor","nodeHaloColor","nHaloSize","nodeHaloSize","nHaloStroke","nodeHaloStroke","nHaloStrokeColor","nodeHaloStrokeColor","nHaloStrokeWidth","nodeHaloStrokeWidth","borderSize","outerBorderSize","eHaloColor","edgeHaloColor","eHaloSize","edgeHaloSize","drawHalo","nodes","edges","nodesOnScreen","edgesOnScreen","clearRect","canvas","save","strokeStyle","forEach","edge","graph","lineWidth","moveTo","type","utils","getSelfLoopControlPoints","bezierCurveTo","x1","y1","x2","y2","getQuadraticControlPoint","cc","quadraticCurveTo","lineTo","fillStyle","filter","node","hidden","map","maxRadius","Number","POSITIVE_INFINITY","centroid","d","points","intersecting","j","getDistance","concat","p","max","apply","point","clusterCircles","restore","prototype","call","window"],"mappings":"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","file":"static/js/18.30fa3eaf.chunk.js","sourcesContent":["/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;\n(function (undefined) {\n  'use strict';\n  /**\n   * Sigma Renderer Halo Utility\n   * ================================\n   *\n   * The aim of this plugin is to display a circled halo behind specified nodes.\n   *\n   * Author: SÃ©bastien Heymann (sheymann) for Linkurious\n   * Version: 0.0.2\n   */\n  // Terminating if sigma were not to be found\n\n  if (typeof sigma === 'undefined') throw new Error('sigma not in scope.');\n  /**\n   * Creates an array of unique values present in all provided arrays using\n   * strict equality for comparisons, i.e. `===`.\n   *\n   * @see lodash\n   * @param {...Array} [array] The arrays to inspect.\n   * @return {Array} Returns an array of shared values.\n   * @example\n   *\n   * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);\n   * // => [1, 2]\n   */\n\n  function intersection() {\n    var args = [],\n        argsIndex = -1,\n        argsLength = arguments.length;\n\n    while (++argsIndex < argsLength) {\n      var value = arguments[argsIndex];\n      args.push(value);\n    }\n\n    var array = args[0],\n        index = -1,\n        length = array ? array.length : 0,\n        result = [];\n\n    outer: while (++index < length) {\n      value = array[index];\n\n      if (result.indexOf(value) < 0) {\n        var argsIndex = argsLength;\n\n        while (--argsIndex) {\n          if (args[argsIndex].indexOf(value) < 0) {\n            continue outer;\n          }\n        }\n\n        result.push(value);\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Draw the specified circles in a given context.\n   *\n   * @param {array}   circles\n   * @param {object}  context\n   * @param {boolean} onlyStroke\n   */\n\n\n  function drawCircles(circles, context, onlyStroke) {\n    for (var i = 0; i < circles.length; i++) {\n      if (circles[i] == null) continue;\n      context.beginPath();\n      context.arc(circles[i].x, circles[i].y, circles[i].radius, 0, Math.PI * 2, true);\n      context.closePath();\n\n      if (onlyStroke) {\n        context.stroke();\n      } else {\n        context.fill();\n      }\n    }\n  }\n  /**\n   * Avoid crossing strokes.\n   *\n   * @see http://vis4.net/blog/posts/clean-your-symbol-maps/\n   * @param {array}  circles    The circles to cluster.\n   * @param {number} margin     The minimal distance between the circle\n   *                            and the points inside it.\n   * @param {?number} maxRadius The max length of a radius\n   * @return {array}            The clustered circles.\n   */\n\n\n  function clusterCircles(circles, margin, maxRadius) {\n    maxRadius = maxRadius || Number.POSITIVE_INFINITY; // console.time('halo cluster');\n\n    if (circles.length > 1) {\n      var intersecting = true,\n          centroid,\n          d,\n          points;\n\n      while (intersecting) {\n        intersecting = false;\n\n        for (var i = 0; i < circles.length; i++) {\n          if (circles[i] === null) continue;\n\n          for (var j = i + 1; j < circles.length; j++) {\n            if (circles[j] === null) continue; // distance between i-1 and i\n\n            d = sigma.utils.getDistance(circles[i].x, circles[i].y, circles[j].x, circles[j].y);\n\n            if (d < maxRadius && d < circles[i].radius + circles[j].radius) {\n              intersecting = true; // Centers of the merged circles:\n\n              points = [{\n                x: circles[i].x,\n                y: circles[i].y,\n                radius: circles[i].radius\n              }, {\n                x: circles[j].x,\n                y: circles[j].y,\n                radius: circles[j].radius\n              }];\n\n              if (circles[i].points) {\n                points = points.concat(circles[i].points);\n              }\n\n              if (circles[j].points) {\n                points = points.concat(circles[j].points);\n              } // Compute the centroid:\n\n\n              centroid = {\n                x: 0,\n                y: 0\n              };\n\n              for (var p = 0; p < points.length; p++) {\n                centroid.x += points[p].x;\n                centroid.y += points[p].y;\n              }\n\n              centroid.x /= points.length;\n              centroid.y /= points.length; // Compute radius:\n\n              centroid.radius = Math.max.apply(null, points.map(function (point) {\n                return margin + sigma.utils.getDistance(centroid.x, centroid.y, point.x, point.y);\n              })); // Merge circles\n\n              circles.push({\n                x: centroid.x,\n                y: centroid.y,\n                radius: centroid.radius,\n                points: points\n              });\n              circles[i] = circles[j] = null;\n              break; // exit for loop\n            }\n          }\n        }\n      }\n    } // console.timeEnd('halo cluster');\n\n\n    return circles;\n  } // Main function\n\n\n  function halo(params) {\n    params = params || {};\n\n    if (!this.domElements['background']) {\n      this.initDOM('canvas', 'background');\n      this.domElements['background'].width = this.container.offsetWidth;\n      this.domElements['background'].height = this.container.offsetHeight;\n      this.container.insertBefore(this.domElements['background'], this.container.firstChild);\n    }\n\n    var self = this,\n        context = self.contexts.background,\n        webgl = this instanceof sigma.renderers.webgl,\n        ePrefix = self.options.prefix,\n        nPrefix = webgl ? ePrefix.substr(5) : ePrefix,\n        nHaloClustering = params.nodeHaloClustering || self.settings('nodeHaloClustering'),\n        nHaloClusteringMaxRadius = params.nodeHaloClusteringMaxRadius || self.settings('nodeHaloClusteringMaxRadius'),\n        nHaloColor = params.nodeHaloColor || self.settings('nodeHaloColor'),\n        nHaloSize = params.nodeHaloSize || self.settings('nodeHaloSize'),\n        nHaloStroke = params.nodeHaloStroke || self.settings('nodeHaloStroke'),\n        nHaloStrokeColor = params.nodeHaloStrokeColor || self.settings('nodeHaloStrokeColor'),\n        nHaloStrokeWidth = params.nodeHaloStrokeWidth || self.settings('nodeHaloStrokeWidth'),\n        borderSize = self.settings('nodeBorderSize') || 0,\n        outerBorderSize = self.settings('nodeOuterBorderSize') || 0,\n        eHaloColor = params.edgeHaloColor || self.settings('edgeHaloColor'),\n        eHaloSize = params.edgeHaloSize || self.settings('edgeHaloSize'),\n        drawHalo = params.drawHalo || self.settings('drawHalo'),\n        nodes = params.nodes || [],\n        edges = params.edges || [],\n        source,\n        target,\n        cp,\n        sSize,\n        sX,\n        sY,\n        tX,\n        tY,\n        margin,\n        circles;\n\n    if (!drawHalo) {\n      return;\n    }\n\n    nodes = webgl ? nodes : intersection(params.nodes, self.nodesOnScreen);\n    edges = webgl ? edges : intersection(params.edges, self.edgesOnScreen); // clear canvas\n\n    context.clearRect(0, 0, context.canvas.width, context.canvas.height);\n    context.save(); // EDGES\n\n    context.strokeStyle = eHaloColor;\n    edges.forEach(function (edge) {\n      source = self.graph.nodes(edge.source);\n      target = self.graph.nodes(edge.target);\n      context.lineWidth = (edge[ePrefix + 'size'] || 1) + eHaloSize;\n      context.beginPath();\n      cp = {};\n      sSize = source[nPrefix + 'size'];\n      sX = source[nPrefix + 'x'];\n      sY = source[nPrefix + 'y'];\n      tX = target[nPrefix + 'x'];\n      tY = target[nPrefix + 'y'];\n      context.moveTo(sX, sY);\n\n      if (edge.type === 'curve' || edge.type === 'curvedArrow') {\n        if (edge.source === edge.target) {\n          cp = sigma.utils.getSelfLoopControlPoints(sX, sY, sSize);\n          context.bezierCurveTo(cp.x1, cp.y1, cp.x2, cp.y2, tX, tY);\n        } else {\n          cp = sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY, edge.cc);\n          context.quadraticCurveTo(cp.x, cp.y, tX, tY);\n        }\n      } else {\n        context.moveTo(sX, sY);\n        context.lineTo(tX, tY);\n      }\n\n      context.stroke();\n      context.closePath();\n    }); // NODES\n\n    context.fillStyle = nHaloColor;\n\n    if (nHaloStroke) {\n      context.lineWidth = nHaloStrokeWidth;\n      context.strokeStyle = nHaloStrokeColor;\n    }\n\n    margin = borderSize + outerBorderSize + nHaloSize;\n    circles = nodes.filter(function (node) {\n      return !node.hidden;\n    }).map(function (node) {\n      return {\n        x: node[nPrefix + 'x'],\n        y: node[nPrefix + 'y'],\n        radius: node[nPrefix + 'size'] + margin\n      };\n    });\n\n    if (nHaloClustering) {\n      // Avoid crossing strokes:\n      circles = clusterCircles(circles, margin, nHaloClusteringMaxRadius);\n    }\n\n    if (nHaloStroke) {\n      drawCircles(circles, context, true);\n    }\n\n    drawCircles(circles, context);\n    context.restore();\n  } // Extending canvas and webl renderers\n\n\n  sigma.renderers.canvas.prototype.halo = halo;\n  sigma.renderers.webgl.prototype.halo = halo; // TODO clear scene?\n}).call(this);\n}.call(window));"],"sourceRoot":""}