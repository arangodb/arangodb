{"version":3,"sources":["../../frontend/js/lib/sigma.canvas.edges.autoCurve.js"],"names":["sigma","utils","pkg","canvas","edges","autoCurve","s","key","ratio","settings","sortByDirection","defaultEdgeType","graph","count","o","source","target","this","i","n","inc","forEach","edge","cc","type","cc_prev_type","d","y","Number","POSITIVE_INFINITY","calc","undefined","call","window"],"mappings":"4EACA,YAIA,WACA,aAEAA,MAAAC,MAAAC,IAAA,sBA6BAF,MAAAG,OAAAC,MAAAC,UAAA,SAAAC,GACA,IAAAC,EACAC,EAAAF,EAAAG,SAAA,kBACAC,EAAAJ,EAAAG,SAAA,4BACAE,EAAAL,EAAAG,SAAA,mBACAL,EAAAE,EAAAM,MAAAR,QACAS,EAAA,CACAN,IAAA,SAAAO,GACA,IAAAP,EAAAO,EAAAC,OAAA,IAAAD,EAAAE,OAEA,OAAAC,KAAAV,GACAA,GAGAG,IACAH,EAAAO,EAAAE,OAAA,IAAAF,EAAAC,OAEAE,KAAAV,IACAA,GAIAG,GAAAO,KAAAH,EAAAE,OAAA,IAAAF,EAAAC,QAEAE,KAAAV,GAAA,CACAW,EAAA,EACAC,EAAA,GAGAF,KAAAV,GAAA,CACAW,EAAA,EACAC,EAAA,GAIAZ,IAEAa,IAAA,SAAAN,GAEAG,UAAAV,IAAAO,IAAAK,MAGAf,EAAAiB,QAAA,SAAAC,GACAT,EAAAO,IAAAE,KAEAlB,EAAAiB,QAAA,SAAAC,GACAf,EAAAM,EAAAN,IAAAe,GAEAT,EAAAN,GAAAY,EAAA,GAAAN,EAAAN,GAAAW,EAAA,GACAI,EAAAC,KAEA,UAAAD,EAAAE,MAAA,YAAAF,EAAAE,MAAA,UAAAb,GAAA,YAAAA,GACAW,EAAAG,eACAH,EAAAG,aAAAH,EAAAE,MAGAF,EAAAE,KAAA,gBAEAF,EAAAG,eACAH,EAAAG,aAAAH,EAAAE,MAGAF,EAAAE,KAAA,UAKAF,EAAAC,GA9FA,SAAAf,EAAAW,EAAAD,EAAAR,GAGA,IAOAgB,EATA,OAAAhB,EAGA,CACAiB,GAFAD,EAAAlB,EAAAW,EAAAD,IAEAU,OAAAC,mBAMA,CACAF,GAFAD,EAAAlB,EADAA,GAAAW,EAAA,GACAD,GAEA,EAAAQ,EAAAP,GAkFAW,CAAAtB,EAAAK,EAAAN,GAAAY,EAAAN,EAAAN,GAAAW,IAAAR,IACOY,EAAAC,KAEPD,EAAAE,KAAAF,EAAAG,aACAH,EAAAG,kBAAAM,EACAT,EAAAC,QAAAQ,MAxGA,KA6GCC,KAAAC","file":"static/js/2.2f2b6600.chunk.js","sourcesContent":["/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;\n\n(function () {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edges');\n\n  var calc = function calc(ratio, n, i, sortByDirection) {\n    if (sortByDirection) {\n      // sort edges by direction:\n      var d = ratio * n / i;\n      return {\n        y: d ? d : Number.POSITIVE_INFINITY\n      };\n    }\n\n    var step = ratio / (n / 2);\n    var d = ratio - step * i;\n    return {\n      y: d ? 1 / d : n\n    };\n  };\n  /**\n   * Curves multiple edges between two nodes (i.e. \"parallel edges\").\n   * This method is not a renderer. It should be called after modification\n   * of the graph structure.\n   * Time complexity: 2 * O(|E|)\n   *\n   * Settings: autoCurveRatio, autoCurveSortByDirection\n   *\n   * @param {object} s The sigma instance\n   */\n\n\n  sigma.canvas.edges.autoCurve = function (s) {\n    var key,\n        ratio = s.settings('autoCurveRatio'),\n        sortByDirection = s.settings('autoCurveSortByDirection'),\n        defaultEdgeType = s.settings('defaultEdgeType'),\n        edges = s.graph.edges();\n    var count = {\n      key: function key(o) {\n        var key = o.source + ',' + o.target;\n\n        if (this[key]) {\n          return key;\n        }\n\n        if (!sortByDirection) {\n          key = o.target + ',' + o.source;\n\n          if (this[key]) {\n            return key;\n          }\n        }\n\n        if (sortByDirection && this[o.target + ',' + o.source]) {\n          // count a parallel edge if an opposite edge exists\n          this[key] = {\n            i: 1,\n            n: 1\n          };\n        } else {\n          this[key] = {\n            i: 0,\n            n: 0\n          };\n        }\n\n        return key;\n      },\n      inc: function inc(o) {\n        // number of edges parallel to this one (included)\n        this[this.key(o)].n++;\n      }\n    };\n    edges.forEach(function (edge) {\n      count.inc(edge);\n    });\n    edges.forEach(function (edge) {\n      key = count.key(edge); // if the edge has parallel edges:\n\n      if (count[key].n > 1 || count[key].i > 0) {\n        if (!edge.cc) {\n          // update edge type:\n          if (edge.type === 'arrow' || edge.type === 'tapered' || defaultEdgeType === 'arrow' || defaultEdgeType === 'tapered') {\n            if (!edge.cc_prev_type) {\n              edge.cc_prev_type = edge.type;\n            }\n\n            edge.type = 'curvedArrow';\n          } else {\n            if (!edge.cc_prev_type) {\n              edge.cc_prev_type = edge.type;\n            }\n\n            edge.type = 'curve';\n          }\n        } // curvature coefficients\n\n\n        edge.cc = calc(ratio, count[key].n, count[key].i++, sortByDirection);\n      } else if (edge.cc) {\n        // the edge is no longer a parallel edge\n        edge.type = edge.cc_prev_type;\n        edge.cc_prev_type = undefined;\n        edge.cc = undefined;\n      }\n    });\n  };\n})();\n}.call(window));"],"sourceRoot":""}