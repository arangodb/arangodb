{"version":3,"sources":["../../frontend/js/lib/sigma.canvas.edges.labels.curve.js"],"names":["undefined","sigma","utils","pkg","canvas","edges","labels","curve","edge","source","target","context","settings","label","prefix","size","fontSize","c","angle","sSize","sX","sY","tX","tY","dX","dY","sign","cp","id","getSelfLoopControlPoints","getPointOnBezierCurve","x1","y1","x2","y2","Math","atan2","getQuadraticControlPoint","getPointOnQuadraticCurve","x","y","pow","save","active","font","join","fillStyle","active_color","color","textAlign","textBaseline","translate","rotate","fillText","restore","call","this","window"],"mappings":"4EACA,YAGA,SAAAA,GACA,aAEA,wBAAAC,MAAA,6BAEAA,MAAAC,MAAAC,IAAA,6BAaAF,MAAAG,OAAAC,MAAAC,OAAAC,MAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACA,qBAAAJ,EAAAK,MAAA,CACA,IAAAC,EAAAF,EAAA,cACAG,EAAAP,EAAAM,EAAA,WACA,KAAAC,EAAAH,EAAA,wBACA,IAAAI,EAUAC,EACAC,EAVAC,EAAAV,EAAAK,EAAA,QACAM,EAAAX,EAAAK,EAAA,KACAO,EAAAZ,EAAAK,EAAA,KACAQ,EAAAZ,EAAAI,EAAA,KACAS,EAAAb,EAAAI,EAAA,KACAU,EAAAF,EAAAF,EACAK,EAAAF,EAAAF,EACAK,EAAAN,EAAAE,EAAA,KACAK,EAAA,GAKAlB,EAAAmB,KAAAlB,EAAAkB,IACAD,EAAA1B,MAAAC,MAAA2B,yBAAAT,EAAAC,EAAAF,GACAF,EAAAhB,MAAAC,MAAA4B,sBAJA,GAIAV,EAAAC,EAAAC,EAAAC,EAAAI,EAAAI,GAAAJ,EAAAK,GAAAL,EAAAM,GAAAN,EAAAO,IACAhB,EAAAiB,KAAAC,MAAA,OAEAT,EAAA1B,MAAAC,MAAAmC,yBAAAjB,EAAAC,EAAAC,EAAAC,GACAN,EAAAhB,MAAAC,MAAAoC,yBARA,GAQAlB,EAAAC,EAAAC,EAAAC,EAAAI,EAAAY,EAAAZ,EAAAa,GACAtB,EAAAiB,KAAAC,MAAAX,EAAAC,EAAAF,EAAAE,IAUAV,EAAA,UAAAJ,EAAA,iBAAAA,EAAA,wBAAAA,EAAA,wBAAAG,EAAAoB,KAAAM,IAAA1B,GAAA,EAAAH,EAAA,0BACAD,EAAA+B,OAEAlC,EAAAmC,QACAhC,EAAAiC,KAAA,CAAAhC,EAAA,mBAAAI,EAAA,KAAAJ,EAAA,eAAAA,EAAA,SAAAiC,KAAA,KACAlC,EAAAmC,UAAA,SAAAlC,EAAA,mBAAAJ,EAAAuC,cAAAnC,EAAA,0BAAAA,EAAA,iCAEAD,EAAAiC,KAAA,CAAAhC,EAAA,aAAAI,EAAA,KAAAJ,EAAA,SAAAiC,KAAA,KACAlC,EAAAmC,UAAA,SAAAlC,EAAA,kBAAAJ,EAAAwC,OAAApC,EAAA,oBAAAA,EAAA,0BAGAD,EAAAsC,UAAA,SACAtC,EAAAuC,aAAA,aACAvC,EAAAwC,UAAAlC,EAAAsB,EAAAtB,EAAAuB,GACA7B,EAAAyC,OAAAlC,GACAP,EAAA0C,SAAA7C,EAAAK,MAAA,GAAAE,EAAA,KACAJ,EAAA2C,eAECC,KAAAC,QACAD,KAAAE","file":"static/js/6.c17b1ae5.chunk.js","sourcesContent":["/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;\n(function (undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined') throw 'sigma is not declared'; // Initialize packages:\n\n  sigma.utils.pkg('sigma.canvas.edges.labels');\n  /**\n   * This label renderer will just display the label on the curve of the edge.\n   * The label is rendered at half distance of the edge extremities, and is\n   * always oriented from left to right on the top side of the curve.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n\n  sigma.canvas.edges.labels.curve = function (edge, source, target, context, settings) {\n    if (typeof edge.label !== 'string') return;\n    var prefix = settings('prefix') || '',\n        size = edge[prefix + 'size'] || 1;\n    if (size < settings('edgeLabelThreshold')) return;\n    var fontSize,\n        sSize = source[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'],\n        dX = tX - sX,\n        dY = tY - sY,\n        sign = sX < tX ? 1 : -1,\n        cp = {},\n        c,\n        angle,\n        t = 0.5; //length of the curve\n\n    if (source.id === target.id) {\n      cp = sigma.utils.getSelfLoopControlPoints(sX, sY, sSize);\n      c = sigma.utils.getPointOnBezierCurve(t, sX, sY, tX, tY, cp.x1, cp.y1, cp.x2, cp.y2);\n      angle = Math.atan2(1, 1); // 45Â°\n    } else {\n      cp = sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY);\n      c = sigma.utils.getPointOnQuadraticCurve(t, sX, sY, tX, tY, cp.x, cp.y);\n      angle = Math.atan2(dY * sign, dX * sign);\n    } // The font size is sublineraly proportional to the edge size, in order to\n    // avoid very large labels on screen.\n    // This is achieved by f(x) = x * x^(-1/ a), where 'x' is the size and 'a'\n    // is the edgeLabelSizePowRatio. Notice that f(1) = 1.\n    // The final form is:\n    // f'(x) = b * x * x^(-1 / a), thus f'(1) = b. Application:\n    // fontSize = defaultEdgeLabelSize if edgeLabelSizePowRatio = 1\n\n\n    fontSize = settings('edgeLabelSize') === 'fixed' ? settings('defaultEdgeLabelSize') : settings('defaultEdgeLabelSize') * size * Math.pow(size, -1 / settings('edgeLabelSizePowRatio'));\n    context.save();\n\n    if (edge.active) {\n      context.font = [settings('activeFontStyle'), fontSize + 'px', settings('activeFont') || settings('font')].join(' ');\n      context.fillStyle = settings('edgeActiveColor') === 'edge' ? edge.active_color || settings('defaultEdgeActiveColor') : settings('defaultEdgeLabelActiveColor');\n    } else {\n      context.font = [settings('fontStyle'), fontSize + 'px', settings('font')].join(' ');\n      context.fillStyle = settings('edgeLabelColor') === 'edge' ? edge.color || settings('defaultEdgeColor') : settings('defaultEdgeLabelColor');\n    }\n\n    context.textAlign = 'center';\n    context.textBaseline = 'alphabetic';\n    context.translate(c.x, c.y);\n    context.rotate(angle);\n    context.fillText(edge.label, 0, -size / 2 - 3);\n    context.restore();\n  };\n}).call(this);\n}.call(window));"],"sourceRoot":""}