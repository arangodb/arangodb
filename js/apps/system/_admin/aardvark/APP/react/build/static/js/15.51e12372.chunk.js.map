{"version":3,"sources":["../../frontend/js/lib/sigma.plugins.filter.js"],"names":["undefined","sigma","utils","pkg","classes","graph","hasMethod","addMethod","id","target","nodes","this","allNeighborsIndex","push","nodesIndex","eid","a","edges","_g","_s","_chain","_keysIndex","Object","create","Processors","register","fn","p","key","toString","length","processor","predicate","unregister","o","filter","Filter","s","deepCopy","copy","i","eval","cloneChain","chain","slice","len","name","n","ln","e","le","hidden","call","source","neighbors","adjacentNodes","nn","no","prototype","nodesBy","edgesBy","neighborsOf","apply","shift","refresh","undo","v","q","la","arguments","clear","unshift","export","import","plugins","window"],"mappings":"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","file":"static/js/15.51e12372.chunk.js","sourcesContent":["/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;\n(function (undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined') throw 'sigma is not declared'; // Initialize package:\n\n  sigma.utils.pkg('sigma.plugins'); // Add custom graph methods:\n\n  /**\n   * This methods returns an array of nodes that are adjacent to a node.\n   *\n   * @param  {string} id The node id.\n   * @return {array}     The array of adjacent nodes.\n   */\n\n  if (!sigma.classes.graph.hasMethod('adjacentNodes')) sigma.classes.graph.addMethod('adjacentNodes', function (id) {\n    if (typeof id !== 'string') throw 'adjacentNodes: the node id must be a string.';\n    var target,\n        nodes = [];\n\n    for (target in this.allNeighborsIndex[id]) {\n      nodes.push(this.nodesIndex[target]);\n    }\n\n    return nodes;\n  });\n  /**\n   * This methods returns an array of edges that are adjacent to a node.\n   *\n   * @param  {string} id The node id.\n   * @return {array}     The array of adjacent edges.\n   */\n\n  if (!sigma.classes.graph.hasMethod('adjacentEdges')) sigma.classes.graph.addMethod('adjacentEdges', function (id) {\n    if (typeof id !== 'string') throw 'adjacentEdges: the node id must be a string.';\n    var a = this.allNeighborsIndex[id],\n        eid,\n        target,\n        edges = [];\n\n    for (target in a) {\n      for (eid in a[target]) {\n        edges.push(a[target][eid]);\n      }\n    }\n\n    return edges;\n  });\n  /**\n   * Sigma Filter\n   * =============================\n   *\n   * @author SÃ©bastien Heymann <seb@linkurio.us> (Linkurious)\n   * @version 0.1\n   */\n\n  var _g = undefined,\n      _s = undefined,\n      _chain = [],\n      // chain of wrapped filters\n  _keysIndex = Object.create(null),\n      Processors = {}; // available predicate processors\n\n  /**\n   * Library of processors\n   * ------------------\n   */\n\n  /**\n   *\n   * @param  {function} fn The predicate.\n   */\n\n\n  Processors.nodes = function nodes(fn) {\n    var n = _g.nodes(),\n        ln = n.length,\n        e = _g.edges(),\n        le = e.length; // hide node, or keep former value\n\n\n    while (ln--) {\n      n[ln].hidden = !fn.call(_g, n[ln]) || n[ln].hidden;\n    }\n\n    while (le--) {\n      if (_g.nodes(e[le].source).hidden || _g.nodes(e[le].target).hidden) e[le].hidden = true;\n    }\n  };\n  /**\n   *\n   * @param  {function} fn The predicate.\n   */\n\n\n  Processors.edges = function edges(fn) {\n    var e = _g.edges(),\n        le = e.length; // hide edge, or keep former value\n\n\n    while (le--) {\n      e[le].hidden = !fn.call(_g, e[le]) || e[le].hidden;\n    }\n  };\n  /**\n   *\n   * @param  {string} id The center node.\n   */\n\n\n  Processors.neighbors = function neighbors(id) {\n    var n = _g.nodes(),\n        ln = n.length,\n        e = _g.edges(),\n        le = e.length,\n        neighbors = _g.adjacentNodes(id),\n        nn = neighbors.length,\n        no = {};\n\n    while (nn--) {\n      no[neighbors[nn].id] = true;\n    }\n\n    while (ln--) {\n      if (n[ln].id !== id && !(n[ln].id in no)) n[ln].hidden = true;\n    }\n\n    while (le--) {\n      if (_g.nodes(e[le].source).hidden || _g.nodes(e[le].target).hidden) e[le].hidden = true;\n    }\n  };\n  /**\n   * This function adds a filter to the chain of filters.\n   *\n   * @param  {function} fn  The filter (i.e. predicate processor).\n   * @param  {function} p   The predicate.\n   * @param  {?string}  key The key to identify the filter.\n   */\n\n\n  function register(fn, p, key) {\n    if (key != undefined && typeof key !== 'string') throw 'The filter key \"' + key.toString() + '\" must be a string.';\n    if (key != undefined && !key.length) throw 'The filter key must be a non-empty string.';\n    if (typeof fn !== 'function') throw 'The predicate of key \"' + key + '\" must be a function.';\n    if ('undo' === key) throw '\"undo\" is a reserved key.';\n    if (_keysIndex[key]) throw 'The filter \"' + key + '\" already exists.';\n    if (key) _keysIndex[key] = true;\n\n    _chain.push({\n      'key': key,\n      'processor': fn,\n      'predicate': p\n    });\n  }\n\n  ;\n  /**\n   * This function removes a set of filters from the chain.\n   *\n   * @param {object} o The filter keys.\n   */\n\n  function unregister(o) {\n    _chain = _chain.filter(function (a) {\n      return !(a.key in o);\n    });\n\n    for (var key in o) {\n      delete _keysIndex[key];\n    }\n  }\n\n  ;\n  /**\n   * Filter Object\n   * ------------------\n   * @param  {sigma} s The related sigma instance.\n   */\n\n  function Filter(s) {\n    _s = s;\n    _g = s.graph;\n  }\n\n  ;\n  /**\n   * This method is used to filter the nodes. The method must be called with\n   * the predicate, which is a function that takes a node as argument and\n   * returns a boolean. It may take an identifier as argument to undo the\n   * filter later. The method wraps the predicate into an anonymous function\n   * that looks through each node in the graph. When executed, the anonymous\n   * function hides the nodes that fail a truth test (predicate). The method\n   * adds the anonymous function to the chain of filters. The filter is not\n   * executed until the apply() method is called.\n   *\n   * > var filter = new sigma.plugins.filter(s);\n   * > filter.nodesBy(function(n) {\n   * >   return this.degree(n.id) > 0;\n   * > }, 'degreeNotNull');\n   *\n   * @param  {function}             fn  The filter predicate.\n   * @param  {?string}              key The key to identify the filter.\n   * @return {sigma.plugins.filter}     Returns the instance.\n   */\n\n  Filter.prototype.nodesBy = function (fn, key) {\n    // Wrap the predicate to be applied on the graph and add it to the chain.\n    register(Processors.nodes, fn, key);\n    return this;\n  };\n  /**\n   * This method is used to filter the edges. The method must be called with\n   * the predicate, which is a function that takes a node as argument and\n   * returns a boolean. It may take an identifier as argument to undo the\n   * filter later. The method wraps the predicate into an anonymous function\n   * that looks through each edge in the graph. When executed, the anonymous\n   * function hides the edges that fail a truth test (predicate). The method\n   * adds the anonymous function to the chain of filters. The filter is not\n   * executed until the apply() method is called.\n   *\n   * > var filter = new sigma.plugins.filter(s);\n   * > filter.edgesBy(function(e) {\n   * >   return e.size > 1;\n   * > }, 'edgeSize');\n   *\n   * @param  {function}             fn  The filter predicate.\n   * @param  {?string}              key The key to identify the filter.\n   * @return {sigma.plugins.filter}     Returns the instance.\n   */\n\n\n  Filter.prototype.edgesBy = function (fn, key) {\n    // Wrap the predicate to be applied on the graph and add it to the chain.\n    register(Processors.edges, fn, key);\n    return this;\n  };\n  /**\n   * This method is used to filter the nodes which are not direct connections\n   * of a given node. The method must be called with the node identifier. It\n   * may take an identifier as argument to undo the filter later. The filter\n   * is not executed until the apply() method is called.\n   *\n   * > var filter = new sigma.plugins.filter(s);\n   * > filter.neighborsOf('n0');\n   *\n   * @param  {string}               id  The node id.\n   * @param  {?string}              key The key to identify the filter.\n   * @return {sigma.plugins.filter}     Returns the instance.\n   */\n\n\n  Filter.prototype.neighborsOf = function (id, key) {\n    if (typeof id !== 'string') throw 'The node id \"' + id.toString() + '\" must be a string.';\n    if (!id.length) throw 'The node id must be a non-empty string.'; // Wrap the predicate to be applied on the graph and add it to the chain.\n\n    register(Processors.neighbors, id, key);\n    return this;\n  };\n  /**\n   * This method is used to execute the chain of filters and to refresh the\n   * display.\n   *\n   * > var filter = new sigma.plugins.filter(s);\n   * > filter\n   * >   .nodesBy(function(n) {\n   * >     return this.degree(n.id) > 0;\n   * >   }, 'degreeNotNull')\n   * >   .apply();\n   *\n   * @return {sigma.plugins.filter}      Returns the instance.\n   */\n\n\n  Filter.prototype.apply = function () {\n    for (var i = 0, len = _chain.length; i < len; ++i) {\n      _chain[i].processor(_chain[i].predicate);\n    }\n\n    ;\n\n    if (_chain[0] && 'undo' === _chain[0].key) {\n      _chain.shift();\n    }\n\n    _s.refresh();\n\n    return this;\n  };\n  /**\n   * This method undoes one or several filters, depending on how it is called.\n   *\n   * To undo all filters, call \"undo\" without argument. To undo a specific\n   * filter, call it with the key of the filter. To undo multiple filters, call\n   * it with an array of keys or multiple arguments, and it will undo each\n   * filter, in the same order. The undo is not executed until the apply()\n   * method is called. For instance:\n   *\n   * > var filter = new sigma.plugins.filter(s);\n   * > filter\n   * >   .nodesBy(function(n) {\n   * >     return this.degree(n.id) > 0;\n   * >   }, 'degreeNotNull');\n   * >   .edgesBy(function(e) {\n   * >     return e.size > 1;\n   * >   }, 'edgeSize')\n   * >   .undo();\n   *\n   * Other examples:\n   * > filter.undo();\n   * > filter.undo('myfilter');\n   * > filter.undo(['myfilter1', 'myfilter2']);\n   * > filter.undo('myfilter1', 'myfilter2');\n   *\n   * @param  {?(string|array|*string))} v Eventually one key, an array of keys.\n   * @return {sigma.plugins.filter}       Returns the instance.\n   */\n\n\n  Filter.prototype.undo = function (v) {\n    var q = Object.create(null),\n        la = arguments.length; // find removable filters\n\n    if (la === 1) {\n      if (Object.prototype.toString.call(v) === '[object Array]') for (var i = 0, len = v.length; i < len; i++) {\n        q[v[i]] = true;\n      } else // 1 filter key\n        q[v] = true;\n    } else if (la > 1) {\n      for (var i = 0; i < la; i++) {\n        q[arguments[i]] = true;\n      }\n    } else this.clear();\n\n    unregister(q);\n\n    function processor() {\n      var n = _g.nodes(),\n          ln = n.length,\n          e = _g.edges(),\n          le = e.length;\n\n      while (ln--) {\n        n[ln].hidden = false;\n      }\n\n      while (le--) {\n        e[le].hidden = false;\n      }\n    }\n\n    ;\n\n    _chain.unshift({\n      'key': 'undo',\n      'processor': processor\n    });\n\n    return this;\n  }; // fast deep copy function\n\n\n  function deepCopy(o) {\n    var copy = Object.create(null);\n\n    for (var i in o) {\n      if (typeof o[i] === \"object\" && o[i] !== null) {\n        copy[i] = deepCopy(o[i]);\n      } else if (typeof o[i] === \"function\" && o[i] !== null) {\n        // clone function:\n        eval(\" copy[i] = \" + o[i].toString()); //copy[i] = o[i].bind(_g);\n      } else copy[i] = o[i];\n    }\n\n    return copy;\n  }\n\n  ;\n\n  function cloneChain(chain) {\n    // Clone the array of filters:\n    var copy = chain.slice(0);\n\n    for (var i = 0, len = copy.length; i < len; i++) {\n      copy[i] = deepCopy(copy[i]);\n      if (typeof copy[i].processor === \"function\") copy[i].processor = 'filter.processors.' + copy[i].processor.name;\n    }\n\n    ;\n    return copy;\n  }\n  /**\n   * This method is used to empty the chain of filters.\n   * Prefer the undo() method to reset filters.\n   *\n   * > var filter = new sigma.plugins.filter(s);\n   * > filter.clear();\n   *\n   * @return {sigma.plugins.filter} Returns the instance.\n   */\n\n\n  Filter.prototype.clear = function () {\n    _chain.length = 0; // clear the array\n\n    _keysIndex = Object.create(null);\n    return this;\n  };\n  /**\n   * This method clones the filter chain and return the copy.\n   *\n   * > var filter = new sigma.plugins.filter(s);\n   * > var chain = filter.export();\n   *\n   * @return {object}   The cloned chain of filters.\n   */\n\n\n  Filter.prototype.export = function () {\n    var c = cloneChain(_chain);\n    return c;\n  };\n  /**\n   * This method sets the chain of filters with the specified chain.\n   *\n   * > var filter = new sigma.plugins.filter(s);\n   * > var chain = [\n   * >   {\n   * >     key: 'my-filter',\n   * >     predicate: function(n) {...},\n   * >     processor: 'filter.processors.nodes'\n   * >   }, ...\n   * > ];\n   * > filter.import(chain);\n   *\n   * @param {array} chain The chain of filters.\n   * @return {sigma.plugins.filter} Returns the instance.\n   */\n\n\n  Filter.prototype.import = function (chain) {\n    if (chain === undefined) throw 'Wrong arguments.';\n    if (Object.prototype.toString.call(chain) !== '[object Array]') throw 'The chain\" must be an array.';\n    var copy = cloneChain(chain);\n\n    for (var i = 0, len = copy.length; i < len; i++) {\n      if (copy[i].predicate === undefined || copy[i].processor === undefined) throw 'Wrong arguments.';\n      if (copy[i].key != undefined && typeof copy[i].key !== 'string') throw 'The filter key \"' + copy[i].key.toString() + '\" must be a string.';\n      if (typeof copy[i].predicate !== 'function') throw 'The predicate of key \"' + copy[i].key + '\" must be a function.';\n      if (typeof copy[i].processor !== 'string') throw 'The processor of key \"' + copy[i].key + '\" must be a string.'; // Replace the processor name by the corresponding function:\n\n      switch (copy[i].processor) {\n        case 'filter.processors.nodes':\n          copy[i].processor = Processors.nodes;\n          break;\n\n        case 'filter.processors.edges':\n          copy[i].processor = Processors.edges;\n          break;\n\n        case 'filter.processors.neighbors':\n          copy[i].processor = Processors.neighbors;\n          break;\n\n        default:\n          throw 'Unknown processor ' + copy[i].processor;\n      }\n    }\n\n    ;\n    _chain = copy;\n    return this;\n  };\n  /**\n   * Interface\n   * ------------------\n   *\n   * > var filter = new sigma.plugins.filter(s);\n   */\n\n\n  var filter = null;\n  /**\n   * @param  {sigma} s The related sigma instance.\n   */\n\n  sigma.plugins.filter = function (s) {\n    // Create filter if undefined\n    if (!filter) {\n      filter = new Filter(s);\n    }\n\n    return filter;\n  };\n}).call(this);\n}.call(window));"],"sourceRoot":""}