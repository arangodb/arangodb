{"version":3,"sources":["../../frontend/js/lib/jquery.csv.min.js"],"names":["RegExp","escape","s","replace","undefined","$","jQuery","csv","defaults","separator","delimiter","headers","hooks","castToScalar","value","state","isNaN","test","parseFloat","integer","parseInt","parsers","parse","options","rowNum","colNum","data","entry","exit","endOfEntry","start","onParseEntry","push","hookVal","end","endOfValue","onParseValue","hook","escSeparator","escDelimiter","match","matchSrc","source","m0","Error","length","splitLines","entries","endOfLine","prevChar","substr","parseEntry","helpers","collectPropertyNames","objects","o","propName","props","hasOwnProperty","indexOf","toArray","callback","config","toArrays","onPreParse","onPostParse","toObjects","lines","transform","headerOptions","headerLine","i","len","object","j","call","fromArrays","arrays","line","lineValues","output","strValue","toString","escMatcher","search","join","fromObjects","sortOrder","manualOrder","origObjects","sort","propsManual","concat","p","csvEntry2Array","csv2Array","csv2Dictionary","module","exports","this"],"mappings":"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","file":"static/js/19.c751e993.chunk.js","sourcesContent":["/**\n * jQuery-csv (jQuery Plugin)\n *\n * This document is licensed as free software under the terms of the\n * MIT License: http://www.opensource.org/licenses/mit-license.php\n *\n * Acknowledgements:\n * The original design and influence to implement this library as a jquery\n * plugin is influenced by jquery-json (http://code.google.com/p/jquery-json/).\n * If you're looking to use native JSON.Stringify but want additional backwards\n * compatibility for browsers that don't support it, I highly recommend you\n * check it out.\n *\n * A special thanks goes out to rwk@acm.org for providing a lot of valuable\n * feedback to the project including the core for the new FSM\n * (Finite State Machine) parsers. If you're looking for a stable TSV parser\n * be sure to take a look at jquery-tsv (http://code.google.com/p/jquery-tsv/).\n\n * For legal purposes I'll include the \"NO WARRANTY EXPRESSED OR IMPLIED.\n * USE AT YOUR OWN RISK.\". Which, in 'layman's terms' means, by using this\n * library you are accepting responsibility if it breaks your code.\n *\n * Legal jargon aside, I will do my best to provide a useful and stable core\n * that can effectively be built on.\n *\n * Copyrighted 2012 by Evan Plaice.\n */\nRegExp.escape = function (s) {\n  return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n};\n\n(function (undefined) {\n  'use strict';\n\n  var $; // to keep backwards compatibility\n\n  if (typeof jQuery !== 'undefined' && jQuery) {\n    $ = jQuery;\n  } else {\n    $ = {};\n  }\n  /**\n   * jQuery.csv.defaults\n   * Encapsulates the method paramater defaults for the CSV plugin module.\n   */\n\n\n  $.csv = {\n    defaults: {\n      separator: ',',\n      delimiter: '\"',\n      headers: true\n    },\n    hooks: {\n      castToScalar: function castToScalar(value, state) {\n        var hasDot = /\\./;\n\n        if (isNaN(value)) {\n          return value;\n        } else {\n          if (hasDot.test(value)) {\n            return parseFloat(value);\n          } else {\n            var integer = parseInt(value);\n\n            if (isNaN(integer)) {\n              return null;\n            } else {\n              return integer;\n            }\n          }\n        }\n      }\n    },\n    parsers: {\n      parse: function parse(csv, options) {\n        // cache settings\n        var separator = options.separator;\n        var delimiter = options.delimiter; // set initial state if it's missing\n\n        if (!options.state.rowNum) {\n          options.state.rowNum = 1;\n        }\n\n        if (!options.state.colNum) {\n          options.state.colNum = 1;\n        } // clear initial state\n\n\n        var data = [];\n        var entry = [];\n        var state = 0;\n        var value = '';\n        var exit = false;\n\n        function endOfEntry() {\n          // reset the state\n          state = 0;\n          value = ''; // if 'start' hasn't been met, don't output\n\n          if (options.start && options.state.rowNum < options.start) {\n            // update global state\n            entry = [];\n            options.state.rowNum++;\n            options.state.colNum = 1;\n            return;\n          }\n\n          if (options.onParseEntry === undefined) {\n            // onParseEntry hook not set\n            data.push(entry);\n          } else {\n            var hookVal = options.onParseEntry(entry, options.state); // onParseEntry Hook\n            // false skips the row, configurable through a hook\n\n            if (hookVal !== false) {\n              data.push(hookVal);\n            }\n          } //console.log('entry:' + entry);\n          // cleanup\n\n\n          entry = []; // if 'end' is met, stop parsing\n\n          if (options.end && options.state.rowNum >= options.end) {\n            exit = true;\n          } // update global state\n\n\n          options.state.rowNum++;\n          options.state.colNum = 1;\n        }\n\n        function endOfValue() {\n          if (options.onParseValue === undefined) {\n            // onParseValue hook not set\n            entry.push(value);\n          } else {\n            var hook = options.onParseValue(value, options.state); // onParseValue Hook\n            // false skips the row, configurable through a hook\n\n            if (hook !== false) {\n              entry.push(hook);\n            }\n          } //console.log('value:' + value);\n          // reset the state\n\n\n          value = '';\n          state = 0; // update global state\n\n          options.state.colNum++;\n        } // escape regex-specific control chars\n\n\n        var escSeparator = RegExp.escape(separator);\n        var escDelimiter = RegExp.escape(delimiter); // compile the regEx str using the custom delimiter/separator\n\n        var match = /(D|S|\\r\\n|\\n|\\r|[^DS\\r\\n]+)/;\n        var matchSrc = match.source;\n        matchSrc = matchSrc.replace(/S/g, escSeparator);\n        matchSrc = matchSrc.replace(/D/g, escDelimiter);\n        match = new RegExp(matchSrc, 'gm'); // put on your fancy pants...\n        // process control chars individually, use look-ahead on non-control chars\n\n        csv.replace(match, function (m0) {\n          if (exit) {\n            return;\n          }\n\n          switch (state) {\n            // the start of a value\n            case 0:\n              // null last value\n              if (m0 === separator) {\n                value += '';\n                endOfValue();\n                break;\n              } // opening delimiter\n\n\n              if (m0 === delimiter) {\n                state = 1;\n                break;\n              } // null last value\n\n\n              if (/^(\\r\\n|\\n|\\r)$/.test(m0)) {\n                endOfValue();\n                endOfEntry();\n                break;\n              } // un-delimited value\n\n\n              value += m0;\n              state = 3;\n              break;\n            // delimited input\n\n            case 1:\n              // second delimiter? check further\n              if (m0 === delimiter) {\n                state = 2;\n                break;\n              } // delimited data\n\n\n              value += m0;\n              state = 1;\n              break;\n            // delimiter found in delimited input\n\n            case 2:\n              // escaped delimiter?\n              if (m0 === delimiter) {\n                value += m0;\n                state = 1;\n                break;\n              } // null value\n\n\n              if (m0 === separator) {\n                endOfValue();\n                break;\n              } // end of entry\n\n\n              if (/^(\\r\\n|\\n|\\r)$/.test(m0)) {\n                endOfValue();\n                endOfEntry();\n                break;\n              } // broken paser?\n\n\n              throw new Error('CSVDataError: Illegal State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n            // un-delimited input\n\n            case 3:\n              // null last value\n              if (m0 === separator) {\n                endOfValue();\n                break;\n              } // end of entry\n\n\n              if (/^(\\r\\n|\\n|\\r)$/.test(m0)) {\n                endOfValue();\n                endOfEntry();\n                break;\n              }\n\n              if (m0 === delimiter) {\n                // non-compliant data\n                throw new Error('CSVDataError: Illegal Quote [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n              } // broken parser?\n\n\n              throw new Error('CSVDataError: Illegal Data [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n\n            default:\n              // shenanigans\n              throw new Error('CSVDataError: Unknown State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n          } //console.log('val:' + m0 + ' state:' + state);\n\n        }); // submit the last entry\n        // ignore null last line\n\n        if (entry.length !== 0) {\n          endOfValue();\n          endOfEntry();\n        }\n\n        return data;\n      },\n      // a csv-specific line splitter\n      splitLines: function splitLines(csv, options) {\n        // cache settings\n        var separator = options.separator;\n        var delimiter = options.delimiter; // set initial state if it's missing\n\n        if (!options.state.rowNum) {\n          options.state.rowNum = 1;\n        } // clear initial state\n\n\n        var entries = [];\n        var state = 0;\n        var entry = '';\n        var exit = false;\n\n        function endOfLine() {\n          // reset the state\n          state = 0; // if 'start' hasn't been met, don't output\n\n          if (options.start && options.state.rowNum < options.start) {\n            // update global state\n            entry = '';\n            options.state.rowNum++;\n            return;\n          }\n\n          if (options.onParseEntry === undefined) {\n            // onParseEntry hook not set\n            entries.push(entry);\n          } else {\n            var hookVal = options.onParseEntry(entry, options.state); // onParseEntry Hook\n            // false skips the row, configurable through a hook\n\n            if (hookVal !== false) {\n              entries.push(hookVal);\n            }\n          } // cleanup\n\n\n          entry = ''; // if 'end' is met, stop parsing\n\n          if (options.end && options.state.rowNum >= options.end) {\n            exit = true;\n          } // update global state\n\n\n          options.state.rowNum++;\n        } // escape regex-specific control chars\n\n\n        var escSeparator = RegExp.escape(separator);\n        var escDelimiter = RegExp.escape(delimiter); // compile the regEx str using the custom delimiter/separator\n\n        var match = /(D|S|\\n|\\r|[^DS\\r\\n]+)/;\n        var matchSrc = match.source;\n        matchSrc = matchSrc.replace(/S/g, escSeparator);\n        matchSrc = matchSrc.replace(/D/g, escDelimiter);\n        match = new RegExp(matchSrc, 'gm'); // put on your fancy pants...\n        // process control chars individually, use look-ahead on non-control chars\n\n        csv.replace(match, function (m0) {\n          if (exit) {\n            return;\n          }\n\n          switch (state) {\n            // the start of a value/entry\n            case 0:\n              // null value\n              if (m0 === separator) {\n                entry += m0;\n                state = 0;\n                break;\n              } // opening delimiter\n\n\n              if (m0 === delimiter) {\n                entry += m0;\n                state = 1;\n                break;\n              } // end of line\n\n\n              if (m0 === '\\n') {\n                endOfLine();\n                break;\n              } // phantom carriage return\n\n\n              if (/^\\r$/.test(m0)) {\n                break;\n              } // un-delimit value\n\n\n              entry += m0;\n              state = 3;\n              break;\n            // delimited input\n\n            case 1:\n              // second delimiter? check further\n              if (m0 === delimiter) {\n                entry += m0;\n                state = 2;\n                break;\n              } // delimited data\n\n\n              entry += m0;\n              state = 1;\n              break;\n            // delimiter found in delimited input\n\n            case 2:\n              // escaped delimiter?\n              var prevChar = entry.substr(entry.length - 1);\n\n              if (m0 === delimiter && prevChar === delimiter) {\n                entry += m0;\n                state = 1;\n                break;\n              } // end of value\n\n\n              if (m0 === separator) {\n                entry += m0;\n                state = 0;\n                break;\n              } // end of line\n\n\n              if (m0 === '\\n') {\n                endOfLine();\n                break;\n              } // phantom carriage return\n\n\n              if (m0 === '\\r') {\n                break;\n              } // broken paser?\n\n\n              throw new Error('CSVDataError: Illegal state [Row:' + options.state.rowNum + ']');\n            // un-delimited input\n\n            case 3:\n              // null value\n              if (m0 === separator) {\n                entry += m0;\n                state = 0;\n                break;\n              } // end of line\n\n\n              if (m0 === '\\n') {\n                endOfLine();\n                break;\n              } // phantom carriage return\n\n\n              if (m0 === '\\r') {\n                break;\n              } // non-compliant data\n\n\n              if (m0 === delimiter) {\n                throw new Error('CSVDataError: Illegal quote [Row:' + options.state.rowNum + ']');\n              } // broken parser?\n\n\n              throw new Error('CSVDataError: Illegal state [Row:' + options.state.rowNum + ']');\n\n            default:\n              // shenanigans\n              throw new Error('CSVDataError: Unknown state [Row:' + options.state.rowNum + ']');\n          } //console.log('val:' + m0 + ' state:' + state);\n\n        }); // submit the last entry\n        // ignore null last line\n\n        if (entry !== '') {\n          endOfLine();\n        }\n\n        return entries;\n      },\n      // a csv entry parser\n      parseEntry: function parseEntry(csv, options) {\n        // cache settings\n        var separator = options.separator;\n        var delimiter = options.delimiter; // set initial state if it's missing\n\n        if (!options.state.rowNum) {\n          options.state.rowNum = 1;\n        }\n\n        if (!options.state.colNum) {\n          options.state.colNum = 1;\n        } // clear initial state\n\n\n        var entry = [];\n        var state = 0;\n        var value = '';\n\n        function endOfValue() {\n          if (options.onParseValue === undefined) {\n            // onParseValue hook not set\n            entry.push(value);\n          } else {\n            var hook = options.onParseValue(value, options.state); // onParseValue Hook\n            // false skips the value, configurable through a hook\n\n            if (hook !== false) {\n              entry.push(hook);\n            }\n          } // reset the state\n\n\n          value = '';\n          state = 0; // update global state\n\n          options.state.colNum++;\n        } // checked for a cached regEx first\n\n\n        if (!options.match) {\n          // escape regex-specific control chars\n          var escSeparator = RegExp.escape(separator);\n          var escDelimiter = RegExp.escape(delimiter); // compile the regEx str using the custom delimiter/separator\n\n          var match = /(D|S|\\n|\\r|[^DS\\r\\n]+)/;\n          var matchSrc = match.source;\n          matchSrc = matchSrc.replace(/S/g, escSeparator);\n          matchSrc = matchSrc.replace(/D/g, escDelimiter);\n          options.match = new RegExp(matchSrc, 'gm');\n        } // put on your fancy pants...\n        // process control chars individually, use look-ahead on non-control chars\n\n\n        csv.replace(options.match, function (m0) {\n          switch (state) {\n            // the start of a value\n            case 0:\n              // null last value\n              if (m0 === separator) {\n                value += '';\n                endOfValue();\n                break;\n              } // opening delimiter\n\n\n              if (m0 === delimiter) {\n                state = 1;\n                break;\n              } // skip un-delimited new-lines\n\n\n              if (m0 === '\\n' || m0 === '\\r') {\n                break;\n              } // un-delimited value\n\n\n              value += m0;\n              state = 3;\n              break;\n            // delimited input\n\n            case 1:\n              // second delimiter? check further\n              if (m0 === delimiter) {\n                state = 2;\n                break;\n              } // delimited data\n\n\n              value += m0;\n              state = 1;\n              break;\n            // delimiter found in delimited input\n\n            case 2:\n              // escaped delimiter?\n              if (m0 === delimiter) {\n                value += m0;\n                state = 1;\n                break;\n              } // null value\n\n\n              if (m0 === separator) {\n                endOfValue();\n                break;\n              } // skip un-delimited new-lines\n\n\n              if (m0 === '\\n' || m0 === '\\r') {\n                break;\n              } // broken paser?\n\n\n              throw new Error('CSVDataError: Illegal State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n            // un-delimited input\n\n            case 3:\n              // null last value\n              if (m0 === separator) {\n                endOfValue();\n                break;\n              } // skip un-delimited new-lines\n\n\n              if (m0 === '\\n' || m0 === '\\r') {\n                break;\n              } // non-compliant data\n\n\n              if (m0 === delimiter) {\n                throw new Error('CSVDataError: Illegal Quote [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n              } // broken parser?\n\n\n              throw new Error('CSVDataError: Illegal Data [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n\n            default:\n              // shenanigans\n              throw new Error('CSVDataError: Unknown State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n          } //console.log('val:' + m0 + ' state:' + state);\n\n        }); // submit the last value\n\n        endOfValue();\n        return entry;\n      }\n    },\n    helpers: {\n      /**\n       * $.csv.helpers.collectPropertyNames(objectsArray)\n       * Collects all unique property names from all passed objects.\n       *\n       * @param {Array} objects Objects to collect properties from.\n       *\n       * Returns an array of property names (array will be empty,\n       * if objects have no own properties).\n       */\n      collectPropertyNames: function collectPropertyNames(objects) {\n        var o,\n            propName,\n            props = [];\n\n        for (o in objects) {\n          for (propName in objects[o]) {\n            if (objects[o].hasOwnProperty(propName) && props.indexOf(propName) < 0 && typeof objects[o][propName] !== 'function') {\n              props.push(propName);\n            }\n          }\n        }\n\n        return props;\n      }\n    },\n\n    /**\n     * $.csv.toArray(csv)\n     * Converts a CSV entry string to a javascript array.\n     *\n     * @param {Array} csv The string containing the CSV data.\n     * @param {Object} [options] An object containing user-defined options.\n     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n     *\n     * This method deals with simple CSV strings only. It's useful if you only\n     * need to parse a single entry. If you need to parse more than one line,\n     * use $.csv2Array instead.\n     */\n    toArray: function toArray(csv, options, callback) {\n      options = options !== undefined ? options : {};\n      var config = {};\n      config.callback = callback !== undefined && typeof callback === 'function' ? callback : false;\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;\n      var state = options.state !== undefined ? options.state : {}; // setup\n\n      options = {\n        delimiter: config.delimiter,\n        separator: config.separator,\n        onParseEntry: options.onParseEntry,\n        onParseValue: options.onParseValue,\n        state: state\n      };\n      var entry = $.csv.parsers.parseEntry(csv, options); // push the value to a callback if one is defined\n\n      if (!config.callback) {\n        return entry;\n      } else {\n        config.callback('', entry);\n      }\n    },\n\n    /**\n     * $.csv.toArrays(csv)\n     * Converts a CSV string to a javascript array.\n     *\n     * @param {String} csv The string containing the raw CSV data.\n     * @param {Object} [options] An object containing user-defined options.\n     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n     *\n     * This method deals with multi-line CSV. The breakdown is simple. The first\n     * dimension of the array represents the line (or entry/row) while the second\n     * dimension contains the values (or values/columns).\n     */\n    toArrays: function toArrays(csv, options, callback) {\n      options = options !== undefined ? options : {};\n      var config = {};\n      config.callback = callback !== undefined && typeof callback === 'function' ? callback : false;\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter; // setup\n\n      var data = [];\n      options = {\n        delimiter: config.delimiter,\n        separator: config.separator,\n        onPreParse: options.onPreParse,\n        onParseEntry: options.onParseEntry,\n        onParseValue: options.onParseValue,\n        onPostParse: options.onPostParse,\n        start: options.start,\n        end: options.end,\n        state: {\n          rowNum: 1,\n          colNum: 1\n        }\n      }; // onPreParse hook\n\n      if (options.onPreParse !== undefined) {\n        options.onPreParse(csv, options.state);\n      } // parse the data\n\n\n      data = $.csv.parsers.parse(csv, options); // onPostParse hook\n\n      if (options.onPostParse !== undefined) {\n        options.onPostParse(data, options.state);\n      } // push the value to a callback if one is defined\n\n\n      if (!config.callback) {\n        return data;\n      } else {\n        config.callback('', data);\n      }\n    },\n\n    /**\n     * $.csv.toObjects(csv)\n     * Converts a CSV string to a javascript object.\n     * @param {String} csv The string containing the raw CSV data.\n     * @param {Object} [options] An object containing user-defined options.\n     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n     * @param {Boolean} [headers] Indicates whether the data contains a header line. Defaults to true.\n     *\n     * This method deals with multi-line CSV strings. Where the headers line is\n     * used as the key for each value per entry.\n     */\n    toObjects: function toObjects(csv, options, callback) {\n      options = options !== undefined ? options : {};\n      var config = {};\n      config.callback = callback !== undefined && typeof callback === 'function' ? callback : false;\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;\n      config.headers = 'headers' in options ? options.headers : $.csv.defaults.headers;\n      options.start = 'start' in options ? options.start : 1; // account for headers\n\n      if (config.headers) {\n        options.start++;\n      }\n\n      if (options.end && config.headers) {\n        options.end++;\n      } // setup\n\n\n      var lines = [];\n      var data = [];\n      options = {\n        delimiter: config.delimiter,\n        separator: config.separator,\n        onPreParse: options.onPreParse,\n        onParseEntry: options.onParseEntry,\n        onParseValue: options.onParseValue,\n        onPostParse: options.onPostParse,\n        start: options.start,\n        end: options.end,\n        state: {\n          rowNum: 1,\n          colNum: 1\n        },\n        match: false,\n        transform: options.transform\n      }; // fetch the headers\n\n      var headerOptions = {\n        delimiter: config.delimiter,\n        separator: config.separator,\n        start: 1,\n        end: 1,\n        state: {\n          rowNum: 1,\n          colNum: 1\n        }\n      }; // onPreParse hook\n\n      if (options.onPreParse !== undefined) {\n        options.onPreParse(csv, options.state);\n      } // parse the csv\n\n\n      var headerLine = $.csv.parsers.splitLines(csv, headerOptions);\n      var headers = $.csv.toArray(headerLine[0], options); // fetch the data\n\n      lines = $.csv.parsers.splitLines(csv, options); // reset the state for re-use\n\n      options.state.colNum = 1;\n\n      if (headers) {\n        options.state.rowNum = 2;\n      } else {\n        options.state.rowNum = 1;\n      } // convert data to objects\n\n\n      for (var i = 0, len = lines.length; i < len; i++) {\n        var entry = $.csv.toArray(lines[i], options);\n        var object = {};\n\n        for (var j = 0; j < headers.length; j++) {\n          object[headers[j]] = entry[j];\n        }\n\n        if (options.transform !== undefined) {\n          data.push(options.transform.call(undefined, object));\n        } else {\n          data.push(object);\n        } // update row state\n\n\n        options.state.rowNum++;\n      } // onPostParse hook\n\n\n      if (options.onPostParse !== undefined) {\n        options.onPostParse(data, options.state);\n      } // push the value to a callback if one is defined\n\n\n      if (!config.callback) {\n        return data;\n      } else {\n        config.callback('', data);\n      }\n    },\n\n    /**\n    * $.csv.fromArrays(arrays)\n    * Converts a javascript array to a CSV String.\n    *\n    * @param {Array} arrays An array containing an array of CSV entries.\n    * @param {Object} [options] An object containing user-defined options.\n    * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n    * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n    *\n    * This method generates a CSV file from an array of arrays (representing entries).\n    */\n    fromArrays: function fromArrays(arrays, options, callback) {\n      options = options !== undefined ? options : {};\n      var config = {};\n      config.callback = callback !== undefined && typeof callback === 'function' ? callback : false;\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;\n      var output = '',\n          line,\n          lineValues,\n          i,\n          j;\n\n      for (i = 0; i < arrays.length; i++) {\n        line = arrays[i];\n        lineValues = [];\n\n        for (j = 0; j < line.length; j++) {\n          var strValue = line[j] === undefined || line[j] === null ? '' : line[j].toString();\n\n          if (strValue.indexOf(config.delimiter) > -1) {\n            strValue = strValue.replace(new RegExp(config.delimiter, 'g'), config.delimiter + config.delimiter);\n          }\n\n          var escMatcher = '\\n|\\r|S|D';\n          escMatcher = escMatcher.replace('S', config.separator);\n          escMatcher = escMatcher.replace('D', config.delimiter);\n\n          if (strValue.search(escMatcher) > -1) {\n            strValue = config.delimiter + strValue + config.delimiter;\n          }\n\n          lineValues.push(strValue);\n        }\n\n        output += lineValues.join(config.separator) + '\\r\\n';\n      } // push the value to a callback if one is defined\n\n\n      if (!config.callback) {\n        return output;\n      } else {\n        config.callback('', output);\n      }\n    },\n\n    /**\n     * $.csv.fromObjects(objects)\n     * Converts a javascript dictionary to a CSV string.\n     *\n     * @param {Object} objects An array of objects containing the data.\n     * @param {Object} [options] An object containing user-defined options.\n     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n     * @param {Character} [sortOrder] Sort order of columns (named after\n     *   object properties). Use 'alpha' for alphabetic. Default is 'declare',\n     *   which means, that properties will _probably_ appear in order they were\n     *   declared for the object. But without any guarantee.\n     * @param {Character or Array} [manualOrder] Manually order columns. May be\n     * a strin in a same csv format as an output or an array of header names\n     * (array items won't be parsed). All the properties, not present in\n     * `manualOrder` will be appended to the end in accordance with `sortOrder`\n     * option. So the `manualOrder` always takes preference, if present.\n     *\n     * This method generates a CSV file from an array of objects (name:value pairs).\n     * It starts by detecting the headers and adding them as the first line of\n     * the CSV file, followed by a structured dump of the data.\n     */\n    fromObjects: function fromObjects(objects, options, callback) {\n      options = options !== undefined ? options : {};\n      var config = {};\n      config.callback = callback !== undefined && typeof callback === 'function' ? callback : false;\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;\n      config.headers = 'headers' in options ? options.headers : $.csv.defaults.headers;\n      config.sortOrder = 'sortOrder' in options ? options.sortOrder : 'declare';\n      config.manualOrder = 'manualOrder' in options ? options.manualOrder : [];\n      config.transform = options.transform;\n\n      if (typeof config.manualOrder === 'string') {\n        config.manualOrder = $.csv.toArray(config.manualOrder, config);\n      }\n\n      if (config.transform !== undefined) {\n        var origObjects = objects;\n        objects = [];\n        var i;\n\n        for (i = 0; i < origObjects.length; i++) {\n          objects.push(config.transform.call(undefined, origObjects[i]));\n        }\n      }\n\n      var props = $.csv.helpers.collectPropertyNames(objects);\n\n      if (config.sortOrder === 'alpha') {\n        props.sort();\n      } // else {} - nothing to do for 'declare' order\n\n\n      if (config.manualOrder.length > 0) {\n        var propsManual = [].concat(config.manualOrder);\n        var p;\n\n        for (p = 0; p < props.length; p++) {\n          if (propsManual.indexOf(props[p]) < 0) {\n            propsManual.push(props[p]);\n          }\n        }\n\n        props = propsManual;\n      }\n\n      var o,\n          p,\n          line,\n          output = [],\n          propName;\n\n      if (config.headers) {\n        output.push(props);\n      }\n\n      for (o = 0; o < objects.length; o++) {\n        line = [];\n\n        for (p = 0; p < props.length; p++) {\n          propName = props[p];\n\n          if (propName in objects[o] && typeof objects[o][propName] !== 'function') {\n            line.push(objects[o][propName]);\n          } else {\n            line.push('');\n          }\n        }\n\n        output.push(line);\n      } // push the value to a callback if one is defined\n\n\n      return $.csv.fromArrays(output, options, config.callback);\n    }\n  }; // Maintenance code to maintain backward-compatibility\n  // Will be removed in release 1.0\n\n  $.csvEntry2Array = $.csv.toArray;\n  $.csv2Array = $.csv.toArrays;\n  $.csv2Dictionary = $.csv.toObjects; // CommonJS module is defined\n\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = $.csv;\n  }\n}).call(this);"],"sourceRoot":""}