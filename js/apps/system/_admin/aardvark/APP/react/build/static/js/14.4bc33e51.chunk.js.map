{"version":3,"sources":["../../frontend/js/lib/sigma.plugins.dragNodes.js"],"names":["sigma","DragNodes","s","renderer","classes","dispatcher","extend","this","_self","_s","_body","document","body","_renderer","_mouse","container","lastChild","_camera","camera","_node","_prefix","_hoverStack","_hoverIndex","_isMouseDown","_drag","nodeMouseOver","event","data","node","id","push","length","addEventListener","nodeMouseDown","treatOutNode","indexCheck","map","e","indexOf","splice","removeEventListener","size","graph","nodes","k","c","nodeMouseMove","nodeMouseUp","cameras","undefined","edgequadtree","_enabled","settings","mouseEnabled","enableHovering","refresh","dispatchEvent","captor","navigator","userAgent","toLowerCase","clearTimeout","timeOut","setTimeout","executeNodeMouseMove","offset","element","style","window","getComputedStyle","getCssProperty","prop","parseInt","getPropertyValue","replace","left","getBoundingClientRect","top","calculateOffset","x","clientX","y","clientY","cos","Math","angle","sin","ref","i","n","aux","renX","renY","xRatio","yRatio","renderers","svg","firstChild","webgl","options","prefix","substr","bind","unbindAll","unbind","utils","pkg","_instance","plugins","dragNodes","killDragNodes","call"],"mappings":"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","file":"static/js/14.4bc33e51.chunk.js","sourcesContent":["/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n/**\n * This plugin provides a method to drag & drop nodes. Check the\n * sigma.plugins.dragNodes function doc or the examples/basic.html &\n * examples/api-candy.html code samples to know more.\n */\n(function () {\n  'use strict';\n\n  if (typeof sigma === 'undefined') throw 'sigma is not declared';\n  sigma.utils.pkg('sigma.plugins');\n  /**\n   * This function will add `mousedown`, `mouseup` & `mousemove` events to the\n   * nodes in the `overNode`event to perform drag & drop operations. It uses\n   * `linear interpolation` [http://en.wikipedia.org/wiki/Linear_interpolation]\n   * and `rotation matrix` [http://en.wikipedia.org/wiki/Rotation_matrix] to\n   * calculate the X and Y coordinates from the `cam` or `renderer` node\n   * attributes. These attributes represent the coordinates of the nodes in\n   * the real container, not in canvas.\n   *\n   * Fired events:\n   * *************\n   * startdrag  Fired at the beginning of the drag.\n   * drag       Fired while the node is dragged.\n   * drop       Fired at the end of the drag if the node has been dragged.\n   * dragend    Fired at the end of the drag.\n   *\n   * Recognized parameters:\n   * **********************\n   * @param  {sigma}    s        The related sigma instance.\n   * @param  {renderer} renderer The related renderer instance.\n   */\n\n  function DragNodes(s, renderer) {\n    sigma.classes.dispatcher.extend(this); // A quick hardcoded rule to prevent people from using this plugin with the\n    // WebGL renderer (which is impossible at the moment):\n    // if (\n    //   sigma.renderers.webgl &&\n    //   renderer instanceof sigma.renderers.webgl\n    // )\n    //   throw new Error(\n    //     'The sigma.plugins.dragNodes is not compatible with the WebGL renderer'\n    //   );\n    // Init variables:\n\n    var _self = this,\n        _s = s,\n        _body = document.body,\n        _renderer = renderer,\n        _mouse = renderer.container.lastChild,\n        _camera = renderer.camera,\n        _node = null,\n        _prefix = '',\n        _hoverStack = [],\n        _hoverIndex = {},\n        _isMouseDown = false,\n        _isMouseOverCanvas = false,\n        _drag = false;\n\n    if (renderer instanceof sigma.renderers.svg) {\n      _mouse = renderer.container.firstChild;\n    } // It removes the initial substring ('read_') if it's a WegGL renderer.\n\n\n    if (renderer instanceof sigma.renderers.webgl) {\n      _prefix = renderer.options.prefix.substr(5);\n    } else {\n      _prefix = renderer.options.prefix;\n    }\n\n    renderer.bind('overNode', nodeMouseOver);\n    renderer.bind('outNode', treatOutNode);\n    renderer.bind('click', click);\n\n    _s.bind('kill', function () {\n      _self.unbindAll();\n    });\n    /**\n     * Unbind all event listeners.\n     */\n\n\n    this.unbindAll = function () {\n      _mouse.removeEventListener('mousedown', nodeMouseDown);\n\n      _body.removeEventListener('mousemove', nodeMouseMove);\n\n      _body.removeEventListener('mouseup', nodeMouseUp);\n\n      _renderer.unbind('overNode', nodeMouseOver);\n\n      _renderer.unbind('outNode', treatOutNode);\n    }; // Calculates the global offset of the given element more accurately than\n    // element.offsetTop and element.offsetLeft.\n\n\n    function calculateOffset(element) {\n      var style = window.getComputedStyle(element);\n\n      var getCssProperty = function getCssProperty(prop) {\n        return parseInt(style.getPropertyValue(prop).replace('px', '')) || 0;\n      };\n\n      return {\n        left: element.getBoundingClientRect().left + getCssProperty('padding-left'),\n        top: element.getBoundingClientRect().top + getCssProperty('padding-top')\n      };\n    }\n\n    ;\n\n    function click(event) {\n      // event triggered at the end of the click\n      _isMouseDown = false;\n\n      _body.removeEventListener('mousemove', nodeMouseMove);\n\n      _body.removeEventListener('mouseup', nodeMouseUp);\n\n      if (!_hoverStack.length) {\n        _node = null;\n      }\n    }\n\n    ;\n\n    function nodeMouseOver(event) {\n      // Don't treat the node if it is already registered\n      if (_hoverIndex[event.data.node.id]) {\n        return;\n      } // Add node to array of current nodes over\n\n\n      _hoverStack.push(event.data.node);\n\n      _hoverIndex[event.data.node.id] = true;\n\n      if (_hoverStack.length && !_isMouseDown) {\n        // Set the current node to be the last one in the array\n        _node = _hoverStack[_hoverStack.length - 1];\n\n        _mouse.addEventListener('mousedown', nodeMouseDown);\n      }\n    }\n\n    ;\n\n    function treatOutNode(event) {\n      // Remove the node from the array\n      var indexCheck = _hoverStack.map(function (e) {\n        return e;\n      }).indexOf(event.data.node);\n\n      _hoverStack.splice(indexCheck, 1);\n\n      delete _hoverIndex[event.data.node.id];\n\n      if (_hoverStack.length && !_isMouseDown) {\n        // On out, set the current node to be the next stated in array\n        _node = _hoverStack[_hoverStack.length - 1];\n      } else {\n        _mouse.removeEventListener('mousedown', nodeMouseDown);\n      }\n    }\n\n    ;\n\n    function nodeMouseDown(event) {\n      _isMouseDown = true;\n\n      var size = _s.graph.nodes().length; // when there is only node in the graph, the plugin cannot apply\n      // linear interpolation. So treat it as if a user is dragging\n      // the graph\n\n\n      if (_node && size > 1) {\n        _mouse.removeEventListener('mousedown', nodeMouseDown);\n\n        _body.addEventListener('mousemove', nodeMouseMove);\n\n        _body.addEventListener('mouseup', nodeMouseUp); // Do not refresh edgequadtree during drag:\n\n\n        var k, c;\n\n        for (k in _s.cameras) {\n          c = _s.cameras[k];\n\n          if (c.edgequadtree !== undefined) {\n            c.edgequadtree._enabled = false;\n          }\n        } // Deactivate drag graph.\n\n\n        _renderer.settings({\n          mouseEnabled: false,\n          enableHovering: false\n        });\n\n        _s.refresh();\n\n        _self.dispatchEvent('startdrag', {\n          node: _node,\n          captor: event,\n          renderer: _renderer\n        });\n      }\n    }\n\n    ;\n\n    function nodeMouseUp(event) {\n      _isMouseDown = false;\n\n      _mouse.addEventListener('mousedown', nodeMouseDown);\n\n      _body.removeEventListener('mousemove', nodeMouseMove);\n\n      _body.removeEventListener('mouseup', nodeMouseUp); // Allow to refresh edgequadtree:\n\n\n      var k, c;\n\n      for (k in _s.cameras) {\n        c = _s.cameras[k];\n\n        if (c.edgequadtree !== undefined) {\n          c.edgequadtree._enabled = true;\n        }\n      } // Activate drag graph.\n\n\n      _renderer.settings({\n        mouseEnabled: true,\n        enableHovering: true\n      });\n\n      _s.refresh();\n\n      if (_drag) {\n        _self.dispatchEvent('drop', {\n          node: _node,\n          captor: event,\n          renderer: _renderer\n        });\n      }\n\n      _self.dispatchEvent('dragend', {\n        node: _node,\n        captor: event,\n        renderer: _renderer\n      });\n\n      _drag = false;\n      _node = null;\n    }\n\n    ;\n\n    function nodeMouseMove(event) {\n      if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {\n        clearTimeout(timeOut);\n        var timeOut = setTimeout(executeNodeMouseMove, 0);\n      } else {\n        executeNodeMouseMove();\n      }\n\n      function executeNodeMouseMove() {\n        var offset = calculateOffset(_renderer.container),\n            x = event.clientX - offset.left,\n            y = event.clientY - offset.top,\n            cos = Math.cos(_camera.angle),\n            sin = Math.sin(_camera.angle),\n            nodes = _s.graph.nodes(),\n            ref = []; // Getting and derotating the reference coordinates.\n\n\n        for (var i = 0; i < 2; i++) {\n          var n = nodes[i];\n          var aux = {\n            x: n.x * cos + n.y * sin,\n            y: n.y * cos - n.x * sin,\n            renX: n[_prefix + 'x'],\n            renY: n[_prefix + 'y']\n          };\n          ref.push(aux);\n        } // Applying linear interpolation.\n        // if the nodes are on top of each other, we use the camera ratio to interpolate\n\n\n        if (ref[0].x === ref[1].x && ref[0].y === ref[1].y) {\n          var xRatio = ref[0].renX === 0 ? 1 : ref[0].renX;\n          var yRatio = ref[0].renY === 0 ? 1 : ref[0].renY;\n          x = ref[0].x / xRatio * (x - ref[0].renX) + ref[0].x;\n          y = ref[0].y / yRatio * (y - ref[0].renY) + ref[0].y;\n        } else {\n          var xRatio = (ref[1].renX - ref[0].renX) / (ref[1].x - ref[0].x);\n          var yRatio = (ref[1].renY - ref[0].renY) / (ref[1].y - ref[0].y); // if the coordinates are the same, we use the other ratio to interpolate\n\n          if (ref[1].x === ref[0].x) {\n            xRatio = yRatio;\n          }\n\n          if (ref[1].y === ref[0].y) {\n            yRatio = xRatio;\n          }\n\n          x = (x - ref[0].renX) / xRatio + ref[0].x;\n          y = (y - ref[0].renY) / yRatio + ref[0].y;\n        } // Rotating the coordinates.\n\n\n        _node.x = x * cos - y * sin;\n        _node.y = y * cos + x * sin;\n\n        _s.refresh();\n\n        _drag = true;\n\n        _self.dispatchEvent('drag', {\n          node: _node,\n          captor: event,\n          renderer: _renderer\n        });\n      }\n    }\n\n    ;\n  }\n\n  ;\n  /**\n   * Interface\n   * ------------------\n   *\n   * > var dragNodesListener = sigma.plugins.dragNodes(s, s.renderers[0]);\n   */\n\n  var _instance = {};\n  /**\n   * @param  {sigma} s The related sigma instance.\n   * @param  {renderer} renderer The related renderer instance.\n   */\n\n  sigma.plugins.dragNodes = function (s, renderer) {\n    // Create object if undefined\n    if (!_instance[s.id]) {\n      _instance[s.id] = new DragNodes(s, renderer);\n    }\n\n    s.bind('kill', function () {\n      sigma.plugins.killDragNodes(s);\n    });\n    return _instance[s.id];\n  };\n  /**\n   * This method removes the event listeners and kills the dragNodes instance.\n   *\n   * @param  {sigma} s The related sigma instance.\n   */\n\n\n  sigma.plugins.killDragNodes = function (s) {\n    if (_instance[s.id] instanceof DragNodes) {\n      _instance[s.id].unbindAll();\n\n      delete _instance[s.id];\n    }\n  };\n}).call(window);\n}.call(window));"],"sourceRoot":""}