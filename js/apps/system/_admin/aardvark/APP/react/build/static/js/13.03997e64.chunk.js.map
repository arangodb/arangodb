{"version":3,"sources":["../../frontend/js/lib/sigma.plugins.animate.js"],"names":["sigma","utils","pkg","_id","_cache","parseColor","val","result","match","replace","length","parseInt","charAt","r","g","b","interpolateColors","c1","c2","p","join","plugins","animate","s","options","nodes","startPositions","k","o","id","duration","settings","easing","easings","quadraticInOut","start","dateNow","graph","reduce","res","node","animations","Object","create","kill","cameras","edgequadtree","_enabled","step","forEach","refresh","onComplete","requestAnimationFrame","cancelAnimationFrame","call","window"],"mappings":"6EACA,YAOA,WACA,aAEA,wBAAAA,MAAA,6BACAA,MAAAC,MAAAC,IAAA,iBACA,IAAAC,EAAA,EACAC,EAAA,GAGA,SAAAC,EAAAC,GACA,GAAAF,EAAAE,GAAA,OAAAF,EAAAE,GACA,IAAAC,EAAA,QAeA,OAbAD,EAAAE,MAAA,MAEAD,EAAA,KADAD,MAAA,IAAAG,QAAA,UACAC,OAAA,CAAAC,SAAAL,EAAAM,OAAA,GAAAN,EAAAM,OAAA,OAAAD,SAAAL,EAAAM,OAAA,GAAAN,EAAAM,OAAA,OAAAD,SAAAL,EAAAM,OAAA,GAAAN,EAAAM,OAAA,SAAAD,SAAAL,EAAAM,OAAA,GAAAN,EAAAM,OAAA,OAAAD,SAAAL,EAAAM,OAAA,GAAAN,EAAAM,OAAA,OAAAD,SAAAL,EAAAM,OAAA,GAAAN,EAAAM,OAAA,QACKN,EAAAE,MAAA,kBAELD,EAAA,GADAD,IAAAE,MAAA,kEACA,IAAAF,EAAA,IAAAA,EAAA,KAGAF,EAAAE,GAAA,CACAO,EAAAN,EAAA,GACAO,EAAAP,EAAA,GACAQ,EAAAR,EAAA,IAEAH,EAAAE,GAGA,SAAAU,EAAAC,EAAAC,EAAAC,GAQA,OAPAF,EAAAZ,EAAAY,GACAC,EAAAb,EAAAa,GAMA,UAJAD,EAAAJ,GAAA,EAAAM,GAAAD,EAAAL,EAAAM,EAIA,EAHAF,EAAAH,GAAA,EAAAK,GAAAD,EAAAJ,EAAAK,EAGA,EAFAF,EAAAF,GAAA,EAAAI,GAAAD,EAAAH,EAAAI,GAEAC,KAAA,SAmCApB,MAAAqB,QAAAC,QAAA,SAAAC,EAAAD,EAAAE,GACA,IAKAC,EACAC,EAoBAC,EA1BAC,EAAAJ,GAAA,GACAK,IAAA1B,EACA2B,EAAAF,EAAAE,UAAAP,EAAAQ,SAAA,kBACAC,EAAA,kBAAAJ,EAAAI,OAAAhC,MAAAC,MAAAgC,QAAAL,EAAAI,QAAA,oBAAAJ,EAAAI,OAAAJ,EAAAI,OAAAhC,MAAAC,MAAAgC,QAAAC,eACAC,EAAAnC,MAAAC,MAAAmC,UAwBA,IAAAT,KAnBAF,EADAG,EAAAH,OAAAG,EAAAH,MAAAf,OACA,kBAAAkB,EAAAH,MAAA,GAAAG,EAAAH,MAA0DF,EAAAc,MAAAZ,MAAAG,EAAAH,OACrDF,EAAAc,MAAAZ,QAGLC,EAAAD,EAAAa,OAAA,SAAAC,EAAAC,GACA,IAAAb,EAGA,IAAAA,KAFAY,EAAAC,EAAAX,IAAA,GAEAP,EACAK,KAAAa,IAAAD,EAAAC,EAAAX,IAAAF,GAAAa,EAAAb,IAGA,OAAAY,GACK,IACLhB,EAAAkB,WAAAlB,EAAAkB,YAAAC,OAAAC,OAAA,IACA3C,MAAAqB,QAAAuB,KAAArB,GAIAA,EAAAsB,QACAtB,EAAAsB,QAAAlB,GACAmB,aAAAC,UAAA,GAGA,SAAAC,IACA,IAAA7B,GAAAnB,MAAAC,MAAAmC,UAAAD,GAAAL,EAEA,GAAAX,GAAA,GAOA,IAAAQ,EAEA,IAAAA,KARAF,EAAAwB,QAAA,SAAAT,GACA,QAAAb,KAAAL,EACAK,KAAAL,IAAAkB,EAAAb,GAAAa,EAAAlB,EAAAK,OAMAJ,EAAAsB,QACAtB,EAAAsB,QAAAlB,GACAmB,aAAAC,UAAA,EAGAxB,EAAA2B,UACA,oBAAAtB,EAAAuB,YAAAvB,EAAAuB,kBAEAhC,EAAAa,EAAAb,GACAM,EAAAwB,QAAA,SAAAT,GACA,QAAAb,KAAAL,EACAK,KAAAL,IACAK,EAAAnB,MAAA,UAAAgC,EAAAb,GAAAX,EAAAU,EAAAc,EAAAX,IAAAF,GAAAa,EAAAlB,EAAAK,IAAAR,GAAkHqB,EAAAb,GAAAa,EAAAlB,EAAAK,IAAAR,EAAAO,EAAAc,EAAAX,IAAAF,IAAA,EAAAR,MAIlHI,EAAA2B,UACA3B,EAAAkB,WAAAZ,GAAAuB,sBAAAJ,GAIAA,IAGAhD,MAAAqB,QAAAuB,KAAA,SAAArB,GACA,QAAAI,KAAAJ,EAAAkB,YAAA,GACAY,qBAAA9B,EAAAkB,WAAAd,IAMA,IAAAA,KAAAJ,EAAAsB,QACAtB,EAAAsB,QAAAlB,GACAmB,aAAAC,UAAA,KAGCO,KAAAC,UACAD,KAAAC","file":"static/js/13.03997e64.chunk.js","sourcesContent":["/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n/**\n * This plugin provides a method to animate a sigma instance by interpolating\n * some node properties. Check the sigma.plugins.animate function doc or the\n * examples/animate.html code sample to know more.\n */\n(function () {\n  'use strict';\n\n  if (typeof sigma === 'undefined') throw 'sigma is not declared';\n  sigma.utils.pkg('sigma.plugins');\n  var _id = 0,\n      _cache = {}; // TOOLING FUNCTIONS:\n  // ******************\n\n  function parseColor(val) {\n    if (_cache[val]) return _cache[val];\n    var result = [0, 0, 0];\n\n    if (val.match(/^#/)) {\n      val = (val || '').replace(/^#/, '');\n      result = val.length === 3 ? [parseInt(val.charAt(0) + val.charAt(0), 16), parseInt(val.charAt(1) + val.charAt(1), 16), parseInt(val.charAt(2) + val.charAt(2), 16)] : [parseInt(val.charAt(0) + val.charAt(1), 16), parseInt(val.charAt(2) + val.charAt(3), 16), parseInt(val.charAt(4) + val.charAt(5), 16)];\n    } else if (val.match(/^ *rgba? *\\(/)) {\n      val = val.match(/^ *rgba? *\\( *([0-9]*) *, *([0-9]*) *, *([0-9]*) *(,.*)?\\) *$/);\n      result = [+val[1], +val[2], +val[3]];\n    }\n\n    _cache[val] = {\n      r: result[0],\n      g: result[1],\n      b: result[2]\n    };\n    return _cache[val];\n  }\n\n  function interpolateColors(c1, c2, p) {\n    c1 = parseColor(c1);\n    c2 = parseColor(c2);\n    var c = {\n      r: c1.r * (1 - p) + c2.r * p,\n      g: c1.g * (1 - p) + c2.g * p,\n      b: c1.b * (1 - p) + c2.b * p\n    };\n    return 'rgb(' + [c.r | 0, c.g | 0, c.b | 0].join(',') + ')';\n  }\n  /**\n   * This function will animate some specified node properties. It will\n   * basically call requestAnimationFrame, interpolate the values and call the\n   * refresh method during a specified duration.\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters in the settings\n   * object:\n   *\n   *   {?array}             nodes      An array of node objects or node ids. If\n   *                                   not specified, all nodes of the graph\n   *                                   will be animated.\n   *   {?(function|string)} easing     Either the name of an easing in the\n   *                                   sigma.utils.easings package or a\n   *                                   function. If not specified, the\n   *                                   quadraticInOut easing from this package\n   *                                   will be used instead.\n   *   {?number}            duration   The duration of the animation. If not\n   *                                   specified, the \"animationsTime\" setting\n   *                                   value of the sigma instance will be used\n   *                                   instead.\n   *   {?function}          onComplete Eventually a function to call when the\n   *                                   animation is ended.\n   *\n   * @param  {sigma}   s       The related sigma instance.\n   * @param  {object}  animate An hash with the keys being the node properties\n   *                           to interpolate, and the values being the related\n   *                           target values.\n   * @param  {?object} options Eventually an object with options.\n   */\n\n\n  sigma.plugins.animate = function (s, animate, options) {\n    var o = options || {},\n        id = ++_id,\n        duration = o.duration || s.settings('animationsTime'),\n        easing = typeof o.easing === 'string' ? sigma.utils.easings[o.easing] : typeof o.easing === 'function' ? o.easing : sigma.utils.easings.quadraticInOut,\n        start = sigma.utils.dateNow(),\n        nodes,\n        startPositions;\n\n    if (o.nodes && o.nodes.length) {\n      if (typeof o.nodes[0] === 'object') nodes = o.nodes;else nodes = s.graph.nodes(o.nodes); // argument is an array of IDs\n    } else nodes = s.graph.nodes(); // Store initial positions:\n\n\n    startPositions = nodes.reduce(function (res, node) {\n      var k;\n      res[node.id] = {};\n\n      for (k in animate) {\n        if (k in node) res[node.id][k] = node[k];\n      }\n\n      return res;\n    }, {});\n    s.animations = s.animations || Object.create({});\n    sigma.plugins.kill(s); // Do not refresh edgequadtree during drag:\n\n    var k, c;\n\n    for (k in s.cameras) {\n      c = s.cameras[k];\n      c.edgequadtree._enabled = false;\n    }\n\n    function step() {\n      var p = (sigma.utils.dateNow() - start) / duration;\n\n      if (p >= 1) {\n        nodes.forEach(function (node) {\n          for (var k in animate) {\n            if (k in animate) node[k] = node[animate[k]];\n          }\n        }); // Allow to refresh edgequadtree:\n\n        var k, c;\n\n        for (k in s.cameras) {\n          c = s.cameras[k];\n          c.edgequadtree._enabled = true;\n        }\n\n        s.refresh();\n        if (typeof o.onComplete === 'function') o.onComplete();\n      } else {\n        p = easing(p);\n        nodes.forEach(function (node) {\n          for (var k in animate) {\n            if (k in animate) {\n              if (k.match(/color$/)) node[k] = interpolateColors(startPositions[node.id][k], node[animate[k]], p);else node[k] = node[animate[k]] * p + startPositions[node.id][k] * (1 - p);\n            }\n          }\n        });\n        s.refresh();\n        s.animations[id] = requestAnimationFrame(step);\n      }\n    }\n\n    step();\n  };\n\n  sigma.plugins.kill = function (s) {\n    for (var k in s.animations || {}) {\n      cancelAnimationFrame(s.animations[k]);\n    } // Allow to refresh edgequadtree:\n\n\n    var k, c;\n\n    for (k in s.cameras) {\n      c = s.cameras[k];\n      c.edgequadtree._enabled = true;\n    }\n  };\n}).call(window);\n}.call(window));"],"sourceRoot":""}