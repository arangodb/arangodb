{"version":3,"sources":["../../frontend/js/lib/sigma.layout.noverlap.js"],"names":["undefined","sigma","Error","utils","pkg","settings","speed","scaleNodes","nodeMargin","gridSize","permittedExpansion","rendererIndex","maxIterations","_instance","_eventEmitter","Noverlap","self","this","init","sigInst","options","config","extend","easing","duration","nodes","plugins","animate","running","atomicGo","iterCount","i","n","n1","xwidth","yheight","xcenter","ycenter","grid","row","col","minXBox","maxXBox","minYBox","maxYBox","adjacentNodes","subRow","subCol","nxmin","nxmax","nymin","nymax","graph","nodesCount","length","xmin","Infinity","xmax","ymin","ymax","dn","dx","dy","Math","min","dn_x","dn_size","max","dn_y","floor","push","id","forEach","nodeId","subNodeId","indexOf","n2","xDist","yDist","dist","sqrt","random","fixed","go","stop","start","prefix","renderers","dispatchEvent","x","y","onComplete","refresh","kill","prototype","configNoverlap","classes","dispatcher","bind","startNoverlap","isNoverlapRunning","call","window"],"mappings":"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","file":"static/js/12.1403cb16.chunk.js","sourcesContent":["/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;\n(function (undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined') throw new Error('sigma is not declared'); // Initialize package:\n\n  sigma.utils.pkg('sigma.layout.noverlap');\n  /**\n   * Noverlap Layout\n   * ===============================\n   *\n   * Author: @apitts / Andrew Pitts\n   * Algorithm: @jacomyma / Mathieu Jacomy (originally contributed to Gephi and ported to sigma.js under the MIT license by @andpitts with permission)\n   * Acknowledgement: @sheyman / SÃ©bastien Heymann (some inspiration has been taken from other MIT licensed layout algorithms authored by @sheyman)\n   * Version: 0.1\n   */\n\n  var settings = {\n    speed: 3,\n    scaleNodes: 1.2,\n    nodeMargin: 5.0,\n    gridSize: 20,\n    permittedExpansion: 1.1,\n    rendererIndex: 0,\n    maxIterations: 500\n  };\n  var _instance = {};\n  /**\n   * Event emitter Object\n   * ------------------\n   */\n\n  var _eventEmitter = {};\n  /**\n  * Noverlap Object\n  * ------------------\n  */\n\n  function Noverlap() {\n    var self = this;\n\n    this.init = function (sigInst, options) {\n      options = options || {}; // Properties\n\n      this.sigInst = sigInst;\n      this.config = sigma.utils.extend(options, settings);\n      this.easing = options.easing;\n      this.duration = options.duration;\n\n      if (options.nodes) {\n        this.nodes = options.nodes;\n        delete options.nodes;\n      }\n\n      if (!sigma.plugins || typeof sigma.plugins.animate === 'undefined') {\n        throw new Error('sigma.plugins.animate is not declared');\n      } // State\n\n\n      this.running = false;\n    };\n    /**\n     * Single layout iteration.\n     */\n\n\n    this.atomicGo = function () {\n      if (!this.running || this.iterCount < 1) return false;\n      var nodes = this.nodes || this.sigInst.graph.nodes(),\n          nodesCount = nodes.length,\n          i,\n          n,\n          n1,\n          n2,\n          xmin = Infinity,\n          xmax = -Infinity,\n          ymin = Infinity,\n          ymax = -Infinity,\n          xwidth,\n          yheight,\n          xcenter,\n          ycenter,\n          grid,\n          row,\n          col,\n          minXBox,\n          maxXBox,\n          minYBox,\n          maxYBox,\n          adjacentNodes,\n          subRow,\n          subCol,\n          nxmin,\n          nxmax,\n          nymin,\n          nymax;\n      this.iterCount--;\n      this.running = false;\n\n      for (i = 0; i < nodesCount; i++) {\n        n = nodes[i];\n        n.dn.dx = 0;\n        n.dn.dy = 0; //Find the min and max for both x and y across all nodes\n\n        xmin = Math.min(xmin, n.dn_x - (n.dn_size * self.config.scaleNodes + self.config.nodeMargin));\n        xmax = Math.max(xmax, n.dn_x + (n.dn_size * self.config.scaleNodes + self.config.nodeMargin));\n        ymin = Math.min(ymin, n.dn_y - (n.dn_size * self.config.scaleNodes + self.config.nodeMargin));\n        ymax = Math.max(ymax, n.dn_y + (n.dn_size * self.config.scaleNodes + self.config.nodeMargin));\n      }\n\n      xwidth = xmax - xmin;\n      yheight = ymax - ymin;\n      xcenter = (xmin + xmax) / 2;\n      ycenter = (ymin + ymax) / 2;\n      xmin = xcenter - self.config.permittedExpansion * xwidth / 2;\n      xmax = xcenter + self.config.permittedExpansion * xwidth / 2;\n      ymin = ycenter - self.config.permittedExpansion * yheight / 2;\n      ymax = ycenter + self.config.permittedExpansion * yheight / 2;\n      grid = {}; //An object of objects where grid[row][col] is an array of node ids representing nodes that fall in that grid. Nodes can fall in more than one grid\n\n      for (row = 0; row < self.config.gridSize; row++) {\n        grid[row] = {};\n\n        for (col = 0; col < self.config.gridSize; col++) {\n          grid[row][col] = [];\n        }\n      } //Place nodes in grid\n\n\n      for (i = 0; i < nodesCount; i++) {\n        n = nodes[i];\n        nxmin = n.dn_x - (n.dn_size * self.config.scaleNodes + self.config.nodeMargin);\n        nxmax = n.dn_x + (n.dn_size * self.config.scaleNodes + self.config.nodeMargin);\n        nymin = n.dn_y - (n.dn_size * self.config.scaleNodes + self.config.nodeMargin);\n        nymax = n.dn_y + (n.dn_size * self.config.scaleNodes + self.config.nodeMargin);\n        minXBox = Math.floor(self.config.gridSize * (nxmin - xmin) / (xmax - xmin));\n        maxXBox = Math.floor(self.config.gridSize * (nxmax - xmin) / (xmax - xmin));\n        minYBox = Math.floor(self.config.gridSize * (nymin - ymin) / (ymax - ymin));\n        maxYBox = Math.floor(self.config.gridSize * (nymax - ymin) / (ymax - ymin));\n\n        for (col = minXBox; col <= maxXBox; col++) {\n          for (row = minYBox; row <= maxYBox; row++) {\n            grid[row][col].push(n.id);\n          }\n        }\n      }\n\n      adjacentNodes = {}; //An object that stores the node ids of adjacent nodes (either in same grid box or adjacent grid box) for all nodes\n\n      for (row = 0; row < self.config.gridSize; row++) {\n        for (col = 0; col < self.config.gridSize; col++) {\n          grid[row][col].forEach(function (nodeId) {\n            if (!adjacentNodes[nodeId]) {\n              adjacentNodes[nodeId] = [];\n            }\n\n            for (subRow = Math.max(0, row - 1); subRow <= Math.min(row + 1, self.config.gridSize - 1); subRow++) {\n              for (subCol = Math.max(0, col - 1); subCol <= Math.min(col + 1, self.config.gridSize - 1); subCol++) {\n                grid[subRow][subCol].forEach(function (subNodeId) {\n                  if (subNodeId !== nodeId && adjacentNodes[nodeId].indexOf(subNodeId) === -1) {\n                    adjacentNodes[nodeId].push(subNodeId);\n                  }\n                });\n              }\n            }\n          });\n        }\n      } //If two nodes overlap then repulse them\n\n\n      for (i = 0; i < nodesCount; i++) {\n        n1 = nodes[i];\n        adjacentNodes[n1.id].forEach(function (nodeId) {\n          var n2 = self.sigInst.graph.nodes(nodeId);\n          var xDist = n2.dn_x - n1.dn_x;\n          var yDist = n2.dn_y - n1.dn_y;\n          var dist = Math.sqrt(xDist * xDist + yDist * yDist);\n          var collision = dist < n1.dn_size * self.config.scaleNodes + self.config.nodeMargin + (n2.dn_size * self.config.scaleNodes + self.config.nodeMargin);\n\n          if (collision) {\n            self.running = true;\n\n            if (dist > 0) {\n              n2.dn.dx += xDist / dist * (1 + n1.dn_size);\n              n2.dn.dy += yDist / dist * (1 + n1.dn_size);\n            } else {\n              n2.dn.dx += xwidth * 0.01 * (0.5 - Math.random());\n              n2.dn.dy += yheight * 0.01 * (0.5 - Math.random());\n            }\n          }\n        });\n      }\n\n      for (i = 0; i < nodesCount; i++) {\n        n = nodes[i];\n\n        if (!n.fixed) {\n          n.dn_x = n.dn_x + n.dn.dx * 0.1 * self.config.speed;\n          n.dn_y = n.dn_y + n.dn.dy * 0.1 * self.config.speed;\n        }\n      }\n\n      if (this.running && this.iterCount < 1) {\n        this.running = false;\n      }\n\n      return this.running;\n    };\n\n    this.go = function () {\n      this.iterCount = this.config.maxIterations;\n\n      while (this.running) {\n        this.atomicGo();\n      }\n\n      ;\n      this.stop();\n    };\n\n    this.start = function () {\n      if (this.running) return;\n      var nodes = this.sigInst.graph.nodes();\n      var prefix = this.sigInst.renderers[self.config.rendererIndex].options.prefix;\n      this.running = true; // Init nodes\n\n      for (var i = 0; i < nodes.length; i++) {\n        nodes[i].dn_x = nodes[i][prefix + 'x'];\n        nodes[i].dn_y = nodes[i][prefix + 'y'];\n        nodes[i].dn_size = nodes[i][prefix + 'size'];\n        nodes[i].dn = {\n          dx: 0,\n          dy: 0\n        };\n      }\n\n      _eventEmitter[self.sigInst.id].dispatchEvent('start');\n\n      this.go();\n    };\n\n    this.stop = function () {\n      var nodes = this.sigInst.graph.nodes();\n      this.running = false;\n\n      if (this.easing) {\n        _eventEmitter[self.sigInst.id].dispatchEvent('interpolate');\n\n        sigma.plugins.animate(self.sigInst, {\n          x: 'dn_x',\n          y: 'dn_y'\n        }, {\n          easing: self.easing,\n          onComplete: function onComplete() {\n            self.sigInst.refresh();\n\n            for (var i = 0; i < nodes.length; i++) {\n              nodes[i].dn = null;\n              nodes[i].dn_x = null;\n              nodes[i].dn_y = null;\n            }\n\n            _eventEmitter[self.sigInst.id].dispatchEvent('stop');\n          },\n          duration: self.duration\n        });\n      } else {\n        // Apply changes\n        for (var i = 0; i < nodes.length; i++) {\n          nodes[i].x = nodes[i].dn_x;\n          nodes[i].y = nodes[i].dn_y;\n        }\n\n        this.sigInst.refresh();\n\n        for (var i = 0; i < nodes.length; i++) {\n          nodes[i].dn = null;\n          nodes[i].dn_x = null;\n          nodes[i].dn_y = null;\n        }\n\n        _eventEmitter[self.sigInst.id].dispatchEvent('stop');\n      }\n    };\n\n    this.kill = function () {\n      this.sigInst = null;\n      this.config = null;\n      this.easing = null;\n    };\n  }\n\n  ;\n  /**\n   * Interface\n   * ----------\n   */\n\n  /**\n   * Configure the layout algorithm.\n    * Recognized options:\n   * **********************\n   * Here is the exhaustive list of every accepted parameter in the settings\n   * object:\n   *\n   *   {?number}            speed               A larger value increases the convergence speed at the cost of precision\n   *   {?number}            scaleNodes          The ratio to scale nodes by - a larger ratio will lead to more space around larger nodes\n   *   {?number}            nodeMargin          A fixed margin to apply around nodes regardless of size\n   *   {?number}            maxIterations       The maximum number of iterations to perform before the layout completes.\n   *   {?integer}           gridSize            The number of rows and columns to use when partioning nodes into a grid for efficient computation\n   *   {?number}            permittedExpansion  A permitted expansion factor to the overall size of the network applied at each iteration\n   *   {?integer}           rendererIndex       The index of the renderer to use for node co-ordinates. Defaults to zero.\n   *   {?(function|string)} easing              Either the name of an easing in the sigma.utils.easings package or a function. If not specified, the\n   *                                            quadraticInOut easing from this package will be used instead.\n   *   {?number}            duration            The duration of the animation. If not specified, the \"animationsTime\" setting value of the sigma instance will be used instead.\n   *\n   *\n   * @param  {object} config  The optional configuration object.\n   *\n   * @return {sigma.classes.dispatcher} Returns an event emitter.\n   */\n\n  sigma.prototype.configNoverlap = function (config) {\n    var sigInst = this;\n    if (!config) throw new Error('Missing argument: \"config\"'); // Create instance if undefined\n\n    if (!_instance[sigInst.id]) {\n      _instance[sigInst.id] = new Noverlap();\n      _eventEmitter[sigInst.id] = {};\n      sigma.classes.dispatcher.extend(_eventEmitter[sigInst.id]); // Binding on kill to clear the references\n\n      sigInst.bind('kill', function () {\n        _instance[sigInst.id].kill();\n\n        _instance[sigInst.id] = null;\n        _eventEmitter[sigInst.id] = null;\n      });\n    }\n\n    _instance[sigInst.id].init(sigInst, config);\n\n    return _eventEmitter[sigInst.id];\n  };\n  /**\n   * Start the layout algorithm. It will use the existing configuration if no\n   * new configuration is passed.\n    * Recognized options:\n   * **********************\n   * Here is the exhaustive list of every accepted parameter in the settings\n   * object\n   *\n   *   {?number}            speed               A larger value increases the convergence speed at the cost of precision\n   *   {?number}            scaleNodes          The ratio to scale nodes by - a larger ratio will lead to more space around larger nodes\n   *   {?number}            nodeMargin          A fixed margin to apply around nodes regardless of size\n   *   {?number}            maxIterations       The maximum number of iterations to perform before the layout completes.\n   *   {?integer}           gridSize            The number of rows and columns to use when partioning nodes into a grid for efficient computation\n   *   {?number}            permittedExpansion  A permitted expansion factor to the overall size of the network applied at each iteration\n   *   {?integer}           rendererIndex       The index of the renderer to use for node co-ordinates. Defaults to zero.\n   *   {?(function|string)} easing              Either the name of an easing in the sigma.utils.easings package or a function. If not specified, the\n   *                                            quadraticInOut easing from this package will be used instead.\n   *   {?number}            duration            The duration of the animation. If not specified, the \"animationsTime\" setting value of the sigma instance will be used instead.\n   *\n   *\n   *\n   * @param  {object} config  The optional configuration object.\n   *\n   * @return {sigma.classes.dispatcher} Returns an event emitter.\n   */\n\n\n  sigma.prototype.startNoverlap = function (config) {\n    var sigInst = this;\n\n    if (config) {\n      this.configNoverlap(sigInst, config);\n    }\n\n    _instance[sigInst.id].start();\n\n    return _eventEmitter[sigInst.id];\n  };\n  /**\n   * Returns true if the layout has started and is not completed.\n   *\n   * @return {boolean}\n   */\n\n\n  sigma.prototype.isNoverlapRunning = function () {\n    var sigInst = this;\n    return !!_instance[sigInst.id] && _instance[sigInst.id].running;\n  };\n}).call(this);\n}.call(window));"],"sourceRoot":""}