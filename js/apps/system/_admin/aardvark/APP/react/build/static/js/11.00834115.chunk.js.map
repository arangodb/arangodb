{"version":3,"sources":["../../frontend/js/lib/sigma.layout.fruchtermanReingold.js"],"names":["undefined","sigma","Error","utils","pkg","settings","autoArea","area","gravity","speed","iterations","_instance","_eventEmitter","FruchtermanReingold","self","this","init","sigInst","options","config","extend","easing","duration","plugins","animate","running","atomicGo","iterCount","i","j","n","n2","e","xDist","yDist","dist","repulsiveF","nodes","graph","edges","nodesCount","length","edgesCount","nSource","nTarget","attractiveF","d","gf","limitedDist","maxDisplace","Math","sqrt","k","fr","fr_x","x","fr_y","y","dx","dy","id","source","target","fixed","min","go","stop","start","dispatchEvent","onComplete","refresh","kill","layouts","fruchtermanReingold","configure","classes","dispatcher","bind","isRunning","progress","call","window"],"mappings":"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","file":"static/js/11.00834115.chunk.js","sourcesContent":["/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;\n(function (undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined') throw new Error('sigma is not declared'); // Initialize package:\n\n  sigma.utils.pkg('sigma.layouts.fruchtermanReingold');\n  /**\n   * Sigma Fruchterman-Reingold\n   * ===============================\n   *\n   * Author: Sébastien Heymann @ Linkurious\n   * Version: 0.1\n   */\n\n  var settings = {\n    autoArea: true,\n    area: 1,\n    gravity: 10,\n    speed: 0.1,\n    iterations: 1000\n  };\n  var _instance = {};\n  /**\n   * Event emitter Object\n   * ------------------\n   */\n\n  var _eventEmitter = {};\n  /**\n   * Fruchterman Object\n   * ------------------\n   */\n\n  function FruchtermanReingold() {\n    var self = this;\n\n    this.init = function (sigInst, options) {\n      options = options || {}; // Properties\n\n      this.sigInst = sigInst;\n      this.config = sigma.utils.extend(options, settings);\n      this.easing = options.easing;\n      this.duration = options.duration;\n\n      if (!sigma.plugins || typeof sigma.plugins.animate === 'undefined') {\n        throw new Error('sigma.plugins.animate is not declared');\n      } // State\n\n\n      this.running = false;\n    };\n    /**\n     * Single layout iteration.\n     */\n\n\n    this.atomicGo = function () {\n      if (!this.running || this.iterCount < 1) return false;\n      var nodes = this.sigInst.graph.nodes(),\n          edges = this.sigInst.graph.edges(),\n          i,\n          j,\n          n,\n          n2,\n          e,\n          xDist,\n          yDist,\n          dist,\n          repulsiveF,\n          nodesCount = nodes.length,\n          edgesCount = edges.length;\n      this.config.area = this.config.autoArea ? nodesCount * nodesCount : this.config.area;\n      this.iterCount--;\n      this.running = this.iterCount > 0;\n      var maxDisplace = Math.sqrt(this.config.area) / 10,\n          k = Math.sqrt(this.config.area / (1 + nodesCount));\n\n      for (i = 0; i < nodesCount; i++) {\n        n = nodes[i]; // Init\n\n        if (!n.fr) {\n          n.fr_x = n.x;\n          n.fr_y = n.y;\n          n.fr = {\n            dx: 0,\n            dy: 0\n          };\n        }\n\n        for (j = 0; j < nodesCount; j++) {\n          n2 = nodes[j]; // Repulsion force\n\n          if (n.id != n2.id) {\n            xDist = n.fr_x - n2.fr_x;\n            yDist = n.fr_y - n2.fr_y;\n            dist = Math.sqrt(xDist * xDist + yDist * yDist) + 0.01; // var dist = Math.sqrt(xDist * xDist + yDist * yDist) - n1.size - n2.size;\n\n            if (dist > 0) {\n              repulsiveF = k * k / dist;\n              n.fr.dx += xDist / dist * repulsiveF;\n              n.fr.dy += yDist / dist * repulsiveF;\n            }\n          }\n        }\n      }\n\n      var nSource, nTarget, attractiveF;\n\n      for (i = 0; i < edgesCount; i++) {\n        e = edges[i]; // Attraction force\n\n        nSource = self.sigInst.graph.nodes(e.source);\n        nTarget = self.sigInst.graph.nodes(e.target);\n        xDist = nSource.fr_x - nTarget.fr_x;\n        yDist = nSource.fr_y - nTarget.fr_y;\n        dist = Math.sqrt(xDist * xDist + yDist * yDist) + 0.01; // dist = Math.sqrt(xDist * xDist + yDist * yDist) - nSource.size - nTarget.size;\n\n        attractiveF = dist * dist / k;\n\n        if (dist > 0) {\n          nSource.fr.dx -= xDist / dist * attractiveF;\n          nSource.fr.dy -= yDist / dist * attractiveF;\n          nTarget.fr.dx += xDist / dist * attractiveF;\n          nTarget.fr.dy += yDist / dist * attractiveF;\n        }\n      }\n\n      var d, gf, limitedDist;\n\n      for (i = 0; i < nodesCount; i++) {\n        n = nodes[i]; // Gravity\n\n        d = Math.sqrt(n.fr_x * n.fr_x + n.fr_y * n.fr_y);\n        gf = 0.01 * k * self.config.gravity * d;\n        n.fr.dx -= gf * n.fr_x / d;\n        n.fr.dy -= gf * n.fr_y / d; // Speed\n\n        n.fr.dx *= self.config.speed;\n        n.fr.dy *= self.config.speed; // Apply computed displacement\n\n        if (!n.fixed) {\n          xDist = n.fr.dx;\n          yDist = n.fr.dy;\n          dist = Math.sqrt(xDist * xDist + yDist * yDist);\n\n          if (dist > 0) {\n            limitedDist = Math.min(maxDisplace * self.config.speed, dist);\n            n.fr_x += xDist / dist * limitedDist;\n            n.fr_y += yDist / dist * limitedDist;\n          }\n        }\n      }\n\n      return this.running;\n    };\n\n    this.go = function () {\n      this.iterCount = this.config.iterations;\n\n      while (this.running) {\n        this.atomicGo();\n      }\n\n      ;\n      this.stop();\n    };\n\n    this.start = function () {\n      if (this.running) return;\n      var nodes = this.sigInst.graph.nodes();\n      this.running = true; // Init nodes\n\n      for (var i = 0; i < nodes.length; i++) {\n        nodes[i].fr_x = nodes[i].x;\n        nodes[i].fr_y = nodes[i].y;\n        nodes[i].fr = {\n          dx: 0,\n          dy: 0\n        };\n      }\n\n      _eventEmitter[self.sigInst.id].dispatchEvent('start');\n\n      this.go();\n    };\n\n    this.stop = function () {\n      var nodes = this.sigInst.graph.nodes();\n      this.running = false;\n\n      if (this.easing) {\n        _eventEmitter[self.sigInst.id].dispatchEvent('interpolate');\n\n        sigma.plugins.animate(self.sigInst, {\n          x: 'fr_x',\n          y: 'fr_y'\n        }, {\n          easing: self.easing,\n          onComplete: function onComplete() {\n            self.sigInst.refresh();\n\n            for (var i = 0; i < nodes.length; i++) {\n              nodes[i].fr = null;\n              nodes[i].fr_x = null;\n              nodes[i].fr_y = null;\n            }\n\n            _eventEmitter[self.sigInst.id].dispatchEvent('stop');\n          },\n          duration: self.duration\n        });\n      } else {\n        // Apply changes\n        for (var i = 0; i < nodes.length; i++) {\n          nodes[i].x = nodes[i].fr_x;\n          nodes[i].y = nodes[i].fr_y;\n        }\n\n        this.sigInst.refresh();\n\n        for (var i = 0; i < nodes.length; i++) {\n          nodes[i].fr = null;\n          nodes[i].fr_x = null;\n          nodes[i].fr_y = null;\n        }\n\n        _eventEmitter[self.sigInst.id].dispatchEvent('stop');\n      }\n    };\n\n    this.kill = function () {\n      this.sigInst = null;\n      this.config = null;\n      this.easing = null;\n    };\n  }\n\n  ;\n  /**\n   * Interface\n   * ----------\n   */\n\n  /**\n   * Configure the layout algorithm.\n    * Recognized options:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters in the settings\n   * object:\n   *\n   *   {?boolean}           autoArea   If `true`, area will be computed as N².\n   *   {?number}            area       The area of the graph.\n   *   {?number}            gravity    This force attracts all nodes to the\n   *                                   center to avoid dispersion of\n   *                                   disconnected components.\n   *   {?number}            speed      A greater value increases the\n   *                                   convergence speed at the cost of precision loss.\n   *   {?number}            iterations The number of iterations to perform\n   *                                   before the layout completes.\n   *   {?(function|string)} easing     Either the name of an easing in the\n   *                                   sigma.utils.easings package or a\n   *                                   function. If not specified, the\n   *                                   quadraticInOut easing from this package\n   *                                   will be used instead.\n   *   {?number}            duration   The duration of the animation. If not\n   *                                   specified, the \"animationsTime\" setting\n   *                                   value of the sigma instance will be used\n   *                                   instead.\n   *\n   *\n   * @param  {sigma}   sigInst The related sigma instance.\n   * @param  {object} config  The optional configuration object.\n   *\n   * @return {sigma.classes.dispatcher} Returns an event emitter.\n   */\n\n  sigma.layouts.fruchtermanReingold.configure = function (sigInst, config) {\n    if (!sigInst) throw new Error('Missing argument: \"sigInst\"');\n    if (!config) throw new Error('Missing argument: \"config\"'); // Create instance if undefined\n\n    if (!_instance[sigInst.id]) {\n      _instance[sigInst.id] = new FruchtermanReingold();\n      _eventEmitter[sigInst.id] = {};\n      sigma.classes.dispatcher.extend(_eventEmitter[sigInst.id]); // Binding on kill to clear the references\n\n      sigInst.bind('kill', function () {\n        _instance[sigInst.id].kill();\n\n        _instance[sigInst.id] = null;\n        _eventEmitter[sigInst.id] = null;\n      });\n    }\n\n    _instance[sigInst.id].init(sigInst, config);\n\n    return _eventEmitter[sigInst.id];\n  };\n  /**\n   * Start the layout algorithm. It will use the existing configuration if no\n   * new configuration is passed.\n    * Recognized options:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters in the settings\n   * object:\n   *\n   *   {?boolean}           autoArea   If `true`, area will be computed as N².\n   *   {?number}            area       The area of the graph.\n   *   {?number}            gravity    This force attracts all nodes to the\n   *                                   center to avoid dispersion of\n   *                                   disconnected components.\n   *   {?number}            speed      A greater value increases the\n   *                                   convergence speed at the cost of precision loss.\n   *   {?number}            iterations The number of iterations to perform\n   *                                   before the layout completes.\n   *   {?(function|string)} easing     Either the name of an easing in the\n   *                                   sigma.utils.easings package or a\n   *                                   function. If not specified, the\n   *                                   quadraticInOut easing from this package\n   *                                   will be used instead.\n   *   {?number}            duration   The duration of the animation. If not\n   *                                   specified, the \"animationsTime\" setting\n   *                                   value of the sigma instance will be used\n   *                                   instead.\n   *\n   *\n   * @param  {sigma}   sigInst The related sigma instance.\n   * @param  {?object} config  The optional configuration object.\n   *\n   * @return {sigma.classes.dispatcher} Returns an event emitter.\n   */\n\n\n  sigma.layouts.fruchtermanReingold.start = function (sigInst, config) {\n    if (!sigInst) throw new Error('Missing argument: \"sigInst\"');\n\n    if (config) {\n      this.configure(sigInst, config);\n    }\n\n    _instance[sigInst.id].start();\n\n    return _eventEmitter[sigInst.id];\n  };\n  /**\n   * Returns true if the layout has started and is not completed.\n   *\n   * @param  {sigma}   sigInst The related sigma instance.\n   *\n   * @return {boolean}\n   */\n\n\n  sigma.layouts.fruchtermanReingold.isRunning = function (sigInst) {\n    if (!sigInst) throw new Error('Missing argument: \"sigInst\"');\n    return !!_instance[sigInst.id] && _instance[sigInst.id].running;\n  };\n  /**\n   * Returns the number of iterations done divided by the total number of\n   * iterations to perform.\n   *\n   * @param  {sigma}   sigInst The related sigma instance.\n   *\n   * @return {number} A value between 0 and 1.\n   */\n\n\n  sigma.layouts.fruchtermanReingold.progress = function (sigInst) {\n    if (!sigInst) throw new Error('Missing argument: \"sigInst\"');\n    return (_instance[sigInst.id].config.iterations - _instance[sigInst.id].iterCount) / _instance[sigInst.id].config.iterations;\n  };\n}).call(this);\n}.call(window));"],"sourceRoot":""}