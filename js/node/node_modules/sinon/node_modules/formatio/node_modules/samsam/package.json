{
  "name": "samsam",
  "version": "1.1.1",
  "description": "Value identification and comparison functions",
  "homepage": "http://busterjs.org/docs/buster-assertions",
  "author": {
    "name": "Christian Johansen"
  },
  "contributors": [
    {
      "name": "Christian Johansen",
      "email": "christian@cjohansen.no",
      "url": "http://cjohansen.no"
    },
    {
      "name": "August Lilleaas",
      "email": "august.lilleaas@gmail.com",
      "url": "http://augustl.com"
    },
    {
      "name": "Daniel Wittner",
      "email": "d.wittner@gmx.de",
      "url": "https://github.com/dwittner"
    }
  ],
  "main": "./lib/samsam",
  "repository": {
    "type": "git",
    "url": "https://github.com/busterjs/samsam.git"
  },
  "scripts": {
    "test": "node test/samsam-test.js",
    "test-debug": "node --debug-brk test/samsam-test.js"
  },
  "devDependencies": {
    "buster": "0.6.11"
  },
  "readme": "# samsam\n\n[![Build status](https://secure.travis-ci.org/busterjs/samsam.png?branch=master)](http://travis-ci.org/busterjs/samsam)\n\n> Same same, but different\n\n`samsam` is a collection of predicate and comparison functions useful for\nidentifiying the type of values and to compare values with varying degrees of\nstrictness.\n\n`samsam` is a general-purpose library with no dependencies. It works in browsers\n(including old and rowdy ones, like IE6) and Node. It will define itself as an\nAMD module if you want it to (i.e. if there's a `define` function available).\n\n`samsam` was originally extracted from the\n`referee <http://github.com/busterjs/referee/>`_ assertion library, which\nships with the Buster.JS testing framework.\n\n\n## Predicate functions\n\n\n### `isArguments(object)`\n\nReturns `true` if `object` is an `arguments` object, `false` otherwise.\n\n\n### `isNegZero(value)`\n\nReturns `true` if `value` is `-0`.\n\n\n## `isElement(object)`\n\nReturns `true` if `object` is a DOM element node. Unlike\nUnderscore.js/lodash, this function will return `false` if `object` is an\n*element-like* object, i.e. a regular object with a `nodeType` property that\nholds the value `1`.\n\n\n###`isDate(object)`\n\nReturns true if the object is a `Date`, or *date-like*. Duck typing of date\nobjects work by checking that the object has a `getTime` function whose return\nvalue equals the return value from the object's `valueOf`.\n\n\n## Comparison functions\n\n\n###`identical(x, y)`\n\nStrict equality check according to `EcmaScript Harmony's `egal`.\n\n**From the Harmony wiki:**\n\n> An egal function simply makes available the internal `SameValue` function\nfrom section 9.12 of the ES5 spec. If two values are egal, then they are not\nobservably distinguishable.\n\n`identical` returns `true` when `===` is `true`, except for `-0` and\n`+0`, where it returns `false`. Additionally, it returns `true` when\n`NaN` is compared to itself.\n\n\n### `deepEqual(obj1, obj2)`\n\nDeep equal comparison. Two values are \"deep equal\" if:\n\n* They are identical\n* They are both date objects representing the same time\n* They are both arrays containing elements that are all deepEqual\n* They are objects with the same set of properties, and each property\n  in `obj1` is deepEqual to the corresponding property in `obj2`\n\n\n### `match(object, matcher)`\n\nPartial equality check. Compares `object` with matcher according a wide set of\nrules:\n\n\n**String matcher**\n\nIn its simplest form, `match` performs a case insensitive substring match.\nWhen the matcher is a string, `object` is converted to a string, and the\nfunction returns `true` if the matcher is a case-insensitive substring of\n`object` as a string.\n\n```javascript\nsamsam.match(\"Give me something\", \"Give\"); //true\nsamsam.match(\"Give me something\", \"sumptn\"); // false\nsamsam.match({ toString: function () { return \"yeah\"; } }, \"Yeah!\"); // true\n```\n\nThe last example is not symmetric. When the matcher is a string, the `object`\nis coerced to a string - in this case using `toString`. Changing the order of\nthe arguments would cause the matcher to be an object, in which case different\nrules apply (see below).\n\n\n**Boolean matcher**\n\nPerforms a strict (i.e. `===`) match with the object. So, only `true`\nmatches `true`, and only `false` matches `false`.\n\n\n**Regular expression matcher**\n\nWhen the matcher is a regular expression, the function will pass if\n`object.test(matcher)` is `true`. `match` is written in a generic way, so\nany object with a `test` method will be used as a matcher this way.\n\n```javascript\nsamsam.match(\"Give me something\", /^[a-z\\s]$/i); // true\nsamsam.match(\"Give me something\", /[0-9]/); // false\nsamsam.match({ toString: function () { return \"yeah!\"; } }, /yeah/); // true\nsamsam.match(234, /[a-z]/); // false\n```\n\n\n**Number matcher**\n\nWhen the matcher is a number, the assertion will pass if `object == matcher`.\n\n```javascript\nsamsam.match(\"123\", 123); // true\nsamsam.match(\"Give me something\", 425); // false\nsamsam.match({ toString: function () { return \"42\"; } }, 42); // true\nsamsam.match(234, 1234); // false\n```\n\n\n**Function matcher**\n\nWhen the matcher is a function, it is called with `object` as its only\nargument. `match` returns `true` if the function returns `true`. A strict\nmatch is performed against the return value, so a boolean `true` is required,\ntruthy is not enough.\n\n```javascript\n// true\nsamsam.match(\"123\", function (exp) {\n    return exp == \"123\";\n});\n\n// false\nsamsam.match(\"Give me something\", function () {\n    return \"ok\";\n});\n\n// true\nsamsam.match({\n    toString: function () {\n        return \"42\";\n    }\n}, function () { return true; });\n\n// false\nsamsam.match(234, function () {});\n```\n\n\n**Object matcher**\n\nAs mentioned above, if an object matcher defines a `test` method, `match`\nwill return `true` if `matcher.test(object)` returns truthy.\n\nIf the matcher does not have a test method, a recursive match is performed. If\nall properties of `matcher` matches corresponding properties in `object`,\n`match` returns `true`. Note that the object matcher does not care if the\nnumber of properties in the two objects are the same - only if all properties in\nthe matcher recursively matches ones in `object`.\n\n```javascript\n// true\nsamsam.match(\"123\", {\n    test: function (arg) {\n        return arg == 123;\n    }\n});\n\n// false\nsamsam.match({}, { prop: 42 });\n\n// true\nsamsam.match({\n    name: \"Chris\",\n    profession: \"Programmer\"\n}, {\n    name: \"Chris\"\n});\n\n// false\nsamsam.match(234, { name: \"Chris\" });\n```\n\n\n**DOM elements**\n\n`match` can be very helpful when comparing DOM elements, because it allows\nyou to compare several properties with one call:\n\n```javascript\nvar el = document.getElementById(\"myEl\");\n\nsamsam.match(el, {\n    tagName: \"h2\",\n    className: \"item\",\n    innerHTML: \"Howdy\"\n});\n```\n\n\n## Changelog\n\n**1.1.1** (26.03.2014)\n\n* [Make `isArguments` work with arguments from `\"strict mode\"` functions](https://github.com/busterjs/samsam/commit/72903613af90f39474f8388ed8957eaea4cf46ae)\n* [Fix type error for nested object in function `match`](https://github.com/busterjs/samsam/commit/9d3420a11e9b3c65559945e60ca56980820db20f)\n* Fix for issue [#366, Assertion match fails with data attribute](https://github.com/busterjs/buster/issues/366)\n",
  "readmeFilename": "Readme.md",
  "bugs": {
    "url": "https://github.com/busterjs/samsam/issues"
  },
  "_id": "samsam@1.1.1",
  "dist": {
    "shasum": "bb0da6cbcdaa7ab039aaa5b5f1cd64f24accdf92"
  },
  "_from": "samsam@~1.1",
  "_resolved": "https://registry.npmjs.org/samsam/-/samsam-1.1.1.tgz"
}
