#!/usr/bin/env python3
from __future__ import print_function
import csv, sys, os.path, re, io
from pathlib import Path

# wrap text after x characters
def wrap(string, width=80, ind1=0, ind2=0, prefix=''):
  string = prefix + ind1 * " " + string
  newstring = ""
  string = string.replace("\n", " ")

  while len(string) > width:
    marker = width - 1
    while not string[marker].isspace():
      marker = marker - 1

    newline = string[0:marker] + "\n"
    newstring = newstring + newline
    string = prefix + ind2 * " " + string[marker + 1:]

  return newstring + string

def genTsFile(errors, version):
  out = f"/*jshint maxlen: 240 */\n\n{prologue}\n/// ArangoDB {version}"
  # print individual errors
  for e in errors:
    name = e[0]
    msg  = e[2].replace("\n", " ").replace("\\", "").replace("\"", "\\\"")
    out = f"{out}export const {name.ljust(70)} = {e[1]};\n"

  out += "export const errors = {\n"
  i=0
  for e in errors:
    name = e[0]
    msg  = e[2].replace("\n", " ").replace("\\", "").replace("\"", "\\\"")
    out = f"""{out} {name.ljust(30)}: {{
    "code" : {e[1]},
    "message" : "{msg}"
    }}"""

    i = i + 1

    if i < len(errors):
      out = out + ",\n"
    else:
      out = out + "\n};\n"

  out += """
export type ErrorType = keyof typeof errors;
export function fromCode(code: number): ErrorType {
  for (const [key, value] of Object.entries(errors)) {
    if (value.code === code) {
      return key as ErrorType;
    }
  }
  return "ERROR_FAILED";
}
             """
  return out

# generate javascript file from errors
def genJsFile(errors, version):
  jslint = "/*jshint maxlen: 240 */\n\n"

  out = jslint \
      + prologue\
      + f"/// ArangoDB {version}\n"\
      + "(function () {\n"\
      + "  \"use strict\";\n"\
      + "  var internal = require(\"internal\");\n"\
      + "\n"\
      + "  internal.errors = {\n"

  # print individual errors
  i = 0
  for e in errors:
    name = "\"" + e[0] + "\""
    msg  = e[2].replace("\n", " ").replace("\\", "").replace("\"", "\\\"")
    out = out\
        + "    " + name.ljust(30) + " : { \"code\" : " + e[1] + ", \"message\" : \"" + msg + "\" }"

    i = i + 1

    if i < len(errors):
      out = out + ",\n"
    else:
      out = out + "\n"


  out = out\
      + "  };\n"\
      + "\n"\
      + "  // For compatibility with <= 3.3\n"\
      + "  internal.errors.ERROR_ARANGO_COLLECTION_NOT_FOUND = internal.errors.ERROR_ARANGO_DATA_SOURCE_NOT_FOUND;\n"\
      + "}());\n"\
      + "\n"

  return out

# generate javascript file from errors
def genPyFile(errors, version):
  out = f'''""" arangodb {version} error codes generated by utils/generateErrorfile.py """'''

  # print individual errors
  i = 0
  for e in errors:
    name = e[0][6:]
    msg  = e[2].replace("\n", " ").replace("\\", "").replace("\"", "\\\"")
    out = f"{out}\n\n# {e[2].strip()}\n{name.ljust(70)} = {e[1]}"
  return out + "\n"

def quotedErrorMessage(error):
    msg  = error[2].replace("\n", " ").replace("\\", "").replace("\"", "\\\"")
    return "\"" + msg + "\""

def errorName(error):
    return "TRI_" + error[0]

# generate C header file from errors
def genCHeaderFile(errors):
  wiki = "// Error codes and meanings\n"\
       + "// The following errors might be raised when running ArangoDB:\n"

  header = """
#pragma once

#include "Basics/ErrorCode.h"

/* clang-format off */
""" \
           + wiki

  # print individual errors
  for e in errors:
    header = header\
           + "\n"\
           + "/// " + e[1] + ": " + e[0] + "\n"\
           + wrap(e[2], 80, 0, 0, "/// \"") + "\"\n"\
           + wrap(e[3], 80, 0, 0, "/// ") + "\n"\
           + "#define " + errorName(e).ljust(65) + " (::ErrorCode{" + e[1] + "})\n"

  return header

def genErrorRegistryHeaderFile(errors):
    template = """
#pragma once

#include "Basics/voc-errors.h"

/* clang-format off */

namespace frozen {{
template<>
struct elsa<ErrorCode> {{
  constexpr auto operator()(ErrorCode const& value, std::size_t seed) const -> std::size_t {{
    return elsa<int>{{}}.operator()(static_cast<int>(value), seed);
  }}
}};
}}  // namespace frozen

#include <frozen/unordered_map.h>

// for format macro constants, e.g. PRId64
#include <cinttypes>

namespace arangodb::error {{
constexpr static frozen::unordered_map<ErrorCode, const char*, {numErrorMessages}> ErrorMessages = {{
{initializerList}
}};
}}
"""
    initializerList = '\n'.join([
        "    {" + errorName(e) + ",  // " + e[1] + "\n" + \
        "      " + quotedErrorMessage(e) + "},"
        for e in errors
    ])

    return template.format(numErrorMessages = len(errors), initializerList = initializerList)


if len(sys.argv) < 3:
  print("usage: {} <sourcefile> <outfile>".format(sys.argv[0]), file=sys.stderr)
  sys.exit(1)

source = sys.argv[1]

version = (Path(source).parent / ".." / ".." / "ARANGO-VERSION").read_text().strip()

# define some globals
prologue = "/// auto-generated file generated from errors.dat\n"\
         + "\n"


# read input file

errors = []
with io.open(source, encoding="utf-8", newline=None) as source_fh:
    errors = csv.reader(io.open(source, encoding="utf-8", newline=None))

    errorsList = []

    r1 = re.compile(r'^#.*')

    for e in errors:
      if len(e) == 0:
        continue

      if r1.match(e[0]):
        continue

      if e[0] == "" or e[1] == "" or e[2] == "" or e[3] == "":
        print("invalid error declaration file: {}".format(source), file=sys.stderr)
        sys.exit()

      errorsList.append(e)

outfile = sys.argv[2]
extension = os.path.splitext(outfile)[1]

basename = os.path.basename(outfile)
filename = basename if extension != ".tmp" else os.path.splitext(basename)[0]

if filename == "errors.js":
  out = genJsFile(errorsList, version)
elif filename == "errors.ts":
  out = genTsFile(errorsList, version)
elif filename == "errno.py":
  out = genPyFile(errorsList, version)
elif filename == "voc-errors.h":
  out = genCHeaderFile(errorsList)
elif filename == "error-registry.h":
  out = genErrorRegistryHeaderFile(errorsList)
else:
  print("usage: {} <sourcefile> <outfile>".format(sys.argv[0]), file=sys.stderr)
  sys.exit(1)

with io.open(outfile, mode="w", encoding="utf-8", newline="") as out_fh:
    out_fh.write(out)
